var tipuesearch = {"pages":[{"text":"FEST-3D FEST-3D (Finite-volume Explicit STructured 3-Dimensional) is computational fluid dynamic solver written in Fortran 90 for solving the Navier-Stokes equations on structured grids using state-of-the-art finite-volume  methods. It is a modular, multiblock, finite-volume code developed to solve flow problems  in the field of aerodynamics. Installation For installation instructions check out the Documentation guide. Steps to run FEST-3D For detailed documentation on steps to run the FEST-3D after downlaod and installation, check out \" How to run FEST-3D \" page. Tutorials For tutorials check out the test_case descriptions. Note There are two separate GitHub repositories: 1. FEST-3D directory, which contains the source code 2. Run directory, which contains the tutorials The run directory is a submodule of the FEST-3D code. Modules and Subroutines Although most of modules and subroutines are named such that its purpose is clear from its name, still more information is provided in source File and Modules pages. Documentation of FEST-3D uses Ford documentation generator which generates documentation using the special comments written for each subroutine and module. License FEST-3D is an open-source software available under GNU General Public License v3.0 Citation User are requested to cite the following JOSS article for any research publications made using the FEST-3D solver. Jatinder Pal Singh Sandhu, Anant Girdhar, Rakesh Ramakrishnan, R. Teja, Santanu Ghosh, FEST-3D: Finite-volume Explicit STructured 3-Dimensional solver , Journal of Open Source Software , 5(46), 1555, https://doi.org/10.21105/joss.01555 . Reference Details about the governing equations used in the FEST-3D code can be found in the publication by Jatinder Pal Singh Sandhu et al. ( Singh Sandhu, J. P., Girdhar, A., Ramakrishnan, R., Teja, R. D., & Ghosh, S., A convergence study of solutions using two two-equation RANS turbulence models on a finite volume solver for structured grids , AIAA 2018-3859 ). Bug Halt/Stop condition does not work on MPI Can not run turbulent flow simulation on Windows Subsystem for Linux (WSL) due to outdated OS and libraries used by WSL. Todo Add HLLC and Roe flux difference Schemes FEST-3D Team Group of students from the Department of Aerospace Engineering at Indian Institute of Technology Madras (IITM), Chennai (600036), India. Developers Jatinder Pal Singh Sandhu R. D. Teja Rakesh Ramakrishnan Anant Girdhar Advisor Dr. Santanu Ghosh","tags":"home","loc":"index.html","title":" FEST-3D "},{"text":"This module handles the MPI Communication calls for interface boundary conditions This file depends on sourcefile~~interface1.f90~~EfferentGraph sourcefile~interface1.f90 interface1.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~utils.f90 utils.f90 sourcefile~interface1.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~interface1.f90->sourcefile~vartypes.f90 sourcefile~mapping.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~interface1.f90~~AfferentGraph sourcefile~interface1.f90 interface1.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules interface1 Source Code interface1.f90 Source Code !< This module handles the MPI Communication calls for interface boundary conditions module interface1 !< This module handles the MPI Communication calls for interface boundary conditions use vartypes use mpi use mapping , only : PiDir use mapping , only : PjDir use mapping , only : PkDir use mapping , only : Pilo use mapping , only : Pjlo use mapping , only : Pklo use mapping , only : Pihi use mapping , only : Pjhi use mapping , only : Pkhi use mapping , only : mpi_class use mapping , only : read_interface_map use utils , only : alloc #include \"debug.h\" #include \"error.h\" private integer :: layers = 3 integer :: ibuf_size !< Size of the buffer for I face interface integer :: jbuf_size !< Size of the buffer for J face interface integer :: kbuf_size !< Size of the buffer for K face interface real ( wp ), dimension (:), allocatable :: imin_send_buf !< Array to store data to send data for Imin face real ( wp ), dimension (:), allocatable :: jmin_send_buf !< Array to store data to send data for Jmin face real ( wp ), dimension (:), allocatable :: kmin_send_buf !< Array to store data to send data for Kmin face real ( wp ), dimension (:), allocatable :: imin_recv_buf !< Array to store data to receive data for Imin face real ( wp ), dimension (:), allocatable :: jmin_recv_buf !< Array to store data to receive data for Jmin face real ( wp ), dimension (:), allocatable :: kmin_recv_buf !< Array to store data to receive data for Kmin face real ( wp ), dimension (:), allocatable :: imax_send_buf !< Array to store data to send data for Imax face real ( wp ), dimension (:), allocatable :: jmax_send_buf !< Array to store data to send data for Jmax face real ( wp ), dimension (:), allocatable :: kmax_send_buf !< Array to store data to send data for Kmax face real ( wp ), dimension (:), allocatable :: imax_recv_buf !< Array to store data to receive data for Imax face real ( wp ), dimension (:), allocatable :: jmax_recv_buf !< Array to store data to receive data for Jmax face real ( wp ), dimension (:), allocatable :: kmax_recv_buf !< Array to store data to receive data for Kmax face public :: setup_interface public :: apply_interface contains subroutine setup_interface ( control , dims ) !< Allocate memory for the data communication between processors implicit none type ( controltype ), intent ( in ) :: control !< Control parameters: n_var type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer :: imx , jmx , kmx , n_var character ( len =* ), parameter :: errmsg = \"module: interface, subrouinte setup\" !< Error message imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var ibuf_size = ( jmx - 1 ) * ( kmx - 1 ) * n_var * layers jbuf_size = ( imx - 1 ) * ( kmx - 1 ) * n_var * layers kbuf_size = ( imx - 1 ) * ( jmx - 1 ) * n_var * layers call alloc ( imin_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imin_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_recv_buf , 1 , kbuf_size , errmsg ) end subroutine setup_interface subroutine apply_interface ( qp , control , bc , dims ) !< MPISEND_RECV call to exchange interface infromation between !< connected blocks. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ) :: qp !< Store primitive variable at cell center type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 integer :: imx , jmx , kmx , n_var imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var !---------------------------------------------------------- ! call pattern is change for first block = 0 ! to avoid O-Grid infinite loop for mpi communication call !----------------------------------------------------------- if ( mod ( control % process_id , 2 ) == 0 ) then !--- IMAX ---! if ( bc % imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if !--- IMIN ---! DebugCall ( 'apply_interface' ) if ( bc % imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if else !--- IMIN ---! DebugCall ( 'apply_interface' ) if ( bc % imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if !--- IMAX ---! if ( bc % imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if end if !--- JMIN ---! if ( bc % jmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % jmin_id , tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % jmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 3 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if end if !--- JMAX ---! if ( bc % jmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % jmax_id , tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % jmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 4 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if end if !--- KMIN ---! if ( bc % kmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % kmin_id , tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % kmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 5 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if end if !--- KMAX ---! if ( bc % kmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % kmax_id , tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % kmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 6 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end if call apply_periodic_bc ( qp , control , bc , dims ) end subroutine apply_interface subroutine apply_periodic_bc ( qp , control , bc , dims ) !<If a block is connected to another block in perodic !<fashion, this subroutine will take care of that boundary condition. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ) :: qp !< Store primitive variable at cell center integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 integer :: imx , jmx , kmx , n_var DebugCall ( 'apply_periodic_boundary_condition' ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var if ( bc % PbcId ( 1 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 1 ), tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 1 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if if ( bc % PbcId ( 2 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 2 ), tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 2 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if !--- JMIN ---! if ( bc % PbcId ( 3 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 3 ), tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 3 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if !--- JMAX ---! if ( bc % PbcId ( 4 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 4 ), tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 4 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if !--- KMIN ---! if ( bc % PbcId ( 5 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 5 ), tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 5 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if !--- KMAX ---! if ( bc % PbcId ( 6 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 6 ), tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 6 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end subroutine apply_periodic_bc end module interface1","tags":"","loc":"sourcefile/interface1.f90.html","title":"interface1.f90 – FEST-3D"},{"text":"Utility module to allocate, deallocate and debug message Files dependent on this one sourcefile~~utils.f90~~AfferentGraph sourcefile~utils.f90 utils.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~face_interpolant.f90->sourcefile~utils.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~utils.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~interface1.f90->sourcefile~utils.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~write_output_tec_node.f90->sourcefile~gradients.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~write_output_tec_node.f90->sourcefile~wall_dist.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~utils.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~read_output.f90->sourcefile~utils.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output.f90->sourcefile~read_output_vtk.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~scheme.f90->sourcefile~utils.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~resnorm.f90->sourcefile~utils.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~viscous.f90->sourcefile~utils.f90 sourcefile~viscous.f90->sourcefile~gradients.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~source.f90 source.f90 sourcefile~source.f90->sourcefile~utils.f90 sourcefile~source.f90->sourcefile~gradients.f90 sourcefile~source.f90->sourcefile~wall_dist.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~cc.f90 CC.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~read_output_tec.f90->sourcefile~utils.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~write_output_vtk.f90->sourcefile~gradients.f90 sourcefile~write_output_vtk.f90->sourcefile~wall_dist.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~lusgs.f90->sourcefile~utils.f90 sourcefile~lusgs.f90->sourcefile~gradients.f90 sourcefile~lusgs.f90->sourcefile~wall_dist.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~bc.f90 bc.f90 sourcefile~bc.f90->sourcefile~utils.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~read_output_vtk.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90->sourcefile~gradients.f90 sourcefile~write_output_tec.f90->sourcefile~wall_dist.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~utils.f90 sourcefile~update.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~update.f90->sourcefile~gradients.f90 sourcefile~update.f90->sourcefile~wall_dist.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~cc.f90->sourcefile~wall_dist.f90 sourcefile~plusgs.f90->sourcefile~utils.f90 sourcefile~plusgs.f90->sourcefile~gradients.f90 sourcefile~plusgs.f90->sourcefile~wall_dist.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~wall.f90 wall.f90 sourcefile~wall.f90->sourcefile~utils.f90 sourcefile~convergence.f90 convergence.f90 sourcefile~convergence.f90->sourcefile~resnorm.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~solver.f90->sourcefile~wall_dist.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~solver.f90->sourcefile~geometry.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~cc.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~face_interpolant.f90 sourcefile~bc_primitive.f90->sourcefile~wall_dist.f90 sourcefile~ausmp.f90->sourcefile~face_interpolant.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~convergence.f90 sourcefile~main.f90->sourcefile~solver.f90 var pansourcefileutilsf90AfferentGraph = svgPanZoom('#sourcefileutilsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules utils Source Code utils.f90 Source Code !< Utility module to allocate, deallocate and debug message module utils !< Utility module to allocate, deallocate and debug message implicit none private public :: alloc interface alloc module procedure alloc_rank1_real , & alloc_rank2_real , & alloc_rank3_real , & alloc_rank4_real , & alloc_rank5_real , & alloc_rank6_real , & alloc_rank1_integer ,& alloc_rank2_integer ,& alloc_rank3_integer end interface alloc contains subroutine alloc_rank1_real ( var , start1 , stop1 , errmsg ) !< Allcoate 1-Dimensional array of type: real implicit none real , dimension (:), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 stop end if end subroutine alloc_rank1_real subroutine alloc_rank2_real ( var , start1 , stop1 , start2 , stop2 , errmsg ) !< Allcoate 2-Dimensional array of type: real implicit none real , dimension (:, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 stop end if end subroutine alloc_rank2_real subroutine alloc_rank3_real ( var , start1 , stop1 , start2 , stop2 , & start3 , stop3 , errmsg ) !< Allcoate 3-Dimensional array of type: real implicit none real , dimension (:, :, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 , start3 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 , stop3 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 , start3 : stop3 ), & stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 , stop3 - start3 + 1 stop end if end subroutine alloc_rank3_real subroutine alloc_rank4_real ( var , start1 , stop1 , start2 , stop2 , & start3 , stop3 , start4 , stop4 , errmsg ) !< Allcoate 4-Dimensional array of type: real implicit none real , dimension (:, :, :, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 , start3 , start4 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 , stop3 , stop4 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 , start3 : stop3 , & start4 : stop4 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 , stop3 - stop3 + 1 , & stop4 - start4 + 1 stop end if end subroutine alloc_rank4_real subroutine alloc_rank5_real ( var , start1 , stop1 , start2 , stop2 , & start3 , stop3 , start4 , stop4 , start5 , stop5 , errmsg ) !< Allcoate 5-Dimensional array of type: real implicit none real , dimension (:, :, :, :, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 , start3 , start4 , start5 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 , stop3 , stop4 , stop5 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 , start3 : stop3 , & start4 : stop4 , start5 : stop5 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 , stop3 - stop3 + 1 , & stop4 - start4 + 1 , stop5 - start5 + 1 stop end if end subroutine alloc_rank5_real subroutine alloc_rank6_real ( var , start1 , stop1 , start2 , stop2 , & !< Allcoate 6-Dimensional array of type: real start3 , stop3 , start4 , stop4 , start5 , stop5 , start6 , stop6 , errmsg ) implicit none real , dimension (:, :, :, :, :,:), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 , start3 , start4 , start5 , start6 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 , stop3 , stop4 , stop5 , stop6 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 , start3 : stop3 , & start4 : stop4 , start5 : stop5 , start6 : stop6 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 , stop3 - stop3 + 1 , & stop4 - start4 + 1 , stop5 - start5 + 1 stop end if end subroutine alloc_rank6_real subroutine alloc_rank1_integer ( var , start1 , stop1 , errmsg ) !< Allcoate 1-Dimensional array of type: integer implicit none integer , dimension (:), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 stop end if end subroutine alloc_rank1_integer subroutine alloc_rank2_integer ( var , start1 , stop1 , start2 , stop2 , errmsg ) !< Allcoate 2-Dimensional array of type: integer implicit none integer , dimension (:, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 stop end if end subroutine alloc_rank2_integer subroutine alloc_rank3_integer ( var , start1 , stop1 , start2 , stop2 , & start3 , stop3 , errmsg ) !< Allcoate 3-Dimensional array of type: integer implicit none integer , dimension (:, :, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 , start3 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 , stop3 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 , start3 : stop3 ), & stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 , stop3 - start3 + 1 stop end if end subroutine alloc_rank3_integer end module utils","tags":"","loc":"sourcefile/utils.f90.html","title":"utils.f90 – FEST-3D"},{"text":"Preconditioned LU-SGS scheme\n  maxtrix-free implicit time-integration method\n  for low speed flows This file depends on sourcefile~~plusgs.f90~~EfferentGraph sourcefile~plusgs.f90 plusgs.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~plusgs.f90->sourcefile~global_sa.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~plusgs.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~plusgs.f90->sourcefile~wall_dist.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~plusgs.f90->sourcefile~global_kkl.f90 sourcefile~utils.f90 utils.f90 sourcefile~plusgs.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~plusgs.f90->sourcefile~vartypes.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~plusgs.f90->sourcefile~global_sst.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~plusgs.f90~~AfferentGraph sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules plusgs Source Code plusgs.f90 Source Code !< Preconditioned LU-SGS scheme !<  maxtrix-free implicit time-integration method !<  for low speed flows module plusgs !< !< Reference: Kitamura, K., Shima, E., Fujimoto, K. and Wang, Z.J., !< Performance of low-dissipation Euler fluxes and preconditioned LU-SGS !< at low speeds, Communications in Computational Physics, vol. 10 no. 1, pp.90-119, 2011 !----------------------------------------------- use vartypes use global_kkl , only : cphi1 use global_kkl , only : cphi2 use global_kkl , only : fphi use global_kkl , only : eta use global_kkl , only : cd1 use global_kkl , only : cmu use global_sst , only : beta1 use global_sst , only : beta2 use global_sst , only : bstar use global_sst , only : sst_F1 use global_sa , only : sigma_sa use global_sa , only : cb1 use global_sa , only : cb2 use global_sa , only : cw1 use global_sa , only : cw2 use global_sa , only : cw3 use global_sa , only : cv1 use global_sa , only : sigma_sa use global_sa , only : kappa_sa use global_sa , only : cv1_3 use global_sa , only : cw3_6 use wall_dist , only : dist use viscosity , only : mu use viscosity , only : mu_t use gradients , only : gradu_x use gradients , only : gradu_y use gradients , only : gradu_z use gradients , only : gradv_x use gradients , only : gradv_y use gradients , only : gradv_z use gradients , only : gradw_x use gradients , only : gradw_y use gradients , only : gradw_z use utils , only : alloc !--- sst implicit update ---! use global_sst , only : sst_F1 use global_sst , only : sigma_k1 use global_sst , only : sigma_k2 use global_sst , only : sigma_w1 use global_sst , only : sigma_w2 use global_kkl , only : sigma_k use global_kkl , only : sigma_phi #include \"debug.h\" #include \"error.h\" real ( wp ), dimension (:,:,:,:), allocatable :: delQ !< Change of state variable (solution) over one time-step real ( wp ), dimension (:,:,:,:), allocatable :: delQstar !< Intermediate change of state variable over one time-step real ( wp ), dimension (:,:,:), allocatable , target :: dummy !< Dummy variable real ( wp ), dimension (:,:,:), pointer :: tmu !< Pointer to turbulent viscosity real ( wp ), dimension (:,:,:), pointer :: mmu !< Pointer to molecular viscosity integer :: imx , jmx , kmx , n_var real ( wp ) :: gm , mu_ref , Reynolds_number , free_stream_tu real ( wp ) :: tk_inf real ( wp ) :: tkl_inf real ( wp ) :: tPr , Pr , R_gas real ( wp ) :: MInf public :: update_with_plusgs public :: setup_plusgs !  public :: destroy_plusgs contains subroutine setup_plusgs ( control , scheme , flow , dims ) !< Allocate array memory for data communication implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx character ( len =* ), parameter :: errmsg = \"module: LUSGS, subrouinte setup\" !< Error message imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var gm = flow % gm mu_ref = flow % mu_ref Reynolds_number = flow % Reynolds_number free_stream_tu = flow % tu_inf tk_inf = flow % tk_inf tkl_inf = flow % tkl_inf tpr = flow % tpr pr = flow % pr MInf = flow % MInf R_gas = flow % R_gas call alloc ( delQ , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) call alloc ( delQstar , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) if ( mu_ref == 0.0 . or . scheme % turbulence == 'none' ) then call alloc ( dummy , 0 , imx , 0 , jmx , 0 , kmx ) dummy = 0.0 end if if ( mu_ref == 0.0 ) then mmu => dummy else mmu => mu end if if ( trim ( scheme % turbulence ) == 'none' ) then tmu => dummy else tmu => mu_t end if end subroutine setup_plusgs subroutine update_with_plusgs ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , residue , scheme , dims ) !< Time-integrate with LU_SGS method implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal select case ( trim ( scheme % turbulence )) case ( 'none' ) call update_laminar_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'sst' , 'sst2003' ) select case ( trim ( scheme % transition )) case ( 'none' , 'bc' ) call update_SST_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'lctm2015' ) call update_lctm2015 ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case DEFAULT Fatal_error end select case ( 'kkl' ) !          call update_KKL_variables() case ( 'sa' , 'saBC' ) call update_SA_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case Default Fatal_error end select end subroutine update_with_plusgs subroutine update_laminar_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update laminar flow with LU-SGS scheme implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 5 ) :: deltaU real ( wp ) :: D real ( wp ), dimension ( 1 : 5 ) :: conservativeQ real ( wp ), dimension ( 1 : 5 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 5 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 5 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 5 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 5 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 5 ) :: Q2 real ( wp ), dimension ( 1 : 5 ) :: Q3 real ( wp ), dimension ( 1 : 5 ) :: Q4 real ( wp ), dimension ( 1 : 5 ) :: Q5 real ( wp ), dimension ( 1 : 5 ) :: Q6 real ( wp ), dimension ( 1 : 5 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 5 ) :: DQ1 real ( wp ), dimension ( 1 : 5 ) :: DQ2 real ( wp ), dimension ( 1 : 5 ) :: DQ3 real ( wp ), dimension ( 1 : 5 ) :: DQ4 real ( wp ), dimension ( 1 : 5 ) :: DQ5 real ( wp ), dimension ( 1 : 5 ) :: DQ6 real ( wp ), dimension ( 1 : 7 ) :: Flist1 real ( wp ), dimension ( 1 : 7 ) :: Flist2 real ( wp ), dimension ( 1 : 7 ) :: Flist3 real ( wp ), dimension ( 1 : 7 ) :: Flist4 real ( wp ), dimension ( 1 : 7 ) :: Flist5 real ( wp ), dimension ( 1 : 7 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: eps real ( wp ) :: M real ( wp ) :: VMag real ( wp ) :: SoundMag real ( wp ) :: u , v , w , r , p , H real ( wp ) :: factor real ( wp ), dimension ( 1 : 5 , 1 : 5 ) :: PrecondInv !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 5 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 5 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 5 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = Flux ( Q3 , Q0 , DQ0 , Flist3 ) r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) !deltaU(1:5) = -residue(i,j,k,1:5) & deltaU ( 1 : 5 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 5 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 5 )) ) delQstar ( i , j , k , 1 : 5 ) = deltaU ( 1 : 5 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 5 ) DQ5 = delQ ( i , j + 1 , k , 1 : 5 ) DQ6 = delQ ( i , j , k + 1 , 1 : 5 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = Flux ( Q6 , Q0 , DQ0 , Flist6 ) r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) delQ ( i , j , k , 1 : 5 ) = delQstar ( i , j , k , 1 : 5 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 5 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) ! add new change into conservative solution conservativeQ ( 1 : 5 ) = conservativeQ ( 1 : 5 ) + delQ ( i , j , k , 1 : 5 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) end do end do end do end subroutine update_laminar_variables function Flux ( ql , qr , du , inputs ) !< Calculate the total flux through face for laminar flow. !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !<left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !<right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: U !< conservative variables real ( wp ), dimension ( 1 : n_var ) :: W !< new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P !< primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 1 : 5 ) = U ( 1 : 5 ) + du ( 1 : 5 ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux = Flux * Area end function Flux function SpectralRadius ( ql , qr , inputs , c1 , c2 , eps ) !< Calculated spectral radius implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !<left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !<right state real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : 3 ) , intent ( in ) :: c1 !<cell center 1 real ( wp ), dimension ( 1 : 3 ) , intent ( in ) :: c2 !<cell center 2 real ( wp ) , intent ( in ) :: eps ! local variables real ( wp ) :: SpectralRadius real ( wp ) :: NormalSpeed real ( wp ) :: SpeedOfSound real ( wp ) :: vis real ( wp ) :: mu real ( wp ) :: rho real ( wp ) :: distance !extract inputs real ( wp ) :: Area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mm real ( wp ) :: tm Area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mm = inputs ( 6 ) tm = inputs ( 7 ) ! in state vector q (2-4) are the cell center velocity NormalSpeed = 0.5 * ( ( ( ql ( 2 ) + qr ( 2 ) ) * nx ) & + ( ( ql ( 3 ) + qr ( 3 ) ) * ny ) & + ( ( ql ( 4 ) + qr ( 4 ) ) * nz ) & ) NormalSpeed = abs ( NormalSpeed ) SpeedOfSound = 0.5 * ( sqrt ( gm * ql ( 5 ) / ql ( 1 )) + sqrt ( gm * qr ( 5 ) / qr ( 1 )) ) ! visocus part mu = mm / Pr + tm / tPr rho = 0.5 * ( ql ( 1 ) + qr ( 1 ) ) distance = sqrt (( c1 ( 1 ) - c2 ( 1 )) ** 2 + ( c1 ( 2 ) - c2 ( 2 )) ** 2 + ( c1 ( 3 ) - c2 ( 3 )) ** 2 ) vis = 2.0 * gm * ( mm / pr + tm / tpr ) / ( rho * distance ) SpectralRadius = ( 0.5 * (( 1.0 + eps ) * NormalSpeed & + sqrt ((( eps - 1.0 ) ** 2 ) * ( NormalSpeed ** 2 ) & + 4 * eps * ( SpeedOfSound ** 2 ))) + vis ) * Area end function SpectralRadius subroutine update_SST_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (SST) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 7 ) :: deltaU real ( wp ), dimension ( 1 : 7 ) :: D real ( wp ), dimension ( 1 : 7 ) :: conservativeQ real ( wp ), dimension ( 1 : 7 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 7 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 7 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 7 ) :: Q2 real ( wp ), dimension ( 1 : 7 ) :: Q3 real ( wp ), dimension ( 1 : 7 ) :: Q4 real ( wp ), dimension ( 1 : 7 ) :: Q5 real ( wp ), dimension ( 1 : 7 ) :: Q6 real ( wp ), dimension ( 1 : 7 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 7 ) :: DQ1 real ( wp ), dimension ( 1 : 7 ) :: DQ2 real ( wp ), dimension ( 1 : 7 ) :: DQ3 real ( wp ), dimension ( 1 : 7 ) :: DQ4 real ( wp ), dimension ( 1 : 7 ) :: DQ5 real ( wp ), dimension ( 1 : 7 ) :: DQ6 real ( wp ), dimension ( 1 : 8 ) :: Flist1 real ( wp ), dimension ( 1 : 8 ) :: Flist2 real ( wp ), dimension ( 1 : 8 ) :: Flist3 real ( wp ), dimension ( 1 : 8 ) :: Flist4 real ( wp ), dimension ( 1 : 8 ) :: Flist5 real ( wp ), dimension ( 1 : 8 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: beta real ( wp ) :: eps real ( wp ) :: M real ( wp ) :: VMag real ( wp ) :: SoundMag real ( wp ) :: u , v , w , r , p , kk , ww , H real ( wp ) :: factor real ( wp ), dimension ( 1 : 7 , 1 : 7 ) :: PrecondInv ! intermittency real ( wp ) :: De , Dp De = 0.0 Dp = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SSTFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SSTFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SSTFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SSTFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SSTFlux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) kk = Q0 ( 6 ) ww = Q0 ( 7 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * kk * VMag * VMag / 2.0 PrecondInv ( 7 , 1 ) = 0.0 - factor * ww * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * kk * ( - u ) PrecondInv ( 7 , 2 ) = 0.0 - factor * ww * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * kk * ( - v ) PrecondInv ( 7 , 3 ) = 0.0 - factor * ww * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * kk * ( - w ) PrecondInv ( 7 , 4 ) = 0.0 - factor * ww * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * kk * ( 1. ) PrecondInv ( 7 , 5 ) = 0.0 - factor * ww * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * kk * ( - 1. ) PrecondInv ( 7 , 6 ) = 0.0 - factor * ww * ( - 1. ) PrecondInv ( 1 , 7 ) = 0.0 - factor * 1 * ( 0. ) PrecondInv ( 2 , 7 ) = 0.0 - factor * u * ( 0. ) PrecondInv ( 3 , 7 ) = 0.0 - factor * v * ( 0. ) PrecondInv ( 4 , 7 ) = 0.0 - factor * w * ( 0. ) PrecondInv ( 5 , 7 ) = 0.0 - factor * H * ( 0. ) PrecondInv ( 6 , 7 ) = 0.0 - factor * kk * ( 0. ) PrecondInv ( 7 , 7 ) = 1.0 - factor * ww * ( 0. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 7 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SSTFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SSTFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SSTFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SSTFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SSTFlux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) kk = Q0 ( 6 ) ww = Q0 ( 7 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * kk * VMag * VMag / 2.0 PrecondInv ( 7 , 1 ) = 0.0 - factor * ww * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * kk * ( - u ) PrecondInv ( 7 , 2 ) = 0.0 - factor * ww * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * kk * ( - v ) PrecondInv ( 7 , 3 ) = 0.0 - factor * ww * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * kk * ( - w ) PrecondInv ( 7 , 4 ) = 0.0 - factor * ww * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * kk * ( 1. ) PrecondInv ( 7 , 5 ) = 0.0 - factor * ww * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * kk * ( - 1. ) PrecondInv ( 7 , 6 ) = 0.0 - factor * ww * ( - 1. ) PrecondInv ( 1 , 7 ) = 0.0 - factor * 1 * ( 0. ) PrecondInv ( 2 , 7 ) = 0.0 - factor * u * ( 0. ) PrecondInv ( 3 , 7 ) = 0.0 - factor * v * ( 0. ) PrecondInv ( 4 , 7 ) = 0.0 - factor * w * ( 0. ) PrecondInv ( 5 , 7 ) = 0.0 - factor * H * ( 0. ) PrecondInv ( 6 , 7 ) = 0.0 - factor * kk * ( 0. ) PrecondInv ( 7 , 7 ) = 1.0 - factor * ww * ( 0. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if end do end do end do end subroutine update_SST_variables function SSTFlux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent flow (SST) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 8 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: SSTFlux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtkdx real ( wp ) :: dtkdy real ( wp ) :: dtkdz real ( wp ) :: dtwdx real ( wp ) :: dtwdy real ( wp ) :: dtwdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: sigma_k real ( wp ) :: sigma_w real ( wp ) :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux = Flux * Area SSTFlux = Flux end function SSTFlux subroutine update_SA_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (SA) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 6 ) :: deltaU real ( wp ), dimension ( 1 : 6 ) :: D real ( wp ), dimension ( 1 : 6 ) :: conservativeQ real ( wp ), dimension ( 1 : 6 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 6 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 6 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 6 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 6 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 6 ) :: Q2 real ( wp ), dimension ( 1 : 6 ) :: Q3 real ( wp ), dimension ( 1 : 6 ) :: Q4 real ( wp ), dimension ( 1 : 6 ) :: Q5 real ( wp ), dimension ( 1 : 6 ) :: Q6 real ( wp ), dimension ( 1 : 6 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 6 ) :: DQ1 real ( wp ), dimension ( 1 : 6 ) :: DQ2 real ( wp ), dimension ( 1 : 6 ) :: DQ3 real ( wp ), dimension ( 1 : 6 ) :: DQ4 real ( wp ), dimension ( 1 : 6 ) :: DQ5 real ( wp ), dimension ( 1 : 6 ) :: DQ6 real ( wp ), dimension ( 1 : 7 ) :: Flist1 real ( wp ), dimension ( 1 : 7 ) :: Flist2 real ( wp ), dimension ( 1 : 7 ) :: Flist3 real ( wp ), dimension ( 1 : 7 ) :: Flist4 real ( wp ), dimension ( 1 : 7 ) :: Flist5 real ( wp ), dimension ( 1 : 7 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: eps real ( wp ) :: M real ( wp ) :: VMag real ( wp ) :: SoundMag real ( wp ) :: u , v , w , p , H , tv !r real ( wp ) :: factor real ( wp ), dimension ( 1 : 6 , 1 : 6 ) :: PrecondInv real ( wp ) :: fv1 real ( wp ) :: fv2 real ( wp ) :: fw real ( wp ) :: g real ( wp ) :: r real ( wp ) :: dist_i real ( wp ) :: dist_i_2 real ( wp ) :: Ji real ( wp ) :: Ji_2 real ( wp ) :: Ji_3 real ( wp ) :: S real ( wp ) :: Omega real ( wp ) :: k2 real ( wp ) :: inv_k2_d2 real ( wp ) :: Shat real ( wp ) :: inv_Shat real ( wp ) :: nu real ( wp ) :: glim real ( wp ) :: g_6 real ( wp ) :: dfv1 real ( wp ) :: dfv2 real ( wp ) :: dfw real ( wp ) :: dShat real ( wp ) :: dr real ( wp ) :: dg real ( wp ) :: density !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 6 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 6 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 6 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SAFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SAFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SAFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SAFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SAFlux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) tv = Q0 ( 6 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * tv * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * tv * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * tv * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * tv * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * tv * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * tv * ( - 1. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * cells ( i , j , k )% volume ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * cells ( i , j , k )% volume ! --  end of source term -- ! deltaU ( 1 : 6 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 6 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 6 )) ) delQstar ( i , j , k , 1 : 6 ) = deltaU ( 1 : 6 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 6 ) DQ5 = delQ ( i , j + 1 , k , 1 : 6 ) DQ6 = delQ ( i , j , k + 1 , 1 : 6 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SAFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SAFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SAFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SAFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SAFlux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) tv = Q0 ( 6 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * tv * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * tv * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * tv * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * tv * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * tv * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * tv * ( - 1. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * cells ( i , j , k )% volume ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * cells ( i , j , k )% volume ! --  end of source term -- ! delQ ( i , j , k , 1 : 6 ) = delQstar ( i , j , k , 1 : 6 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 6 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) ! add new change into conservative solution conservativeQ ( 1 : 6 ) = conservativeQ ( 1 : 6 ) + delQ ( i , j , k , 1 : 6 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) end do end do end do end subroutine update_SA_variables function SAFlux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent flow (SA) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: SAFlux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtvdx real ( wp ) :: dtvdy real ( wp ) :: dtvdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: muCap area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) ! viscous terms muCap = 0.25 * ( P ( 1 ) + W ( 1 )) * ( P ( 6 ) + W ( 6 )) mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtvdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtvdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtvdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz tmu = 0.5 * ( W ( 6 ) + P ( 6 )) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + muCap ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ) / sigma_sa Flux = Flux * Area SAFlux = Flux end function SAFlux subroutine update_lctm2015 ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS/transition (LCTM2015) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 8 ) :: deltaU real ( wp ), dimension ( 1 : 8 ) :: D real ( wp ), dimension ( 1 : 8 ) :: conservativeQ real ( wp ), dimension ( 1 : 8 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 8 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 8 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 8 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 8 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 8 ) :: Q2 real ( wp ), dimension ( 1 : 8 ) :: Q3 real ( wp ), dimension ( 1 : 8 ) :: Q4 real ( wp ), dimension ( 1 : 8 ) :: Q5 real ( wp ), dimension ( 1 : 8 ) :: Q6 real ( wp ), dimension ( 1 : 8 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 8 ) :: DQ1 real ( wp ), dimension ( 1 : 8 ) :: DQ2 real ( wp ), dimension ( 1 : 8 ) :: DQ3 real ( wp ), dimension ( 1 : 8 ) :: DQ4 real ( wp ), dimension ( 1 : 8 ) :: DQ5 real ( wp ), dimension ( 1 : 8 ) :: DQ6 real ( wp ), dimension ( 1 : 8 ) :: Flist1 real ( wp ), dimension ( 1 : 8 ) :: Flist2 real ( wp ), dimension ( 1 : 8 ) :: Flist3 real ( wp ), dimension ( 1 : 8 ) :: Flist4 real ( wp ), dimension ( 1 : 8 ) :: Flist5 real ( wp ), dimension ( 1 : 8 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: beta real ( wp ) :: eps real ( wp ) :: M real ( wp ) :: VMag real ( wp ) :: SoundMag real ( wp ) :: u , v , w , r , p , kk , ww , H , im real ( wp ) :: factor real ( wp ), dimension ( 1 : 8 , 1 : 8 ) :: PrecondInv real ( wp ), dimension ( 1 : 8 , 1 : 8 ) :: Identity ! intermittency real ( wp ) :: Fonset1 real ( wp ) :: Fonset2 real ( wp ) :: Fonset3 real ( wp ) :: Fonset real ( wp ) :: Rev real ( wp ) :: RT real ( wp ) :: Fturb real ( wp ) :: Re_theta real ( wp ) :: TuL real ( wp ) :: strain real ( wp ) :: vort real ( wp ) :: Dp , De real ( wp ) :: Fpg real ( wp ) :: density Dp = 0.0 De = 0.0 !Identity matrix Identity = 0.0 do i = 1 , 8 Identity ( i , i ) = 1.0 end do !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 8 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 8 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 8 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) kk = Q0 ( 6 ) ww = Q0 ( 7 ) im = Q0 ( 8 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) !preconditing start PrecondInv (:, 1 ) = VMag * VMag / 2.0 PrecondInv (:, 2 ) = - u PrecondInv (:, 3 ) = - v PrecondInv (:, 4 ) = - w PrecondInv (:, 5 ) = 1.0 PrecondInv (:, 6 ) = - 1.0 PrecondInv (:, 7 ) = 0.0 PrecondInv (:, 8 ) = 0.0 PrecondInv ( 2 ,:) = u * PrecondInv ( 2 ,:) PrecondInv ( 3 ,:) = v * PrecondInv ( 3 ,:) PrecondInv ( 4 ,:) = w * PrecondInv ( 4 ,:) PrecondInv ( 5 ,:) = H * PrecondInv ( 5 ,:) PrecondInv ( 6 ,:) = kk * PrecondInv ( 6 ,:) PrecondInv ( 7 ,:) = ww * PrecondInv ( 7 ,:) PrecondInv ( 8 ,:) = im * PrecondInv ( 8 ,:) PrecondInv = Identity - ( factor * PrecondInv ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*cells(i,j,k)%volume) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) Fpg = 1.0 !max(Fpg, 0.0) TuL = min ( 10 0.0 * sqrt ( 2.0 * qp ( i , j , k , 6 ) / 3.0 ) / ( qp ( i , j , k , 7 ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) Rev = density * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density * qp ( i , j , k , 6 ) / ( mu ( i , j , k ) * qp ( i , j , k , 7 )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * cells ( i , j , k )% volume ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 8 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 8 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 8 )) ) delQstar ( i , j , k , 1 : 8 ) = deltaU ( 1 : 8 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 8 ) DQ5 = delQ ( i , j + 1 , k , 1 : 8 ) DQ6 = delQ ( i , j , k + 1 , 1 : 8 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) !preconditing start PrecondInv (:, 1 ) = VMag * VMag / 2.0 PrecondInv (:, 2 ) = - u PrecondInv (:, 3 ) = - v PrecondInv (:, 4 ) = - w PrecondInv (:, 5 ) = 1.0 PrecondInv (:, 6 ) = - 1.0 PrecondInv (:, 7 ) = 0.0 PrecondInv (:, 8 ) = 0.0 PrecondInv ( 2 ,:) = u * PrecondInv ( 2 ,:) PrecondInv ( 3 ,:) = v * PrecondInv ( 3 ,:) PrecondInv ( 4 ,:) = w * PrecondInv ( 4 ,:) PrecondInv ( 5 ,:) = H * PrecondInv ( 5 ,:) PrecondInv ( 6 ,:) = kk * PrecondInv ( 6 ,:) PrecondInv ( 7 ,:) = ww * PrecondInv ( 7 ,:) PrecondInv ( 8 ,:) = im * PrecondInv ( 8 ,:) PrecondInv = Identity - ( factor * PrecondInv ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*cells(i,j,k)%volume) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) Fpg = 1.0 !max(Fpg, 0.0) TuL = min ( 10 0.0 * sqrt ( 2.0 * qp ( i , j , k , 6 ) / 3.0 ) / ( qp ( i , j , k , 7 ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) Rev = density * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density * qp ( i , j , k , 6 ) / ( mu ( i , j , k ) * qp ( i , j , k , 7 )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * cells ( i , j , k )% volume ) delQ ( i , j , k , 1 : 8 ) = delQstar ( i , j , k , 1 : 8 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 8 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) conservativeQ ( 8 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 8 ) ! add new change into conservative solution conservativeQ ( 1 : n_var ) = conservativeQ ( 1 : n_var ) + delQ ( i , j , k , 1 : n_var ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0.0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0.0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if qp ( i , j , k , 8 ) = conservativeQ ( 8 ) / conservativeQ ( 1 ) qp ( i , j , k , 8 ) = max ( qp ( i , j , k , 8 ), 0.0 ) !qp(i,j,k,8) = min(qp(i,j,k,8), 1.0) end do end do end do end subroutine update_lctm2015 function lctm2015flux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent/transition flow (LCTM2015) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 8 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: lctm2015flux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtkdx real ( wp ) :: dtkdy real ( wp ) :: dtkdz real ( wp ) :: dtwdx real ( wp ) :: dtwdy real ( wp ) :: dtwdz real ( wp ) :: dtgmdx real ( wp ) :: dtgmdy real ( wp ) :: dtgmdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: sigma_k real ( wp ) :: sigma_w real ( wp ) :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 8 ) = ql ( 1 ) * ql ( 8 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 8 ) = U ( 8 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) W ( 8 ) = max ( W ( 8 ), 0.0 ) !W(8) = min(W(8), 1.0) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) Flux ( 8 ) = ( W ( 8 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume dtgmdx = ( P ( 8 ) - W ( 8 ) ) * nx * Area / Volume dtgmdy = ( P ( 8 ) - W ( 8 ) ) * ny * Area / Volume dtgmdz = ( P ( 8 ) - W ( 8 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux ( 8 ) = Flux ( 8 ) + ( mmu + tmu ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ) Flux = Flux * Area lctm2015flux = Flux end function lctm2015flux end module plusgs","tags":"","loc":"sourcefile/plusgs.f90.html","title":"plusgs.f90 – FEST-3D"},{"text":"Allocate memory to laminar gradients if flow is viscous and\n allocate memory to tubulence gradients base upon the model being used This file depends on sourcefile~~gradients.f90~~EfferentGraph sourcefile~gradients.f90 gradients.f90 sourcefile~utils.f90 utils.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~gradients.f90~~AfferentGraph sourcefile~gradients.f90 gradients.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output_tec_node.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~time.f90 time.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output_tec.f90->sourcefile~gradients.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~gradients.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~plusgs.f90->sourcefile~gradients.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~viscous.f90->sourcefile~gradients.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~source.f90->sourcefile~gradients.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output_vtk.f90->sourcefile~gradients.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~lusgs.f90->sourcefile~gradients.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 var pansourcefilegradientsf90AfferentGraph = svgPanZoom('#sourcefilegradientsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules gradients Source Code gradients.f90 Source Code !< Allocate memory to laminar gradients if flow is viscous and !< allocate memory to tubulence gradients base upon the model being used module gradients !< Allocate memory to laminar gradients if flow is viscous and !< allocate memory to tubulence gradients base upon the model being used !------------------------------------------------------------------ ! 170509  Jatinder Pal Singh Sandhu !         - first build !------------------------------------------------------------------- #include \"error.h\" #include \"debug.h\" use vartypes use utils , only : alloc implicit none !private ! gradients integer :: n_grad = 4 !< Number of variable to store gradient for real ( wp ), dimension (:, :, :, :), allocatable , target :: gradqp_x !< Store gradient of n_grad variables with respect to direction x real ( wp ), dimension (:, :, :, :), allocatable , target :: gradqp_y !< Store gradient of n_grad variables with respect to direction y real ( wp ), dimension (:, :, :, :), allocatable , target :: gradqp_z !< Store gradient of n_grad variables with respect to direction z real ( wp ), dimension (:, :, :), pointer :: gradu_x !< Gradient of variable U with respect to direction x real ( wp ), dimension (:, :, :), pointer :: gradu_y !< Gradient of variable U with respect to direction y real ( wp ), dimension (:, :, :), pointer :: gradu_z !< Gradient of variable U with respect to direction z real ( wp ), dimension (:, :, :), pointer :: gradv_x !< Gradient of variable V with respect to direction x real ( wp ), dimension (:, :, :), pointer :: gradv_y !< Gradient of variable V with respect to direction y real ( wp ), dimension (:, :, :), pointer :: gradv_z !< Gradient of variable V with respect to direction z real ( wp ), dimension (:, :, :), pointer :: gradw_x !< Gradient of variable W with respect to direction x real ( wp ), dimension (:, :, :), pointer :: gradw_y !< Gradient of variable W with respect to direction y real ( wp ), dimension (:, :, :), pointer :: gradw_z !< Gradient of variable W with respect to direction z real ( wp ), dimension (:, :, :), pointer :: gradT_x !< Gradient of variable Temperature with respect to direction x real ( wp ), dimension (:, :, :), pointer :: gradT_y !< Gradient of variable Temperature with respect to direction y real ( wp ), dimension (:, :, :), pointer :: gradT_z !< Gradient of variable Temperature with respect to direction z real ( wp ), dimension (:, :, :), pointer :: gradtk_x !< Gradient of variable turbulent kinetic energy with respect to direction x real ( wp ), dimension (:, :, :), pointer :: gradtk_y !< Gradient of variable turbulent kinetic energy with respect to direction y real ( wp ), dimension (:, :, :), pointer :: gradtk_z !< Gradient of variable turbulent kinetic energy with respect to direction z real ( wp ), dimension (:, :, :), pointer :: gradtw_x !< Gradient of variable dissipation rate with respect to direction x real ( wp ), dimension (:, :, :), pointer :: gradtw_y !< Gradient of variable dissipation rate with respect to direction y real ( wp ), dimension (:, :, :), pointer :: gradtw_z !< Gradient of variable dissipation rate with respect to direction z real ( wp ), dimension (:, :, :), pointer :: gradtkl_x !< Gradient of variable kL with respect to direction x real ( wp ), dimension (:, :, :), pointer :: gradtkl_y !< Gradient of variable kL with respect to direction y real ( wp ), dimension (:, :, :), pointer :: gradtkl_z !< Gradient of variable kL with respect to direction z real ( wp ), dimension (:, :, :), pointer :: gradte_x !< Gradient of variable turbulent energy dissiaption with respect to direction x real ( wp ), dimension (:, :, :), pointer :: gradte_y !< Gradient of variable turbulent energy dissiaption with respect to direction y real ( wp ), dimension (:, :, :), pointer :: gradte_z !< Gradient of variable turbulent energy dissiaption with respect to direction z real ( wp ), dimension (:, :, :), pointer :: gradtv_x !< Gradient of variable turbulenct visocity(SA mode) with respect to direction x real ( wp ), dimension (:, :, :), pointer :: gradtv_y !< Gradient of variable turbulenct visocity(SA mode) with respect to direction y real ( wp ), dimension (:, :, :), pointer :: gradtv_z !< Gradient of variable turbulenct visocity(SA mode) with respect to direction z real ( wp ), dimension (:, :, :), pointer :: gradtgm_x !< Gradient of variable intermittency with respect to direction x real ( wp ), dimension (:, :, :), pointer :: gradtgm_y !< Gradient of variable intermittency with respect to direction y real ( wp ), dimension (:, :, :), pointer :: gradtgm_z !< Gradient of variable intermittency with respect to direction z real ( wp ) :: R_gas integer :: imx , jmx , kmx , n_var type :: singlesub integer :: imin , imax , il , iu integer :: jmin , jmax , jl , ju integer :: kmin , kmax , kl , ku integer :: sig = 1 end type singlesub public :: setup_gradients public :: evaluate_all_gradients !public :: destroy_gradients contains subroutine setup_gradients ( control , scheme , flow , dims ) !< Memoery allocation to the gradient variables and !< setup pointer to the slice to the main gradient variable !< based on the various models being used. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ) , intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ) , intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx DebugCall ( \"setup_gradients\" ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var R_gas = flow % R_gas if ( flow % mu_ref /= 0 ) then call get_n_grad ( scheme ) !call allocate_memory() call alloc ( gradqp_x , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_x\" )) call alloc ( gradqp_y , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_y\" )) call alloc ( gradqp_z , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_z\" )) ! Linking pointer to laminar gradients !call setup_laminar_grad() DebugCall ( 'setup_laminar_grad' ) !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z gradu_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 1 ) gradv_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 2 ) gradw_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 3 ) gradT_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 4 ) gradu_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 1 ) gradv_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 2 ) gradw_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 3 ) gradT_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 4 ) gradu_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 1 ) gradv_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 2 ) gradw_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 3 ) gradT_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 4 ) ! Linking pointer to turbulent gradients select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) !call setup_sa_grad() DebugCall ( \"setup_sa_grad\" ) gradtv_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtv_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtv_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) case ( 'sst' , 'sst2003' ) !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z DebugCall ( 'setup_sst_grad' ) gradtk_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtw_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 6 ) gradtk_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtw_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 6 ) gradtk_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) gradtw_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 6 ) case ( 'kkl' ) !call setup_kkl_grad() DebugCall ( 'setup_kkl_grad' ) gradtk_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtkl_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 6 ) gradtk_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtkl_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 6 ) gradtk_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) gradtkl_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 6 ) case DEFAULT Fatal_error end select !Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) !call setup_lctm2015_grad() gradtgm_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, n_grad ) gradtgm_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, n_grad ) gradtgm_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, n_grad ) case ( 'none' , 'bc' ) !do nothing continue case DEFAULT Fatal_error end Select end if end subroutine setup_gradients subroutine get_n_grad ( scheme ) !< Set number of variables for which !< gradient is required based on the !< being used implicit none type ( schemetype ) , intent ( in ) :: scheme !< finite-volume Schemes DebugCall ( \"get_n_grad\" ) select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) n_grad = 5 case ( 'sst' , 'sst2003' ) n_grad = 6 case ( 'kkl' ) n_grad = 6 case DEFAULT Fatal_error end select !Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) n_grad = n_grad + 1 case ( 'none' , 'bc' ) n_grad = n_grad + 0 case DEFAULT Fatal_error end Select end subroutine get_n_grad subroutine evaluate_all_gradients ( qp , Temp , cells , Ifaces , Jfaces , Kfaces , scheme , bc , dims ) !< Call to all the required gradients and !< apply boundary condition for ghost cell !< gradients implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), Target :: qp !< Store primitive variable at cell center real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Temp !< Store Temperature variable at cell center type ( schemetype ) , intent ( in ) :: scheme !< finite-volume Schemes type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :), pointer :: x_speed !< U pointer, point to slice of qp (:,:,:,2) real ( wp ), dimension (:, :, :), pointer :: y_speed !< V pointer, point to slice of qp (:,:,:,3) real ( wp ), dimension (:, :, :), pointer :: z_speed !< W pointer, point to slice of qp (:,:,:,4) real ( wp ), dimension (:, :, :), pointer :: tk !< TKE/mass real ( wp ), dimension (:, :, :), pointer :: tw !< Omega real ( wp ), dimension (:, :, :), pointer :: tv !< SA visocity real ( wp ), dimension (:, :, :), pointer :: tkl !< KL K-KL method real ( wp ), dimension (:, :, :), pointer :: tgm !< Intermittency of LCTM2015 DebugCall ( 'evaluate_all_gradients' ) x_speed ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 2 ) y_speed ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 3 ) z_speed ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 4 ) !call compute_gradient_G(gradu_x, qp(:,:,:,2), cells, Ifaces, Jfaces, Kfaces, dims, 'x') call compute_gradient_G ( gradu_x , x_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradv_x , y_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradw_x , z_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradT_x , Temp , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) !call compute_gradient_G(gradu_y, qp(:,:,:,2), cells, Ifaces, Jfaces, Kfaces, dims, 'y') call compute_gradient_G ( gradu_y , x_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) call compute_gradient_G ( gradv_y , y_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) call compute_gradient_G ( gradw_y , z_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) call compute_gradient_G ( gradT_y , Temp , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) if ( dims % kmx > 2 ) then call compute_gradient_G ( gradu_z , x_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) call compute_gradient_G ( gradv_z , y_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) call compute_gradient_G ( gradw_z , z_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) !call compute_gradient_T(gradT_z         , cells, Ifaces, Jfaces, Kfaces, dims, 'z') call compute_gradient_G ( gradT_z , Temp , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) else gradqp_z = 0.0 end if select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) tv ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 6 ) call compute_gradient_G ( gradtv_x , tv , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtv_y , tv , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtv_z , tv , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) end if case ( 'sst' , 'sst2003' ) tk ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 6 ) tw ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 7 ) call compute_gradient_G ( gradtk_x , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtw_x , tw , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtk_y , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) call compute_gradient_G ( gradtw_y , tw , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtk_z , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) call compute_gradient_G ( gradtw_z , tw , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) end if case ( 'kkl' ) tk ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 6 ) tkl ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 7 ) call compute_gradient_G ( gradtk_x , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtkl_x , tkl , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtk_y , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) call compute_gradient_G ( gradtkl_y , tkl , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtk_z , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) call compute_gradient_G ( gradtkl_z , tkl , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) end if case DEFAULT Fatal_error end select select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 8 ) call compute_gradient_G ( gradtgm_x , tgm , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtgm_y , tgm , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtgm_z , tgm , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) end if case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call apply_gradient_bc ( qp , temp , cells , Ifaces , Jfaces , Kfaces , bc , dims ) end subroutine evaluate_all_gradients subroutine compute_gradient_G ( grad , var , cells , Ifaces , Jfaces , Kfaces , dims , dir ) !<  Compute gradient of any input scalar implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( 0 : dims % imx , 0 : dims % jmx , 0 : dims % kmx ), intent ( out ) :: grad !< Output variable storing the graident of var real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: var !< Input variable of which graident is required character ( len =* ) , intent ( in ) :: dir !< Direction with respect to which gradients are calculated type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i integer :: j integer :: k DebugCall ( 'compute_gradient_G' ) grad (:,:,:) = 0.0 select case ( dir ) case ( 'x' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Ifaces ( i , j , k )% nx * Ifaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Jfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Kfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Ifaces ( i + 1 , j , k )% nx * Ifaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Jfaces ( i , j + 1 , k )% nx * Jfaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Kfaces ( i , j , k + 1 )% nx * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case ( 'y' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Ifaces ( i , j , k )% ny * Ifaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Jfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Kfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Ifaces ( i + 1 , j , k )% ny * Ifaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Jfaces ( i , j + 1 , k )% ny * Jfaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Kfaces ( i , j , k + 1 )% ny * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case ( 'z' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Ifaces ( i , j , k )% nz * Ifaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Jfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Kfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Ifaces ( i + 1 , j , k )% nz * Ifaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Jfaces ( i , j + 1 , k )% nz * Jfaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Kfaces ( i , j , k + 1 )% nz * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case DEFAULT print * , \"ERROR: gradient direction error\" Fatal_error end select if ( any ( isnan ( grad ))) then Fatal_error end if end subroutine compute_gradient_G subroutine apply_gradient_bc ( qp , temp , cells , Ifaces , Jfaces , Kfaces , bc , dims ) !< Call same subroutine for all the face !< Apply/set value of all gradient in the ghost cells !< gradqp_G = (qp_I - qp_G)*Area_W*unit_normal_G/(volume_G) !< volume_G = volume_I !----------------------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Input variable of which graident is required real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Temp !< Intput Temperature variable type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal type ( boundarytype ), intent ( in ) :: bc type ( singlesub ) :: domain DebugCall ( 'apply_gradient_bc' ) domain % imin = 1 domain % imax = 1 domain % jmin = 1 domain % jmax = dims % jmx - 1 domain % kmin = 1 domain % kmax = dims % kmx - 1 domain % il = 1 ; domain % jl = 0 ; domain % kl = 0 domain % iu = 0 ; domain % ju = 0 ; domain % ku = 0 domain % sig = 1 call apply_gradient_bc_face ( qp , temp , cells , Ifaces , dims , domain , bc % imin_id , bc % fixed_wall_temperature ( 1 )) domain % imin = dims % imx domain % imax = dims % imx domain % jmin = 1 domain % jmax = dims % jmx - 1 domain % kmin = 1 domain % kmax = dims % kmx - 1 domain % il = 0 ; domain % jl = 0 ; domain % kl = 0 domain % iu = 1 ; domain % ju = 0 ; domain % ku = 0 domain % sig = - 1 call apply_gradient_bc_face ( qp , temp , cells , Ifaces , dims , domain , bc % imax_id , bc % fixed_wall_temperature ( 2 )) domain % imin = 1 domain % imax = dims % imx - 1 domain % jmin = 1 domain % jmax = 1 domain % kmin = 1 domain % kmax = dims % kmx - 1 domain % il = 0 ; domain % jl = 1 ; domain % kl = 0 domain % iu = 0 ; domain % ju = 0 ; domain % ku = 0 domain % sig = 1 call apply_gradient_bc_face ( qp , temp , cells , Jfaces , dims , domain , bc % jmin_id , bc % fixed_wall_temperature ( 3 )) domain % imin = 1 domain % imax = dims % imx - 1 domain % jmin = dims % jmx domain % jmax = dims % jmx domain % kmin = 1 domain % kmax = dims % kmx - 1 domain % il = 0 ; domain % jl = 0 ; domain % kl = 0 domain % iu = 0 ; domain % ju = 1 ; domain % ku = 0 domain % sig = - 1 call apply_gradient_bc_face ( qp , temp , cells , Jfaces , dims , domain , bc % jmax_id , bc % fixed_wall_temperature ( 4 )) domain % imin = 1 domain % imax = dims % imx - 1 domain % jmin = 1 domain % jmax = dims % jmx - 1 domain % kmin = 1 domain % kmax = 1 domain % il = 0 ; domain % jl = 0 ; domain % kl = 1 domain % iu = 0 ; domain % ju = 0 ; domain % ku = 0 domain % sig = 1 call apply_gradient_bc_face ( qp , temp , cells , Kfaces , dims , domain , bc % kmin_id , bc % fixed_wall_temperature ( 5 )) domain % imin = 1 domain % imax = dims % imx - 1 domain % jmin = 1 domain % jmax = dims % jmx - 1 domain % kmin = dims % kmx domain % kmax = dims % kmx domain % il = 0 ; domain % jl = 0 ; domain % kl = 0 domain % iu = 0 ; domain % ju = 0 ; domain % ku = 1 domain % sig = - 1 call apply_gradient_bc_face ( qp , temp , cells , Kfaces , dims , domain , bc % kmax_id , bc % fixed_wall_temperature ( 6 )) end subroutine apply_gradient_bc subroutine apply_gradient_bc_face ( qp , temp , cells , faces , dims , domain , bc_id , fixed_temp ) !< Call same subroutine for all the face !< Apply/set value of all gradient in the ghost cells !< gradqp_G = (qp_I - qp_G)*Area_W*unit_normal_G/(volume_G) !< volume_G = volume_I !----------------------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( singlesub ), intent ( in ) :: domain !< flags for direction real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Input variable of which graident is required real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Temp !< Intput Temperature variable type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: faces !< Input varaible which stores any(I,J,K) faces' area and unit normal integer , intent ( in ) :: bc_id real ( wp ), intent ( in ) :: fixed_temp real ( wp ), dimension ( n_grad ) :: qp_I real ( wp ), dimension ( n_grad ) :: qp_G real ( wp ) :: T_I real ( wp ) :: T_G real ( wp ) :: c_x real ( wp ) :: c_y real ( wp ) :: c_z integer :: i , j , k , l real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: dot integer :: il , jl , kl integer :: iu , ju , ku il = domain % il jl = domain % jl kl = domain % kl iu = domain % iu ju = domain % ju ku = domain % ku do k = domain % kmin , domain % kmax do j = domain % jmin , domain % jmax do i = domain % imin , domain % imax nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz c_x = faces ( i , j , k )% A * nx / cells ( i - iu , j - ju , k - ku )% volume c_y = faces ( i , j , k )% A * ny / cells ( i - iu , j - ju , k - ku )% volume c_z = faces ( i , j , k )% A * nz / cells ( i - iu , j - ju , k - ku )% volume T_I = Temp ( i - iu , j - ju , k - ku ) T_G = Temp ( i - il , j - jl , k - kl ) qp_I = qp ( i - iu , j - ju , k - ku , 2 : dims % n_var ) qp_G = qp ( i - il , j - jl , k - kl , 2 : dims % n_var ) ! normal component of gradient gradqp_x ( i - il , j - jl , k - kl ,:) = domain % sig * ( qp_I - qp_G ) * c_x gradqp_y ( i - il , j - jl , k - kl ,:) = domain % sig * ( qp_I - qp_G ) * c_y gradqp_z ( i - il , j - jl , k - kl ,:) = domain % sig * ( qp_I - qp_G ) * c_z gradqp_x ( i - il , j - jl , k - kl , 4 ) = domain % sig * ( T_I - T_G ) * c_x gradqp_y ( i - il , j - jl , k - kl , 4 ) = domain % sig * ( T_I - T_G ) * c_y gradqp_z ( i - il , j - jl , k - kl , 4 ) = domain % sig * ( T_I - T_G ) * c_z if ( bc_id ==- 5 . and . ( fixed_temp < 1. . and . fixed_temp >= 0. )) then gradqp_x ( i - il , j - jl , k - kl , 4 ) = - gradqp_x ( i - iu , j - ju , k - ku , 4 ) gradqp_y ( i - il , j - jl , k - kl , 4 ) = - gradqp_y ( i - iu , j - ju , k - ku , 4 ) gradqp_z ( i - il , j - jl , k - kl , 4 ) = - gradqp_z ( i - iu , j - ju , k - ku , 4 ) end if !parallel component of gradient do l = 1 , n_grad dot = ( gradqp_x ( i - iu , j - ju , k - ku , l ) * nx ) + ( gradqp_y ( i - iu , j - ju , k - ku , l ) * ny ) + ( gradqp_z ( i - iu , j - ju , k - ku , l ) * nz ) gradqp_x ( i - il , j - jl , k - kl , l ) = gradqp_x ( i - il , j - jl , k - kl , l ) + ( gradqp_x ( i - iu , j - ju , k - ku , l ) - dot * nx ) gradqp_y ( i - il , j - jl , k - kl , l ) = gradqp_y ( i - il , j - jl , k - kl , l ) + ( gradqp_y ( i - iu , j - ju , k - ku , l ) - dot * ny ) gradqp_z ( i - il , j - jl , k - kl , l ) = gradqp_z ( i - il , j - jl , k - kl , l ) + ( gradqp_z ( i - iu , j - ju , k - ku , l ) - dot * nz ) end do end do end do end do end subroutine apply_gradient_bc_face end module gradients","tags":"","loc":"sourcefile/gradients.f90.html","title":"gradients.f90 – FEST-3D"},{"text":"Calculate the time step for the current iteration This file depends on sourcefile~~time.f90~~EfferentGraph sourcefile~time.f90 time.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~utils.f90 utils.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~read.f90 read.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~time.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~face_interpolant.f90->sourcefile~utils.f90 sourcefile~face_interpolant.f90->sourcefile~vartypes.f90 sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~face_interpolant.f90->sourcefile~weno_nm.f90 sourcefile~ppm.f90 ppm.f90 sourcefile~face_interpolant.f90->sourcefile~ppm.f90 sourcefile~weno.f90 weno.f90 sourcefile~face_interpolant.f90->sourcefile~weno.f90 sourcefile~muscl.f90 muscl.f90 sourcefile~face_interpolant.f90->sourcefile~muscl.f90 sourcefile~read.f90->sourcefile~vartypes.f90 sourcefile~weno_nm.f90->sourcefile~vartypes.f90 sourcefile~ppm.f90->sourcefile~vartypes.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~weno.f90->sourcefile~vartypes.f90 sourcefile~muscl.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~time.f90~~AfferentGraph sourcefile~time.f90 time.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules time Source Code time.f90 Source Code !< Calculate the time step for the current iteration module time !< Calculate the time step for the current iteration use vartypes use mpi use viscosity , only : mu use viscosity , only : mu_t use utils , only : alloc use face_interpolant , only : & x_qp_left , x_qp_right , & y_qp_left , y_qp_right , & z_qp_left , z_qp_right use read , only : read_input_and_controls #include \"debug.h\" #include \"error.h\" private integer :: & nb_ticks_initial , & !< Initial value of the clock tick counter nb_ticks_final , & !< Final value of the clock tick counter nb_ticks_max , & !< Maximum value of the clock counter nb_ticks_sec , & !< Number of clock ticks per second nb_ticks !< Number of clock ticks of the code real ( wp ) :: elapsed_time !< real(wp) time in seconds real ( wp ) :: t1 !< Start clock time real ( wp ) :: t2 !< Finish clock time real ( wp ) :: cpu_time_elapsed real ( wp ) :: sim_clock = 0.0 integer :: imx , jmx , kmx , n_var ! Public methods public :: setup_time public :: destroy_time public :: compute_time_step public :: update_simulation_clock contains subroutine setup_time ( delta_t , control , dims ) !< Allocate memeroy and setup initial clock implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension (:,:,:), allocatable , intent ( out ) :: delta_t !< Local time increment value at each cell center DebugCall ( 'initmisc' ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var call alloc ( delta_t , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , & errmsg = 'Error: Unable to allocate memory for delta_t.' ) CALL SYSTEM_CLOCK ( COUNT_RATE = nb_ticks_sec , COUNT_MAX = nb_ticks_max ) CALL SYSTEM_CLOCK ( COUNT = nb_ticks_initial ) CALL CPU_TIME ( t1 ) end subroutine setup_time subroutine destroy_time ( control ) !< Deallocate memory and find simulation time. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters real ( wp ), dimension (:), allocatable :: total_time !< Total time of executation for each block integer :: ierr !< error variable for mpi communication DebugCall ( 'deallocate_misc' ) !simlulation clock data if ( control % process_id == 0 ) write ( * , '(A)' ) '>> TIME <<' if ( control % process_id == 0 ) write ( * , '(A)' ) \"Simulation Clock : \" // trim ( write_time ( sim_clock )) call alloc ( total_time , 1 , control % total_process ) CALL CPU_TIME ( t2 ) CALL SYSTEM_CLOCK ( COUNT = nb_ticks_final ) nb_ticks = nb_ticks_final - nb_ticks_initial IF ( nb_ticks_final < nb_ticks_initial ) & nb_ticks = nb_ticks + nb_ticks_max elapsed_time = REAL ( nb_ticks ) / nb_ticks_sec cpu_time_elapsed = t2 - t1 write ( * , '(A,I0,A)' ) 'process: ' , control % process_id ,& \" > SYSTEM clock <: \" // trim ( write_time ( elapsed_time )) // & \" /-\\ CPU time <: \" // trim ( write_time ( cpu_time_elapsed )) !total time including all blocks call MPI_GATHER ( elapsed_time , 1 , MPI_DOUBLE_PRECISION , & total_time , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierr ) if ( control % process_id == 0 ) print * , \"Total SYSTEM clock: \" , trim ( write_time ( sum ( total_time ))) call MPI_GATHER ( cpu_time_elapsed , 1 , MPI_DOUBLE_PRECISION , & total_time , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierr ) if ( control % process_id == 0 ) print * , \"Total CPU time    : \" , trim ( write_time ( sum ( total_time ))) end subroutine destroy_time function write_time ( time_in_seconds ) result ( string ) !< Particular format to write time in output log file implicit none real ( wp ), intent ( in ) :: time_in_seconds !< Time to output character ( len = 64 ) :: string !< Time as string in particlar format if ( time_in_seconds > 86400 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 8640 0. , \"days\" elseif ( time_in_seconds > 3600 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 360 0. , \"Hr.\" elseif ( time_in_seconds > 60 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 6 0. , \"Min.\" elseif ( time_in_seconds > 0 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds , \"Sec.\" else write ( string , '(A)' ) \"Not Valid\" end if end function write_time subroutine compute_local_time_step ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , scheme , flow , dims ) !< Compute the time step to be used at each cell center !< !< Local time stepping can be used to get the solution !< advance towards steady state faster. If only the steady !< state solution is required, i.e., transients are !< irrelevant, use local time stepping. !----------------------------------------------------------- implicit none real ( wp ), intent ( in ) :: CFL !< CFL number type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ) :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum real ( wp ) :: x_sound_speed_avg , y_sound_speed_avg , z_sound_speed_avg integer :: i , j , k DebugCall ( 'compute_local_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! For orientation, refer to the report. The standard i,j,k ! direction are marked. All orientation notations are w.r.t ! to the perspective shown in the image. ! Faces with lower index x_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * x_qp_left ( i , j , k , 5 ) / & x_qp_left ( i , j , k , 1 )) + & sqrt ( flow % gm * x_qp_right ( i , j , k , 5 ) / & x_qp_right ( i , j , k , 1 )) ) y_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * y_qp_left ( i , j , k , 5 ) / & y_qp_left ( i , j , k , 1 )) + & sqrt ( flow % gm * y_qp_right ( i , j , k , 5 ) / & y_qp_right ( i , j , k , 1 )) ) z_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * z_qp_left ( i , j , k , 5 ) / & z_qp_left ( i , j , k , 1 )) + & sqrt ( flow % gm * z_qp_right ( i , j , k , 5 ) / & z_qp_right ( i , j , k , 1 )) ) ! For left face: i.e., lower index face along xi direction lmx1 = abs ( & ( qp ( i , j , k , 2 ) * Ifaces ( i , j , k )% nx ) + & ( qp ( i , j , k , 3 ) * Ifaces ( i , j , k )% ny ) + & ( qp ( i , j , k , 4 ) * Ifaces ( i , j , k )% nz )) + & x_sound_speed_avg ! For front face, i.e., lower index face along eta direction lmx2 = abs ( & ( qp ( i , j , k , 2 ) * Jfaces ( i , j , k )% nx ) + & ( qp ( i , j , k , 3 ) * Jfaces ( i , j , k )% ny ) + & ( qp ( i , j , k , 4 ) * Jfaces ( i , j , k )% nz )) + & y_sound_speed_avg ! For bottom face, i.e., lower index face along zeta direction lmx3 = abs ( & ( qp ( i , j , k , 2 ) * Kfaces ( i , j , k )% nx ) + & ( qp ( i , j , k , 3 ) * Kfaces ( i , j , k )% ny ) + & ( qp ( i , j , k , 4 ) * Kfaces ( i , j , k )% nz )) + & z_sound_speed_avg ! Faces with higher index x_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * x_qp_left ( i + 1 , j , k , 5 ) / x_qp_left ( i + 1 , j , k , 1 )) + & sqrt ( flow % gm * x_qp_right ( i + 1 , j , k , 5 ) / x_qp_right ( i + 1 , j , k , 1 )) ) y_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * y_qp_left ( i , j + 1 , k , 5 ) / y_qp_left ( i , j + 1 , k , 1 )) + & sqrt ( flow % gm * y_qp_right ( i , j + 1 , k , 5 ) / y_qp_right ( i , j + 1 , k , 1 )) ) z_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * z_qp_left ( i , j , k + 1 , 5 ) / z_qp_left ( i , j , k + 1 , 1 )) + & sqrt ( flow % gm * z_qp_right ( i , j , k + 1 , 5 ) / z_qp_right ( i , j , k + 1 , 1 )) ) ! For right face, i.e., higher index face along xi direction lmx4 = abs ( & ( qp ( i + 1 , j , k , 2 ) * Ifaces ( i + 1 , j , k )% nx ) + & !x_speed*xnx ( qp ( i + 1 , j , k , 3 ) * Ifaces ( i + 1 , j , k )% ny ) + & !y_speed*xny ( qp ( i + 1 , j , k , 4 ) * Ifaces ( i + 1 , j , k )% nz )) + & !z_speed*xnz x_sound_speed_avg ! For back face, i.e., higher index face along eta direction lmx5 = abs ( & ( qp ( i , j + 1 , k , 2 ) * Jfaces ( i , j + 1 , k )% nx ) + & ( qp ( i , j + 1 , k , 3 ) * Jfaces ( i , j + 1 , k )% ny ) + & ( qp ( i , j + 1 , k , 4 ) * Jfaces ( i , j + 1 , k )% nz )) + & y_sound_speed_avg ! For top face, i.e., higher index face along zeta direction lmx6 = abs ( & ( qp ( i , j , k + 1 , 2 ) * Kfaces ( i , j , k + 1 )% nx ) + & ( qp ( i , j , k + 1 , 3 ) * Kfaces ( i , j , k + 1 )% ny ) + & ( qp ( i , j , k + 1 , 4 ) * Kfaces ( i , j , k + 1 )% nz )) + & z_sound_speed_avg lmxsum = ( Ifaces ( i , j , k )% A * lmx1 ) + & ( Jfaces ( i , j , k )% A * lmx2 ) + & ( Kfaces ( i , j , k )% A * lmx3 ) + & ( Ifaces ( i + 1 , j , k )% A * lmx4 ) + & ( Jfaces ( i , j + 1 , k )% A * lmx5 ) + & ( Kfaces ( i , j , k + 1 )% A * lmx6 ) delta_t ( i , j , k ) = 1. / lmxsum delta_t ( i , j , k ) = delta_t ( i , j , k ) * cells ( i , j , k )% volume * CFL end do end do end do if ( flow % mu_ref /= 0.0 ) then call add_viscous_time ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , flow , dims ) end if if ( flow % mu_ref /= 0 . and . trim ( scheme % turbulence ) /= 'none' ) then call add_turbulent_time ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , flow , dims ) end if end subroutine compute_local_time_step subroutine compute_global_time_step ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , scheme , flow , dims ) !< Compute a common time step to be used at all cell centers !< !< Global time stepping is generally used to get time !< accurate solutions; transients can be studied by !< employing this strategy. !<----------------------------------------------------------- implicit none real ( wp ), intent ( in ) :: CFL !< CFL number type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces DebugCall ( 'compute_global_time_step' ) if ( scheme % global_time_step > 0 ) then delta_t = scheme % global_time_step else call compute_local_time_step ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , scheme , flow , dims ) ! The global time step is the minimum of all the local time ! steps. delta_t = minval ( delta_t ) end if end subroutine compute_global_time_step subroutine compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) !< Compute the time step to be used !< !< This calls either compute_global_time_step() or !< compute_local_time_step() based on what !< time_stepping_method is set to. !----------------------------------------------------------- implicit none real ( wp ), intent ( in ) :: CFL !< CFL number type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces DebugCall ( 'compute_time_step' ) if ( scheme % time_stepping_method . eq . 'g' ) then call compute_global_time_step ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , scheme , flow , dims ) else if ( scheme % time_stepping_method . eq . 'l' ) then call compute_local_time_step ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , scheme , flow , dims ) else print * , 'In compute_time_step: value for time_stepping_method (' // scheme % time_stepping_method // ') not recognized.' Fatal_error end if !update_simulation clock call update_simulation_clock ( delta_t , scheme , dims ) end subroutine compute_time_step subroutine update_simulation_clock ( delta_t , scheme , dims ) !<  Update the simulation clock !< !<  It is sometimes useful to know what the simulation time is !<  at every iteration so that a comparison with an analytical !<  solution is possible. Since, the global timesteps used may !<  not be uniform, we need to track this explicitly. !< !<  Of course, it makes sense to track this only if the time !<  stepping is global and not local. If the time stepping is !<  local, the simulation clock is set to -1. If it is global !<  it is incremented according to the time step found. !----------------------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes: time stepping methods real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center if ( scheme % time_stepping_method . eq . 'g' . and . sim_clock >= 0. ) then sim_clock = sim_clock + minval ( delta_t ) else if ( scheme % time_stepping_method . eq . 'l' ) then sim_clock = - 1 end if end subroutine update_simulation_clock subroutine add_viscous_time ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , flow , dims ) !< Addition to local time step due to viscous effects implicit none real ( wp ), intent ( in ) :: CFL !< CFL number type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ) :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum integer :: i , j , k DebugCall ( 'add_viscous_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! Faces with lower index ! For left face: i.e., lower index face along xi direction lmx1 = mu ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i - 1 , j , k )% centerx - cells ( i , j , k )% centerx ) * Ifaces ( i , j , k )% nx ) + & (( cells ( i - 1 , j , k )% centery - cells ( i , j , k )% centery ) * Ifaces ( i , j , k )% ny ) + & (( cells ( i - 1 , j , k )% centerz - cells ( i , j , k )% centerz ) * Ifaces ( i , j , k )% nz ))) ! For front face, i.e., lower index face along eta direction lmx2 = mu ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i , j - 1 , k )% centerx - cells ( i , j , k )% centerx ) * Jfaces ( i , j , k )% nx ) + & (( cells ( i , j - 1 , k )% centery - cells ( i , j , k )% centery ) * Jfaces ( i , j , k )% ny ) + & (( cells ( i , j - 1 , k )% centerz - cells ( i , j , k )% centerz ) * Jfaces ( i , j , k )% nz ))) ! For bottom face, i.e., lower index face along zeta direction lmx3 = mu ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i , j , k - 1 )% centerx - cells ( i , j , k )% centerx ) * Kfaces ( i , j , k )% nx ) + & (( cells ( i , j , k - 1 )% centery - cells ( i , j , k )% centery ) * Kfaces ( i , j , k )% ny ) + & (( cells ( i , j , k - 1 )% centerz - cells ( i , j , k )% centerz ) * Kfaces ( i , j , k )% nz ))) ! For right face, i.e., higher index face along xi direction lmx4 = mu ( i + 1 , j , k ) / ( qp ( i + 1 , j , k , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i + 1 , j , k )% centerx ) * Ifaces ( i + 1 , j , k )% nx ) + & (( cells ( i , j , k )% centery - cells ( i + 1 , j , k )% centery ) * Ifaces ( i + 1 , j , k )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i + 1 , j , k )% centerz ) * Ifaces ( i + 1 , j , k )% nz ))) ! For back face, i.e., higher index face along eta direction lmx5 = mu ( i , j + 1 , k ) / ( qp ( i , j + 1 , k , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i , j + 1 , k )% centerx ) * Jfaces ( i , j + 1 , k )% nx ) + & (( cells ( i , j , k )% centery - cells ( i , j + 1 , k )% centery ) * Jfaces ( i , j + 1 , k )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i , j + 1 , k )% centerz ) * Jfaces ( i , j + 1 , k )% nz ))) ! For top face, i.e., higher index face along zeta direction lmx6 = mu ( i , j , k + 1 ) / ( qp ( i , j , k + 1 , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i , j , k + 1 )% centerx ) * Kfaces ( i , j , k + 1 )% nx ) + & (( cells ( i , j , k )% centery - cells ( i , j , k + 1 )% centery ) * Kfaces ( i , j , k + 1 )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i , j , k + 1 )% centerz ) * Kfaces ( i , j , k + 1 )% nz ))) lmxsum = ( Ifaces ( i , j , k )% A * lmx1 ) + & ( Jfaces ( i , j , k )% A * lmx2 ) + & ( Kfaces ( i , j , k )% A * lmx3 ) + & ( Ifaces ( i + 1 , j , k )% A * lmx4 ) + & ( Jfaces ( i , j + 1 , k )% A * lmx5 ) + & ( Kfaces ( i , j , k + 1 )% A * lmx6 ) lmxsum = flow % gm * lmxsum / flow % Pr lmxsum = 2. / ( lmxsum + ( 2. * CFL * cells ( i , j , k )% volume / delta_t ( i , j , k ))) delta_t ( i , j , k ) = CFL * ( lmxsum * cells ( i , j , k )% volume ) end do end do end do end subroutine add_viscous_time subroutine add_turbulent_time ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , flow , dims ) !< Addition to local time step due to turbulence implicit none real ( wp ), intent ( in ) :: CFL !< CFL number type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ) :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum integer :: i , j , k DebugCall ( 'add_viscous_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! Faces with lower index ! For left face: i.e., lower index face along xi direction lmx1 = mu_t ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i - 1 , j , k )% centerx - cells ( i , j , k )% centerx ) * Ifaces ( i , j , k )% nx ) + & (( cells ( i - 1 , j , k )% centery - cells ( i , j , k )% centery ) * Ifaces ( i , j , k )% ny ) + & (( cells ( i - 1 , j , k )% centerz - cells ( i , j , k )% centerz ) * Ifaces ( i , j , k )% nz ))) ! For front face, i.e., lower index face along eta direction lmx2 = mu_t ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i , j - 1 , k )% centerx - cells ( i , j , k )% centerx ) * Jfaces ( i , j , k )% nx ) + & (( cells ( i , j - 1 , k )% centery - cells ( i , j , k )% centery ) * Jfaces ( i , j , k )% ny ) + & (( cells ( i , j - 1 , k )% centerz - cells ( i , j , k )% centerz ) * Jfaces ( i , j , k )% nz ))) ! For bottom face, i.e., lower index face along zeta direction lmx3 = mu_t ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i , j , k - 1 )% centerx - cells ( i , j , k )% centerx ) * Kfaces ( i , j , k )% nx ) + & (( cells ( i , j , k - 1 )% centery - cells ( i , j , k )% centery ) * Kfaces ( i , j , k )% ny ) + & (( cells ( i , j , k - 1 )% centerz - cells ( i , j , k )% centerz ) * Kfaces ( i , j , k )% nz ))) ! For right face, i.e., higher index face along xi direction lmx4 = mu_t ( i + 1 , j , k ) / ( qp ( i + 1 , j , k , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i + 1 , j , k )% centerx ) * Ifaces ( i + 1 , j , k )% nx ) + & (( cells ( i , j , k )% centery - cells ( i + 1 , j , k )% centery ) * Ifaces ( i + 1 , j , k )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i + 1 , j , k )% centerz ) * Ifaces ( i + 1 , j , k )% nz ))) ! For back face, i.e., higher index face along eta direction lmx5 = mu_t ( i , j + 1 , k ) / ( qp ( i , j + 1 , k , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i , j + 1 , k )% centerx ) * Jfaces ( i , j + 1 , k )% nx ) + & (( cells ( i , j , k )% centery - cells ( i , j + 1 , k )% centery ) * Jfaces ( i , j + 1 , k )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i , j + 1 , k )% centerz ) * Jfaces ( i , j + 1 , k )% nz ))) ! For top face, i.e., higher index face along zeta direction lmx6 = mu_t ( i , j , k + 1 ) / ( qp ( i , j , k + 1 , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i , j , k + 1 )% centerx ) * Kfaces ( i , j , k + 1 )% nx ) + & (( cells ( i , j , k )% centery - cells ( i , j , k + 1 )% centery ) * Kfaces ( i , j , k + 1 )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i , j , k + 1 )% centerz ) * Kfaces ( i , j , k + 1 )% nz ))) lmxsum = ( Ifaces ( i , j , k )% A * lmx1 ) + & ( Jfaces ( i , j , k )% A * lmx2 ) + & ( Kfaces ( i , j , k )% A * lmx3 ) + & ( Ifaces ( i + 1 , j , k )% A * lmx4 ) + & ( Jfaces ( i , j + 1 , k )% A * lmx5 ) + & ( Kfaces ( i , j , k + 1 )% A * lmx6 ) lmxsum = flow % gm * lmxsum / flow % tPr lmxsum = 2. / ( lmxsum + ( 2. * CFL * cells ( i , j , k )% volume / delta_t ( i , j , k ))) delta_t ( i , j , k ) = CFL * ( lmxsum * cells ( i , j , k )% volume ) end do end do end do end subroutine add_turbulent_time end module time","tags":"","loc":"sourcefile/time.f90.html","title":"time.f90 – FEST-3D"},{"text":"Allocate memory to the state variables and initialize them This file depends on sourcefile~~state.f90~~EfferentGraph sourcefile~state.f90 state.f90 sourcefile~utils.f90 utils.f90 sourcefile~state.f90->sourcefile~utils.f90 sourcefile~check_output_control.f90 check_output_control.f90 sourcefile~state.f90->sourcefile~check_output_control.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~state.f90->sourcefile~vartypes.f90 sourcefile~check_output_control.f90->sourcefile~vartypes.f90 sourcefile~read_output.f90->sourcefile~utils.f90 sourcefile~read_output.f90->sourcefile~check_output_control.f90 sourcefile~read_output.f90->sourcefile~vartypes.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output.f90->sourcefile~read_output_vtk.f90 sourcefile~read_output_tec.f90->sourcefile~utils.f90 sourcefile~read_output_tec.f90->sourcefile~vartypes.f90 sourcefile~read_output_vtk.f90->sourcefile~utils.f90 sourcefile~read_output_vtk.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~state.f90~~AfferentGraph sourcefile~state.f90 state.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules state Source Code state.f90 Source Code !< Allocate memory to the state variables and initialize them module state !< Allocate memory to the state variables and initialize them !< The state of the system is defined using the density, velocity and !< pressure (primitive variables qp), and trubulent and transition !< variables at the cell-center points. !------------------------------------------------------------------- ! The state module contains the state variables and the methods that ! act on them. !------------------------------------------------------------------- #include \"debug.h\" #include \"error.h\" use vartypes use utils , only : alloc use read_output , only : read_file use check_output_control , only : verify_write_control implicit none private integer :: n_var integer :: imx , jmx , kmx ! Public methods public :: setup_state contains subroutine setup_state ( files , qp , control , scheme , flow , dims ) !< Setup the state module. !< This subroutine should be run before the state variables !< are initilized. This subroutine allocates the memory for !< state variables and sets up the aliases to refer to the !< components of the state !----------------------------------------------------------- implicit none type ( filetype ), intent ( inout ) :: files !< Files' name and handler type ( controltype ), intent ( inout ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( inout ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( inout ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension (:,:,:,:), allocatable , intent ( inout ), target :: qp !< Store primitive variable at cell center DebugCall ( \"setup_state\" ) n_var = control % n_var imx = dims % imx jmx = dims % jmx kmx = dims % kmx call set_n_var_value ( control , scheme ) dims % n_var = control % n_var !call allocate_memory(qp) call alloc ( qp , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var , AErrMsg ( \"qp\" )) allocate ( control % previous_res ( 1 : control % n_var + 1 )) !call link_aliases(scheme) call init_infinity_values ( scheme , flow ) call initstate ( files , qp , control , scheme , flow , dims ) end subroutine setup_state subroutine init_infinity_values ( scheme , flow ) !< Set the values of the infinity variables \"qp_inf\" !----------------------------------------------------------- implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes: turbulence, transition model, etc type ( flowtype ), intent ( inout ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. DebugCall ( \"init_infinity_values\" ) flow % vel_mag = sqrt ( flow % x_speed_inf ** 2 + flow % y_speed_inf ** 2 + flow % z_speed_inf ** 2 ) flow % MInf = flow % vel_mag / sqrt ( flow % gm * flow % pressure_inf / flow % density_inf ) flow % Reynolds_number = flow % density_inf * flow % vel_mag * 1.0 / flow % mu_ref flow % Turb_intensity_inf = flow % tu_inf / 100 select case ( trim ( scheme % turbulence )) case ( \"none\" ) continue case ( \"sst\" , \"sst2003\" , \"bsl\" ) flow % tk_inf = 1.5 * (( flow % Vel_mag * flow % Turb_Intensity_inf ) ** 2 ) flow % tw_inf = flow % density_inf * flow % tk_inf / ( flow % mu_ref * flow % mu_ratio_inf ) case ( \"kkl\" ) flow % tk_inf = 9 * ( 1 e - 9 ) * ( sound_speed_inf ( flow ) ** 2 ) flow % tkl_inf = 1.5589 * ( 1 e - 6 ) * ( flow % mu_ref * sound_speed_inf ( flow )) / flow % density_inf case ( \"sa\" ) flow % tv_inf = flow % mu_ratio_inf * flow % mu_ref / flow % density_inf case ( \"saBC\" ) flow % tv_inf = 0.005 * flow % mu_ratio_inf * flow % mu_ref / flow % density_inf case ( \"kw\" ) flow % tk_inf = 1.5 * (( flow % Vel_mag * flow % Turb_Intensity_inf ) ** 2 ) flow % tw_inf = flow % density_inf * flow % tk_inf / ( flow % mu_ref * flow % mu_ratio_inf ) case ( \"ke\" ) flow % tk_inf = 1.5 * (( flow % Vel_mag * flow % Turb_Intensity_inf ) ** 2 ) flow % tw_inf = 0.09 * flow % density_inf * flow % tk_inf * flow % tk_inf / ( flow % mu_ref * flow % mu_ratio_inf ) case ( \"des-sst\" ) flow % tk_inf = 1.5 * (( flow % Vel_mag * flow % Turb_Intensity_inf ) ** 2 ) flow % tw_inf = flow % density_inf * flow % tk_inf / ( flow % mu_ref * flow % mu_ratio_inf ) case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select end subroutine init_infinity_values function sound_speed_inf ( flow ) result ( a ) !< Return the free stream speed of sound. !----------------------------------------------------------- implicit none type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ) :: a !< output variable: speed of sound a = sqrt ( flow % gm * flow % pressure_inf / flow % density_inf ) end function sound_speed_inf subroutine initstate ( files , qp , control , scheme , flow , dims ) !< Initialize the state. !< If load file(start_from) is 0, then the state should be !< set to the infinity values. Otherwise, read the state_file !< to get the state values !----------------------------------------------------------- implicit none type ( filetype ), intent ( inout ) :: files !< Files' name and handler type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( controltype ), intent ( inout ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: qp !< Store primitive variable at cell center DebugCall ( \"initstate\" ) call verify_write_control ( control , scheme , flow ) if ( control % start_from . eq . 0 ) then ! Set the state to the infinity values call init_state_with_infinity_values ( qp , scheme , flow , dims ) else write ( files % infile , '(a,i4.4,a,i2.2)' ) & \"time_directories/\" , control % start_from , \"/process_\" , process_id ! Set the state to the infinity values so if some ! variable are not restart variable they get free_stream value call init_state_with_infinity_values ( qp , scheme , flow , dims ) call read_file ( files , qp , control , scheme , dims ) end if end subroutine initstate subroutine init_state_with_infinity_values ( qp , scheme , flow , dims ) !< Initialize the state based on the infinity values !----------------------------------------------------------- implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: qp !< Store primitive variable at cell center DebugCall ( \"init_state_with_infinity_values\" ) !density = density_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 ) = flow % density_inf !x_speed = x_speed_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 2 ) = flow % x_speed_inf !y_speed = y_speed_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 3 ) = flow % y_speed_inf !z_speed = z_speed_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 4 ) = flow % z_speed_inf !pressure = pressure_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 5 ) = flow % pressure_inf select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) !tk = tk_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 6 ) = flow % tk_inf !tw = tw_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 7 ) = flow % tw_inf case ( \"kkl\" ) !tk = tk_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 6 ) = flow % tk_inf !tkl = tkl_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 7 ) = flow % tkl_inf case ( \"sa\" , \"saBC\" ) !tv = tv_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 6 ) = flow % tv_inf case ( \"ke\" ) !tk = tk_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 6 ) = flow % tk_inf !te = te_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 7 ) = flow % te_inf case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) !tgm = tgm_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 8 ) = flow % tgm_inf case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine init_state_with_infinity_values subroutine set_n_var_value ( control , scheme ) !< Set number of variable to solver for based on !< the tubulence and transition model being used implicit none type ( controltype ), intent ( inout ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes DebugCall ( \"set_n_var_value\" ) select case ( trim ( scheme % turbulence )) case ( 'none' ) n_var = 5 case ( 'sa' , 'saBC' ) n_var = 6 case ( 'sst' , \"sst2003\" , 'bsl' , 'kw' , 'ke' , 'kkl' , 'Des-kw' ) n_var = 7 case DEFAULT n_var = 5 end select !Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) n_var = n_var + 1 case ( 'bc' , 'none' ) n_var = n_var + 0 case DEFAULT Fatal_error end Select control % n_var = n_var end subroutine set_n_var_value end module state","tags":"","loc":"sourcefile/state.f90.html","title":"state.f90 – FEST-3D"},{"text":"Calculate Cell-center and normal through them for transition model This file depends on sourcefile~~cc.f90~~EfferentGraph sourcefile~cc.f90 CC.f90 sourcefile~utils.f90 utils.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~cc.f90->sourcefile~wall_dist.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~cc.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~cc.f90~~AfferentGraph sourcefile~cc.f90 CC.f90 sourcefile~source.f90 source.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~cc.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~source.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules CC Source Code CC.f90 Source Code !< Calculate Cell-center and normal through them for transition model module CC !< In order to calculate pressure gradient in the transition model, two !< quantities are required: the distance of the cell-center from the wall !< andn the normal made by the distance vector field (from wall to cell-center). !< This module calucate both with gradient of V.n also. #include \"debug.h\" #include \"error.h\" use vartypes use wall_dist , only : dist use utils , only : alloc implicit none private real ( wp ), dimension (:, :, :), allocatable :: CCnormalX !< Cell-Center normal nx with respect to wall; used for transition model (pressure gradient calcualtion) real ( wp ), dimension (:, :, :), allocatable :: CCnormalY !< Cell-Center normal ny with respect to wall; used for transiton model (pressure gradient calculation) real ( wp ), dimension (:, :, :), allocatable :: CCnormalZ !< Cell-Center normal nz with respect to wall; used for transiton model (pressure gradient calculation) real ( wp ), dimension (:, :, :), allocatable :: CCVn !< Store value at Cell-Center of dot product between velocity vector and cell-center normal. {vec(Velocity).normal} real ( wp ), dimension (:, :, :), allocatable :: DCCVnX !< Store Derivative of Cell-Center CCVn with respect to x real ( wp ), dimension (:, :, :), allocatable :: DCCVnY !< Store Derivative of Cell-Center CCVn with respect to y real ( wp ), dimension (:, :, :), allocatable :: DCCVnZ !< Store Derivative of Cell-Center CCVn with respect to z public :: find_DCCVn public :: setupCC public :: CCnormalX public :: CCnormalY public :: CCnormalZ public :: DCCVnX public :: DCCVnY public :: DCCVnZ contains subroutine setupCC ( scheme , cells , Ifaces , Jfaces , Kfaces , dims ) !< Allocate memory for the cell center variable only in case of transition model implicit none type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal DebugCall ( \"Setup CC\" ) if (( scheme % transition == 'lctm2015' ) . and . scheme % turbulence /= 'none' ) then call alloc ( CCnormalX , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"CCnormalX\" )) call alloc ( CCnormalY , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"CCnormalY\" )) call alloc ( CCnormalZ , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"CCnormalZ\" )) call alloc ( CCVn , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"CCVn\" )) call alloc ( DCCVnX , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"DCCVnZ\" )) call alloc ( DCCVnY , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"DCCVnY\" )) call alloc ( DCCVnZ , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"DCCVnZ\" )) call find_CCnormal ( cells , Ifaces , Jfaces , Kfaces , dims ) end if end subroutine setupCC subroutine find_CCnormal ( cells , Ifaces , Jfaces , Kfaces , dims ) !< Find the cell-center unit normal implicit none type ( extent ), intent ( in ) :: dims type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal call compute_gradient ( CCnormalX , dist , cells , Ifaces , Jfaces , Kfaces , 'x' , dims ) call compute_gradient ( CCnormalY , dist , cells , Ifaces , Jfaces , Kfaces , 'y' , dims ) call compute_gradient ( CCnormalZ , dist , cells , Ifaces , Jfaces , Kfaces , 'z' , dims ) !using already allocated memeory for storing magnitude CCVn = sqrt ( CCnormalX ** 2 + CCnormalY ** 2 + CCnormalZ ** 2 ) !CCVn hold the magnitude of CCnormal temporaraly and can be !overwritten after next three lines of code. CCnormalX = CCnormalX / ( CCVn + 1 e - 12 ) CCnormalY = CCnormalY / ( CCVn + 1 e - 12 ) CCnormalZ = CCnormalZ / ( CCVn + 1 e - 12 ) end subroutine find_CCnormal subroutine find_CCVn ( qp , dims ) !< Taking a dot product between Cell-center velocity and unit normal implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx , - 2 : dims % jmx , - 2 : dims % kmx , - 2 : dims % n_var ), intent ( in ) :: qp CCVn = CCnormalX * qp (:,:,:, 2 ) + CCnormalY * qp (:,:,:, 3 ) + CCnormalZ * qp (:,:,:, 4 ) ! (nx,ny,nz).(u,v,w) end subroutine find_CCVn subroutine find_DCCVn ( qp , cells , Ifaces , Jfaces , Kfaces , dims ) !< Find gradient of the dot product between cell velocity and unit normal implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx , - 2 : dims % jmx , - 2 : dims % kmx , - 2 : dims % n_var ), intent ( in ) :: qp type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal call find_CCVn ( qp , dims ) call compute_gradient ( DCCVnX , dist , cells , Ifaces , Jfaces , Kfaces , 'x' , dims ) call compute_gradient ( DCCVnY , dist , cells , Ifaces , Jfaces , Kfaces , 'y' , dims ) call compute_gradient ( DCCVnZ , dist , cells , Ifaces , Jfaces , Kfaces , 'z' , dims ) end subroutine find_DCCVn subroutine compute_gradient ( grad , var , cells , Ifaces , Jfaces , Kfaces , dir , dims ) !< Generalized subroutine to calculate gradients implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( out ) :: grad real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: var character ( len =* ) , intent ( in ) :: dir type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i integer :: j integer :: k ! initialize grad = 0.0 select case ( dir ) case ( 'x' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Ifaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Ifaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Ifaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Ifaces ( i + 1 , j , k )% nx * Ifaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Ifaces ( i , j + 1 , k )% ny * Ifaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Ifaces ( i , j , k + 1 )% nz * Ifaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case ( 'y' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Jfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Jfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Jfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Jfaces ( i + 1 , j , k )% nx * Jfaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Jfaces ( i , j + 1 , k )% ny * Jfaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Jfaces ( i , j , k + 1 )% nz * Jfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case ( 'z' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Kfaces ( i , j , k )% nx * Kfaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Kfaces ( i , j , k )% ny * Kfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Kfaces ( i , j , k )% nz * Kfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Kfaces ( i + 1 , j , k )% nx * Kfaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Kfaces ( i , j + 1 , k )% ny * Kfaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Kfaces ( i , j , k + 1 )% nz * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case DEFAULT print * , \"ERROR: gradient direction error\" Fatal_error end select if ( any ( isnan ( grad ))) then Fatal_error end if end subroutine compute_gradient end module CC","tags":"","loc":"sourcefile/cc.f90.html","title":"CC.f90 – FEST-3D"},{"text":"The viscous module contains the viscous fluxes calculations This file depends on sourcefile~~viscous.f90~~EfferentGraph sourcefile~viscous.f90 viscous.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscous.f90->sourcefile~global_sa.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~viscous.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~viscous.f90->sourcefile~gradients.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscous.f90->sourcefile~global_kkl.f90 sourcefile~utils.f90 utils.f90 sourcefile~viscous.f90->sourcefile~utils.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~viscous.f90->sourcefile~global_sst.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~viscous.f90~~AfferentGraph sourcefile~viscous.f90 viscous.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules viscous Source Code viscous.f90 Source Code !< The viscous module contains the viscous fluxes calculations module viscous !< The viscous module contains the viscous fluxes calculations !----------------------------------------------------------------- #include \"error.h\" use vartypes use gradients , only : gradu_x use gradients , only : gradu_y use gradients , only : gradu_z use gradients , only : gradv_x use gradients , only : gradv_y use gradients , only : gradv_z use gradients , only : gradw_x use gradients , only : gradw_y use gradients , only : gradw_z use gradients , only : gradT_x use gradients , only : gradT_y use gradients , only : gradT_z use gradients , only : gradtk_x use gradients , only : gradtk_y use gradients , only : gradtk_z use gradients , only : gradtw_x use gradients , only : gradtw_y use gradients , only : gradtw_z use gradients , only : gradtkl_x use gradients , only : gradtkl_y use gradients , only : gradtkl_z use gradients , only : gradtv_x use gradients , only : gradtv_y use gradients , only : gradtv_z use gradients , only : gradtgm_x use gradients , only : gradtgm_y use gradients , only : gradtgm_z use viscosity , only : mu use viscosity , only : mu_t use global_sst , only : sst_F1 use global_sst , only : sigma_k1 use global_sst , only : sigma_k2 use global_sst , only : sigma_w1 use global_sst , only : sigma_w2 use global_kkl , only : sigma_k use global_kkl , only : sigma_phi use global_sa , only : sigma_sa use global_sa , only : cb2 use utils , only : alloc implicit none private integer :: imx , jmx , kmx public :: compute_viscous_fluxes contains subroutine compute_viscous_fluxes ( F , G , H , qp , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) !< Call to all viscous flux subroutine based on !< the drection and turbulence/transition model being !< used implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F , G , H type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces integer , dimension ( 3 ) :: flagsi = ( / 1 , 0 , 0 / ) integer , dimension ( 3 ) :: flagsj = ( / 0 , 1 , 0 / ) integer , dimension ( 3 ) :: flagsk = ( / 0 , 0 , 1 / ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx call compute_viscous_fluxes_laminar ( F , qp , cells , Ifaces , flagsi , scheme , flow , dims ) call compute_viscous_fluxes_laminar ( G , qp , cells , Jfaces , flagsj , scheme , flow , dims ) call compute_viscous_fluxes_laminar ( H , qp , cells , Kfaces , flagsk , scheme , flow , dims ) select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call compute_viscous_fluxes_sa ( F , qp , cells , Ifaces , flagsi , dims ) call compute_viscous_fluxes_sa ( G , qp , cells , Jfaces , flagsj , dims ) call compute_viscous_fluxes_sa ( H , qp , cells , Kfaces , flagsk , dims ) case ( 'sst' , 'sst2003' ) call compute_viscous_fluxes_sst ( F , qp , cells , Ifaces , flagsi , dims ) call compute_viscous_fluxes_sst ( G , qp , cells , Jfaces , flagsj , dims ) if ( kmx == 2 ) then continue else call compute_viscous_fluxes_sst ( H , qp , cells , Kfaces , flagsk , dims ) end if case ( 'kkl' ) call compute_viscous_fluxes_kkl ( F , qp , cells , Ifaces , flagsi , dims ) call compute_viscous_fluxes_kkl ( G , qp , cells , Jfaces , flagsj , dims ) call compute_viscous_fluxes_kkl ( H , qp , cells , Kfaces , flagsk , dims ) case DEFAULT Fatal_error end select select case ( trim ( scheme % transition )) case ( 'lctm2015' ) call compute_viscous_fluxes_lctm2015 ( F , qp , cells , Ifaces , flagsi , dims ) call compute_viscous_fluxes_lctm2015 ( G , qp , cells , Jfaces , flagsj , dims ) if ( kmx == 2 ) then continue else call compute_viscous_fluxes_lctm2015 ( H , qp , cells , Kfaces , flagsk , dims ) end if case ( 'none' , 'bc' ) !do nothing continue case DEFAULT Fatal_error end select if ( any ( isnan ( G ))) then Fatal_error end if if ( any ( isnan ( F ))) then Fatal_error end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_viscous_fluxes subroutine compute_viscous_fluxes_laminar ( F , qp , cells , faces , flags , scheme , flow , dims ) !< Compute viscous fluxes for first five Navier-Stokes equation implicit none real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Flux array type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal ! local variables real ( wp ) :: dudx , dudy , dudz real ( wp ) :: dvdx , dvdy , dvdz real ( wp ) :: dwdx , dwdy , dwdz real ( wp ) :: dTdx , dTdy , dTdz real ( wp ) :: normal_comp real ( wp ) :: d_LR real ( wp ) :: T_RE real ( wp ) :: T_LE real ( wp ) :: K_heat , Qx , Qy , Qz real ( wp ) :: mu_f real ( wp ) :: mut_f real ( wp ) :: total_mu real ( wp ) :: delx real ( wp ) :: dely real ( wp ) :: delz real ( wp ) :: delu real ( wp ) :: delv real ( wp ) :: delw real ( wp ) :: delT real ( wp ) :: Tau_xx real ( wp ) :: Tau_xy real ( wp ) :: Tau_xz real ( wp ) :: Tau_yx real ( wp ) :: Tau_yy real ( wp ) :: Tau_yz real ( wp ) :: Tau_zx real ( wp ) :: Tau_zy real ( wp ) :: Tau_zz real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: area real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface integer :: i , j , k integer :: ii , jj , kk ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) !--------------------------------------------------------------------- ! Calculating the fluxes at the faces !-------------------------------------------------------------------- do k = 1 , dims % kmx - 1 + kk do j = 1 , dims % jmx - 1 + jj do i = 1 , dims % imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dudx = 0.5 * ( gradu_x ( i - ii , j - jj , k - kk ) + gradu_x ( i , j , k )) dudy = 0.5 * ( gradu_y ( i - ii , j - jj , k - kk ) + gradu_y ( i , j , k )) dudz = 0.5 * ( gradu_z ( i - ii , j - jj , k - kk ) + gradu_z ( i , j , k )) dvdx = 0.5 * ( gradv_x ( i - ii , j - jj , k - kk ) + gradv_x ( i , j , k )) dvdy = 0.5 * ( gradv_y ( i - ii , j - jj , k - kk ) + gradv_y ( i , j , k )) dvdz = 0.5 * ( gradv_z ( i - ii , j - jj , k - kk ) + gradv_z ( i , j , k )) dwdx = 0.5 * ( gradw_x ( i - ii , j - jj , k - kk ) + gradw_x ( i , j , k )) dwdy = 0.5 * ( gradw_y ( i - ii , j - jj , k - kk ) + gradw_y ( i , j , k )) dwdz = 0.5 * ( gradw_z ( i - ii , j - jj , k - kk ) + gradw_z ( i , j , k )) dTdx = 0.5 * ( gradT_x ( i - ii , j - jj , k - kk ) + gradT_x ( i , j , k )) dTdy = 0.5 * ( gradT_y ( i - ii , j - jj , k - kk ) + gradT_y ( i , j , k )) dTdz = 0.5 * ( gradT_z ( i - ii , j - jj , k - kk ) + gradT_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = cells ( i , j , k )% centerx - cells ( i - ii , j - jj , k - kk )% centerx dely = cells ( i , j , k )% centery - cells ( i - ii , j - jj , k - kk )% centery delz = cells ( i , j , k )% centerz - cells ( i - ii , j - jj , k - kk )% centerz d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! Finding the temperature of left and right element to the face i,j,k T_LE = qp ( i - ii , j - jj , k - kk , 5 ) / ( qp ( i - ii , j - jj , k - kk , 1 ) * flow % R_gas ) T_RE = qp ( i , j , k , 5 ) / ( qp ( i , j , k , 1 ) * flow % R_gas ) ! difference in state across face delu = qp ( i , j , k , 2 ) - qp ( i - ii , j - jj , k - kk , 2 ) !x_speed delv = qp ( i , j , k , 3 ) - qp ( i - ii , j - jj , k - kk , 3 ) !y_speed delw = qp ( i , j , k , 4 ) - qp ( i - ii , j - jj , k - kk , 4 ) !z_speed delT = T_RE - T_LE !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( delu - ( dudx * delx + dudy * dely + dudz * delz )) / d_LR dudx = dudx + ( normal_comp * delx / d_LR ) dudy = dudy + ( normal_comp * dely / d_LR ) dudz = dudz + ( normal_comp * delz / d_LR ) normal_comp = ( delv - ( dvdx * delx + dvdy * dely + dvdz * delz )) / d_LR dvdx = dvdx + ( normal_comp * delx / d_LR ) dvdy = dvdy + ( normal_comp * dely / d_LR ) dvdz = dvdz + ( normal_comp * delz / d_LR ) normal_comp = ( delw - ( dwdx * delx + dwdy * dely + dwdz * delz )) / d_LR dwdx = dwdx + ( normal_comp * delx / d_LR ) dwdy = dwdy + ( normal_comp * dely / d_LR ) dwdz = dwdz + ( normal_comp * delz / d_LR ) normal_comp = ( delT - ( dTdx * delx + dTdy * dely + dTdz * delz )) / d_LR dTdx = dTdx + ( normal_comp * delx / d_LR ) dTdy = dTdy + ( normal_comp * dely / d_LR ) dTdz = dTdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) if ( trim ( scheme % turbulence ) /= 'none' ) then mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) else mut_f = 0.0 end if ! effective viscosity total_mu = mu_f + mut_f ! Using lambda = -2 * mu / 3 ! diagonal terms of stress tensor Tau_xx = 2. * total_mu * ( dudx - (( dudx + dvdy + dwdz ) / 3. )) Tau_yy = 2. * total_mu * ( dvdy - (( dudx + dvdy + dwdz ) / 3. )) Tau_zz = 2. * total_mu * ( dwdz - (( dudx + dvdy + dwdz ) / 3. )) ! off diagonal symmetrical part of stress tensor Tau_xy = total_mu * ( dvdx + dudy ) Tau_xz = total_mu * ( dwdx + dudz ) Tau_yz = total_mu * ( dwdy + dvdz ) Tau_yx = Tau_xy Tau_zx = Tau_xz Tau_zy = Tau_yz ! Pr: Prandtl Number and tPr: Turbulent Prandtl number ! Qx, Qy, Qz: Conduction fluxes K_heat = ( mu_f / flow % Pr + mut_f / flow % tPr ) * flow % gm * flow % R_gas / ( flow % gm - 1 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz ! calling some element from memory and keep them handy for calculation nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz area = faces ( i , j , k )% A uface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 2 ) + qp ( i , j , k , 2 )) vface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 3 ) + qp ( i , j , k , 3 )) wface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 4 ) + qp ( i , j , k , 4 )) ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - (( Tau_xx * nx + Tau_xy * ny + Tau_xz * nz ) * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - (( Tau_yx * nx + Tau_yy * ny + Tau_yz * nz ) * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - (( Tau_zx * nx + Tau_zy * ny + Tau_zz * nz ) * area ) ! Energy flux ! (TijVj + Qi)ni F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * ( & (( Tau_xx * uface + Tau_xy * vface + Tau_xz * wface + Qx ) * nx ) + & (( Tau_yx * uface + Tau_yy * vface + Tau_yz * wface + Qy ) * ny ) + & (( Tau_zx * uface + Tau_zy * vface + Tau_zz * wface + Qz ) * nz ) ) ) end do end do end do end subroutine compute_viscous_fluxes_laminar subroutine compute_viscous_fluxes_sst ( F , qp , cells , faces , flags , dims ) !< Compute viscous fluxes for additianal equations due to SST turbulence model implicit none real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< flux array type ( extent ), intent ( in ) :: dims !< Extent of the domain: imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction swithc real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< quantities on the face ! local variables real ( wp ) :: tkface real ( wp ) :: rhoface real ( wp ) :: normal_comp real ( wp ) :: d_LR real ( wp ) :: mu_f real ( wp ) :: mut_f real ( wp ) :: total_mu real ( wp ) :: delx real ( wp ) :: dely real ( wp ) :: delz real ( wp ) :: deltk real ( wp ) :: deltw real ( wp ) :: Tau_xx real ( wp ) :: Tau_yy real ( wp ) :: Tau_zz real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: area integer :: i , j , k integer :: ii , jj , kk !--- sst variable requirement ---! real ( wp ) :: dtkdx , dtkdy , dtkdz , dtwdx , dtwdy , dtwdz real ( wp ) :: F1 real ( wp ) :: sigma_kf real ( wp ) :: sigma_wf ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , dims % kmx - 1 + kk do j = 1 , dims % jmx - 1 + jj do i = 1 , dims % imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtkdx = 0.5 * ( gradtk_x ( i - ii , j - jj , k - kk ) + gradtk_x ( i , j , k )) dtkdy = 0.5 * ( gradtk_y ( i - ii , j - jj , k - kk ) + gradtk_y ( i , j , k )) dtkdz = 0.5 * ( gradtk_z ( i - ii , j - jj , k - kk ) + gradtk_z ( i , j , k )) dtwdx = 0.5 * ( gradtw_x ( i - ii , j - jj , k - kk ) + gradtw_x ( i , j , k )) dtwdy = 0.5 * ( gradtw_y ( i - ii , j - jj , k - kk ) + gradtw_y ( i , j , k )) dtwdz = 0.5 * ( gradtw_z ( i - ii , j - jj , k - kk ) + gradtw_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = cells ( i , j , k )% centerx - cells ( i - ii , j - jj , k - kk )% centerx dely = cells ( i , j , k )% centery - cells ( i - ii , j - jj , k - kk )% centery delz = cells ( i , j , k )% centerz - cells ( i - ii , j - jj , k - kk )% centerz d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltk = qp ( i , j , k , 6 ) - qp ( i - ii , j - jj , k - kk , 6 ) !TKE deltw = qp ( i , j , k , 7 ) - qp ( i - ii , j - jj , k - kk , 7 ) !Omega !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltk - ( dtkdx * delx + dtkdy * dely + dtkdz * delz )) / d_LR dtkdx = dtkdx + ( normal_comp * delx / d_LR ) dtkdy = dtkdy + ( normal_comp * dely / d_LR ) dtkdz = dtkdz + ( normal_comp * delz / d_LR ) normal_comp = ( deltw - ( dtwdx * delx + dtwdy * dely + dtwdz * delz )) / d_LR dtwdx = dtwdx + ( normal_comp * delx / d_LR ) dtwdy = dtwdy + ( normal_comp * dely / d_LR ) dtwdz = dtwdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) F1 = 0.5 * ( sst_F1 ( i - ii , j - jj , k - kk ) + sst_F1 ( i , j , k )) sigma_kf = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_wf = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) total_mu = mu_f + mut_f rhoface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 1 ) + qp ( i , j , k , 1 )) !Density tkface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 6 ) + qp ( i , j , k , 6 )) !TKE ! k in reynolds stress Tau_xx = - 2.0 * rhoface * tkface / 3.0 Tau_yy = Tau_xx Tau_zz = Tau_xx ! calling some element from memory and keep them handy for calculation nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz area = faces ( i , j , k )% A ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - ( Tau_xx * nx * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - ( Tau_yy * ny * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - ( Tau_zz * nz * area ) F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * (( mu_f + sigma_kf * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + sigma_kf * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 7 ) = F ( i , j , k , 7 ) - ( area * (( mu_f + sigma_wf * mut_f ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_sst subroutine compute_viscous_fluxes_kkl ( F , qp , cells , faces , flags , dims ) !< Compute viscous fluxes for additianal equations due to k-kL turbulence model implicit none real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Flux array type ( extent ), intent ( in ) :: dims !< Extent of the domain: imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for directions switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal ! local variables real ( wp ) :: tkface real ( wp ) :: rhoface real ( wp ) :: normal_comp real ( wp ) :: d_LR real ( wp ) :: mu_f real ( wp ) :: mut_f real ( wp ) :: total_mu real ( wp ) :: delx real ( wp ) :: dely real ( wp ) :: delz real ( wp ) :: deltk real ( wp ) :: deltkl real ( wp ) :: Tau_xx real ( wp ) :: Tau_yy real ( wp ) :: Tau_zz real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: area integer :: i , j , k integer :: ii , jj , kk !--- kkl variable requirement  ---! real ( wp ) :: dtkdx , dtkdy , dtkdz real ( wp ) :: dtkldx , dtkldy , dtkldz ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , dims % kmx - 1 + kk do j = 1 , dims % jmx - 1 + jj do i = 1 , dims % imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtkdx = 0.5 * ( gradtk_x ( i - ii , j - jj , k - kk ) + gradtk_x ( i , j , k )) dtkdy = 0.5 * ( gradtk_y ( i - ii , j - jj , k - kk ) + gradtk_y ( i , j , k )) dtkdz = 0.5 * ( gradtk_z ( i - ii , j - jj , k - kk ) + gradtk_z ( i , j , k )) dtkldx = 0.5 * ( gradtkl_x ( i - ii , j - jj , k - kk ) + gradtkl_x ( i , j , k )) dtkldy = 0.5 * ( gradtkl_y ( i - ii , j - jj , k - kk ) + gradtkl_y ( i , j , k )) dtkldz = 0.5 * ( gradtkl_z ( i - ii , j - jj , k - kk ) + gradtkl_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = cells ( i , j , k )% centerx - cells ( i - ii , j - jj , k - kk )% centerx dely = cells ( i , j , k )% centery - cells ( i - ii , j - jj , k - kk )% centery delz = cells ( i , j , k )% centerz - cells ( i - ii , j - jj , k - kk )% centerz d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltk = qp ( i , j , k , 6 ) - qp ( i - ii , j - jj , k - kk , 6 ) !TKE deltkl = qp ( i , j , k , 7 ) - qp ( i - ii , j - jj , k - kk , 7 ) !Kl !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltk - ( dtkdx * delx + dtkdy * dely + dtkdz * delz )) / d_LR dtkdx = dtkdx + ( normal_comp * delx / d_LR ) dtkdy = dtkdy + ( normal_comp * dely / d_LR ) dtkdz = dtkdz + ( normal_comp * delz / d_LR ) normal_comp = ( deltkl - ( dtkldx * delx + dtkldy * dely + dtkldz * delz )) / d_LR dtkldx = dtkldx + ( normal_comp * delx / d_LR ) dtkldy = dtkldy + ( normal_comp * dely / d_LR ) dtkldz = dtkldz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) total_mu = mu_f + mut_f rhoface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 1 ) + qp ( i , j , k , 1 )) tkface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 6 ) + qp ( i , j , k , 6 )) ! k in reynolds stress Tau_xx = - 2.0 * rhoface * tkface / 3.0 Tau_yy = Tau_xx Tau_zz = Tau_xx ! calling some element from memory and keep them handy for calculation nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz area = faces ( i , j , k )% A ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - ( Tau_xx * nx * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - ( Tau_yy * ny * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - ( Tau_zz * nz * area ) F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * (( mu_f + sigma_k * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + sigma_k * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 7 ) = F ( i , j , k , 7 ) - ( area * (( mu_f + sigma_phi * mut_f ) * ( dtkldx * nx + dtkldy * ny + dtkldz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_kkl subroutine compute_viscous_fluxes_sa ( F , qp , cells , faces , flags , dims ) !< Compute viscous fluxes for additianal equations due to SA turbulence model implicit none real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Flux array type ( extent ), intent ( in ) :: dims !< Extent of the domain: imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal ! local variables real ( wp ) :: rhoface real ( wp ) :: normal_comp real ( wp ) :: d_LR real ( wp ) :: mu_f real ( wp ) :: mut_f real ( wp ) :: delx real ( wp ) :: dely real ( wp ) :: delz real ( wp ) :: deltv real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: area integer :: i , j , k integer :: ii , jj , kk !--- sa variable requirement ---! real ( wp ) :: dtvdx , dtvdy , dtvdz ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , dims % kmx - 1 + kk do j = 1 , dims % jmx - 1 + jj do i = 1 , dims % imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtvdx = 0.5 * ( gradtv_x ( i - ii , j - jj , k - kk ) + gradtv_x ( i , j , k )) dtvdy = 0.5 * ( gradtv_y ( i - ii , j - jj , k - kk ) + gradtv_y ( i , j , k )) dtvdz = 0.5 * ( gradtv_z ( i - ii , j - jj , k - kk ) + gradtv_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = cells ( i , j , k )% centerx - cells ( i - ii , j - jj , k - kk )% centerx dely = cells ( i , j , k )% centery - cells ( i - ii , j - jj , k - kk )% centery delz = cells ( i , j , k )% centerz - cells ( i - ii , j - jj , k - kk )% centerz d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltv = qp ( i , j , k , 6 ) - qp ( i - ii , j - jj , k - kk , 6 ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltv - ( dtvdx * delx + dtvdy * dely + dtvdz * delz )) / d_LR dtvdx = dtvdx + ( normal_comp * delx / d_LR ) dtvdy = dtvdy + ( normal_comp * dely / d_LR ) dtvdz = dtvdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! rhoface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 1 ) + qp ( i , j , k , 1 )) mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( qp ( i - ii , j - jj , k - kk , 6 ) + qp ( i , j , k , 6 )) * rhoface ! calling some element from memory and keep them handy for calculation nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz area = faces ( i , j , k )% A ! adding viscous fluxes to stored convective flux F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + mut_f ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ))) / sigma_sa end do end do end do end subroutine compute_viscous_fluxes_sa subroutine compute_viscous_fluxes_lctm2015 ( F , qp , cells , faces , flags , dims ) !< Compute viscous fluxes for additianal equations due to LCTM2015 transition model implicit none real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Flux array type ( extent ), intent ( in ) :: dims !< Extent of the doamin:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !<flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal ! local variables real ( wp ) :: rhoface real ( wp ) :: normal_comp real ( wp ) :: d_LR real ( wp ) :: mu_f real ( wp ) :: mut_f real ( wp ) :: delx real ( wp ) :: dely real ( wp ) :: delz real ( wp ) :: deltgm real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: area integer :: i , j , k integer :: ii , jj , kk !--- sa variable requirement ---! real ( wp ) :: dtgmdx , dtgmdy , dtgmdz ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , dims % kmx - 1 + kk do j = 1 , dims % jmx - 1 + jj do i = 1 , dims % imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtgmdx = 0.5 * ( gradtgm_x ( i - ii , j - jj , k - kk ) + gradtgm_x ( i , j , k )) dtgmdy = 0.5 * ( gradtgm_y ( i - ii , j - jj , k - kk ) + gradtgm_y ( i , j , k )) dtgmdz = 0.5 * ( gradtgm_z ( i - ii , j - jj , k - kk ) + gradtgm_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = cells ( i , j , k )% centerx - cells ( i - ii , j - jj , k - kk )% centerx dely = cells ( i , j , k )% centery - cells ( i - ii , j - jj , k - kk )% centery delz = cells ( i , j , k )% centerz - cells ( i - ii , j - jj , k - kk )% centerz d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltgm = qp ( i , j , k , 8 ) - qp ( i - ii , j - jj , k - kk , 8 ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltgm - ( dtgmdx * delx + dtgmdy * dely + dtgmdz * delz )) / d_LR dtgmdx = dtgmdx + ( normal_comp * delx / d_LR ) dtgmdy = dtgmdy + ( normal_comp * dely / d_LR ) dtgmdz = dtgmdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! rhoface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 1 ) + qp ( i , j , k , 1 )) mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) ! calling some element from memory and keep them handy for calculation nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz area = faces ( i , j , k )% A ! adding viscous fluxes to stored convective flux F ( i , j , k , dims % n_var ) = F ( i , j , k , dims % n_var ) - ( area * (( mu_f + mut_f ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_lctm2015 end module viscous","tags":"","loc":"sourcefile/viscous.f90.html","title":"viscous.f90 – FEST-3D"},{"text":"Add source's contribution to the residual This file depends on sourcefile~~source.f90~~EfferentGraph sourcefile~source.f90 source.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~source.f90->sourcefile~global_sa.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~source.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~source.f90->sourcefile~wall_dist.f90 sourcefile~cc.f90 CC.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~source.f90->sourcefile~global_kkl.f90 sourcefile~utils.f90 utils.f90 sourcefile~source.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~source.f90->sourcefile~vartypes.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~source.f90->sourcefile~global_sst.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~cc.f90->sourcefile~wall_dist.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~cc.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~source.f90~~AfferentGraph sourcefile~source.f90 source.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules source Source Code source.f90 Source Code !< Add source's contribution to the residual module source !< Add source's contribution to the residual !----------------------------------------------------------------- #include \"debug.h\" #include \"error.h\" use vartypes !--- variable required for sst source calculation ---! use global_sst , only : sigma_k1 use global_sst , only : sigma_k2 use global_sst , only : sigma_w1 use global_sst , only : sigma_w2 use global_sst , only : beta1 use global_sst , only : beta2 use global_sst , only : bstar use global_sst , only : a1 use global_sst , only : gama1 use global_sst , only : gama2 use global_sst , only : beta use global_sst , only : sigma_w use global_sst , only : sigma_k use global_sst , only : gama use global_sst , only : sst_F1 use viscosity , only : mu use wall_dist , only : dist use gradients , only : gradu_x use gradients , only : gradu_y use gradients , only : gradu_z use gradients , only : gradv_x use gradients , only : gradv_y use gradients , only : gradv_z use gradients , only : gradw_x use gradients , only : gradw_y use gradients , only : gradw_z use gradients , only : gradtk_x use gradients , only : gradtk_y use gradients , only : gradtk_z use gradients , only : gradtw_x use gradients , only : gradtw_y use gradients , only : gradtw_z use gradients , only : gradtgm_x use gradients , only : gradtgm_y use gradients , only : gradtgm_z !--- variables required for kkl source calculation ---! use global_kkl , only : zeta1 use global_kkl , only : zeta2 use global_kkl , only : zeta3 use global_kkl , only : sigma_phi use global_kkl , only : cmu use global_kkl , only : kappa use global_kkl , only : c11 use global_kkl , only : c12 use global_kkl , only : cd1 use global_kkl , only : cphi1 use global_kkl , only : cphi2 use global_kkl , only : fphi use global_kkl , only : eta !variables required by sa source term calculation use global_sa , only : cb1 use global_sa , only : cb2 use global_sa , only : cw1 use global_sa , only : cw2 use global_sa , only : cw3 use global_sa , only : cv1 use global_sa , only : sigma_sa use global_sa , only : kappa_sa use global_sa , only : cv1_3 use global_sa , only : cw3_6 use gradients , only : gradtv_x use gradients , only : gradtv_y use gradients , only : gradtv_z use viscosity , only : mu_t use CC , only : DCCVnX use CC , only : DCCVnY use CC , only : DCCVnZ use CC , only : CCnormalX use CC , only : CCnormalY use CC , only : CCnormalZ use CC , only : find_DCCVn use utils , only : alloc implicit none private public :: add_source_term_residue contains subroutine add_source_term_residue ( qp , residue , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) !< Call to add different source terms to the residual of different equations. implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal DebugCall ( 'add_source_term_residue' ) select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' ) select case ( trim ( scheme % transition )) case ( 'none' ) call add_sa_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'bc' ) call add_saBC_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , flow , dims ) case DEFAULT Fatal_error end select case ( 'sst' , 'sst2003' ) select case ( trim ( scheme % transition )) case ( 'none' ) call add_sst_source ( qp , residue , cells , scheme , dims ) case ( 'lctm2015' ) call add_sst_source_lctm2015 ( qp , residue , cells , Ifaces , Jfaces , Kfaces , scheme , dims ) case ( 'bc' ) call add_sst_bc_source ( qp , residue , cells , flow , dims ) case DEFAULT Fatal_error end select case ( 'kkl' ) call add_kkl_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , dims ) case DEFAULT Fatal_error end select end subroutine add_source_term_residue subroutine add_sst_source ( qp , residue , cells , scheme , dims ) !< Add residual due to source terms of the SST turbulence model implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume !< Store residue at each cell-center integer :: i , j , k real ( wp ) :: CD !< cross diffusion term real ( wp ) :: F1 !< single cell belding fuction real ( wp ) :: vort !< vorticity magnitude real ( wp ) :: S_k !< Total source term of TKE equation real ( wp ) :: S_w !< Total source term of omega equation real ( wp ) :: D_k !< destruction term of TKE equation real ( wp ) :: D_w !< destruction term of omega equation real ( wp ) :: P_k !< production term of TKE equation real ( wp ) :: P_w !< production term of Omega equation real ( wp ) :: lamda !< additional source term in Omega equation integer :: limiter !< production term limiter real ( wp ) :: divergence !< del.V real ( wp ) :: density !< single cell density real ( wp ) :: tk !< single cell TKE real ( wp ) :: tw !< single cell Omega if ( trim ( scheme % turbulence ) == 'sst2003' ) then limiter = 10 gama1 = 5.0 / 9.0 gama2 = 0.44 else limiter = 20 end if do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tw = qp ( i , j , k , 7 ) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) CD = 2 * density * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw CD = max ( CD , 1 0.0 ** ( - limiter )) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density * tw * tk D_w = beta * density * tw ** 2 ! ____ PRODUCTION term____ divergence = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) P_k = mu_t ( i , j , k ) * ( vort ** 2 ) - (( 2.0 / 3.0 ) * density * tk * divergence ) P_k = min ( P_k , limiter * D_k ) P_w = ( density * gama / mu_t ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD S_k = P_k - D_k !Source term TKE S_w = P_w - D_w + lamda !source term omega S_k = S_k * cells ( i , j , k )% volume S_w = S_w * cells ( i , j , k )% volume residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_k residue ( i , j , k , 7 ) = residue ( i , j , k , 7 ) - S_w end do end do end do end subroutine add_sst_source subroutine add_sst_source_lctm2015 ( qp , residue , cells , Ifaces , Jfaces , Kfaces , scheme , dims ) !< Add residual due to source terms of the LCTM2015 transition model implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ) :: CD !< Cross-diffustion term real ( wp ) :: F1 !< single cell blending function real ( wp ) :: vort !< vorticity magnitude real ( wp ) :: S_K !< Total source term in TKE equation real ( wp ) :: S_w !< Total source term in Omega equation real ( wp ) :: S_gm !< Total source term in Gamma equation real ( wp ) :: D_k !< Destruction term in TKE equation real ( wp ) :: D_w !< Destruction term in Omega equation real ( wp ) :: D_gm !< Destruction term in Gamma equation real ( wp ) :: P_k !< production term in TKE equation real ( wp ) :: P_w !< production term in Omega equation real ( wp ) :: P_gm !< production term in Gamma equation real ( wp ) :: lamda !< additional source term in Omega equation real ( wp ) :: Fonset1 , Fonset2 , Fonset3 , Fonset !< Transition onset term real ( wp ) :: Rev !< Reynodlds number based on vorticity real ( wp ) :: RT !< Turbulent reynolds number real ( wp ) :: Fturb real ( wp ) :: Re_theta !< Cutt-off reynolds number based on momentum thickness real ( wp ) :: TuL !< local turbulence intensity real ( wp ) :: strain !< Strain rate magnitude real ( wp ) :: intermittency !< intermittency real ( wp ) :: Pk_lim !< production lim term real ( wp ) :: Fon_lim real ( wp ) :: lamd !< pressure gradient real ( wp ) :: Fpg !< pressure gradient functin real ( wp ) :: divergence !< del.V real ( wp ) :: dvdy !< pressure gradient sensor integer :: limiter !< production limiter real ( wp ) :: density !< single cell Density real ( wp ) :: tk !< single cell TKE real ( wp ) :: tw !< single cell Omega if ( trim ( scheme % turbulence ) == 'sst2003' ) then limiter = 10 gama1 = 5.0 / 9.0 gama2 = 0.44 else limiter = 20 end if !for pressure gradient calculation call find_DCCVn ( qp , cells , Ifaces , Jfaces , Kfaces , dims ) do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tw = qp ( i , j , k , 7 ) intermittency = qp ( i , j , k , 8 ) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( ((( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 ) & + (( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 ) & + (( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 ) & + 2 * ( gradu_x ( i , j , k ) ** 2 ) & + 2 * ( gradv_y ( i , j , k ) ** 2 ) & + 2 * ( gradw_z ( i , j , k ) ** 2 ) & )& ) CD = 2 * density * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw CD = max ( CD , 1 0.0 ** ( - limiter )) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density * tw * tk D_w = beta * density * tw ** 2 ! ____ PRODUCTION term____ divergence = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) P_k = mu_t ( i , j , k ) * ( vort * strain ) - (( 2.0 / 3.0 ) * density * tk * divergence ) P_k = min ( P_k , limiter * D_k ) P_w = ( density * gama / mu_t ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD ! ____Transition modeling  ____ ! --pressure gradient dvdy = DCCVnX ( i , j , k ) * CCnormalX ( i , j , k ) & + DCCVnY ( i , j , k ) * CCnormalY ( i , j , k ) & + DCCVnZ ( i , j , k ) * CCnormalZ ( i , j , k ) lamd = ( - 7.57e-3 ) * ( dvdy * dist ( i , j , k ) * dist ( i , j , k ) * density / mu ( i , j , k )) + 0.0128 lamd = min ( max ( lamd , - 1.0 ), 1.0 ) if ( lamd >= 0.0 ) then Fpg = min ( 1.0 + 1 4.68 * lamd , 1.5 ) else Fpg = min ( 1.0 - 7.34 * lamd , 3.0 ) end if Fpg = max ( Fpg , 0.0 ) ! --gradient TuL = min ( 10 0.0 * sqrt ( 2.0 * tk / 3.0 ) / ( tw * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) !Re_theta = 100.0 + 1000.0*exp(-TuL) Rev = density * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density * tk / ( mu ( i , j , k ) * tw ) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) P_gm = 100 * density * strain * intermittency * ( 1.0 - intermittency ) * Fonset D_gm = 0.06 * density * vort * intermittency * Fturb * (( 5 0.0 * intermittency ) - 1.0 ) Fon_lim = min ( max (( Rev / ( 2.2 * 110 0.0 )) - 1.0 , 0.0 ), 3.0 ) Pk_lim = 5 * max ( intermittency - 0.2 , 0.0 ) * ( 1.0 - intermittency ) * Fon_lim * max ( 3 * mu ( i , j , k ) - mu_t ( i , j , k ), 0.0 ) * strain * vort S_k = intermittency * P_k - max ( intermittency , 0.1 ) * D_k + Pk_lim !Source term gm S_W = P_w - D_w + lamda !Source term gm S_gm = P_gm - D_gm !Source term gm S_k = S_k * cells ( i , j , k )% volume S_w = S_w * cells ( i , j , k )% volume S_gm = S_gm * cells ( i , j , k )% Volume residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_k residue ( i , j , k , 7 ) = residue ( i , j , k , 7 ) - S_w residue ( i , j , k , 8 ) = residue ( i , j , k , 8 ) - S_gm end do end do end do end subroutine add_sst_source_lctm2015 ! SST-BC model subroutine add_sst_bc_source ( qp , residue , cells , flow , dims ) !< Add residual due to source terms of the SST-BC transition model implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume integer :: i , j , k real ( wp ) :: CD !< cross-diffusion term real ( wp ) :: F1 !< single cell blending function real ( wp ) :: vort !< vorticity magnitude real ( wp ) :: S_k !< Total source term in TKE equation real ( wp ) :: S_w !< Total source term in Omega equation real ( wp ) :: D_k !< Destruction term in TKE equation real ( wp ) :: D_w !< Destruction term in Omega equation real ( wp ) :: P_k !< Production term in TKE equation real ( wp ) :: P_w !< production term in Omega equation real ( wp ) :: lamda !< addtion source term in Omega equation real ( wp ) :: TuL !< local turbulence intensity !--------BC model ----- real ( wp ) :: chi_1 = 0.002 real ( wp ) :: chi_2 = 5.0 real ( wp ) :: nu_BC real ( wp ) :: nu_cr real ( wp ) :: nu_t real ( wp ) :: re_v real ( wp ) :: re_theta real ( wp ) :: re_theta_t real ( wp ) :: term1 real ( wp ) :: term2 real ( wp ) :: term_exponential real ( wp ) :: gamma_BC !< intermittency function real ( wp ) :: vmag !< velocity magnitude real ( wp ) :: density !< single cell Density real ( wp ) :: tk !< single cell TKE real ( wp ) :: tw !< single cell omega do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tw = qp ( i , j , k , 7 ) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) CD = 2 * density * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw !CD = max(CD, 1e-20) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density * tw * tk D_w = beta * density * tw ** 2 ! ____ PRODUCTION term____ P_k = mu_t ( i , j , k ) * ( vort ** 2 ) P_k = min ( P_k , 2 0.0 * D_k ) P_w = ( density * gama / mu_t ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD ! ____Transition modeling  ____ !------ BC model --- vmag = sqrt ( SUM ( qp ( i , j , k , 2 : 4 ) ** 2 )) chi_1 = 0.002 chi_2 = 5.0 nu_t = mu_t ( i , j , k ) / density nu_cr = chi_2 / flow % Reynolds_number nu_bc = nu_t / ( vmag * dist ( i , j , k )) TuL = flow % tu_inf !local turbulence intensity might not work for BC model re_v = density * dist ( i , j , k ) * dist ( i , j , k ) * vort / mu ( i , j , k ) re_theta = re_v / 2.193 re_theta_t = ( 80 3.73 * (( TuL + 0.6067 ) ** ( - 1.027 ))) term1 = sqrt ( max ( re_theta - re_theta_t , 0. ) / ( chi_1 * re_theta_t )) term2 = sqrt ( max ( nu_BC - nu_cr , 0.0 ) / nu_cr ) term_exponential = ( term1 + term2 ) gamma_BC = 1.0 - exp ( - term_exponential ) P_k = gamma_BC * P_k S_k = P_k - D_k !Source term TKE S_w = P_w - D_w + lamda !source term omega S_k = S_k * cells ( i , j , k )% volume S_w = S_w * cells ( i , j , k )% volume residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_k residue ( i , j , k , 7 ) = residue ( i , j , k , 7 ) - S_w end do end do end do end subroutine add_sst_bc_source subroutine add_kkl_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , dims ) !< Add residual due to source terms of the k-kL turbulence model implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ) :: Tau11 real ( wp ) :: Tau12 real ( wp ) :: Tau13 real ( wp ) :: Tau21 real ( wp ) :: Tau22 real ( wp ) :: Tau23 real ( wp ) :: Tau31 real ( wp ) :: Tau32 real ( wp ) :: Tau33 real ( wp ) :: S11 real ( wp ) :: S12 real ( wp ) :: S13 real ( wp ) :: S21 real ( wp ) :: S22 real ( wp ) :: S23 real ( wp ) :: S31 real ( wp ) :: S32 real ( wp ) :: S33 real ( wp ) :: delv real ( wp ) :: d2udx2 real ( wp ) :: d2udy2 real ( wp ) :: d2udz2 real ( wp ) :: d2vdx2 real ( wp ) :: d2vdy2 real ( wp ) :: d2vdz2 real ( wp ) :: d2wdx2 real ( wp ) :: d2wdy2 real ( wp ) :: d2wdz2 real ( wp ) :: Lvk real ( wp ) :: fp real ( wp ) :: ud real ( wp ) :: udd real ( wp ) :: S_k real ( wp ) :: S_kl real ( wp ) :: D_k real ( wp ) :: D_kl real ( wp ) :: P_k real ( wp ) :: P_kl real ( wp ) :: density real ( wp ) :: tk real ( wp ) :: tkl do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tkl = qp ( i , j , k , 7 ) S11 = 0.5 * ( gradu_x ( i , j , k ) + gradu_x ( i , j , k )) S12 = 0.5 * ( gradu_y ( i , j , k ) + gradv_x ( i , j , k )) S13 = 0.5 * ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) S21 = 0.5 * ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) S22 = 0.5 * ( gradv_y ( i , j , k ) + gradv_y ( i , j , k )) S23 = 0.5 * ( gradv_z ( i , j , k ) + gradw_y ( i , j , k )) S31 = 0.5 * ( gradw_x ( i , j , k ) + gradu_z ( i , j , k )) S32 = 0.5 * ( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) S33 = 0.5 * ( gradw_z ( i , j , k ) + gradw_z ( i , j , k )) delv = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) Tau11 = mu_t ( i , j , k ) * ( 2 * S11 - ( 2.0 / 3.0 ) * delv ) - ( 2.0 / 3.0 ) * density * tk Tau12 = mu_t ( i , j , k ) * ( 2 * S12 ) Tau13 = mu_t ( i , j , k ) * ( 2 * S13 ) Tau21 = mu_t ( i , j , k ) * ( 2 * S21 ) Tau22 = mu_t ( i , j , k ) * ( 2 * S22 - ( 2.0 / 3.0 ) * delv ) - ( 2.0 / 3.0 ) * density * tk Tau23 = mu_t ( i , j , k ) * ( 2 * S23 ) Tau31 = mu_t ( i , j , k ) * ( 2 * S31 ) Tau32 = mu_t ( i , j , k ) * ( 2 * S32 ) Tau33 = mu_t ( i , j , k ) * ( 2 * S33 - ( 2.0 / 3.0 ) * delv ) - ( 2.0 / 3.0 ) * density * tk P_k = 0. P_k = P_k + Tau11 * gradu_x ( i , j , k ) + Tau12 * gradu_y ( i , j , k ) + Tau13 * gradu_z ( i , j , k ) P_k = P_k + Tau21 * gradv_x ( i , j , k ) + Tau22 * gradv_y ( i , j , k ) + Tau23 * gradv_z ( i , j , k ) P_k = P_k + Tau31 * gradw_x ( i , j , k ) + Tau32 * gradw_y ( i , j , k ) + Tau33 * gradw_z ( i , j , k ) D_k = ( cmu ** 0.75 ) * density * ( tk ** 2.5 ) / max ( tkl , 1.e-20 ) P_k = min ( P_k , 20 * D_k ) ! calculation of Lvk ! first get second order gradients d2udx2 = ( - ( gradu_x ( i - 1 , j , k ) + gradu_x ( i , j , k )) * Ifaces ( i , j , k )% nx * Ifaces ( i , j , k )% A & - ( gradu_x ( i , j - 1 , k ) + gradu_x ( i , j , k )) * Jfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( gradu_x ( i , j , k - 1 ) + gradu_x ( i , j , k )) * Kfaces ( i , j , k )% nx * Kfaces ( i , j , k )% A & + ( gradu_x ( i + 1 , j , k ) + gradu_x ( i , j , k )) * Ifaces ( i + 1 , j , k )% nx * Ifaces ( i + 1 , j , k )% A & + ( gradu_x ( i , j + 1 , k ) + gradu_x ( i , j , k )) * Jfaces ( i , j + 1 , k )% nx * Jfaces ( i , j + 1 , k )% A & + ( gradu_x ( i , j , k + 1 ) + gradu_x ( i , j , k )) * Kfaces ( i , j , k + 1 )% nx * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2udy2 = ( - ( gradu_y ( i - 1 , j , k ) + gradu_y ( i , j , k )) * Ifaces ( i , j , k )% ny * Ifaces ( i , j , k )% A & - ( gradu_y ( i , j - 1 , k ) + gradu_y ( i , j , k )) * Jfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( gradu_y ( i , j , k - 1 ) + gradu_y ( i , j , k )) * Kfaces ( i , j , k )% ny * Kfaces ( i , j , k )% A & + ( gradu_y ( i + 1 , j , k ) + gradu_y ( i , j , k )) * Ifaces ( i + 1 , j , k )% ny * Ifaces ( i + 1 , j , k )% A & + ( gradu_y ( i , j + 1 , k ) + gradu_y ( i , j , k )) * Jfaces ( i , j + 1 , k )% ny * Jfaces ( i , j + 1 , k )% A & + ( gradu_y ( i , j , k + 1 ) + gradu_y ( i , j , k )) * Kfaces ( i , j , k + 1 )% ny * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2udz2 = ( - ( gradu_z ( i - 1 , j , k ) + gradu_z ( i , j , k )) * Ifaces ( i , j , k )% nz * Ifaces ( i , j , k )% A & - ( gradu_z ( i , j - 1 , k ) + gradu_z ( i , j , k )) * Jfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & - ( gradu_z ( i , j , k - 1 ) + gradu_z ( i , j , k )) * Kfaces ( i , j , k )% nz * Kfaces ( i , j , k )% A & + ( gradu_z ( i + 1 , j , k ) + gradu_z ( i , j , k )) * Ifaces ( i + 1 , j , k )% nz * Ifaces ( i + 1 , j , k )% A & + ( gradu_z ( i , j + 1 , k ) + gradu_z ( i , j , k )) * Jfaces ( i , j + 1 , k )% nz * Jfaces ( i , j + 1 , k )% A & + ( gradu_z ( i , j , k + 1 ) + gradu_z ( i , j , k )) * Kfaces ( i , j , k + 1 )% nz * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) ! gradient of v component d2vdx2 = ( - ( gradv_x ( i - 1 , j , k ) + gradv_x ( i , j , k )) * Ifaces ( i , j , k )% nx * Ifaces ( i , j , k )% A & - ( gradv_x ( i , j - 1 , k ) + gradv_x ( i , j , k )) * Jfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( gradv_x ( i , j , k - 1 ) + gradv_x ( i , j , k )) * Kfaces ( i , j , k )% nx * Kfaces ( i , j , k )% A & + ( gradv_x ( i + 1 , j , k ) + gradv_x ( i , j , k )) * Ifaces ( i + 1 , j , k )% nx * Ifaces ( i + 1 , j , k )% A & + ( gradv_x ( i , j + 1 , k ) + gradv_x ( i , j , k )) * Jfaces ( i , j + 1 , k )% nx * Jfaces ( i , j + 1 , k )% A & + ( gradv_x ( i , j , k + 1 ) + gradv_x ( i , j , k )) * Kfaces ( i , j , k + 1 )% nx * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2vdy2 = ( - ( gradv_y ( i - 1 , j , k ) + gradv_y ( i , j , k )) * Ifaces ( i , j , k )% ny * Ifaces ( i , j , k )% A & - ( gradv_y ( i , j - 1 , k ) + gradv_y ( i , j , k )) * Jfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( gradv_y ( i , j , k - 1 ) + gradv_y ( i , j , k )) * Kfaces ( i , j , k )% ny * Kfaces ( i , j , k )% A & + ( gradv_y ( i + 1 , j , k ) + gradv_y ( i , j , k )) * Ifaces ( i + 1 , j , k )% ny * Ifaces ( i + 1 , j , k )% A & + ( gradv_y ( i , j + 1 , k ) + gradv_y ( i , j , k )) * Jfaces ( i , j + 1 , k )% ny * Jfaces ( i , j + 1 , k )% A & + ( gradv_y ( i , j , k + 1 ) + gradv_y ( i , j , k )) * Kfaces ( i , j , k + 1 )% ny * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2vdz2 = ( - ( gradv_z ( i - 1 , j , k ) + gradv_z ( i , j , k )) * Ifaces ( i , j , k )% nz * Ifaces ( i , j , k )% A & - ( gradv_z ( i , j - 1 , k ) + gradv_z ( i , j , k )) * Jfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & - ( gradv_z ( i , j , k - 1 ) + gradv_z ( i , j , k )) * Kfaces ( i , j , k )% nz * Kfaces ( i , j , k )% A & + ( gradv_z ( i + 1 , j , k ) + gradv_z ( i , j , k )) * Ifaces ( i + 1 , j , k )% nz * Ifaces ( i + 1 , j , k )% A & + ( gradv_z ( i , j + 1 , k ) + gradv_z ( i , j , k )) * Jfaces ( i , j + 1 , k )% nz * Jfaces ( i , j + 1 , k )% A & + ( gradv_z ( i , j , k + 1 ) + gradv_z ( i , j , k )) * Kfaces ( i , j , k + 1 )% nz * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) !gradients of w components d2wdx2 = ( - ( gradw_x ( i - 1 , j , k ) + gradw_x ( i , j , k )) * Ifaces ( i , j , k )% nx * Ifaces ( i , j , k )% A & - ( gradw_x ( i , j - 1 , k ) + gradw_x ( i , j , k )) * Jfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( gradw_x ( i , j , k - 1 ) + gradw_x ( i , j , k )) * Kfaces ( i , j , k )% nx * Kfaces ( i , j , k )% A & + ( gradw_x ( i + 1 , j , k ) + gradw_x ( i , j , k )) * Ifaces ( i + 1 , j , k )% nx * Ifaces ( i + 1 , j , k )% A & + ( gradw_x ( i , j + 1 , k ) + gradw_x ( i , j , k )) * Jfaces ( i , j + 1 , k )% nx * Jfaces ( i , j + 1 , k )% A & + ( gradw_x ( i , j , k + 1 ) + gradw_x ( i , j , k )) * Kfaces ( i , j , k + 1 )% nx * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2wdy2 = ( - ( gradw_y ( i - 1 , j , k ) + gradw_y ( i , j , k )) * Ifaces ( i , j , k )% ny * Ifaces ( i , j , k )% A & - ( gradw_y ( i , j - 1 , k ) + gradw_y ( i , j , k )) * Jfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( gradw_y ( i , j , k - 1 ) + gradw_y ( i , j , k )) * Kfaces ( i , j , k )% ny * Kfaces ( i , j , k )% A & + ( gradw_y ( i + 1 , j , k ) + gradw_y ( i , j , k )) * Ifaces ( i + 1 , j , k )% ny * Ifaces ( i + 1 , j , k )% A & + ( gradw_y ( i , j + 1 , k ) + gradw_y ( i , j , k )) * Jfaces ( i , j + 1 , k )% ny * Jfaces ( i , j + 1 , k )% A & + ( gradw_y ( i , j , k + 1 ) + gradw_y ( i , j , k )) * Kfaces ( i , j , k + 1 )% ny * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2wdz2 = ( - ( gradw_z ( i - 1 , j , k ) + gradw_z ( i , j , k )) * Ifaces ( i , j , k )% nz * Ifaces ( i , j , k )% A & - ( gradw_z ( i , j - 1 , k ) + gradw_z ( i , j , k )) * Jfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & - ( gradw_z ( i , j , k - 1 ) + gradw_z ( i , j , k )) * Kfaces ( i , j , k )% nz * Kfaces ( i , j , k )% A & + ( gradw_z ( i + 1 , j , k ) + gradw_z ( i , j , k )) * Ifaces ( i + 1 , j , k )% nz * Ifaces ( i + 1 , j , k )% A & + ( gradw_z ( i , j + 1 , k ) + gradw_z ( i , j , k )) * Jfaces ( i , j + 1 , k )% nz * Jfaces ( i , j + 1 , k )% A & + ( gradw_z ( i , j , k + 1 ) + gradw_z ( i , j , k )) * Kfaces ( i , j , k + 1 )% nz * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) udd = sqrt ( ( d2udx2 + d2udy2 + d2udz2 ) ** 2 & + ( d2vdx2 + d2vdy2 + d2vdz2 ) ** 2 & + ( d2wdx2 + d2wdy2 + d2wdz2 ) ** 2 ) ud = sqrt ( 2 * ( s11 ** 2 + s12 ** 2 + s13 ** 2 & + s21 ** 2 + s22 ** 2 + s23 ** 2 & + s31 ** 2 + s32 ** 2 + s33 ** 2 )) Lvk = kappa * abs ( ud / max ( udd , 1.e-20 )) fp = min ( max ( P_k / D_k , 0.5 ), 1.0 ) ! Lvk limiter Lvk = max ( Lvk , tkl / max (( tk * c11 ), 1.e-20 )) Lvk = min ( Lvk , c12 * kappa * dist ( i , j , k ) * fp ) eta = density * dist ( i , j , k ) * sqrt ( 0.3 * tk ) / ( 20 * mu ( i , j , k )) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) cphi2 = zeta3 cphi1 = ( zeta1 - zeta2 * (( tkl / max ( tk * Lvk , 1.e-20 )) ** 2 )) P_kl = cphi1 * tkl * P_k / max ( tk , 1.e-20 ) D_kl = cphi2 * density * ( tk ** 1.5 ) S_k = P_k - D_k - 2 * mu ( i , j , k ) * tk / ( dist ( i , j , k ) ** 2 ) !Source term TKE S_kl = P_kl - D_kl - 6 * mu ( i , j , k ) * tkl * fphi / ( dist ( i , j , k ) ** 2 ) !source term KL S_k = S_k * cells ( i , j , k )% volume S_kl = S_kl * cells ( i , j , k )% volume residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_k residue ( i , j , k , 7 ) = residue ( i , j , k , 7 ) - S_kl end do end do end do end subroutine add_kkl_source subroutine add_sa_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , dims ) !< Add residual due to source terms of SA turbulence model implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ) :: CD1 real ( wp ) :: CD2 real ( wp ) :: fv1 real ( wp ) :: fv2 real ( wp ) :: fw real ( wp ) :: g real ( wp ) :: Scap real ( wp ) :: r real ( wp ) :: vort real ( wp ) :: S_v real ( wp ) :: D_v real ( wp ) :: P_v real ( wp ) :: lamda real ( wp ) :: kd2 real ( wp ) :: xi real ( wp ) :: nu real ( wp ) :: gradrho_x real ( wp ) :: gradrho_y real ( wp ) :: gradrho_z real ( wp ), dimension ( 6 ) :: RhoFace real ( wp ), dimension ( 6 ) :: Area real ( wp ), dimension ( 6 , 3 ) :: Normal real ( wp ) :: density real ( wp ) :: tv do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) tv = qp ( i , j , k , 6 ) RhoFace ( 1 ) = qp ( i - 1 , j , k , 1 ) + density RhoFace ( 2 ) = qp ( i , j - 1 , k , 1 ) + density RhoFace ( 3 ) = qp ( i , j , k - 1 , 1 ) + density RhoFace ( 4 ) = qp ( i + 1 , j , k , 1 ) + density RhoFace ( 5 ) = qp ( i , j + 1 , k , 1 ) + density RhoFace ( 6 ) = qp ( i , j , k + 1 , 1 ) + density Area ( 1 ) = Ifaces ( i , j , k )% A Area ( 2 ) = Jfaces ( i , j , k )% A Area ( 3 ) = Kfaces ( i , j , k )% A Area ( 4 ) = Ifaces ( i + 1 , j , k )% A Area ( 5 ) = Jfaces ( i , j + 1 , k )% A Area ( 6 ) = Kfaces ( i , j , k + 1 )% A Normal ( 1 , 1 : 3 ) = ( / Ifaces ( i , j , k )% nx , Ifaces ( i , j , k )% ny , Ifaces ( i , j , k )% nz / ) Normal ( 2 , 1 : 3 ) = ( / Jfaces ( i , j , k )% nx , Jfaces ( i , j , k )% ny , Jfaces ( i , j , k )% nz / ) Normal ( 3 , 1 : 3 ) = ( / Kfaces ( i , j , k )% nx , Kfaces ( i , j , k )% nx , Kfaces ( i , j , k )% nx / ) Normal ( 4 , 1 : 3 ) = ( / Ifaces ( i + 1 , j , k )% nx , Ifaces ( i + 1 , j , k )% ny , Ifaces ( i + 1 , j , k )% nz / ) Normal ( 5 , 1 : 3 ) = ( / Jfaces ( i , j + 1 , k )% nx , Jfaces ( i , j + 1 , k )% ny , Jfaces ( i , j + 1 , k )% nz / ) Normal ( 6 , 1 : 3 ) = ( / Kfaces ( i , j , k + 1 )% nx , Kfaces ( i , j , k + 1 )% ny , Kfaces ( i , j , k + 1 )% nz / ) gradrho_x = ( - ( RhoFace ( 1 )) * Normal ( 1 , 1 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 1 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 1 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 1 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 1 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 1 ) * Area ( 6 ) & ) / ( 2.0 * cells ( i , j , k )% volume ) gradrho_y = ( - ( RhoFace ( 1 )) * Normal ( 1 , 2 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 2 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 2 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 2 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 2 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 2 ) * Area ( 6 ) & ) / ( 2.0 * cells ( i , j , k )% volume ) gradrho_z = ( - ( RhoFace ( 1 )) * Normal ( 1 , 3 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 3 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 3 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 3 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 3 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 3 ) * Area ( 6 ) & ) / ( 2.0 * cells ( i , j , k )% volume ) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) ! ___ cross diffusion ___ CD1 = cb2 * (( gradtv_x ( i , j , k ) * gradtv_x ( i , j , k ))& + ( gradtv_y ( i , j , k ) * gradtv_y ( i , j , k ))& + ( gradtv_z ( i , j , k ) * gradtv_z ( i , j , k ))& ) ! ___ addition cross diffusion result conservative form of tv ___ CD2 = (( gradrho_x * gradtv_x ( i , j , k ))& + ( gradrho_y * gradtv_y ( i , j , k ))& + ( gradrho_z * gradtv_z ( i , j , k ))& ) kd2 = ( kappa_sa * dist ( i , j , k )) ** 2 nu = mu ( i , j , k ) / density xi = tv / nu ! ___ functions ___ fv1 = ( xi ** 3 ) / (( xi ** 3 ) + ( cv1 ** 3 )) fv2 = 1.0 - xi / ( 1.0 + ( xi * fv1 )) ! ___ Shear stress for production ___ scap = max ( vort + ( tv * fv2 / ( kd2 )), 0.3 * vort ) ! ___ wall function ___ r = min ( tv / ( Scap * kd2 ), 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) fw = g * ( ( 1.0 + ( cw3 ** 6 )) / (( g ** 6 ) + ( cw3 ** 6 )) ) ** ( 1.0 / 6.0 ) ! ____ Dissipation term ___ D_v = density * cw1 * fw * (( tv / dist ( i , j , k )) ** 2 ) ! ____ PRODUCTION term____ P_v = density * cb1 * Scap * tv ! ____ cross diffusion term ___ lamda = density * CD1 / sigma_sa - CD2 * ( nu + tv ) / sigma_sa S_v = ( P_v - D_v + lamda ) * cells ( i , j , k )% volume residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_v end do end do end do end subroutine add_sa_source subroutine add_saBC_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , flow , dims ) !< Add residual due to source terms of SABC transition model implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ) :: CD1 real ( wp ) :: CD2 real ( wp ) :: fv1 real ( wp ) :: fv2 real ( wp ) :: fw real ( wp ) :: g real ( wp ) :: r real ( wp ) :: S_v real ( wp ) :: lamda real ( wp ) :: dist_i real ( wp ) :: dist_i_2 real ( wp ) :: Ji real ( wp ) :: Ji_2 real ( wp ) :: Ji_3 real ( wp ) :: S real ( wp ) :: Omega real ( wp ) :: k2 real ( wp ) :: inv_k2_d2 real ( wp ) :: Shat real ( wp ) :: inv_Shat real ( wp ) :: nu real ( wp ) :: gradrho_x real ( wp ) :: gradrho_y real ( wp ) :: gradrho_z real ( wp ), dimension ( 6 ) :: RhoFace real ( wp ), dimension ( 6 ) :: Area real ( wp ), dimension ( 6 , 3 ) :: Normal ! transition modeling variables real ( wp ) :: chi_1 = 0.002 real ( wp ) :: chi_2 = 5.0 real ( wp ) :: nu_BC real ( wp ) :: nu_cr real ( wp ) :: nu_t real ( wp ) :: u , v , w real ( wp ) :: glim real ( wp ) :: g_6 real ( wp ) :: vmag real ( wp ) :: Production real ( wp ) :: Destruction real ( wp ) :: re_v real ( wp ) :: re_theta real ( wp ) :: re_theta_t real ( wp ) :: term1 real ( wp ) :: term2 real ( wp ) :: term_exponential real ( wp ) :: gamma_BC real ( wp ) :: tu real ( wp ) :: tv real ( wp ) :: density tu = flow % tu_inf do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 !Local_vel_mag density = qp ( i , j , k , 1 ) u = qp ( i , j , k , 2 ) v = qp ( i , j , k , 3 ) w = qp ( i , j , k , 4 ) tv = qp ( i , j , k , 6 ) vmag = sqrt ( u * u + v * v + w * w ) RhoFace ( 1 ) = qp ( i - 1 , j , k , 1 ) + density RhoFace ( 2 ) = qp ( i , j - 1 , k , 1 ) + density RhoFace ( 3 ) = qp ( i , j , k - 1 , 1 ) + density RhoFace ( 4 ) = qp ( i + 1 , j , k , 1 ) + density RhoFace ( 5 ) = qp ( i , j + 1 , k , 1 ) + density RhoFace ( 6 ) = qp ( i , j , k + 1 , 1 ) + density Area ( 1 ) = Ifaces ( i , j , k )% A Area ( 2 ) = Jfaces ( i , j , k )% A Area ( 3 ) = Kfaces ( i , j , k )% A Area ( 4 ) = Ifaces ( i + 1 , j , k )% A Area ( 5 ) = Jfaces ( i , j + 1 , k )% A Area ( 6 ) = Kfaces ( i , j , k + 1 )% A Normal ( 1 , 1 : 3 ) = ( / Ifaces ( i , j , k )% nx , Ifaces ( i , j , k )% ny , Ifaces ( i , j , k )% nz / ) Normal ( 2 , 1 : 3 ) = ( / Jfaces ( i , j , k )% nx , Jfaces ( i , j , k )% ny , Jfaces ( i , j , k )% nz / ) Normal ( 3 , 1 : 3 ) = ( / Kfaces ( i , j , k )% nx , Kfaces ( i , j , k )% nx , Kfaces ( i , j , k )% nx / ) Normal ( 4 , 1 : 3 ) = ( / Ifaces ( i + 1 , j , k )% nx , Ifaces ( i + 1 , j , k )% ny , Ifaces ( i + 1 , j , k )% nz / ) Normal ( 5 , 1 : 3 ) = ( / Jfaces ( i , j + 1 , k )% nx , Jfaces ( i , j + 1 , k )% ny , Jfaces ( i , j + 1 , k )% nz / ) Normal ( 6 , 1 : 3 ) = ( / Kfaces ( i , j , k + 1 )% nx , Kfaces ( i , j , k + 1 )% ny , Kfaces ( i , j , k + 1 )% nz / ) gradrho_x = ( - ( RhoFace ( 1 )) * Normal ( 1 , 1 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 1 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 1 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 1 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 1 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 1 ) * Area ( 6 ) & ) / ( 2 * cells ( i , j , k )% volume ) gradrho_y = ( - ( RhoFace ( 1 )) * Normal ( 1 , 2 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 2 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 2 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 2 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 2 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 2 ) * Area ( 6 ) & ) / ( 2 * cells ( i , j , k )% volume ) gradrho_z = ( - ( RhoFace ( 1 )) * Normal ( 1 , 3 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 3 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 3 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 3 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 3 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 3 ) * Area ( 6 ) & ) / ( 2 * cells ( i , j , k )% volume ) ! __ vorticity __ Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) ! ___ cross diffusion ___ CD1 = cb2 * (( gradtv_x ( i , j , k ) * gradtv_x ( i , j , k ))& + ( gradtv_y ( i , j , k ) * gradtv_y ( i , j , k ))& + ( gradtv_z ( i , j , k ) * gradtv_z ( i , j , k ))& ) ! ___ addition cross diffusion result conservative form of tv ___ CD2 = (( gradrho_x * gradtv_x ( i , j , k ))& + ( gradrho_y * gradtv_y ( i , j , k ))& + ( gradrho_z * gradtv_z ( i , j , k ))& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density Ji = tv / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + tv * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat ! ____ PRODUCTION term____ chi_1 = 0.002 chi_2 = 5.0 nu_t = tv * fv1 nu_cr = chi_2 / flow % Reynolds_number nu_bc = nu_t / ( vmag * dist_i ) re_v = dist_i_2 * Omega / nu re_theta = re_v / 2.193 re_theta_t = ( 80 3.73 * (( tu + 0.6067 ) ** ( - 1.027 ))) !re_theta_t = 163.0 + exp(6.91-0.18) term1 = sqrt ( max ( re_theta - re_theta_t , 0. ) / ( chi_1 * re_theta_t )) term2 = sqrt ( max ( nu_BC - nu_cr , 0.0 ) / nu_cr ) term_exponential = ( term1 + term2 ) gamma_BC = 1.0 - exp ( - term_exponential ) Production = gamma_BC * cb1 * Shat * tv * cells ( i , j , k )% volume ! ___ Destruction term___ ! r = min ( tv * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim Destruction = ( cw1 * fw * tv * tv / dist_i_2 ) * ( cells ( i , j , k )% volume ) ! ____ cross diffusion term ___ lamda = ( density * CD1 / sigma_sa - CD2 * ( nu + tv ) / sigma_sa ) * cells ( i , j , k )% volume S_v = ( Production - Destruction + lamda ) residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_v end do end do end do end subroutine add_saBC_source end module source","tags":"","loc":"sourcefile/source.f90.html","title":"source.f90 – FEST-3D"},{"text":"Files dependent on this one sourcefile~~vartypes.f90~~AfferentGraph sourcefile~vartypes.f90 vartypes.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~face_interpolant.f90->sourcefile~vartypes.f90 sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~face_interpolant.f90->sourcefile~weno_nm.f90 sourcefile~muscl.f90 muscl.f90 sourcefile~face_interpolant.f90->sourcefile~muscl.f90 sourcefile~ppm.f90 ppm.f90 sourcefile~face_interpolant.f90->sourcefile~ppm.f90 sourcefile~weno.f90 weno.f90 sourcefile~face_interpolant.f90->sourcefile~weno.f90 sourcefile~check_output_control.f90 check_output_control.f90 sourcefile~check_output_control.f90->sourcefile~vartypes.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~vartypes.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~weno_nm.f90->sourcefile~vartypes.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~vartypes.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~read.f90 read.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~vartypes.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~face_interpolant.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~interface1.f90->sourcefile~vartypes.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~write_output_tec_node.f90->sourcefile~vartypes.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~write_output_tec_node.f90->sourcefile~gradients.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~write_output_tec_node.f90->sourcefile~wall_dist.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~layout.f90 layout.f90 sourcefile~layout.f90->sourcefile~vartypes.f90 sourcefile~convergence.f90 convergence.f90 sourcefile~convergence.f90->sourcefile~vartypes.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~convergence.f90->sourcefile~resnorm.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~vartypes.f90 sourcefile~state.f90->sourcefile~check_output_control.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~ausmp.f90->sourcefile~vartypes.f90 sourcefile~ausmp.f90->sourcefile~face_interpolant.f90 sourcefile~ausm.f90 ausm.f90 sourcefile~ausm.f90->sourcefile~vartypes.f90 sourcefile~read_output.f90->sourcefile~vartypes.f90 sourcefile~read_output.f90->sourcefile~check_output_control.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output.f90->sourcefile~read_output_vtk.f90 sourcefile~muscl.f90->sourcefile~vartypes.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~scheme.f90->sourcefile~vartypes.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~scheme.f90->sourcefile~ausm.f90 sourcefile~van_leer.f90 van_leer.f90 sourcefile~scheme.f90->sourcefile~van_leer.f90 sourcefile~slau.f90 slau.f90 sourcefile~scheme.f90->sourcefile~slau.f90 sourcefile~ldfss0.f90 ldfss0.f90 sourcefile~scheme.f90->sourcefile~ldfss0.f90 sourcefile~ausmup.f90 ausmUP.f90 sourcefile~scheme.f90->sourcefile~ausmup.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~read_bc.f90->sourcefile~vartypes.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~vartypes.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~solver.f90->sourcefile~layout.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~solver.f90->sourcefile~wall_dist.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~bc.f90 bc.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~solver.f90->sourcefile~geometry.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90->sourcefile~read.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~cc.f90 CC.f90 sourcefile~solver.f90->sourcefile~cc.f90 sourcefile~wall.f90 wall.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~grid.f90 grid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~viscous.f90->sourcefile~vartypes.f90 sourcefile~viscous.f90->sourcefile~gradients.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~mapping.f90->sourcefile~vartypes.f90 sourcefile~resnorm.f90->sourcefile~vartypes.f90 sourcefile~van_leer.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~source.f90 source.f90 sourcefile~source.f90->sourcefile~vartypes.f90 sourcefile~source.f90->sourcefile~gradients.f90 sourcefile~source.f90->sourcefile~wall_dist.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~read_output_tec.f90->sourcefile~vartypes.f90 sourcefile~write_output_vtk.f90->sourcefile~vartypes.f90 sourcefile~write_output_vtk.f90->sourcefile~gradients.f90 sourcefile~write_output_vtk.f90->sourcefile~wall_dist.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~lusgs.f90->sourcefile~vartypes.f90 sourcefile~lusgs.f90->sourcefile~gradients.f90 sourcefile~lusgs.f90->sourcefile~wall_dist.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~ft_bc.f90->sourcefile~vartypes.f90 sourcefile~ft_bc.f90->sourcefile~copy_bc.f90 sourcefile~bc.f90->sourcefile~vartypes.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~slau.f90->sourcefile~vartypes.f90 sourcefile~geometry.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 sourcefile~ppm.f90->sourcefile~vartypes.f90 sourcefile~dump_solution.f90->sourcefile~vartypes.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~read_output_vtk.f90->sourcefile~vartypes.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~bc_primitive.f90->sourcefile~vartypes.f90 sourcefile~bc_primitive.f90->sourcefile~wall_dist.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~bc_primitive.f90->sourcefile~copy_bc.f90 sourcefile~read.f90->sourcefile~vartypes.f90 sourcefile~ldfss0.f90->sourcefile~vartypes.f90 sourcefile~update.f90->sourcefile~vartypes.f90 sourcefile~update.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~update.f90->sourcefile~gradients.f90 sourcefile~update.f90->sourcefile~wall_dist.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~cc.f90->sourcefile~vartypes.f90 sourcefile~cc.f90->sourcefile~wall_dist.f90 sourcefile~weno.f90->sourcefile~vartypes.f90 sourcefile~plusgs.f90->sourcefile~vartypes.f90 sourcefile~plusgs.f90->sourcefile~gradients.f90 sourcefile~plusgs.f90->sourcefile~wall_dist.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~wall.f90->sourcefile~vartypes.f90 sourcefile~grid.f90->sourcefile~vartypes.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~ausmup.f90->sourcefile~vartypes.f90 sourcefile~write_output_tec.f90->sourcefile~vartypes.f90 sourcefile~write_output_tec.f90->sourcefile~gradients.f90 sourcefile~write_output_tec.f90->sourcefile~wall_dist.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~convergence.f90 sourcefile~main.f90->sourcefile~solver.f90 var pansourcefilevartypesf90AfferentGraph = svgPanZoom('#sourcefilevartypesf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules vartypes Source Code vartypes.f90 Source Code module vartypes !< Derived data types use iso_fortran_env , only : wp => real64 implicit none integer :: process_id = 0 !< Id no. of each processor assinged by MPICH library integer , parameter :: FILE_NAME_LENGTH = 64 !< Length of string used for defining any filename integer , parameter :: STRING_BUFFER_LENGTH = 128 !< User to define a string of medium length integer , parameter :: FORMAT_LENGTH = 16 !< Length of string used for file format: tecplot or vtk type , public :: nodetype real ( wp ) :: x real ( wp ) :: y real ( wp ) :: z end type nodetype type , public :: extent integer :: imx integer :: jmx integer :: kmx integer :: n_var end type extent type , public :: celltype real ( wp ) :: volume !< Store cell volume real ( wp ) :: centerx real ( wp ) :: centery real ( wp ) :: centerz !< Store Cell-center location end type celltype type , public :: facetype real ( wp ) :: A !< Store magnitude of face area vector of direction faces real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz !< Store unit face normal vector for all faces end type facetype type , public :: filetype !        integer :: FILE_NAME_LENGTH = 64 !        !< Length of string used for defining any filename integer :: CONFIG_FILE_UNIT = 16 !< Handler unit for config.md file integer :: GRID_FILE_UNIT = 17 !< Handler for input Gridfile; eg: grid_00.txt integer :: BOUNDARY_CONDITIONS_FILE_UNIT = 18 !< Handler for Boundary condition file; eg: bc_00.md !integer, parameter :: STATE_FILE_UNIT = 10 !< __Handler no longer in use__ integer :: IN_FILE_UNIT = 19 !< Handler for restart file for block: eg: time_drectories/0001/process_00.dat integer :: OUT_FILE_UNIT = 20 !< Handler for output file for each block integer :: RESNORM_FILE_UNIT = 21 !< Handler for Residual output file. filename: time_directories/aux/resnorm integer :: LAYOUT_FILE_UNIT = 31 !< Handler for input multi-block layout and boundary condition file. integer :: NODESURF_FILE_UNIT = 32 !< Handler for storing node point on the wall !integer, parameter ::   WALL_DIST_FILE_UNIT = 33 !< __Handler no longer in use__ integer :: RES_CONTROL_FILE_UNIT = 34 !< Handler for residual control file. filename: system/res_control.md !integer, parameter ::        INFO_FILE_UNIT = 35 !< __Handler NO longer in user__; info is handled using print*, command integer :: CONTROL_FILE_UNIT = 36 !< Handler for input system/control.md file integer :: SCHEME_FILE_UNIT = 37 !< Handler for input system/fvscheme.md file integer :: FLOW_FILE_UNIT = 38 !< Handler for input system/flow.md  file integer :: RESTART_FILE_UNIT = 39 !< Handler for Restart file in Restart folder. eg: time_directories/0001/Restart/process_00 integer :: OUTIN_FILE_UNIT = 40 !< Handler for file which controls what variables will be read or stored. system/output_control.md integer :: MAP_FILE_UNIT = 41 !< Handler for input multi-block mapping file with index and direction. integer :: PERIODIC_FILE_UNIT = 42 !< Handler for input periodic boundary condition file integer :: STOP_FILE_UNIT = 43 !< Handler for Stop file !file names character ( len = FILE_NAME_LENGTH ) :: control_file = \"system/control.md\" !< FILENAME string: Control file character ( len = FILE_NAME_LENGTH ) :: scheme_file = \"system/fvscheme.md\" !< FILENAME string: Scheme file character ( len = FILE_NAME_LENGTH ) :: flow_file = \"system/flow.md\" !< FILENAME string: FLow condition file character ( len = FILE_NAME_LENGTH ) :: outin_file = \"system/output_control.md\" !< FILENAME string: Ouput/Input variable control file character ( len = FILE_NAME_LENGTH ) :: layout_file = 'system/mesh/layout/layout.md' !< FILENAME string: Multiple layout/boundary condition file character ( len = FILE_NAME_LENGTH ) :: nodefile_temp = \"scratch.dat\" !< FILENAME string: Temperory file for nodesurface points character ( len = FILE_NAME_LENGTH ) :: surface_node_points = 'time_directories/aux/surfnode.dat' !< FILENAME string: Wall surface node points character ( len = FILE_NAME_LENGTH ) :: res_control_file = 'system/res_control.md' !< FILENAME string: Residual write control file character ( len = FILE_NAME_LENGTH ) :: resnorm_file = 'time_directories/aux/resnorm' !< FILENAME string: Residual output file character ( len = FILE_NAME_LENGTH ) :: stop_file = 'system/stopfile' !< FILENAME string: Halt/stop file character ( len = FILE_NAME_LENGTH ) :: mapfile = 'system/mesh/layout/mapping.txt' !< FILENAME string: Detailed multiblock mapping file with indicies and direction information at interface character ( len = FILE_NAME_LENGTH ) :: periodicfile = 'system/mesh/layout/periodic.txt' !< FILENAME string: Multiblock periodic boundary condition detials character ( len = FILE_NAME_LENGTH ) :: gridfile !< FILENAME string: Grid file character ( len = FILE_NAME_LENGTH ) :: bcfile !< FILENAME string: single block boundary condition detials character ( len = FILE_NAME_LENGTH ) :: outfile !< FILENAME string: single block solution output file character ( len = FILE_NAME_LENGTH ) :: infile !< FILENAME string: single block solution input file character ( len = FILE_NAME_LENGTH ) :: restartfile !< FILENAME string: single block restart file end type filetype type , public :: controltype real ( wp ) :: CFL = 1.0 !< Courant–Friedrichs–Lewy (CFL) (Read from input) integer :: start_from = 0 !< Number of the folder (in time_directories) to load stored state from to restart computation integer :: min_iter = 1 !< Minimum iteration value, starting iteration value integer :: max_iters = 1 !< Maximum iteration value, stop after these many iteration integer :: checkpoint_iter = 0 !< Write interval for output file. Number of iteration after which solver will dump/store a state in a folder in time_directories integer :: checkpoint_iter_count = 0 !< Counter of folder number to write in time_directories/ integer :: current_iter = 0 !< Current iteration number integer :: res_write_interval = 10 !< Write resnorm after every \"res_write_interval\" iteration integer :: purge_write = 1 !< Remove unwanted folder. If Purge_write=2, latest two folder in time_direcotires are kept and 0=no purge integer :: last_iter = 0 !< Last iteration that is stored in the restart file integer :: write_percision = 6 !< Number of place after decimal. Only used for resnorm file character ( len = FORMAT_LENGTH ) :: write_data_format = 'ASCII' !< write data type. Either ASCII or BINARY character ( len = FORMAT_LENGTH ) :: write_file_format = 'tecplot' !< Write file type. Either vtk or tecplot character ( len = FORMAT_LENGTH ) :: read_data_format = 'ASCII' !< Read data type in file. Either ASCII or BINARY character ( len = FORMAT_LENGTH ) :: read_file_format = 'tecplot' !< Read file type. Either vtk or tecplot real ( wp ) :: tolerance = 1 e - 14 !< Minimum value of resnorm after which simulation stop character ( len = STRING_BUFFER_LENGTH ) :: tolerance_type = \"abs\" !< Type of tolerance to check:absolute or relative integer , public :: DEBUG_LEVEL = 1 !< Debug level is an input from the control file. !< 5-> important calls only, and, !< 1-> all the calls character ( len = STRING_BUFFER_LENGTH ) :: previous_flow_type = \"none\" !< Type of flow:inviscid, laminar, etc, stored in the load file integer :: n_var = 5 ! Freestram variable used to read file before inf pointer are linked and allocated character ( len = STRING_BUFFER_LENGTH ), dimension (:), allocatable :: r_list !< Read variable list character ( len = STRING_BUFFER_LENGTH ), dimension (:), allocatable :: w_list !< Write variable list integer :: r_count = 0 !< Number of variable to read from the restart file integer :: w_count = 0 !< Number of variable to write in the output file character ( len = STRING_BUFFER_LENGTH ), dimension (:), allocatable :: Res_list !< Write residual variable list integer :: Res_count !< No of residual variable to save integer :: total_process = 1 !< Total number of process to be used for computation integer :: process_id = 0 !< Id no. of each processor assinged by MPICH library integer :: want_to_stop = 0 !< 0: continue the solver; 1=Stop the solver logical :: Halt = . FALSE . !< Logical value used to stop the solver in main program file. real ( wp ), dimension (:), allocatable :: previous_res !< starting resnrom of previous run end type controltype type , public :: schemetype character ( len = STRING_BUFFER_LENGTH ) :: scheme_name = 'ausm' !< Flux Scheme to use: ausm, ldfss0, vanleer, ausmup, ausmp, slau character ( len = STRING_BUFFER_LENGTH ) :: interpolant = 'muscl' !< Face state reconstruction  method to user: muscl, ppm, none, weno, and wenoNM real ( wp ) :: global_time_step = 1 e - 5 !< Value of global time step to march the solution with character :: time_stepping_method = 'l' !< Either local time stepping or global time stepping character ( len = STRING_BUFFER_LENGTH ) :: time_step_accuracy = 'implicit' !< Type of time_integration scheme: RK4, none(firt order explicit) implicit, integer :: ilimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for I direction faces. integer :: jlimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for J direction faces. integer :: klimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for K direction faces. integer :: itlimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for I direction faces. integer :: jtlimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for J direction faces. integer :: ktlimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for K direction faces. integer :: iPB_switch = 0 !< Turn on/off application of pressure based switching for higher order methods for I direction faces. integer :: jPB_switch = 0 !< Turn on/off application of pressure based switching for higher order methods for J direction faces. integer :: kPB_switch = 0 !< Turn on/off application of pressure based switching for higher order methods for K direction faces. character ( len = 8 ) :: turbulence = 'none' !< Store Turbulence model name character ( len = 8 ) :: transition = 'none' !< Store Transition model name integer :: accur = 1 !< Switch for higher order boundary condition end type schemetype type , public :: flowtype real ( wp ) :: density_inf = 1.2 !< Read freestream Density from control file real ( wp ) :: x_speed_inf = 10 0.0 !< Read freestream U from control file real ( wp ) :: y_speed_inf = 0.0 !< Read freestream V from control file real ( wp ) :: z_speed_inf = 0.0 !< Read freestream W from control file real ( wp ) :: pressure_inf = 101325 !< Read freestream Pressure from control file real ( wp ) :: tk_inf = 0.0 !< Read freestream turbulent kinetic energy rate from control file real ( wp ) :: tw_inf = 0.0 !< Read freestream turbulent dissipation rate from control file real ( wp ) :: te_inf = 0.0 !< Read freestream turbulent dissipation from control file real ( wp ) :: tv_inf = 0.0 !< Read freestream turbulent viscosity(SA) from control file real ( wp ) :: tkl_inf = 0.0 !< Read freestream kL variable from control file real ( wp ) :: tu_inf = 1.0 !< Read freestream turbulence intensity (percentage) from control file real ( wp ) :: tgm_inf = 1.0 !< Read freestream turbulence intermittency from control file real ( wp ) :: vel_mag = 10 0.0 !< Calulated freestream Velocity Magnitude from control file real ( wp ) :: MInf = 0.0 !< Calulated freestream Mach number real ( wp ) :: Reynolds_number = 0.0 !< Calculated free_stream Reynolds_number real ( wp ) :: mu_ratio_inf = 1.0 !< Read freestream turbulent viscosity to molecular viscosity ratio real ( wp ) :: Turb_intensity_inf = 0.01 !< Calculate free_stream turbulence intensity real ( wp ) :: gm = 1.4 !< Gamma commonly 1.4 real ( wp ) :: R_gas = 287 !< Univarsal gas constant real ( wp ) :: mu_ref = 0.0 !< Molecular viscoity reference character ( len = FILE_NAME_LENGTH ) :: mu_variation = \"constant\" !< Type of viscosity variaiton: Sutherland or constant real ( wp ) :: T_ref = 300 !< Reference Temperature of flow for viscosity calculation real ( wp ) :: Sutherland_temp = 110 !< Sutherland temperature for viscosity calculation real ( wp ) :: Pr = 0.7 !< prandtl number real ( wp ) :: tPr = 0.9 !< turbulent Prandtl number end type flowtype type :: boundarytype integer :: imin_id !< Boundary condition number/ID at imin for particulat processor integer :: imax_id !< Boundary condition number/ID at imax for particulat processor integer :: jmin_id !< Boundary condition number/ID at jmin for particulat processor integer :: jmax_id !< Boundary condition number/ID at jmax for particulat processor integer :: kmin_id !< Boundary condition number/ID at kmin for particulat processor integer :: kmax_id !< Boundary condition number/ID at kmax for particulat processor character ( len = 4 ), dimension ( 6 ) :: face_names !< Store name of all six boundary faces integer , dimension ( 6 ) :: id !< Store the boundary condition ID of all six faces real ( wp ) :: c1 !< First coefficient user for higher order boundary condition real ( wp ) :: c2 !< Second coefficient user for higher order boundary condition real ( wp ) :: c3 !< Third coefficient user for higher order boundary condition ! store fix values for 6 faces of domain real ( wp ), dimension ( 6 ) :: fixed_density = 0. !< Density value to fix at particular boundary real ( wp ), dimension ( 6 ) :: fixed_pressure = 0. !< Pressure value to fix at particular boundary real ( wp ), dimension ( 6 ) :: fixed_x_speed = 0. !< X component of velocity to fix at particular boundary condition real ( wp ), dimension ( 6 ) :: fixed_y_speed = 0. !< Y component of velocity to fix at particular boundary condition real ( wp ), dimension ( 6 ) :: fixed_z_speed = 0. !< Z component of velocity to fix at particular boundary condition real ( wp ), dimension ( 6 ) :: fixed_tk = 0. !< Turbulent kinetic energy value to fix at particular boundary condition real ( wp ), dimension ( 6 ) :: fixed_tw = 0. !< Turbulent kinetic energy dissiaption rate value to fix at particular boundary condition(k-omega and SST model) real ( wp ), dimension ( 6 ) :: fixed_te = 0. !< Turbulent kinetic energy dissiaption value to fix at particular boundary condition (K-eplision model) real ( wp ), dimension ( 6 ) :: fixed_tv = 0. !< Turbulent viscosity varialble value to fix at particular boundary condition (for SA turbulence model) real ( wp ), dimension ( 6 ) :: fixed_tkl = 0. !< (Turbulent kinetic energy x length) varialble value to fix at particular boundary condition (for k-kL turbulence model) real ( wp ), dimension ( 6 ) :: fixed_tgm = 0. !<  Fixed intermittency value to apply at particular boundary condition (for SST2003-gamma transition model) real ( wp ), dimension ( 6 ) :: fixed_wall_temperature = 0. !<  Fixed wall temperature value to apply at isothermal wall boundary condition. real ( wp ), dimension ( 6 ) :: fixed_Tpressure = 0. !<  Fixed Total Pressure value to apply at particular boundary condition real ( wp ), dimension ( 6 ) :: fixed_Ttemperature = 0. !<  Fixed Total Temperature value to apply at particular boundary condition !interface mapping integer , dimension ( 6 ) :: ilo , ihi !< Store the lower and upper bound of the indecies of I loop for the interface mapping integer , dimension ( 6 ) :: jlo , jhi !< Store the lower and upper bound of the indecies of J loop for the interface mapping integer , dimension ( 6 ) :: klo , khi !< Store the lower and upper bound of the indecies of K loop for the interface mapping integer , dimension ( 6 ) :: dir_switch = 0 !< Switch for each boundary face. Activated only if ( for eg I-direction in the mapping is mapped with J-direction) integer , dimension ( 6 ) :: otherface !< Store the face number with which the current interface is connected. !zero flux faces integer , dimension (:), allocatable :: make_F_flux_zero !< Store zero to boundary face, which has wall ID, to make F flux zero integer , dimension (:), allocatable :: make_G_flux_zero !< Store zero to boundary face, which has wall ID, to make G flux zero integer , dimension (:), allocatable :: make_H_flux_zero !< Store zero to boundary face, which has wall ID, to make H flux zero !periodic boundary condition integer , dimension ( 6 ) :: PbcId = - 1 !< Block ID for Periodic boundary condition end type boundarytype end module vartypes","tags":"","loc":"sourcefile/vartypes.f90.html","title":"vartypes.f90 – FEST-3D"},{"text":"Check for solution's convergence This file depends on sourcefile~~convergence.f90~~EfferentGraph sourcefile~convergence.f90 convergence.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~convergence.f90->sourcefile~resnorm.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~convergence.f90->sourcefile~vartypes.f90 sourcefile~resnorm.f90->sourcefile~vartypes.f90 sourcefile~utils.f90 utils.f90 sourcefile~resnorm.f90->sourcefile~utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~convergence.f90~~AfferentGraph sourcefile~convergence.f90 convergence.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~convergence.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules convergence Source Code convergence.f90 Source Code !< Check for solution's convergence module convergence !< Check for solution's convergence use vartypes use resnorm , only : Res_abs use resnorm , only : Res_rel #include \"error.h\" implicit none private public :: converged contains function converged ( control ) result ( c ) !< Check if the solution seems to have converged !< The solution is said to have converged if the change in !< the residue norm is \"negligible\". !----------------------------------------------------------- implicit none type ( controltype ), intent ( in ) :: control !< control parameters logical :: c !< convergence result:True or false real ( wp ) :: check = 1 0. select case ( trim ( control % tolerance_type )) case ( 'Mass_abs' ) check = Res_abs ( 0 ) case ( 'Resnorm_abs' ) check = sqrt ( sum ( Res_abs ( 1 :) ** 2 )) case ( 'Viscous_abs' ) check = sqrt ( sum ( Res_abs ( 1 : 5 ) ** 2 )) case ( 'Turbulent_abs' ) check = sqrt ( sum ( Res_abs ( 6 :) ** 2 )) case ( 'Continuity_abs' ) check = Res_abs ( 1 ) case ( 'X-mom_abs' ) check = Res_abs ( 2 ) case ( 'Z-mom_abs' ) check = Res_abs ( 3 ) case ( 'Y-mom_abs' ) check = Res_abs ( 4 ) case ( 'Energy_abs' ) check = Res_abs ( 5 ) case ( 'Mass_rel' ) check = Res_rel ( 0 ) case ( 'Resnorm_rel' ) check = sqrt ( sum ( Res_rel ( 1 :) ** 2 )) case ( 'Viscous_rel' ) check = sqrt ( sum ( Res_rel ( 1 : 5 ) ** 2 )) case ( 'Turbulent_rel' ) check = sqrt ( sum ( Res_rel ( 6 :) ** 2 )) case ( 'Continuity_rel' ) check = Res_rel ( 1 ) case ( 'X-mom_rel' ) check = Res_rel ( 2 ) case ( 'Z-mom_rel' ) check = Res_rel ( 3 ) case ( 'Y-mom_rel' ) check = Res_rel ( 4 ) case ( 'Energy_rel' ) check = Res_rel ( 5 ) case ( 'TKE_abs' ) check = Res_abs ( 6 ) case ( 'tv_abs' ) check = Res_abs ( 6 ) case ( 'Dissipation_abs' ) check = Res_abs ( 7 ) case ( 'Omega_abs' ) check = Res_abs ( 7 ) case ( 'Kl_abs' ) check = Res_abs ( 7 ) case ( 'TKE_rel' ) check = Res_rel ( 6 ) case ( 'tv_rel' ) check = Res_rel ( 6 ) case ( 'Dissipation_rel' ) check = Res_rel ( 7 ) case ( 'Omega_rel' ) check = Res_rel ( 7 ) case ( 'Kl_rel' ) check = Res_rel ( 7 ) case DEFAULT ! making absolute resnorm default check = sqrt ( sum ( Res_abs ( 1 :) ** 2 )) Issue_warning end select if ( check < control % tolerance . and . control % current_iter > 10 ) then c = . TRUE . else c = . FALSE . end if end function converged end module convergence","tags":"","loc":"sourcefile/convergence.f90.html","title":"convergence.f90 – FEST-3D"},{"text":"The grid module read grid file and allocate memory to storing variables This file depends on sourcefile~~grid.f90~~EfferentGraph sourcefile~grid.f90 grid.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~grid.f90->sourcefile~vartypes.f90 sourcefile~mapping.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~grid.f90~~AfferentGraph sourcefile~grid.f90 grid.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules grid Source Code grid.f90 Source Code !< The grid module read grid file and allocate memory to storing variables module grid !< The grid module contains the grid definition (locations of the !< grid points) as well as procedures to load these from a file. !------------------------------------------------------------------- use vartypes use mpi use mapping , only : read_interface_map #include \"error.h\" #include \"debug.h\" private ! Public methods public :: setup_grid contains subroutine setup_grid ( files , nodes , control , bc , dims ) !< Read the grid file and initialize the grid !----------------------------------------------------------- implicit none type ( filetype ), intent ( in ) :: files !< Files' name and handler type ( controltype ), intent ( in ) :: control !< Control parameters type ( boundarytype ), intent ( inout ) :: bc !< boundary conditions and fixed values type ( nodetype ), dimension (:,:,:), allocatable , intent ( out ) :: nodes !< Grid points type ( extent ), intent ( out ) :: dims !< Extent of the domain:imx,jmx,kmx DebugCall ( 'setup_grid' ) open ( files % GRID_FILE_UNIT , file = files % gridfile ) call extract_grid_size ( files % GRID_FILE_UNIT , dims ) ! allocate memory for storing grid points allocate ( nodes ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 )) !read interface mapping call read_interface_map ( files , control , bc , dims ) ! ghost grid exchange call populate_grid_points ( files % GRID_FILE_UNIT , nodes , dims ) close ( files % GRID_FILE_UNIT ) ! populate ghost grid points call ghost_grid ( nodes , dims ) end subroutine setup_grid subroutine extract_grid_size ( file_handler , dims ) !< Extract the grid size from the grid file header ! ! We assume that the grid could be in 1 or 2 dimensions. If ! the grid is in 1 dimension, jmx will be set to 1. ! We assume that at least one number is specified in the ! header, i.e., the grid has atleast one dimension. !----------------------------------------------------------- implicit none integer , intent ( in ) :: file_handler !< (input)file handling unit character ( len = STRING_BUFFER_LENGTH ) :: header !< store header type ( extent ), intent ( out ) :: dims !< Extent of the domain:imx,jmx,kmx integer :: ios ! io operation status DebugCall ( 'extract_grid_size' ) read ( file_handler , '(A)' , iostat = ios ) header if ( ios /= 0 ) then print * , 'Error while reading grid file header.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH !stop end if ! Try to read constants corresponding to two dimensions. read ( header , * , iostat = ios ) dims % imx , dims % jmx , dims % kmx if ( ios /= 0 ) then print * , \"Not able to read dimension from the grid file\" print * , \"Make sure you provdie 3D grid\" Fatal_error end if end subroutine extract_grid_size subroutine populate_grid_points ( file_handler , nodes , dims ) !< Use the grid file to populate the grid points. !----------------------------------------------------------- implicit none integer , intent ( in ) :: file_handler !< (input)file handling unit type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( out ) :: nodes !< Grid points character ( len = STRING_BUFFER_LENGTH ) :: line !< store read line integer :: i , j , k integer :: ios !< input/output  status DebugCall ( 'populate_grid_point' ) !  print *, imx, jmx, kmx ! Read grid points from the grid file do k = 1 , dims % kmx do j = 1 , dims % jmx do i = 1 , dims % imx read ( file_handler , '(A)' , iostat = ios ) line if ( ios /= 0 ) then print * , 'Error while reading grid line.' print * , 'Current grid point: ' , i , j , k print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH print * , 'Exiting program.' !stop end if !call extract_grid_point(line, i, j, k) read ( line , * ) nodes ( i , j , k )% x , nodes ( i , j , k )% y , nodes ( i , j , k )% z end do end do end do end subroutine populate_grid_points subroutine ghost_grid ( nodes , dims ) !< generate ghost grid for the various operations later. implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( inout ) :: nodes !< grid points DebugCall ( 'ghost_grid' ) !------------------------------------------------------------------- !getting ghost cell for all faces even if it is a interface cell ! <algorithm> ! Point_ghost = 2*Point_first_inner_cell - Point_second_inner_cell ! </algorithm> !------------------------------------------------------------------- !--- I faces ---! !imin face -> 0 grid point !imin face -> -1 grid point !imin face -> -2 grid point nodes ( 0 ,:,:)% x = 2 * nodes ( 1 ,:,:)% x - nodes ( 2 ,:,:)% x nodes ( 0 ,:,:)% y = 2 * nodes ( 1 ,:,:)% y - nodes ( 2 ,:,:)% y nodes ( 0 ,:,:)% z = 2 * nodes ( 1 ,:,:)% z - nodes ( 2 ,:,:)% z nodes ( - 1 ,:,:)% x = 2 * nodes ( 0 ,:,:)% x - nodes ( 1 ,:,:)% x nodes ( - 1 ,:,:)% y = 2 * nodes ( 0 ,:,:)% y - nodes ( 1 ,:,:)% y nodes ( - 1 ,:,:)% z = 2 * nodes ( 0 ,:,:)% z - nodes ( 1 ,:,:)% z nodes ( - 2 ,:,:)% x = 2 * nodes ( - 1 ,:,:)% x - nodes ( 0 ,:,:)% x nodes ( - 2 ,:,:)% y = 2 * nodes ( - 1 ,:,:)% y - nodes ( 0 ,:,:)% y nodes ( - 2 ,:,:)% z = 2 * nodes ( - 1 ,:,:)% z - nodes ( 0 ,:,:)% z !imax face -> imx+1 grid point !imax face -> imx+2 grid point !imax face -> imx+3 grid point nodes ( dims % imx + 1 ,:,:)% x = 2 * nodes ( dims % imx + 0 ,:,:)% x - nodes ( dims % imx - 1 ,:,:)% x nodes ( dims % imx + 1 ,:,:)% y = 2 * nodes ( dims % imx + 0 ,:,:)% y - nodes ( dims % imx - 1 ,:,:)% y nodes ( dims % imx + 1 ,:,:)% z = 2 * nodes ( dims % imx + 0 ,:,:)% z - nodes ( dims % imx - 1 ,:,:)% z nodes ( dims % imx + 2 ,:,:)% x = 2 * nodes ( dims % imx + 1 ,:,:)% x - nodes ( dims % imx - 0 ,:,:)% x nodes ( dims % imx + 2 ,:,:)% y = 2 * nodes ( dims % imx + 1 ,:,:)% y - nodes ( dims % imx - 0 ,:,:)% y nodes ( dims % imx + 2 ,:,:)% z = 2 * nodes ( dims % imx + 1 ,:,:)% z - nodes ( dims % imx - 0 ,:,:)% z nodes ( dims % imx + 3 ,:,:)% x = 2 * nodes ( dims % imx + 2 ,:,:)% x - nodes ( dims % imx + 1 ,:,:)% x nodes ( dims % imx + 3 ,:,:)% y = 2 * nodes ( dims % imx + 2 ,:,:)% y - nodes ( dims % imx + 1 ,:,:)% y nodes ( dims % imx + 3 ,:,:)% z = 2 * nodes ( dims % imx + 2 ,:,:)% z - nodes ( dims % imx + 1 ,:,:)% z !--- Jmin faces ---! !jmin faces -> 0 grid point !jmin face -> -1 grid point !jmin face -> -2 grid point nodes (:, 0 ,:)% x = 2 * nodes (:, 1 ,:)% x - nodes (:, 2 ,:)% x nodes (:, 0 ,:)% y = 2 * nodes (:, 1 ,:)% y - nodes (:, 2 ,:)% y nodes (:, 0 ,:)% z = 2 * nodes (:, 1 ,:)% z - nodes (:, 2 ,:)% z nodes (:, - 1 ,:)% x = 2 * nodes (:, 0 ,:)% x - nodes (:, 1 ,:)% x nodes (:, - 1 ,:)% y = 2 * nodes (:, 0 ,:)% y - nodes (:, 1 ,:)% y nodes (:, - 1 ,:)% z = 2 * nodes (:, 0 ,:)% z - nodes (:, 1 ,:)% z nodes (:, - 2 ,:)% x = 2 * nodes (:, - 1 ,:)% x - nodes (:, 0 ,:)% x nodes (:, - 2 ,:)% y = 2 * nodes (:, - 1 ,:)% y - nodes (:, 0 ,:)% y nodes (:, - 2 ,:)% z = 2 * nodes (:, - 1 ,:)% z - nodes (:, 0 ,:)% z !jmax face -> jmx+1 grid point !jmax face -> jmx+3 grid point !jmax face -> jmx+2 grid point nodes (:, dims % jmx + 1 ,:)% x = 2 * nodes (:, dims % jmx + 0 ,:)% x - nodes (:, dims % jmx - 1 ,:)% x nodes (:, dims % jmx + 1 ,:)% y = 2 * nodes (:, dims % jmx + 0 ,:)% y - nodes (:, dims % jmx - 1 ,:)% y nodes (:, dims % jmx + 1 ,:)% z = 2 * nodes (:, dims % jmx + 0 ,:)% z - nodes (:, dims % jmx - 1 ,:)% z nodes (:, dims % jmx + 2 ,:)% x = 2 * nodes (:, dims % jmx + 1 ,:)% x - nodes (:, dims % jmx - 0 ,:)% x nodes (:, dims % jmx + 2 ,:)% y = 2 * nodes (:, dims % jmx + 1 ,:)% y - nodes (:, dims % jmx - 0 ,:)% y nodes (:, dims % jmx + 2 ,:)% z = 2 * nodes (:, dims % jmx + 1 ,:)% z - nodes (:, dims % jmx - 0 ,:)% z nodes (:, dims % jmx + 3 ,:)% x = 2 * nodes (:, dims % jmx + 2 ,:)% x - nodes (:, dims % jmx + 1 ,:)% x nodes (:, dims % jmx + 3 ,:)% y = 2 * nodes (:, dims % jmx + 2 ,:)% y - nodes (:, dims % jmx + 1 ,:)% y nodes (:, dims % jmx + 3 ,:)% z = 2 * nodes (:, dims % jmx + 2 ,:)% z - nodes (:, dims % jmx + 1 ,:)% z !--- Kmax faces ---! !kmin faces -> 0 grid point !kmin face -> -1 grid point !kmin face -> -2 grid point nodes (:,:, 0 )% x = 2 * nodes (:,:, 1 )% x - nodes (:,:, 2 )% x nodes (:,:, 0 )% y = 2 * nodes (:,:, 1 )% y - nodes (:,:, 2 )% y nodes (:,:, 0 )% z = 2 * nodes (:,:, 1 )% z - nodes (:,:, 2 )% z nodes (:,:, - 1 )% x = 2 * nodes (:,:, 0 )% x - nodes (:,:, 1 )% x nodes (:,:, - 1 )% y = 2 * nodes (:,:, 0 )% y - nodes (:,:, 1 )% y nodes (:,:, - 1 )% z = 2 * nodes (:,:, 0 )% z - nodes (:,:, 1 )% z nodes (:,:, - 2 )% x = 2 * nodes (:,:, - 1 )% x - nodes (:,:, 0 )% x nodes (:,:, - 2 )% y = 2 * nodes (:,:, - 1 )% y - nodes (:,:, 0 )% y nodes (:,:, - 2 )% z = 2 * nodes (:,:, - 1 )% z - nodes (:,:, 0 )% z !kmax face -> kmx+1 grid point !kmax face -> kmx+2 grid point !kmax face -> kmx+3 grid point nodes (:,:, dims % kmx + 1 )% x = 2 * nodes (:,:, dims % kmx + 0 )% x - nodes (:,:, dims % kmx - 1 )% x nodes (:,:, dims % kmx + 1 )% y = 2 * nodes (:,:, dims % kmx + 0 )% y - nodes (:,:, dims % kmx - 1 )% y nodes (:,:, dims % kmx + 1 )% z = 2 * nodes (:,:, dims % kmx + 0 )% z - nodes (:,:, dims % kmx - 1 )% z nodes (:,:, dims % kmx + 2 )% x = 2 * nodes (:,:, dims % kmx + 1 )% x - nodes (:,:, dims % kmx - 0 )% x nodes (:,:, dims % kmx + 2 )% y = 2 * nodes (:,:, dims % kmx + 1 )% y - nodes (:,:, dims % kmx - 0 )% y nodes (:,:, dims % kmx + 2 )% z = 2 * nodes (:,:, dims % kmx + 1 )% z - nodes (:,:, dims % kmx - 0 )% z nodes (:,:, dims % kmx + 3 )% x = 2 * nodes (:,:, dims % kmx + 2 )% x - nodes (:,:, dims % kmx + 1 )% x nodes (:,:, dims % kmx + 3 )% y = 2 * nodes (:,:, dims % kmx + 2 )% y - nodes (:,:, dims % kmx + 1 )% y nodes (:,:, dims % kmx + 3 )% z = 2 * nodes (:,:, dims % kmx + 2 )% z - nodes (:,:, dims % kmx + 1 )% z end subroutine ghost_grid end module grid","tags":"","loc":"sourcefile/grid.f90.html","title":"grid.f90 – FEST-3D"},{"text":"Matix-free time integration: LU-SGS This file depends on sourcefile~~lusgs.f90~~EfferentGraph sourcefile~lusgs.f90 lusgs.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~lusgs.f90->sourcefile~global_sa.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~lusgs.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~lusgs.f90->sourcefile~wall_dist.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~lusgs.f90->sourcefile~global_kkl.f90 sourcefile~utils.f90 utils.f90 sourcefile~lusgs.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~lusgs.f90->sourcefile~vartypes.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~lusgs.f90->sourcefile~global_sst.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~lusgs.f90~~AfferentGraph sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules lusgs Source Code lusgs.f90 Source Code !< Matix-free time integration: LU-SGS module lusgs !< !< Reference: Sharov, D., Luo, H., Baum, J., and Loehner, R., !< “Implementation of unstructured grid GMRES+LU-SGS method on !< shared-memory, cache-based parallel computers,” !< 38th Aerospace Sciences Meeting and Exhibit, vol. 927, 2000, p. 2000. use vartypes use global_kkl , only : cphi1 use global_kkl , only : cphi2 use global_kkl , only : fphi use global_kkl , only : eta use global_kkl , only : cd1 use global_kkl , only : cmu use global_sst , only : beta1 use global_sst , only : beta2 use global_sst , only : bstar use global_sst , only : sst_F1 use global_sa , only : sigma_sa use global_sa , only : cb1 use global_sa , only : cb2 use global_sa , only : cw1 use global_sa , only : cw2 use global_sa , only : cw3 use global_sa , only : cv1 use global_sa , only : sigma_sa use global_sa , only : kappa_sa use global_sa , only : cv1_3 use global_sa , only : cw3_6 use wall_dist , only : dist use viscosity , only : mu use viscosity , only : mu_t use gradients , only : gradu_x use gradients , only : gradu_y use gradients , only : gradu_z use gradients , only : gradv_x use gradients , only : gradv_y use gradients , only : gradv_z use gradients , only : gradw_x use gradients , only : gradw_y use gradients , only : gradw_z use utils , only : alloc !--- sst implicit update ---! use global_sst , only : sst_F1 use global_sst , only : sigma_k1 use global_sst , only : sigma_k2 use global_sst , only : sigma_w1 use global_sst , only : sigma_w2 use global_kkl , only : sigma_k use global_kkl , only : sigma_phi #include \"debug.h\" #include \"error.h\" real ( wp ), dimension (:,:,:,:), allocatable :: delQ !< change of state variable (solution) over one time-step real ( wp ), dimension (:,:,:,:), allocatable :: delQstar !< Intermediate change of state variable over one time-step real ( wp ), dimension (:,:,:), allocatable , target :: dummy !< dummy variable real ( wp ), dimension (:,:,:), pointer :: tmu !< Pionter to turbulent viscosity real ( wp ), dimension (:,:,:), pointer :: mmu !< Pointer to molecular viscosity integer :: imx , jmx , kmx , n_var real ( wp ) :: gm , mu_ref , Reynolds_number , free_stream_tu real ( wp ) :: tk_inf real ( wp ) :: tkl_inf real ( wp ) :: tPr , Pr , R_gas public :: update_with_lusgs public :: setup_lusgs contains subroutine setup_lusgs ( control , scheme , flow , dims ) !< allocate array memory for data communication implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx character ( len =* ), parameter :: errmsg = \"module: LUSGS, subrouinte setup\" !< Error message imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var gm = flow % gm mu_ref = flow % mu_ref Reynolds_number = flow % Reynolds_number free_stream_tu = flow % tu_inf tk_inf = flow % tk_inf tkl_inf = flow % tkl_inf tpr = flow % tpr pr = flow % pr R_gas = flow % R_gas call alloc ( delQ , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) call alloc ( delQstar , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) if ( mu_ref == 0.0 . or . scheme % turbulence == 'none' ) then call alloc ( dummy , 0 , imx , 0 , jmx , 0 , kmx ) dummy = 0.0 end if if ( mu_ref == 0.0 ) then mmu => dummy else mmu => mu end if if ( trim ( scheme % turbulence ) == 'none' ) then tmu => dummy else tmu => mu_t end if end subroutine setup_lusgs subroutine update_with_lusgs ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , scheme , dims ) !< Time-integrate with LU_SGS method implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal DebugCall ( \"Update_with_lusgs\" ) select case ( trim ( scheme % turbulence )) case ( 'none' ) call update_laminar_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'sst' , 'sst2003' ) select case ( trim ( scheme % transition )) case ( 'none' , 'bc' ) call update_SST_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'lctm2015' ) call update_lctm2015 ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case DEFAULT Fatal_error end select case ( 'kkl' ) call update_KKL_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'sa' , 'saBC' ) call update_SA_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case Default Fatal_error end select end subroutine update_with_lusgs subroutine update_laminar_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update laminar flow with LU-SGS scheme implicit none integer :: i , j , k type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal real ( wp ), dimension ( 1 : 5 ) :: deltaU real ( wp ) :: D real ( wp ), dimension ( 1 : 5 ) :: conservativeQ real ( wp ), dimension ( 1 : 5 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 5 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 5 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 5 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 5 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 5 ) :: Q2 real ( wp ), dimension ( 1 : 5 ) :: Q3 real ( wp ), dimension ( 1 : 5 ) :: Q4 real ( wp ), dimension ( 1 : 5 ) :: Q5 real ( wp ), dimension ( 1 : 5 ) :: Q6 real ( wp ), dimension ( 1 : 5 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 5 ) :: DQ1 real ( wp ), dimension ( 1 : 5 ) :: DQ2 real ( wp ), dimension ( 1 : 5 ) :: DQ3 real ( wp ), dimension ( 1 : 5 ) :: DQ4 real ( wp ), dimension ( 1 : 5 ) :: DQ5 real ( wp ), dimension ( 1 : 5 ) :: DQ6 real ( wp ), dimension ( 1 : 7 ) :: Flist1 real ( wp ), dimension ( 1 : 7 ) :: Flist2 real ( wp ), dimension ( 1 : 7 ) :: Flist3 real ( wp ), dimension ( 1 : 7 ) :: Flist4 real ( wp ), dimension ( 1 : 7 ) :: Flist5 real ( wp ), dimension ( 1 : 7 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 DebugCall ( \"Update_with_lusgs\" ) !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 5 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 5 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 5 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = Flux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 5 ) = - residue ( i , j , k , 1 : 5 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 5 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 5 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 5 )) ) delQstar ( i , j , k , 1 : 5 ) = deltaU ( 1 : 5 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 5 ) DQ5 = delQ ( i , j + 1 , k , 1 : 5 ) DQ6 = delQ ( i , j , k + 1 , 1 : 5 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = Flux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) delQ ( i , j , k , 1 : 5 ) = delQstar ( i , j , k , 1 : 5 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 5 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 5 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 5 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) ! add new change into conservative solution conservativeQ ( 1 : 5 ) = conservativeQ ( 1 : 5 ) + delQ ( i , j , k , 1 : 5 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) end do end do end do end subroutine update_laminar_variables function Flux ( ql , qr , du , inputs ) !< calculate the total flux through face for laminar flow. !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 1 : 5 ) = U ( 1 : 5 ) + du ( 1 : 5 ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux = Flux * Area end function Flux function SpectralRadius ( ql , qr , inputs , c1 , c2 ) !< Calculate the spectral radius implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : 3 ) , intent ( in ) :: c1 real ( wp ), dimension ( 1 : 3 ) , intent ( in ) :: c2 ! local variables real ( wp ) :: SpectralRadius real ( wp ) :: NormalSpeed real ( wp ) :: SpeedOfSound real ( wp ) :: vis real ( wp ) :: mu real ( wp ) :: rho real ( wp ) :: distance !extract inputs real ( wp ) :: Area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mm real ( wp ) :: tm Area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mm = inputs ( 6 ) tm = inputs ( 7 ) ! in state vector q (2-4) are the cell center velocity NormalSpeed = 0.5 * ( ( ( ql ( 2 ) + qr ( 2 ) ) * nx ) & + ( ( ql ( 3 ) + qr ( 3 ) ) * ny ) & + ( ( ql ( 4 ) + qr ( 4 ) ) * nz ) & ) NormalSpeed = abs ( NormalSpeed ) SpeedOfSound = 0.5 * ( sqrt ( gm * ql ( 5 ) / ql ( 1 )) + sqrt ( gm * qr ( 5 ) / qr ( 1 )) ) ! visocus part mu = mm / Pr + tm / tPr rho = 0.5 * ( ql ( 1 ) + qr ( 1 ) ) distance = sqrt (( c1 ( 1 ) - c2 ( 1 )) ** 2 + ( c1 ( 2 ) - c2 ( 2 )) ** 2 + ( c1 ( 3 ) - c2 ( 3 )) ** 2 ) vis = gm * ( mm / pr + tm / tpr ) / ( rho * distance ) SpectralRadius = ( NormalSpeed + SpeedOfSound + vis ) * Area end function SpectralRadius subroutine update_SST_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (SST) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 7 ) :: deltaU real ( wp ), dimension ( 1 : 7 ) :: D real ( wp ), dimension ( 1 : 7 ) :: conservativeQ real ( wp ), dimension ( 1 : 7 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 7 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 7 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 7 ) :: Q2 real ( wp ), dimension ( 1 : 7 ) :: Q3 real ( wp ), dimension ( 1 : 7 ) :: Q4 real ( wp ), dimension ( 1 : 7 ) :: Q5 real ( wp ), dimension ( 1 : 7 ) :: Q6 real ( wp ), dimension ( 1 : 7 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 7 ) :: DQ1 real ( wp ), dimension ( 1 : 7 ) :: DQ2 real ( wp ), dimension ( 1 : 7 ) :: DQ3 real ( wp ), dimension ( 1 : 7 ) :: DQ4 real ( wp ), dimension ( 1 : 7 ) :: DQ5 real ( wp ), dimension ( 1 : 7 ) :: DQ6 real ( wp ), dimension ( 1 : 8 ) :: Flist1 real ( wp ), dimension ( 1 : 8 ) :: Flist2 real ( wp ), dimension ( 1 : 8 ) :: Flist3 real ( wp ), dimension ( 1 : 8 ) :: Flist4 real ( wp ), dimension ( 1 : 8 ) :: Flist5 real ( wp ), dimension ( 1 : 8 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: beta ! intermittency real ( wp ) :: De , Dp De = 0.0 Dp = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SSTFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SSTFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SSTFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SSTFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SSTFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - ( residue ( i , j , k , 1 : 7 )) & - 0.5 * ((( DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + (( DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + (( DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SSTFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SSTFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SSTFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SSTFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SSTFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * ((( DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + (( DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + (( DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if end do end do end do end subroutine update_SST_variables function SSTFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (SST) implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 8 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: SSTFlux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtkdx real ( wp ) :: dtkdy real ( wp ) :: dtkdz real ( wp ) :: dtwdx real ( wp ) :: dtwdy real ( wp ) :: dtwdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: sigma_k real ( wp ) :: sigma_w real ( wp ) :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux = Flux * Area SSTFlux = Flux end function SSTFlux subroutine update_KKL_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (k-kL) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 7 ) :: deltaU real ( wp ), dimension ( 1 : 7 ) :: D real ( wp ), dimension ( 1 : 7 ) :: conservativeQ real ( wp ), dimension ( 1 : 7 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 7 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 7 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 7 ) :: Q2 real ( wp ), dimension ( 1 : 7 ) :: Q3 real ( wp ), dimension ( 1 : 7 ) :: Q4 real ( wp ), dimension ( 1 : 7 ) :: Q5 real ( wp ), dimension ( 1 : 7 ) :: Q6 real ( wp ), dimension ( 1 : 7 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 7 ) :: DQ1 real ( wp ), dimension ( 1 : 7 ) :: DQ2 real ( wp ), dimension ( 1 : 7 ) :: DQ3 real ( wp ), dimension ( 1 : 7 ) :: DQ4 real ( wp ), dimension ( 1 : 7 ) :: DQ5 real ( wp ), dimension ( 1 : 7 ) :: DQ6 real ( wp ), dimension ( 1 : 7 ) :: Flist1 real ( wp ), dimension ( 1 : 7 ) :: Flist2 real ( wp ), dimension ( 1 : 7 ) :: Flist3 real ( wp ), dimension ( 1 : 7 ) :: Flist4 real ( wp ), dimension ( 1 : 7 ) :: Flist5 real ( wp ), dimension ( 1 : 7 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = KKLFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = KKLFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = KKLFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = KKLFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = KKLFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = KKLFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) D ( 6 ) = D ( 6 ) + ( 2.5 * ( cmu ** ( 0.75 )) * Q0 ( 1 ) * ( Q0 ( 6 ) ** ( 1.5 )) * cells ( i , j , k )% volume / Q0 ( 7 )) D ( 6 ) = D ( 6 ) + ( 2 * mmu ( i , j , k ) * cells ( i , j , k )% volume / ( dist ( i , j , k ) ** 2 )) D ( 7 ) = D ( 7 ) + ( 6 * mmu ( i , j , k ) * cells ( i , j , k )% volume / ( dist ( i , j , k ) ** 2 )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - residue ( i , j , k , 1 : 7 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = KKLFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = KKLFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = KKLFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = KKLFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = KKLFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = KKLFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) D ( 6 ) = D ( 6 ) + ( 2.5 * ( cmu ** ( 0.75 )) * Q0 ( 1 ) * ( Q0 ( 6 ) ** ( 1.5 )) * cells ( i , j , k )% volume / Q0 ( 7 )) D ( 6 ) = D ( 6 ) + ( 2 * mmu ( i , j , k ) * cells ( i , j , k )% volume / ( dist ( i , j , k ) ** 2 )) D ( 7 ) = D ( 7 ) + ( 6 * mmu ( i , j , k ) * cells ( i , j , k )% volume / ( dist ( i , j , k ) ** 2 )) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) qp ( i , j , k , 7 ) = max ( qp ( i , j , k , 7 ), 1.e-8 ) end do end do end do end subroutine update_KKL_variables function KKLFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (k-kL) implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: KKLFlux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtkdx real ( wp ) :: dtkdy real ( wp ) :: dtkdz real ( wp ) :: dtkldx real ( wp ) :: dtkldy real ( wp ) :: dtkldz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) W ( 7 ) = max ( W ( 7 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtkldx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtkldy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtkldz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_phi * tmu ) * ( dtkldx * nx + dtkldy * ny + dtkldz * nz ) Flux = Flux * Area KKLFlux = Flux end function KKLFlux subroutine update_SA_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (SA) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 6 ) :: deltaU real ( wp ), dimension ( 1 : 6 ) :: D real ( wp ), dimension ( 1 : 6 ) :: conservativeQ real ( wp ), dimension ( 1 : 6 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 6 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 6 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 6 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 6 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 6 ) :: Q2 real ( wp ), dimension ( 1 : 6 ) :: Q3 real ( wp ), dimension ( 1 : 6 ) :: Q4 real ( wp ), dimension ( 1 : 6 ) :: Q5 real ( wp ), dimension ( 1 : 6 ) :: Q6 real ( wp ), dimension ( 1 : 6 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 6 ) :: DQ1 real ( wp ), dimension ( 1 : 6 ) :: DQ2 real ( wp ), dimension ( 1 : 6 ) :: DQ3 real ( wp ), dimension ( 1 : 6 ) :: DQ4 real ( wp ), dimension ( 1 : 6 ) :: DQ5 real ( wp ), dimension ( 1 : 6 ) :: DQ6 real ( wp ), dimension ( 1 : 7 ) :: Flist1 real ( wp ), dimension ( 1 : 7 ) :: Flist2 real ( wp ), dimension ( 1 : 7 ) :: Flist3 real ( wp ), dimension ( 1 : 7 ) :: Flist4 real ( wp ), dimension ( 1 : 7 ) :: Flist5 real ( wp ), dimension ( 1 : 7 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: fv1 real ( wp ) :: fv2 real ( wp ) :: fw real ( wp ) :: g real ( wp ) :: r real ( wp ) :: dist_i real ( wp ) :: dist_i_2 real ( wp ) :: Ji real ( wp ) :: Ji_2 real ( wp ) :: Ji_3 real ( wp ) :: S real ( wp ) :: Omega real ( wp ) :: k2 real ( wp ) :: inv_k2_d2 real ( wp ) :: Shat real ( wp ) :: inv_Shat real ( wp ) :: nu real ( wp ) :: glim real ( wp ) :: g_6 real ( wp ) :: dfv1 real ( wp ) :: dfv2 real ( wp ) :: dfw real ( wp ) :: dShat real ( wp ) :: dr real ( wp ) :: dg real ( wp ) :: density !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 6 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 6 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 6 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SAFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SAFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SAFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SAFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SAFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * cells ( i , j , k )% volume ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * cells ( i , j , k )% volume ! --  end of source term -- ! deltaU ( 1 : 6 ) = - residue ( i , j , k , 1 : 6 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 6 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 6 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 6 )) ) delQstar ( i , j , k , 1 : 6 ) = deltaU ( 1 : 6 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 6 ) DQ5 = delQ ( i , j + 1 , k , 1 : 6 ) DQ6 = delQ ( i , j , k + 1 , 1 : 6 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SAFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SAFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SAFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SAFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SAFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * cells ( i , j , k )% volume ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * cells ( i , j , k )% volume ! --  end of source term -- ! delQ ( i , j , k , 1 : 6 ) = delQstar ( i , j , k , 1 : 6 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 6 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 6 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 6 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) ! add new change into conservative solution conservativeQ ( 1 : 6 ) = conservativeQ ( 1 : 6 ) + delQ ( i , j , k , 1 : 6 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) end do end do end do end subroutine update_SA_variables function SAFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (SA) !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: SAFlux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtvdx real ( wp ) :: dtvdy real ( wp ) :: dtvdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: muCap area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) ! viscous terms muCap = 0.25 * ( P ( 1 ) + W ( 1 )) * ( P ( 6 ) + W ( 6 )) mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtvdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtvdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtvdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz tmu = 0.5 * ( W ( 6 ) + P ( 6 )) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + muCap ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ) / sigma_sa Flux = Flux * Area SAFlux = Flux end function SAFlux subroutine update_lctm2015 ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (LCTM2015 transition model with SST2003) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 8 ) :: deltaU real ( wp ), dimension ( 1 : 8 ) :: D real ( wp ), dimension ( 1 : 8 ) :: conservativeQ real ( wp ), dimension ( 1 : 8 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 8 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 8 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 8 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 8 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 8 ) :: Q2 real ( wp ), dimension ( 1 : 8 ) :: Q3 real ( wp ), dimension ( 1 : 8 ) :: Q4 real ( wp ), dimension ( 1 : 8 ) :: Q5 real ( wp ), dimension ( 1 : 8 ) :: Q6 real ( wp ), dimension ( 1 : 8 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 8 ) :: DQ1 real ( wp ), dimension ( 1 : 8 ) :: DQ2 real ( wp ), dimension ( 1 : 8 ) :: DQ3 real ( wp ), dimension ( 1 : 8 ) :: DQ4 real ( wp ), dimension ( 1 : 8 ) :: DQ5 real ( wp ), dimension ( 1 : 8 ) :: DQ6 real ( wp ), dimension ( 1 : 8 ) :: Flist1 real ( wp ), dimension ( 1 : 8 ) :: Flist2 real ( wp ), dimension ( 1 : 8 ) :: Flist3 real ( wp ), dimension ( 1 : 8 ) :: Flist4 real ( wp ), dimension ( 1 : 8 ) :: Flist5 real ( wp ), dimension ( 1 : 8 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: beta ! intermittency real ( wp ) :: Fonset1 real ( wp ) :: Fonset2 real ( wp ) :: Fonset3 real ( wp ) :: Fonset real ( wp ) :: Rev real ( wp ) :: RT real ( wp ) :: Fturb real ( wp ) :: Re_theta real ( wp ) :: TuL real ( wp ) :: strain real ( wp ) :: vort real ( wp ) :: Dp , De real ( wp ) :: density Dp = 0.0 De = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 8 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 8 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 8 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*cells(i,j,k)%volume) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) TuL = min ( 10 0.0 * sqrt ( 2.0 * qp ( i , j , k , 6 ) / 3.0 ) / ( qp ( i , j , k , 7 ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL ) Rev = density * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density * qp ( i , j , k , 6 ) / ( mu ( i , j , k ) * qp ( i , j , k , 7 )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * cells ( i , j , k )% volume ) !storing D in Iflux array for backward sweep deltaU ( 1 : 8 ) = - residue ( i , j , k , 1 : 8 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 8 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 8 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 8 )) ) delQstar ( i , j , k , 1 : 8 ) = deltaU ( 1 : 8 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 8 ) DQ5 = delQ ( i , j + 1 , k , 1 : 8 ) DQ6 = delQ ( i , j , k + 1 , 1 : 8 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*cells(i,j,k)%volume) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) TuL = min ( 10 0.0 * sqrt ( 2.0 * qp ( i , j , k , 6 ) / 3.0 ) / ( qp ( i , j , k , 7 ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL ) Rev = density * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density * qp ( i , j , k , 6 ) / ( mu ( i , j , k ) * qp ( i , j , k , 7 )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * cells ( i , j , k )% volume ) delQ ( i , j , k , 1 : 8 ) = delQstar ( i , j , k , 1 : 8 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 8 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 8 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 8 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) conservativeQ ( 8 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 8 ) ! add new change into conservative solution conservativeQ ( 1 : n_var ) = conservativeQ ( 1 : n_var ) + delQ ( i , j , k , 1 : n_var ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) !              qp(i,j,k,6) = conservativeQ(6) / conservativeQ(1) !              qp(i,j,k,7) = conservativeQ(7) / conservativeQ(1) if ( conservativeQ ( 6 ) > 0.0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0.0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if qp ( i , j , k , 8 ) = conservativeQ ( 8 ) / conservativeQ ( 1 ) qp ( i , j , k , 8 ) = max ( qp ( i , j , k , 8 ), 0.0 ) !qp(i,j,k,8) = min(qp(i,j,k,8), 1.0) end do end do end do end subroutine update_lctm2015 function lctm2015flux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent/transition flow (LCTM2015) !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 8 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: lctm2015flux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtkdx real ( wp ) :: dtkdy real ( wp ) :: dtkdz real ( wp ) :: dtwdx real ( wp ) :: dtwdy real ( wp ) :: dtwdz real ( wp ) :: dtgmdx real ( wp ) :: dtgmdy real ( wp ) :: dtgmdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: sigma_k real ( wp ) :: sigma_w real ( wp ) :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 8 ) = ql ( 1 ) * ql ( 8 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 8 ) = U ( 8 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) W ( 8 ) = max ( W ( 8 ), 0.0 ) !W(8) = min(W(8), 1.0) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) Flux ( 8 ) = ( W ( 8 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume dtgmdx = ( P ( 8 ) - W ( 8 ) ) * nx * Area / Volume dtgmdy = ( P ( 8 ) - W ( 8 ) ) * ny * Area / Volume dtgmdz = ( P ( 8 ) - W ( 8 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux ( 8 ) = Flux ( 8 ) + ( mmu + tmu ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ) Flux = Flux * Area lctm2015flux = Flux end function lctm2015flux end module lusgs","tags":"","loc":"sourcefile/lusgs.f90.html","title":"lusgs.f90 – FEST-3D"},{"text":"This module contains subroutine that \n 1. check if time for resnorm dump is arrived\n 2. calculate resnorm\n 3. send those resnorm to processor number 0\n 4. Recalulate resnorm based on information \n    availble from all processors\n 5. Append the data to resnorm file This file depends on sourcefile~~resnorm.f90~~EfferentGraph sourcefile~resnorm.f90 resnorm.f90 sourcefile~utils.f90 utils.f90 sourcefile~resnorm.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~resnorm.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~resnorm.f90~~AfferentGraph sourcefile~resnorm.f90 resnorm.f90 sourcefile~convergence.f90 convergence.f90 sourcefile~convergence.f90->sourcefile~resnorm.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~convergence.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules resnorm Source Code resnorm.f90 Source Code !< This module contains subroutine that !< 1. check if time for resnorm dump is arrived !< 2. calculate resnorm !< 3. send those resnorm to processor number 0 !< 4. Recalulate resnorm based on information !<    availble from all processors !< 5. Append the data to resnorm file module resnorm !< This module contains subroutine that !< 1. check if time for resnorm dump is arrived !< 2. calculate resnorm !< 3. send those resnorm to processor number 0 !< 4. Recalulate resnorm based on information !<    availble from all processors !< 5. Append the data to resnorm file !---------------------------------------------------- use vartypes use mpi use utils , only : alloc #include \"error.h\" private real ( wp ) :: merror !< mass error real ( wp ), dimension (:), allocatable :: buffer !< Buffer for mpi communication integer , parameter :: Res_itr = 3 !< Iteration after which Res_save is stores real ( wp ), dimension (:), allocatable :: Res_abs !< Absolute value of residual norm real ( wp ), dimension (:), allocatable :: Res_rel !< Relative value of residual norm real ( wp ), dimension (:), allocatable :: Res_save !< Saved iteration for relative values real ( wp ), dimension (:), allocatable :: Res_scale !< Scaling factor for normalization public :: setup_resnorm public :: Res_abs , Res_rel public :: find_resnorm contains subroutine setup_resnorm ( files , control , scheme , flow ) !< Allocate memory, setup scale and file to write implicit none type ( filetype ), intent ( in ) :: files !< Files' name and handler type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-{u,v,rho,p}, etc. call allocate_memory ( control ) call setup_scale ( scheme , flow ) call setup_file ( files , control ) end subroutine setup_resnorm subroutine find_resnorm ( file_handler , residue , F , G , H , control , scheme , dims ) !< Find the normalized residual for each processor implicit none integer , intent ( in ) :: file_handler !< residual file handler type ( controltype ), intent ( inout ) :: control !< Control parameters type ( schemetype ) , intent ( in ) :: scheme !< finite-volume Schemes type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), intent ( in ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: H !< Store fluxes throught the K faces call get_absolute_resnorm ( residue , F , G , H , control , dims ) call collect_resnorm_from_all_blocks ( control ) call assemble_resnom_at_each_process ( control ) call get_relative_resnorm ( control ) if (( mod ( control % current_iter , control % res_write_interval ) == 0 . or . & control % current_iter == Res_itr . or . & control % current_iter == 1 ) . and . & process_id == 0 ) then call write_resnorm ( file_handler , control , scheme ) end if end subroutine find_resnorm subroutine setup_file ( files , control ) !< Open the residual file to write implicit none type ( filetype ), intent ( in ) :: files !< Files' name and handler type ( controltype ), intent ( in ) :: control !< Control parameters integer :: i if ( process_id == 0 ) then if ( control % start_from == 0 ) then open ( files % RESNORM_FILE_UNIT , file = files % resnorm_file ) else open ( files % RESNORM_FILE_UNIT , file = files % resnorm_file , status = 'old' , position = 'append' , action = 'write' ) end if write ( files % RESNORM_FILE_UNIT , '(A,2x)' , advance = 'no' ) \"Iteration\" do i = 1 , control % Res_count write ( files % RESNORM_FILE_UNIT , '(A,2x)' , advance = 'no' ) trim ( control % Res_list ( i )) end do write ( files % RESNORM_FILE_UNIT , * ) end if end subroutine setup_file subroutine allocate_memory ( control ) !< Allocate memory to MPI Communication implicit none type ( controltype ), intent ( in ) :: control call alloc ( Res_abs , 0 , control % n_var ) call alloc ( Res_rel , 0 , control % n_var ) call alloc ( Res_scale , 0 , control % n_var ) call alloc ( Res_save , 0 , control % n_var ) call alloc ( buffer , 1 ,( control % n_var + 1 ) * control % total_process ) end subroutine allocate_memory subroutine setup_scale ( scheme , flow ) !< Setup scale required for relative and absolute !< residual for writing in the file. implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. Res_scale ( 0 ) = 1. Res_scale ( 1 ) = flow % density_inf * flow % vel_mag Res_scale ( 2 ) = flow % density_inf * flow % vel_mag * flow % vel_mag Res_scale ( 3 ) = flow % density_inf * flow % vel_mag * flow % vel_mag Res_scale ( 4 ) = flow % density_inf * flow % vel_mag * flow % vel_mag Res_scale ( 5 ) = ( 0.5 * flow % density_inf * flow % vel_mag ** 3 + & (( flow % gm / ( flow % gm - 1. )) * flow % pressure_inf )) select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tk_inf Res_scale ( 7 ) = flow % density_inf * flow % vel_mag * flow % tw_inf case ( 'kkl' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tk_inf Res_scale ( 7 ) = flow % density_inf * flow % vel_mag * flow % tkl_inf case ( 'des' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tk_inf Res_scale ( 7 ) = flow % density_inf * flow % vel_mag * flow % tw_inf case ( 'sa' , 'saBC' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tv_inf case ( 'kw' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tk_inf Res_scale ( 7 ) = flow % density_inf * flow % vel_mag * flow % tw_inf case ( 'ke' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tk_inf Res_scale ( 7 ) = flow % density_inf * flow % vel_mag * flow % te_inf case DEFAULT Fatal_error end select end subroutine setup_scale subroutine get_absolute_resnorm ( residue , F , G , H , control , dims ) !< Get absolute residual for current process implicit none type ( controltype ), intent ( in ) :: control !< Control parameters: number of variables type ( extent ), intent ( in ) :: dims !< extent of the 3D domain real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), intent ( in ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: H !< Store fluxes throught the K faces integer :: i do i = 1 , control % n_var Res_abs ( i ) = ( sum ( Residue (:,:,:, i ) ** 2 ) / Res_scale ( i ) ** 2 ) end do merror = ( & sum ( F ( 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 )) & - sum ( F ( dims % imx , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 )) & + sum ( G ( 1 : dims % imx - 1 , 1 , 1 : dims % kmx - 1 , 1 )) & - sum ( G ( 1 : dims % imx - 1 , dims % jmx , 1 : dims % kmx - 1 , 1 )) & + sum ( H ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 , 1 )) & - sum ( H ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , dims % kmx , 1 )) & ) Res_abs ( 0 ) = ( merror / Res_scale ( 0 )) end subroutine get_absolute_resnorm subroutine collect_resnorm_from_all_blocks ( control ) !< MPI Communication to gather residual from all processes implicit none type ( controltype ), intent ( in ) :: control !< Control parameters: number of variables integer :: ierr call MPI_ALLGATHER ( Res_abs , control % n_var + 1 , MPI_DOUBLE_PRECISION , & buffer , control % n_var + 1 , MPI_DOUBLE_PRECISION , MPI_COMM_WORLD , ierr ) end subroutine collect_resnorm_from_all_blocks subroutine assemble_resnom_at_each_process ( control ) !< Sum residual obtained from all the processes after MPI_Communication implicit none type ( controltype ), intent ( in ) :: control !< Control parameters: number of variables and total mpi processes integer :: i , j Res_abs = 0. do i = 0 , control % total_process - 1 do j = 0 , control % n_var Res_abs ( j ) = Res_abs ( j ) + buffer (( j + 1 ) + ( control % n_var + 1 ) * i ) end do end do Res_abs ( 1 :) = sqrt ( Res_abs ( 1 :)) Res_abs ( 0 ) = abs ( Res_abs ( 0 )) end subroutine assemble_resnom_at_each_process subroutine get_relative_resnorm ( control ) !< Get relative residual with respect to first iteration residual implicit none type ( controltype ), intent ( inout ) :: control !< Control parameters: iterations if ( control % current_iter <= Res_itr ) Res_save = Res_abs if ( control % start_from /= 0 ) then Res_save = control % previous_Res else control % previous_Res = Res_save end if Res_rel = Res_abs / Res_save end subroutine get_relative_resnorm subroutine write_resnorm ( RESNORM_FILE_UNIT , control , scheme ) !< Writing the residual in the file to save. implicit none integer , intent ( in ) :: RESNORM_FILE_UNIT !<Resnorm file handler unit type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ) , intent ( in ) :: scheme !< turbulenca and transition schemes integer :: i integer :: n = 6 character ( len = 20 ) :: frm n = control % write_percision write ( frm , '(A,I0,A,I0,A)' ) \"(e\" , n + 8 , \".\" , n , \"E2, 4x)\" write ( RESNORM_FILE_UNIT , '(I0,4x)' , advance = 'no' ) control % current_iter + control % last_iter do i = 1 , control % Res_count select case ( trim ( control % Res_list ( i ))) !include \"resnorm_write_cases.inc\" case ( 'Mass_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 0 ) case ( 'Resnorm_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 :) ** 2 )) case ( 'Viscous_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 : 5 ) ** 2 )) case ( 'Turbulent_abs' ) if ( trim ( scheme % turbulence ) /= 'none' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 6 :) ** 2 )) end if case ( 'Continuity_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 1 ) case ( 'X_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 2 ) case ( 'Y_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 3 ) case ( 'Z_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 4 ) case ( 'Energy_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 5 ) case ( 'Mass_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 0 ) case ( 'Resnorm_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 1 :) ** 2 )) case ( 'Viscous_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 1 : 5 ) ** 2 )) case ( 'Turbulent_rel' ) if ( trim ( scheme % turbulence ) /= 'none' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 6 :) ** 2 )) end if case ( 'Continuity_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 1 ) case ( 'X-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 2 ) case ( 'Y-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 3 ) case ( 'Z-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 4 ) case ( 'Energy_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 5 ) case ( 'TKE_abs' ) if ( trim ( scheme % turbulence ) == 'sst' . or . trim ( scheme % turbulence ) == 'kkl' . or . trim ( scheme % turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 6 ) end if case ( 'Tv_abs' ) if ( trim ( scheme % turbulence ) == 'sa' . or . trim ( scheme % turbulence ) == 'saBC' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 6 ) end if case ( 'Dissipation_abs' ) if ( trim ( scheme % turbulence ) == 'ke' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'Omega_abs' ) if ( trim ( scheme % turbulence ) == 'sst' . or . trim ( scheme % turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'Kl_abs' ) if ( trim ( scheme % turbulence ) == 'kkl' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'TKE_rel' ) if ( trim ( scheme % turbulence ) == 'sst' . or . trim ( scheme % turbulence ) == 'kkl' . or . trim ( scheme % turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 6 ) end if case ( 'Tv_rel' ) if ( trim ( scheme % turbulence ) == 'sa' . or . trim ( scheme % turbulence ) == 'saBC' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 6 ) end if case ( 'Dissipation_rel' ) if ( trim ( scheme % turbulence ) == 'ke' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case ( 'Omega_rel' ) if ( trim ( scheme % turbulence ) == 'sst' . or . trim ( scheme % turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case ( 'Kl_rel' ) if ( trim ( scheme % turbulence ) == 'kkl' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case DEFAULT ! making absolute resnorm default write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 :) ** 2 )) Issue_warning end select end do write ( RESNORM_FILE_UNIT , * ) end subroutine write_resnorm end module resnorm","tags":"","loc":"sourcefile/resnorm.f90.html","title":"resnorm.f90 – FEST-3D"},{"text":"This file depends on sourcefile~~solver.f90~~EfferentGraph sourcefile~solver.f90 solver.f90 sourcefile~read.f90 read.f90 sourcefile~solver.f90->sourcefile~read.f90 sourcefile~bc.f90 bc.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~solver.f90->sourcefile~geometry.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~time.f90 time.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~solver.f90->sourcefile~wall_dist.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~wall.f90 wall.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~cc.f90 CC.f90 sourcefile~solver.f90->sourcefile~cc.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~solver.f90->sourcefile~vartypes.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~grid.f90 grid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~layout.f90 layout.f90 sourcefile~solver.f90->sourcefile~layout.f90 sourcefile~state.f90 state.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~read.f90->sourcefile~vartypes.f90 sourcefile~bc.f90->sourcefile~vartypes.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~utils.f90 utils.f90 sourcefile~bc.f90->sourcefile~utils.f90 sourcefile~geometry.f90->sourcefile~vartypes.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~scheme.f90->sourcefile~vartypes.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~slau.f90 slau.f90 sourcefile~scheme.f90->sourcefile~slau.f90 sourcefile~ausm.f90 ausm.f90 sourcefile~scheme.f90->sourcefile~ausm.f90 sourcefile~ausmup.f90 ausmUP.f90 sourcefile~scheme.f90->sourcefile~ausmup.f90 sourcefile~van_leer.f90 van_leer.f90 sourcefile~scheme.f90->sourcefile~van_leer.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~scheme.f90->sourcefile~utils.f90 sourcefile~ldfss0.f90 ldfss0.f90 sourcefile~scheme.f90->sourcefile~ldfss0.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~time.f90->sourcefile~vartypes.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~update.f90->sourcefile~gradients.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~wall_dist.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~update.f90->sourcefile~vartypes.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~update.f90->sourcefile~face_interpolant.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~global_kkl.f90 sourcefile~update.f90->sourcefile~global_sst.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~update.f90->sourcefile~utils.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90->sourcefile~global_sa.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~wall.f90->sourcefile~vartypes.f90 sourcefile~wall.f90->sourcefile~utils.f90 sourcefile~cc.f90->sourcefile~wall_dist.f90 sourcefile~cc.f90->sourcefile~vartypes.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~viscous.f90->sourcefile~gradients.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~viscous.f90->sourcefile~vartypes.f90 sourcefile~viscous.f90->sourcefile~global_kkl.f90 sourcefile~viscous.f90->sourcefile~global_sst.f90 sourcefile~viscous.f90->sourcefile~utils.f90 sourcefile~viscous.f90->sourcefile~global_sa.f90 sourcefile~dump_solution.f90->sourcefile~vartypes.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~grid.f90->sourcefile~vartypes.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~resnorm.f90->sourcefile~vartypes.f90 sourcefile~resnorm.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~vartypes.f90 sourcefile~state.f90->sourcefile~vartypes.f90 sourcefile~check_output_control.f90 check_output_control.f90 sourcefile~state.f90->sourcefile~check_output_control.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~state.f90->sourcefile~utils.f90 sourcefile~interface1.f90->sourcefile~vartypes.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~interface1.f90->sourcefile~utils.f90 var pansourcefilesolverf90EfferentGraph = svgPanZoom('#sourcefilesolverf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~solver.f90~~AfferentGraph sourcefile~solver.f90 solver.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules solver Source Code solver.f90 Source Code module solver !< Setup, run, and destroy the solver !< allocate/deallcoate memory, initialize, iterate !------------------------------------------------- use vartypes use mpi use CC , only : setupCC use read , only : read_input_and_controls use grid , only : setup_grid use geometry , only : setup_geometry use state , only : setup_state use gradients , only : setup_gradients use Scheme , only : setup_scheme use wall_dist , only : setup_wall_dist , find_wall_dist use viscous , only : compute_viscous_fluxes use layout , only : get_process_data , read_layout_file use interface1 , only : setup_interface use resnorm , only : find_resnorm , setup_resnorm !, destroy_resnorm use dump_solution , only : checkpoint use viscosity , only : setup_viscosity use viscosity , only : calculate_viscosity use wall , only : write_surfnode use bc , only : setup_bc use time , only : setup_time use time , only : destroy_time use update , only : get_next_solution use update , only : setup_update #include \"debug.h\" #include \"error.h\" private type ( extent ) :: dims !< Extent of the domain:imx,jmx,kmx type ( nodetype ), dimension (:,:,:), allocatable :: nodes !< Grid points type ( celltype ), dimension (:,:,:), allocatable :: cells !< Cell center quantities: volume, cellCenter type ( facetype ), dimension (:,:,:), allocatable :: Ifaces , Jfaces , Kfaces !< Face quantities: area and unit normal type ( controltype ), public :: control !< Control parameters type ( schemetype ), public :: schemes !< finite-volume Schemes type ( flowtype ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( filetype ) :: files !< Files' name and handler type ( boundarytype ) :: boundary !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), allocatable :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, : ), allocatable :: Temp !< Store Temperature variable at cell center real ( wp ), public , dimension (:, :, :, :), allocatable , target :: F !< Store fluxes throught the I faces real ( wp ), public , dimension (:, :, :, :), allocatable , target :: G !< Store fluxes throught the J faces real ( wp ), public , dimension (:, :, :, :), allocatable , target :: H !< Store fluxes throught the K faces real ( wp ), public , dimension (:, :, :, :), allocatable , target :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :), allocatable :: delta_t !< Local time increment value at each cell center ! Public methods public :: setup_solver public :: destroy_solver public :: iterate_one_more_time_step public :: abort_run public :: finish_run public :: start_run contains subroutine abort_run () !< Aborting the solver implicit none call finish_run () stop end subroutine abort_run subroutine finish_run () !< Finishing the solution computation implicit none integer :: ierr call destroy_solver () call MPI_FINALIZE ( ierr ) end subroutine finish_run subroutine start_run () !< Starting the solver setup implicit none integer :: ierr call MPI_INIT ( ierr ) call setup_solver () end subroutine start_run subroutine setup_solver () !< Call to allocate memoery and initialize domain !-------------------------------------------------- implicit none integer :: ierr DebugCall ( 'setup_solver: Start' ) call get_process_data ( control ) ! parallel calls call read_layout_file ( files , control , boundary ) ! reads layout file calls call read_input_and_controls ( files , control , schemes , flow ) call setup_grid ( files , nodes , control , boundary , dims ) call setup_geometry ( cells , Ifaces , Jfaces , Kfaces , nodes , boundary , dims ) !call setup_viscosity(mu, mu_t, schemes, flow, dims) call setup_viscosity ( schemes , flow , dims ) call setup_state ( files , qp , control , schemes , flow , dims ) allocate ( Temp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 )) call setup_gradients ( control , schemes , flow , dims ) !call setup_source call setup_bc ( files , schemes , flow , boundary , dims ) call setup_time ( delta_t , control , dims ) call setup_update ( control , schemes , flow , dims ) call setup_interface ( control , dims ) call setup_scheme ( residue , F , G , H , control , dims ) if ( schemes % turbulence /= 'none' ) then call write_surfnode ( files , nodes , control , boundary , dims ) call setup_wall_dist ( files , dims ) call mpi_barrier ( MPI_COMM_WORLD , ierr ) call find_wall_dist ( nodes , dims ) end if call setupCC ( schemes , cells , Ifaces , Jfaces , Kfaces , dims ) call setup_resnorm ( files , control , schemes , flow ) call initmisc () control % checkpoint_iter_count = 0 call checkpoint ( files , qp , nodes , control , schemes , dims ) ! Create an initial dump file control % current_iter = 1 DebugCall ( 'setup_solver: checkpoint' ) DebugCall ( 'Setup solver complete' ) end subroutine setup_solver subroutine destroy_solver () !< Call to different modules to deallocate memory !-------------------------------------------------- implicit none DebugCall ( 'destroy_solver' ) call destroy_time ( control ) end subroutine destroy_solver subroutine initmisc () !< Initilize miscellaneous variables !---------------------------------- implicit none DebugCall ( 'initmisc' ) control % current_iter = 0 end subroutine initmisc subroutine iterate_one_more_time_step () !< Perform one time step iteration !  This subroutine performs one iteration by stepping through !  time once. !----------------------------------------------------------- implicit none integer :: ierr DebugCall ( 'iterate_one_more_time_step' ) if ( process_id == 0 ) then print * , control % current_iter end if call get_next_solution ( qp , Temp , residue , delta_t , cells , F , G , H , Ifaces , Jfaces , Kfaces , control , schemes , flow , boundary , dims ) call find_resnorm ( files % RESNORM_FILE_UNIT , residue , F , G , H , control , schemes , dims ) call checkpoint ( files , qp , nodes , control , schemes , dims ) control % current_iter = control % current_iter + 1 if ( process_id == 0 ) then open ( files % STOP_FILE_UNIT , file = files % stop_file ) read ( files % STOP_FILE_UNIT , * ) control % want_to_stop close ( files % STOP_FILE_UNIT ) end if call MPI_BCAST ( control % want_to_stop , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) if ( control % want_to_stop == 1 ) control % Halt = . TRUE . end subroutine iterate_one_more_time_step end module solver","tags":"","loc":"sourcefile/solver.f90.html","title":"solver.f90 – FEST-3D"},{"text":"Setup the indicies map at interface between two blocks This file depends on sourcefile~~mapping.f90~~EfferentGraph sourcefile~mapping.f90 mapping.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~mapping.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mapping.f90~~AfferentGraph sourcefile~mapping.f90 mapping.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~grid.f90 grid.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mapping Source Code mapping.f90 Source Code !< Setup the indicies map at interface between two blocks module mapping !< Setup the indicies map at interface between two blocks use vartypes implicit none private integer , dimension ( 6 ), private :: ilo !< Read Lowest index of I direction integer , dimension ( 6 ), private :: jlo !< Read Lowest index of J direction integer , dimension ( 6 ), private :: klo !< Read Lowest index of K direction integer , dimension ( 6 ), private :: ihi !< Read Highest index of I direction integer , dimension ( 6 ), private :: jhi !< Read Highest index of J direction integer , dimension ( 6 ), private :: khi !< Read Highest index of K direction integer , dimension ( 6 ), public :: Pilo !< Modified lowest index of I direction integer , dimension ( 6 ), public :: Pjlo !< Modified lowest index of J direction integer , dimension ( 6 ), public :: Pklo !< Modified lowest index of K direction integer , dimension ( 6 ), public :: Pihi !< Modified Highest index of I direction integer , dimension ( 6 ), public :: Pjhi !< Modified Highest index of J direction integer , dimension ( 6 ), public :: Pkhi !< Modified Highest index of K direction integer , dimension ( 6 ), public :: PiDir !< Switch for communication direction from !< (low-high) to (hight-low) for I direction integer , dimension ( 6 ), public :: PjDir !< Switch for communication direction from !< (low-high) to (hight-low) for J direction integer , dimension ( 6 ), public :: PkDir !< Switch for communication direction from !< (low-high) to (hight-low) for K direction integer , dimension ( 6 ), public :: Gilo !< Modified lowest index of I direction for Grid data exchange integer , dimension ( 6 ), public :: Gjlo !< Modified lowest index of J direction for Grid data exchange integer , dimension ( 6 ), public :: Gklo !< Modified lowest index of K direction for Grid data exchange integer , dimension ( 6 ), public :: Gihi !< Modified highest index of I direction for Grid data exchange integer , dimension ( 6 ), public :: Gjhi !< Modified highest index of J direction for Grid data exchange integer , dimension ( 6 ), public :: Gkhi !< Modified highest index of K direction for Grid data exchange integer , dimension ( 6 ), public :: mpi_class =- 1 !< Class flag for master or slave public :: read_interface_map contains subroutine read_interface_map ( files , control , bc , dims ) !< Read mapping file in the system/mesh/layout/mapping.txt implicit none type ( filetype ), intent ( in ) :: files !< Files' name and handler type ( controltype ), intent ( in ) :: control !< Control parameters type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( boundarytype ), intent ( inout ) :: bc !< boundary conditions and fixed values integer :: ios integer :: max_call integer :: i integer :: b1 , b2 , f1 , f2 integer :: s11 , s12 , s21 , s22 integer :: e11 , e12 , e21 , e22 integer :: switch integer :: class !--- initialize indicies --! max_call = control % total_process * 6 ilo ( 1 ) = 1 ; ihi ( 1 ) = 1 ilo ( 2 ) = dims % imx ; ihi ( 2 ) = dims % imx ilo ( 3 ) = 1 ; ihi ( 3 ) = dims % imx ilo ( 4 ) = 1 ; ihi ( 4 ) = dims % imx ilo ( 5 ) = 1 ; ihi ( 5 ) = dims % imx ilo ( 6 ) = 1 ; ihi ( 6 ) = dims % imx jlo ( 1 ) = 1 ; jhi ( 1 ) = dims % jmx jlo ( 2 ) = 1 ; jhi ( 2 ) = dims % jmx jlo ( 3 ) = 1 ; jhi ( 3 ) = 1 jlo ( 4 ) = dims % jmx ; jhi ( 4 ) = dims % jmx jlo ( 5 ) = 1 ; jhi ( 5 ) = dims % jmx jlo ( 6 ) = 1 ; jhi ( 6 ) = dims % jmx klo ( 1 ) = 1 ; khi ( 1 ) = dims % kmx klo ( 2 ) = 1 ; khi ( 2 ) = dims % kmx klo ( 3 ) = 1 ; khi ( 3 ) = dims % kmx klo ( 4 ) = 1 ; khi ( 4 ) = dims % kmx klo ( 5 ) = 1 ; khi ( 5 ) = 1 klo ( 6 ) = dims % kmx ; khi ( 6 ) = dims % kmx bc % otherface ( 1 ) = 2 bc % otherface ( 2 ) = 1 bc % otherface ( 3 ) = 4 bc % otherface ( 4 ) = 3 bc % otherface ( 5 ) = 6 bc % otherface ( 6 ) = 5 bc % dir_switch = 0 !--- end of variable intializaiton --! !--- reading map file  ---! open ( files % MAP_FILE_UNIT , file = files % mapfile , status = 'old' , action = 'read' ) read ( files % MAP_FILE_UNIT , * ) ! ignore header do i = 1 , max_call read ( files % MAP_FILE_UNIT , * , iostat = ios ) b1 , f1 , s11 , e11 , s12 , e12 ,& b2 , f2 , s21 , e21 , s22 , e22 , switch , class if ( is_iostat_end ( ios )) EXIT if ( b1 == control % process_id ) then if ( f1 == 1 ) then bc % otherface ( 1 ) = f2 jlo ( 1 ) = s21 jhi ( 1 ) = e21 klo ( 1 ) = s22 khi ( 1 ) = e22 bc % dir_switch ( 1 ) = switch mpi_class ( 1 ) = class elseif ( f1 == 2 ) then bc % otherface ( 2 ) = f2 jlo ( 2 ) = s21 jhi ( 2 ) = e21 klo ( 2 ) = s22 khi ( 2 ) = e22 bc % dir_switch ( 2 ) = switch mpi_class ( 2 ) = class elseif ( f1 == 3 ) then bc % otherface ( 3 ) = f2 ilo ( 3 ) = s21 ihi ( 3 ) = e21 klo ( 3 ) = s22 khi ( 3 ) = e22 bc % dir_switch ( 3 ) = switch mpi_class ( 3 ) = class elseif ( f1 == 4 ) then bc % otherface ( 4 ) = f2 ilo ( 4 ) = s21 ihi ( 4 ) = e21 klo ( 4 ) = s22 khi ( 4 ) = e22 bc % dir_switch ( 4 ) = switch mpi_class ( 4 ) = class elseif ( f1 == 5 ) then bc % otherface ( 5 ) = f2 ilo ( 5 ) = s21 ihi ( 5 ) = e21 jlo ( 5 ) = s22 jhi ( 5 ) = e22 bc % dir_switch ( 5 ) = switch mpi_class ( 5 ) = class elseif ( f1 == 6 ) then bc % otherface ( 6 ) = f2 ilo ( 6 ) = s21 ihi ( 6 ) = e21 jlo ( 6 ) = s22 jhi ( 6 ) = e22 bc % dir_switch ( 6 ) = switch mpi_class ( 6 ) = class end if else continue end if end do close ( files % MAP_FILE_UNIT ) call change_map_to_particular_range () call read_periodic_bc_file ( files , control , bc ) end subroutine read_interface_map subroutine change_map_to_particular_range () !< Modified the indicies for MPI communication !------------------------------------- !eg: 1-kmx to 0 to kmx for data transfer !-------------------------------------- implicit none integer :: i Pilo = ilo Pjlo = jlo Pklo = klo Pihi = ihi Pjhi = jhi Pkhi = khi PiDir = 1 PjDir = 1 PkDir = 1 do i = 1 , 6 if ( ilo ( i ) == 1 . and . i > 2 ) then Pilo ( i ) = 1 Gilo ( i ) =- 2 end if if ( jlo ( i ) == 1 . and . ( i > 4 . or . i < 3 ) ) then Pjlo ( i ) = 1 Gjlo ( i ) =- 2 end if if ( klo ( i ) == 1 . and . i < 5 ) then Pklo ( i ) = 1 Gklo ( i ) =- 2 end if if ( ihi ( i ) == 1 . and . i > 2 ) then Pihi ( i ) = 1 Gihi ( i ) =- 2 PiDir ( i ) =- 1 end if if ( jhi ( i ) == 1 . and . ( i > 4 . or . i < 3 )) then Pjhi ( i ) = 1 Gjhi ( i ) =- 2 PjDir ( i ) =- 1 end if if ( khi ( i ) == 1 . and . i < 5 ) then Pkhi ( i ) = 1 Gkhi ( i ) =- 2 PkDir ( i ) =- 1 end if if ( ilo ( i ) > 1 . and . i > 2 ) then Gilo ( i ) = ilo ( i ) + 3 Pilo ( i ) = ilo ( i ) - 1 PiDir ( i ) =- 1 end if if ( jlo ( i ) > 1 . and . ( i > 4 . or . i < 5 )) then Gjlo ( i ) = jlo ( i ) + 3 Pjlo ( i ) = jlo ( i ) - 1 PjDir ( i ) =- 1 end if if ( klo ( i ) > 1 . and . i < 5 ) then Gklo ( i ) = klo ( i ) + 3 Pklo ( i ) = klo ( i ) - 1 PkDir ( i ) =- 1 end if if ( ihi ( i ) > 1 . and . i > 2 ) then Gihi ( i ) = ihi ( i ) + 3 Pihi ( i ) = ihi ( i ) - 1 end if if ( jhi ( i ) > 1 . and . ( i > 4 . or . i < 5 )) then Gjhi ( i ) = jhi ( i ) + 3 Pjhi ( i ) = jhi ( i ) - 1 end if if ( khi ( i ) > 1 . and . i < 5 ) then Gkhi ( i ) = khi ( i ) + 3 Pkhi ( i ) = khi ( i ) - 1 end if end do end subroutine change_map_to_particular_range subroutine read_periodic_bc_file ( files , control , bc ) !< Read periodic.md file in the system/mesh/layout/periodic.md implicit none type ( filetype ), intent ( in ) :: files !< Files' name and handler type ( controltype ), intent ( in ) :: control !< Control parameters type ( boundarytype ), intent ( inout ) :: bc !< boundary conditions and fixed values integer :: ios integer :: max_call integer :: i integer :: b1 , b2 integer :: f1 , f2 integer :: class open ( files % PERIODIC_FILE_UNIT , file = files % periodicfile , status = 'old' , action = 'read' ) read ( files % PERIODIC_FILE_UNIT , * ) !ignore first line (header) max_call = control % total_process * 6 do i = 1 , max_call read ( files % PERIODIC_FILE_UNIT , * , iostat = ios ) b1 , b2 , f1 , f2 , class if ( is_iostat_end ( ios )) EXIT if ( b1 == control % process_id ) then bc % PbcId ( f1 ) = b2 end if end do close ( files % PERIODIC_FILE_UNIT ) end subroutine read_periodic_bc_file end module mapping","tags":"","loc":"sourcefile/mapping.f90.html","title":"mapping.f90 – FEST-3D"},{"text":"Contains routine to load layout file and sets the layout variables\n and gets process id and total process This file depends on sourcefile~~layout.f90~~EfferentGraph sourcefile~layout.f90 layout.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~layout.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~layout.f90~~AfferentGraph sourcefile~layout.f90 layout.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~layout.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules layout Source Code layout.f90 Source Code !< Contains routine to load layout file and sets the layout variables !< and gets process id and total process module layout !< Contains routine to load layout file and sets the layout variables !< and gets process id and total process !------------------------------ use vartypes use mpi #include \"debug.h\" public :: read_layout_file public :: get_process_data contains subroutine get_process_data ( control ) !<Get Processor Id and total number of processors implicit none type ( controltype ), intent ( inout ) :: control !< Control parameters ! Finds and sets process data integer :: ierr call MPI_COMM_RANK ( MPI_COMM_WORLD , control % process_id , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , control % total_process , ierr ) process_id = control % process_id end subroutine get_process_data subroutine get_next_token_parallel ( handler , buf ) !< Extract the next token from the layout file !< !< Each token is on a separate line. !< There may be multiple comments (lines beginning with #) !< and blank lines in between. !< The purpose of this subroutine is to ignore all these !< lines and return the next \"useful\" line. !----------------------------------------------------------- implicit none integer , intent ( in ) :: handler character ( len = STRING_BUFFER_LENGTH ), intent ( out ) :: buf integer :: ios do !read(CONFIG_FILE_UNIT, '(A)', iostat=ios) buf read ( handler , '(A)' , iostat = ios ) buf if ( ios /= 0 ) then print * , 'Error while reading config file.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH stop end if if ( index ( buf , '#' ) == 1 ) then ! The current line begins with a hash ! Ignore it continue else if ( len_trim ( buf ) == 0 ) then ! The current line is empty ! Ignore it continue else ! A new token has been found ! Break out exit end if end do end subroutine get_next_token_parallel subroutine read_layout_file ( files , control , bc ) !< Read the layout file for particular processor implicit none type ( filetype ), intent ( inout ) :: files !< Files' name and handler type ( boundarytype ), intent ( inout ) :: bc !< boundary conditions and fixed values character ( len = STRING_BUFFER_LENGTH ) :: buf !< read buffer character ( len = 128 ) :: grid_file_buf !< Name of the gridfile to load character ( len = 128 ) :: bc_file !< Name of the boundary condition file to load. type ( controltype ) , intent ( in ) :: control !< Processor id for current block integer :: total_entries !< Total enteries in layout.md for each processorS integer :: i , buf_id DebugCall ( 'read_layout_file' ) open ( files % CONFIG_FILE_UNIT , file = files % layout_file ) ! Read the parameters from the file call get_next_token_parallel ( files % CONFIG_FILE_UNIT , buf ) read ( buf , * ) !control%total_process call get_next_token_parallel ( files % CONFIG_FILE_UNIT , buf ) read ( buf , * ) total_entries i = 0 !print *, process_id call get_next_token_parallel ( files % CONFIG_FILE_UNIT , buf ) do while ( i < control % process_id ) call get_next_token_parallel ( files % CONFIG_FILE_UNIT , buf ) i = i + 1 end do read ( buf , * ) buf_id , grid_file_buf , bc_file , bc % imin_id , bc % imax_id , bc % jmin_id , bc % jmax_id , bc % kmin_id , bc % kmax_id write ( files % gridfile , '(A)' ) 'system/mesh/gridfiles/' // trim ( grid_file_buf ) write ( files % bcfile , '(A)' ) 'system/mesh/bc/' // trim ( bc_file ) end subroutine read_layout_file end module layout","tags":"","loc":"sourcefile/layout.f90.html","title":"layout.f90 – FEST-3D"},{"text":"Setup, destroy, calculate molecular and turbulence viscosity This file depends on sourcefile~~viscosity.f90~~EfferentGraph sourcefile~viscosity.f90 viscosity.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~utils.f90 utils.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~viscosity.f90~~AfferentGraph sourcefile~viscosity.f90 viscosity.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 var pansourcefileviscosityf90AfferentGraph = svgPanZoom('#sourcefileviscosityf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules viscosity Source Code viscosity.f90 Source Code !< Setup, destroy, calculate molecular and turbulence viscosity module viscosity !< Setup, destroy, calculate molecular and turbulence viscosity !----------------------------------------------------- use vartypes use wall_dist , only : dist use global_kkl , only : cmu use global_sst , only : bstar use global_sst , only : a1 use global_sst , only : sst_F1 use global_sst , only : sigma_w2 use global_sa , only : cv1 ! gradients use gradients , only : gradu_x use gradients , only : gradu_y use gradients , only : gradu_z use gradients , only : gradv_x use gradients , only : gradv_y use gradients , only : gradv_z use gradients , only : gradw_x use gradients , only : gradw_y use gradients , only : gradw_z use gradients , only : gradT_x use gradients , only : gradT_y use gradients , only : gradT_z use gradients , only : gradtk_x use gradients , only : gradtk_y use gradients , only : gradtk_z use gradients , only : gradtw_x use gradients , only : gradtw_y use gradients , only : gradtw_z use copy_bc , only : copy1 use utils , only : alloc #include \"error.h\" implicit none private real ( wp ), dimension (:, :, :), allocatable , target :: mu !< Cell-center molecular viscosity real ( wp ), dimension (:, :, :), allocatable , target :: mu_t !< Cell-center turbulent viscosity public :: setup_viscosity public :: calculate_viscosity public :: mu , mu_t contains subroutine calculate_viscosity ( qp , scheme , flow , bc , dims ) !< Calculate molecular and turbulent viscosity implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center integer :: i , j , k real ( wp ) :: T ! molecular viscosity real ( wp ) :: c ! kkl eddy viscosity !- sst varibales -! real ( wp ) :: F real ( wp ) :: arg2 real ( wp ) :: vort real ( wp ) :: NUM real ( wp ) :: DENOM ! for arg2 real ( wp ) :: var1 real ( wp ) :: var2 !for vorticity real ( wp ) :: wijwij real ( wp ) :: wx real ( wp ) :: wy real ( wp ) :: wz !for strain calculation real ( wp ) :: SijSij real ( wp ) :: Sxx , Syy , Szz real ( wp ) :: Sxy , Szx , Syz real ( wp ) :: strain !for arg1 real ( wp ) :: arg1 real ( wp ) :: CD real ( wp ) :: right real ( wp ) :: left ! sa variables real ( wp ) :: fv1 real ( wp ) :: xi real ( wp ) :: pressure real ( wp ) :: density real ( wp ) :: tk real ( wp ) :: tkl real ( wp ) :: tw real ( wp ) :: tv integer :: imx , jmx , kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx !--- calculate_molecular_viscosity ---! if ( flow % mu_ref /= 0. ) then select case ( trim ( flow % mu_variation )) case ( 'sutherland_law' ) ! apply_sutherland_law do k = 0 , kmx do j = 0 , jmx do i = 0 , imx pressure = qp ( i , j , k , 5 ) density = qp ( i , j , k , 1 ) T = pressure / ( density * flow % R_gas ) mu ( i , j , k ) = flow % mu_ref * (( T / flow % T_ref ) ** ( 1.5 )) & * (( flow % T_ref + flow % Sutherland_temp )& / ( T + flow % Sutherland_temp )) end do end do end do case ( 'constant' ) !do nothing !mu will be equal to mu_ref continue case DEFAULT print * , \"mu_variation not recognized:\" print * , \"   found '\" , trim ( flow % mu_variation ), \"'\" print * , \"accepted values: 1) sutherland_law\" print * , \"                 2) constant\" Fatal_error end select end if !--- end molecular viscosity calculation---! !--- calculate_turbulent_viscosity  ---! if ( scheme % turbulence /= 'none' ) then select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) !call calculate_sa_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx tv = qp ( i , j , k , 6 ) density = qp ( i , j , k , 1 ) ! xsi xi = tv * density / mu ( i , j , k ) !calculation fo fv1 function fv1 = ( xi ** 3 ) / (( xi ** 3 ) + ( cv1 ** 3 )) mu_t ( i , j , k ) = density * tv * fv1 end do end do end do ! populating ghost cell do i = 1 , 6 select case ( bc % id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sa_mu, \"symm\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sa_mu, \"anti\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sa eddy viscosity  ---! case ( 'sst2003' ) !call calculate_sst_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tw = qp ( i , j , k , 7 ) ! calculate_arg2() var1 = sqrt ( tk ) / ( bstar * tw * dist ( i , j , k )) var2 = 500 * ( mu ( i , j , k ) / density ) / (( dist ( i , j , k ) ** 2 ) * tw ) arg2 = max ( 2 * var1 , var2 ) ! calculate_f2() F = tanh ( arg2 ** 2 ) ! calculate_vorticity( sxx = ( gradu_x ( i , j , k )) syy = ( gradv_y ( i , j , k )) szz = ( gradw_z ( i , j , k )) syz = ( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) szx = ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) sxy = ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) SijSij = ( 2.0 * ( sxx ** 2 )) + ( 2.0 * ( syy ** 2 )) + ( 2.0 * ( szz ** 2 )) + syz ** 2 + szx ** 2 + sxy ** 2 strain = sqrt ( SijSij ) NUM = density * a1 * tk DENOM = max ( max (( a1 * tw ), strain * F ), 1.0e-10 ) mu_t ( i , j , k ) = NUM / DENOM !-- end eddy visocisyt calculation --! !-- calculating blending function F1 --! CD = max ( 2 * density * sigma_w2 * ( & gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw , & 1.0e-10 ) right = 4 * ( density * sigma_w2 * tk ) / ( CD * ( dist ( i , j , k ) ** 2 )) left = max ( var1 , var2 ) arg1 = min ( left , right ) sst_F1 ( i , j , k ) = tanh ( arg1 ** 4 ) !-- end of blending function F1 calculation --! end do end do end do select case ( trim ( scheme % transition )) case ( 'lctm2015' ) do k = 0 , kmx do j = 0 , jmx do i = 0 , imx !modified blending function (Menter 2015) var1 = density * dist ( i , j , k ) * sqrt ( tk ) / mu ( i , j , k ) var2 = exp ( - ( var1 / 120 ) ** 8 ) sst_F1 ( i , j , k ) = max ( sst_F1 ( i , j , k ), var2 ) end do end do end do case DEFAULT !do nothing continue end select ! populating ghost cell do i = 1 , 6 select case ( bc % id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sst_mu, \"symm\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sst_mu, \"anti\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sst2003 eddy viscosity  and blending fucntion calculation ---! case ( 'sst' ) !call calculate_sst_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tw = qp ( i , j , k , 7 ) ! calculate_arg2() var1 = sqrt ( tk ) / ( bstar * tw * dist ( i , j , k )) var2 = 500 * ( mu ( i , j , k ) / density ) / (( dist ( i , j , k ) ** 2 ) * tw ) arg2 = max ( 2 * var1 , var2 ) ! calculate_f2() F = tanh ( arg2 ** 2 ) ! calculate_vorticity( wx = ( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) wy = ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) wz = ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) wijwij = wx ** 2 + wy ** 2 + wz ** 2 vort = sqrt ( wijwij ) NUM = density * a1 * tk DENOM = max ( max (( a1 * tw ), vort * F ), 1.e-20 ) mu_t ( i , j , k ) = NUM / DENOM !-- end eddy visocisyt calculation --! !-- calculating blending function F1 --! CD = max ( 2 * density * sigma_w2 * ( & gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw , & 1 e - 20 ) right = 4 * ( density * sigma_w2 * tk ) / ( CD * ( dist ( i , j , k ) ** 2 )) left = max ( var1 , var2 ) arg1 = min ( left , right ) sst_F1 ( i , j , k ) = tanh ( arg1 ** 4 ) !-- end of blending function F1 calculation --! end do end do end do select case ( trim ( scheme % transition )) case ( 'lctm2015' ) do k = 0 , kmx do j = 0 , jmx do i = 0 , imx !modified blending function (Menter 2015) var1 = density * dist ( i , j , k ) * sqrt ( tk ) / mu ( i , j , k ) var2 = exp ( - ( var1 / 120 ) ** 8 ) sst_F1 ( i , j , k ) = max ( sst_F1 ( i , j , k ), var2 ) end do end do end do case DEFAULT !do nothing continue end select ! populating ghost cell do i = 1 , 6 select case ( bc % id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sst_mu, \"symm\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sst_mu, \"anti\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sst eddy viscosity  and blending fucntion calculation ---! case ( 'kkl' ) !--- calculate_kkl_mu() c = cmu ** 0.25 do k = 0 , kmx do j = 0 , jmx do i = 0 , imx density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tkl = qp ( i , j , k , 7 ) mu_t ( i , j , k ) = c * density * tkl / ( max ( sqrt ( tk ), 1.e-20 )) if ( tkl < 1.e-14 . or . tk < 1.e-14 ) & mu_t ( i , j , k ) = 0.0 end do end do end do ! populating ghost cell do i = 1 , 6 select case ( bc % id ( i )) case ( - 10 , 0 :) !interface continue case ( - 4 : - 1 , - 6 , - 8 , - 9 ) !call copy1(kkl_mu, \"symm\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(kkl_mu, \"anti\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of kkl eddy viscosity calculation ---! case DEFAULT Fatal_error end select end if !--- end turbulent viscosity calculation---! !--- check on viscosity ---! if ( any ( isnan ( mu ))) then Fatal_error end if end subroutine calculate_viscosity subroutine setup_viscosity ( scheme , flow , dims ) !< Allocate and pointer for molecular and turbulent viscosity implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. integer :: imx , jmx , kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx !setup_molecular_viscosity() if ( flow % mu_ref /= 0. ) then call alloc ( mu , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) mu = flow % mu_ref !intialize end if !--- setup_turbulent_viscosity ---! if ( scheme % turbulence /= 'none' ) then call alloc ( mu_t , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) select case ( trim ( scheme % turbulence )) case ( 'none' , 'sa' , 'saBC' , 'kkl' ) !do nothing continue case ( 'sst' , 'sst2003' ) !-- sst blending funciton F1 --! call alloc ( sst_F1 , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) sst_F1 = 0. !-- sst blnding function setup compete--! case DEFAULT Fatal_error end select end if ! --- end turbulent viscosity setup ---! end subroutine setup_viscosity end module viscosity","tags":"","loc":"sourcefile/viscosity.f90.html","title":"viscosity.f90 – FEST-3D"},{"text":"Time integration module This file depends on sourcefile~~update.f90~~EfferentGraph sourcefile~update.f90 update.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~update.f90->sourcefile~global_kkl.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~update.f90->sourcefile~face_interpolant.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~update.f90->sourcefile~wall_dist.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~update.f90->sourcefile~global_sa.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~update.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~time.f90 time.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~utils.f90 utils.f90 sourcefile~update.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~update.f90->sourcefile~vartypes.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~update.f90->sourcefile~global_sst.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~face_interpolant.f90->sourcefile~utils.f90 sourcefile~face_interpolant.f90->sourcefile~vartypes.f90 sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~face_interpolant.f90->sourcefile~weno_nm.f90 sourcefile~muscl.f90 muscl.f90 sourcefile~face_interpolant.f90->sourcefile~muscl.f90 sourcefile~ppm.f90 ppm.f90 sourcefile~face_interpolant.f90->sourcefile~ppm.f90 sourcefile~weno.f90 weno.f90 sourcefile~face_interpolant.f90->sourcefile~weno.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~scheme.f90->sourcefile~utils.f90 sourcefile~scheme.f90->sourcefile~vartypes.f90 sourcefile~van_leer.f90 van_leer.f90 sourcefile~scheme.f90->sourcefile~van_leer.f90 sourcefile~ausmup.f90 ausmUP.f90 sourcefile~scheme.f90->sourcefile~ausmup.f90 sourcefile~slau.f90 slau.f90 sourcefile~scheme.f90->sourcefile~slau.f90 sourcefile~ldfss0.f90 ldfss0.f90 sourcefile~scheme.f90->sourcefile~ldfss0.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~ausm.f90 ausm.f90 sourcefile~scheme.f90->sourcefile~ausm.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~time.f90->sourcefile~vartypes.f90 sourcefile~read.f90 read.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~face_interpolant.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~vartypes.f90 sourcefile~interface1.f90->sourcefile~utils.f90 sourcefile~interface1.f90->sourcefile~vartypes.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~plusgs.f90->sourcefile~global_kkl.f90 sourcefile~plusgs.f90->sourcefile~wall_dist.f90 sourcefile~plusgs.f90->sourcefile~global_sa.f90 sourcefile~plusgs.f90->sourcefile~gradients.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~plusgs.f90->sourcefile~utils.f90 sourcefile~plusgs.f90->sourcefile~vartypes.f90 sourcefile~plusgs.f90->sourcefile~global_sst.f90 sourcefile~viscous.f90->sourcefile~global_kkl.f90 sourcefile~viscous.f90->sourcefile~global_sa.f90 sourcefile~viscous.f90->sourcefile~gradients.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~viscous.f90->sourcefile~utils.f90 sourcefile~viscous.f90->sourcefile~vartypes.f90 sourcefile~viscous.f90->sourcefile~global_sst.f90 sourcefile~bc_primitive.f90->sourcefile~wall_dist.f90 sourcefile~bc_primitive.f90->sourcefile~vartypes.f90 sourcefile~bc_primitive.f90->sourcefile~global_sst.f90 sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~bc_primitive.f90->sourcefile~copy_bc.f90 sourcefile~source.f90->sourcefile~global_kkl.f90 sourcefile~source.f90->sourcefile~wall_dist.f90 sourcefile~source.f90->sourcefile~global_sa.f90 sourcefile~source.f90->sourcefile~gradients.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~source.f90->sourcefile~utils.f90 sourcefile~source.f90->sourcefile~vartypes.f90 sourcefile~source.f90->sourcefile~global_sst.f90 sourcefile~cc.f90 CC.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~lusgs.f90->sourcefile~global_kkl.f90 sourcefile~lusgs.f90->sourcefile~wall_dist.f90 sourcefile~lusgs.f90->sourcefile~global_sa.f90 sourcefile~lusgs.f90->sourcefile~gradients.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~lusgs.f90->sourcefile~utils.f90 sourcefile~lusgs.f90->sourcefile~vartypes.f90 sourcefile~lusgs.f90->sourcefile~global_sst.f90 sourcefile~ft_bc.f90->sourcefile~vartypes.f90 sourcefile~ft_bc.f90->sourcefile~copy_bc.f90 sourcefile~weno_nm.f90->sourcefile~vartypes.f90 sourcefile~van_leer.f90->sourcefile~vartypes.f90 sourcefile~muscl.f90->sourcefile~vartypes.f90 sourcefile~read.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 sourcefile~ausmup.f90->sourcefile~vartypes.f90 sourcefile~ppm.f90->sourcefile~vartypes.f90 sourcefile~cc.f90->sourcefile~wall_dist.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~cc.f90->sourcefile~vartypes.f90 sourcefile~weno.f90->sourcefile~vartypes.f90 sourcefile~slau.f90->sourcefile~vartypes.f90 sourcefile~mapping.f90->sourcefile~vartypes.f90 sourcefile~ldfss0.f90->sourcefile~vartypes.f90 sourcefile~ausmp.f90->sourcefile~face_interpolant.f90 sourcefile~ausmp.f90->sourcefile~vartypes.f90 sourcefile~ausm.f90->sourcefile~vartypes.f90 var pansourcefileupdatef90EfferentGraph = svgPanZoom('#sourcefileupdatef90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~update.f90~~AfferentGraph sourcefile~update.f90 update.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules update Source Code update.f90 Source Code !< Time integration module module update !< This module march the solution is time. use vartypes use global_kkl , only : cphi1 use global_kkl , only : cphi2 use global_kkl , only : fphi use global_kkl , only : eta use global_kkl , only : cd1 use global_kkl , only : cmu use global_sst , only : beta1 use global_sst , only : beta2 use global_sst , only : bstar use global_sst , only : sst_F1 use global_sa , only : cb1 use global_sa , only : cw1 use global_sa , only : cw2 use global_sa , only : cw3 use global_sa , only : cv1 use global_sa , only : kappa_sa use gradients , only : gradu_x use gradients , only : gradu_y use gradients , only : gradu_z use gradients , only : gradv_x use gradients , only : gradv_y use gradients , only : gradv_z use gradients , only : gradw_x use gradients , only : gradw_y use gradients , only : gradw_z use wall_dist , only : dist use viscosity , only : mu use viscosity , only : mu_t use utils , only : alloc !subroutine for residual calculation use interface1 , only : apply_interface use bc_primitive , only : populate_ghost_primitive use face_interpolant , only : compute_face_interpolant use boundary_state_reconstruction , only : reconstruct_boundary_state use scheme , only : compute_fluxes use gradients , only : evaluate_all_gradients use viscosity , only : calculate_viscosity use viscous , only : compute_viscous_fluxes use scheme , only : compute_residue use source , only : add_source_term_residue use time , only : compute_time_step !--- sst implicit update ---! use global_sst , only : sst_F1 use global_sst , only : sigma_k1 use global_sst , only : sigma_k2 use global_sst , only : sigma_w1 use global_sst , only : sigma_w2 use plusgs , only : update_with_plusgs use plusgs , only : setup_plusgs use lusgs , only : update_with_lusgs use lusgs , only : setup_lusgs #include \"debug.h\" #include \"error.h\" private real ( wp ), dimension (:,:,:,:), allocatable :: U_store !< Array to store the intermediate solution real ( wp ), dimension (:,:,:,:), allocatable :: R_store !< Array to store the intermediate Residue real ( wp ), dimension (:,:,:,:), allocatable , target :: aux !< Array to store some auxilary intermediate variables real ( wp ), dimension (:) , allocatable :: u1 !< Variable array old for each cell center real ( wp ), dimension (:) , allocatable :: u2 !< Variable array new for each cell center real ( wp ), dimension (:) , allocatable :: R !< Residue array for each cell center integer :: imx , jmx , kmx , n_var ! Public methods public :: setup_update public :: get_next_solution contains subroutine setup_update ( control , scheme , flow , dims ) !< Allocate memory to variables required based !< on the time-integration scheme. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var call alloc ( u1 , 1 , n_var ) call alloc ( u2 , 1 , n_var ) call alloc ( R , 1 , n_var ) call alloc ( aux , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) select case ( scheme % time_step_accuracy ) case ( \"none\" ) ! Do nothing continue case ( \"RK2\" , \"RK4\" ) call alloc ( U_store , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) call alloc ( R_store , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var ) case ( \"TVDRK2\" , \"TVDRK3\" ) call alloc ( U_store , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) case ( \"implicit\" ) call setup_lusgs ( control , scheme , flow , dims ) case ( \"plusgs\" ) call setup_plusgs ( control , scheme , flow , dims ) case default Fatal_error end select end subroutine setup_update subroutine get_next_solution ( qp , Temp , residue , delta_t , cells , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) !< Get solution at next time-step using scheme !< given in the input file. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( inout ) :: Temp !< Store Temperature variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ) :: CFL CFL = control % CFL !finding the updated Temperature using ideal gas law !T=P/(R_gas*Rho) Temp = qp (:,:,:, 5 ) / ( flow % R_gas * qp (:,:,:, 1 ) ) select case ( trim ( scheme % time_step_accuracy )) case ( \"none\" ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1. , 1. , . FALSE .) case ( \"RK4\" ) R_store = 0. U_store = qp call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 0.5 , 1. , . FALSE ., R_store , U_store ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 0.5 , 2. , . FALSE ., R_store , U_store ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 2. , . FALSE ., R_store , U_store ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1. / 6. , 1. , . TRUE . , R_store , U_store ) case ( \"RK2\" ) R_store = 0. U_store = qp call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 0.5 , 1. , . FALSE ., R_store , U_store ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 0.5 , 1. , . TRUE ., R_store , U_store ) case ( \"TVDRK3\" ) U_store = qp call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 1. ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 1. ) qp = 0.75 * U_store + 0.25 * qp call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 1. ) qp = ( 1. / 3. ) * U_store + ( 2. / 3. ) * qp case ( \"TVDRK2\" ) U_store = qp call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 1. ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 1. ) qp = 0.5 * U_store + 0.5 * qp case ( \"implicit\" ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with_lusgs ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , scheme , dims ) case ( \"plusgs\" ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with_plusgs ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , residue , scheme , dims ) case default Fatal_error end select end subroutine get_next_solution subroutine update_with ( qp , residue , delta_t , cells , scheme , flow , type , time_factor , store_factor , use , Rn , un ) !< A generalized scheme to updat the solution explicitly using !< any RK method and even first order euler explicit. implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( inout ), target :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( in ) :: cells !< Cell center quantities: volume real ( wp ), dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. character ( len =* ), intent ( in ) :: type real ( wp ), intent ( in ), optional :: time_factor ! time factor real ( wp ), intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ), optional , target :: un real ( wp ), dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional :: Rn real ( wp ) :: TF = 1.0 !time factor real ( wp ) :: SF = 1.0 !store factor Logical :: TU = . FALSE . !to use or not real ( wp ), dimension (:,:,:,:), pointer :: Quse integer :: i , j , k real ( wp ) :: KE = 0. real ( wp ) :: beta !sa variables real ( wp ) :: vort real ( wp ) :: fv1 real ( wp ) :: fv2 real ( wp ) :: fw real ( wp ) :: g real ( wp ) :: scap real ( wp ) :: rsa real ( wp ) :: kd2 real ( wp ) :: xi real ( wp ) :: mass_residue real ( wp ) :: x_mom_residue , y_mom_residue , z_mom_residue real ( wp ) :: energy_residue real ( wp ) :: TKE_residue , Omega_residue , kl_residue if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if select case ( type ) case ( 'primitive' ) !update primitive variable do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 mass_residue = residue ( i , j , k , 1 ) x_mom_residue = residue ( i , j , k , 2 ) y_mom_residue = residue ( i , j , k , 3 ) z_mom_residue = residue ( i , j , k , 4 ) energy_residue = residue ( i , j , k , 5 ) u1 ( 1 : n_var ) = Quse ( i , j , k , 1 : n_var ) ! finding primitive residue R ( 1 ) = mass_residue R ( 2 ) = - 1 * ( u1 ( 2 ) / u1 ( 1 )) * mass_residue + x_mom_residue / u1 ( 1 ) R ( 3 ) = - 1 * ( u1 ( 3 ) / u1 ( 1 )) * mass_residue + y_mom_residue / u1 ( 1 ) R ( 4 ) = - 1 * ( u1 ( 4 ) / u1 ( 1 )) * mass_residue + z_mom_residue / u1 ( 1 ) R ( 5 ) = 0.5 * ( flow % gm - 1. ) * ( sum ( u1 ( 2 : 4 ) ** 2 ) * mass_residue ) & - ( flow % gm - 1. ) * u1 ( 2 ) * x_mom_residue & - ( flow % gm - 1. ) * u1 ( 3 ) * y_mom_residue & - ( flow % gm - 1. ) * u1 ( 4 ) * z_mom_residue & + ( flow % gm - 1. ) * energy_residue select case ( scheme % turbulence ) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) TKE_residue = residue ( i , j , k , 6 ) omega_residue = residue ( i , j , k , 7 ) beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 5 ) = R ( 5 ) - ( flow % gm - 1. ) * TKE_residue R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue & + ( 1. / ( 1. + bstar * u1 ( 6 ) * delta_t ( i , j , k ))) * TKE_residue / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue & + ( 1. / ( 1. + 2. * beta * u1 ( 6 ) * delta_t ( i , j , k ))) * omega_residue / u1 ( 1 ) case ( 'kkl' ) TKE_residue = residue ( i , j , k , 6 ) kl_residue = residue ( i , j , k , 7 ) eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 5 ) = R ( 5 ) - ( flow % gm - 1. ) * TKE_residue R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue & + ( 1. / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * u1 ( 1 ) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )))) * TKE_residue / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue & + ( 1. / ( 1. + ( 6 * mu ( i , j , k ) * fphi / dist ( i , j , k ) ** 2 ) * delta_t ( i , j , k ))) * kl_residue / u1 ( 1 ) case DEFAULT Fatal_error end select !check if user want to store residue if ( present ( Rn )) then Rn ( i , j , k , 1 : n_var ) = Rn ( i , j , k , 1 : n_var ) + SF * R ( 1 : n_var ) if ( TU ) R (:) = Rn ( i , j , k ,:) end if !update u2 (:) = u1 (:) - R (:) * ( TF * delta_t ( i , j , k ) / cells ( i , j , k )% volume ) !check solution for non pyhysical results if (( u2 ( 1 ) < 0. ) . or . ( u2 ( 5 )) < 0. ) then Fatal_error else !update qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kkl' ) if ( u2 ( 6 ) > 0. ) qp ( i , j , k , 6 ) = u2 ( 6 ) if ( u2 ( 7 ) > 0. ) qp ( i , j , k , 7 ) = u2 ( 7 ) case DEFAULT ! do nothing continue end select end if end do end do end do case ( 'conservative' ) !include \"update_conservative.inc\" !update conservative variable do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! getting conservative variable u1 ( 1 ) = Quse ( i , j , k , 1 ) u1 ( 2 :) = Quse ( i , j , k , 2 :) * u1 ( 1 ) select case ( scheme % turbulence ) case ( 'sst' , 'sst2003' , 'kkl' ) KE = 0.0 !u1(6) case ( 'sa' , 'saBC' ) KE = 0.0 case DEFAULT KE = 0. end select u1 ( 5 ) = ( u1 ( 5 ) / ( flow % gm - 1. ) + 0.5 * sum ( u1 ( 2 : 4 ) ** 2 )) / u1 ( 1 ) + KE ! get R R ( 1 : n_var ) = residue ( i , j , k , 1 : n_var ) ! point implicit destruction term select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 6 ) = R ( 6 ) / ( 1 + ( beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1 + ( 2 * beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) case ( 'kkl' ) eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 6 ) = R ( 6 ) / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * sqrt ( u1 ( 1 )) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / ( dist ( i , j , k ) ** 2 ))) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1. + ( 6 * mu ( i , j , k ) * fphi / ( dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )) case ( 'sa' , 'saBC' ) vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) kd2 = ( kappa_sa * dist ( i , j , k )) ** 2 xi = U1 ( 6 ) * qp ( i , j , k , 1 ) / mu ( i , j , k ) fv1 = xi ** 3 / ( xi ** 3 + cv1 ** 3 ) fv2 = 1.0 - xi / ( 1 + xi * fv1 ) scap = vort + U1 ( 6 ) * fv2 / ( kd2 ) rsa = min ( U1 ( 6 ) / ( Scap * kd2 ), 1 0.0 ) g = rsa + cw2 * ( rsa ** 6 - rsa ) fw = g * ( ( 1.0 + cw3 ** 6 ) / ( g ** 6 + cw3 ** 6 ) ) ** ( 1.0 / 6.0 ) R ( 6 ) = R ( 6 ) / ( 1. + (( - 1.0 * u1 ( 1 ) * cb1 * scap ) + ( 2.0 * u1 ( 1 ) * cw1 * fw * u1 ( 6 ) / ( dist ( i , j , k ) ** 2 ))) * delta_t ( i , j , k )) case DEFAULT Fatal_error end select !check if user want to store residue if ( present ( Rn )) then Rn ( i , j , k , 1 : n_var ) = Rn ( i , j , k , 1 : n_var ) + SF * R ( 1 : n_var ) if ( TU ) R (:) = Rn ( i , j , k ,:) end if !update u2 ( 1 : n_var ) = u1 ( 1 : n_var ) - R ( 1 : n_var ) * ( TF * delta_t ( i , j , k ) / cells ( i , j , k )% volume ) ! getting primitve variable back variable u2 ( 1 ) = u2 ( 1 ) u2 ( 2 :) = u2 ( 2 :) / u2 ( 1 ) select case ( scheme % turbulence ) case ( 'sst' , 'sst2003' , 'kkl' ) KE = 0.0 !u2(6) case ( 'sa' , 'saBC' ) !u2(6) = u2(6)*u2(1) KE = 0.0 case DEFAULT KE = 0. end select u2 ( 5 ) = ( flow % gm - 1. ) * u2 ( 1 ) * ( u2 ( 5 ) - ( 0.5 * sum ( u2 ( 2 : 4 ) ** 2 )) - KE ) !check solution for non pyhysical results if (( u2 ( 1 ) < 0. ) . or . ( u2 ( 5 )) < 0. . or . any ( isnan ( u2 ))) then print * , u2 (:) print * , \"R: \" , R print * , \"old \" , U1 Fatal_error else !update qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kkl' ) if ( u2 ( 6 ) >= 0. ) then qp ( i , j , k , 6 ) = u2 ( 6 ) else !  qp(i,j,k,6) = tk_inf !  qp(i,j,k,6) = (max(qp(i-1,j,k,6),0.) + max(qp(i+1,j,k,6),0.) & !                +max(qp(i,j-1,k,6),0.) + max(qp(i,j+1,k,6),0.) & !                )/4 !  qp(i,j,k,6) = 1.e-3*maxval(qp(i-1:i+1,j-1:j+1,k-1:k+1,6)) end if if ( u2 ( 7 ) >= 0. ) then qp ( i , j , k , 7 ) = u2 ( 7 ) else !  qp(i,j,k,7) = tkl_inf !  qp(i,j,k,7) = (max(qp(i-1,j,k,7),0.) + max(qp(i+1,j,k,7),0.) & !                +max(qp(i,j-1,k,7),0.) + max(qp(i,j+1,k,7),0.) & !                )/4 end if case ( 'sa' , 'saBC' ) qp ( i , j , k , 6 ) = max ( u2 ( 6 ), 1.e-12 ) case DEFAULT ! do nothing continue end select end if !print*, i,j, R(1:n_var) end do end do end do case DEFAULT Fatal_error end select end subroutine update_with !subroutine get_total_conservative_Residue(qp, Temp, residue, F,G,H, control, scheme, flow, dims) subroutine get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) !< For each iteration it apply boundary conditions, !< use higher order method to reconstruct state at !< face, evalute fluxes at each face, calculate !< inviscid residual, and introuduce additional !< residual due to  viscosity, turbulence and source !< terms. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Temp !< Store Temperature variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal call apply_interface ( qp , control , bc , dims ) call populate_ghost_primitive ( qp , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_face_interpolant ( qp , cells , scheme , flow , dims ) call reconstruct_boundary_state ( qp , control , scheme , bc , dims ) call compute_fluxes ( F , G , H , Ifaces , Jfaces , Kfaces , scheme , flow , bc , dims ) if ( flow % mu_ref /= 0.0 ) then call evaluate_all_gradients ( qp , Temp , cells , Ifaces , Jfaces , Kfaces , scheme , bc , dims ) call calculate_viscosity ( qp , scheme , flow , bc , dims ) call compute_viscous_fluxes ( F , G , H , qp , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) end if call compute_residue ( residue , F , G , H , dims ) call add_source_term_residue ( qp , residue , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) end subroutine get_total_conservative_Residue end module update","tags":"","loc":"sourcefile/update.f90.html","title":"update.f90 – FEST-3D"},{"text":"The geometry module calculates various geometrical quantities like \n face-normals, face-areas and cell-volumes to be used in computations. This file depends on sourcefile~~geometry.f90~~EfferentGraph sourcefile~geometry.f90 geometry.f90 sourcefile~utils.f90 utils.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~geometry.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~geometry.f90~~AfferentGraph sourcefile~geometry.f90 geometry.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~geometry.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules geometry Source Code geometry.f90 Source Code !< The geometry module calculates various geometrical quantities like !< face-normals, face-areas and cell-volumes to be used in computations. module geometry !< The geometry module calculates various geometrical quantities like !< face-normals, face-areas and cell-volumes to be used in computations. !------------------------------------------------------------------- #include \"error.h\" #include \"debug.h\" use vartypes use utils , only : alloc implicit none private integer :: imx , jmx , kmx ! Public methods public :: setup_geometry contains subroutine allocate_memory ( cells , Ifaces , Jfaces , Kfaces ) !< Allocate memory for the required variables. !----------------------------------------------------------- implicit none type ( celltype ), dimension (:,:,:), allocatable , intent ( out ) :: cells !< Store cell center quantities: volume, cell center coordinate type ( facetype ), dimension (:,:,:), allocatable , intent ( out ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension (:,:,:), allocatable , intent ( out ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension (:,:,:), allocatable , intent ( out ) :: Kfaces !< Store face quantites for K faces: normal and area DebugCall ( 'allocate_memory' ) allocate ( cells ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 )) !< Allocate memory for cells !----------------------------------------------------------- allocate ( Ifaces ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 )) allocate ( Jfaces ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 )) allocate ( Kfaces ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 )) !< Allocate memory for the face variables. !----------------------------------------------------------- end subroutine allocate_memory subroutine normalize_face_normals ( Ifaces , Jfaces , Kfaces , bc ) !< Normalize the face normal vectors computed to get unit !< vectors !----------------------------------------------------------- implicit none type ( facetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ), intent ( inout ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ), intent ( inout ) :: Kfaces !< Store face quantites for K faces: normal and area type ( boundarytype ), intent ( in ) :: bc integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 3 if ( Ifaces ( i , j , k )% A /= 0. ) then Ifaces ( i , j , k )% nx = Ifaces ( i , j , k )% nx / Ifaces ( i , j , k )% A Ifaces ( i , j , k )% ny = Ifaces ( i , j , k )% ny / Ifaces ( i , j , k )% A Ifaces ( i , j , k )% nz = Ifaces ( i , j , k )% nz / Ifaces ( i , j , k )% A end if end do end do end do do k = - 2 , kmx + 2 do j = - 2 , jmx + 3 do i = - 2 , imx + 2 if ( Jfaces ( i , j , k )% A /= 0. ) then Jfaces ( i , j , k )% nx = Jfaces ( i , j , k )% nx / Jfaces ( i , j , k )% A Jfaces ( i , j , k )% ny = Jfaces ( i , j , k )% ny / Jfaces ( i , j , k )% A Jfaces ( i , j , k )% nz = Jfaces ( i , j , k )% nz / Jfaces ( i , j , k )% A end if end do end do end do do k = - 2 , kmx + 3 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 if ( Kfaces ( i , j , k )% A /= 0. ) then Kfaces ( i , j , k )% nx = Kfaces ( i , j , k )% nx / Kfaces ( i , j , k )% A Kfaces ( i , j , k )% ny = Kfaces ( i , j , k )% ny / Kfaces ( i , j , k )% A Kfaces ( i , j , k )% nz = Kfaces ( i , j , k )% nz / Kfaces ( i , j , k )% A end if end do end do end do ! pole boundary condition if ( bc % imin_id ==- 7 ) then Ifaces ( 1 ,:,:)% nx = Ifaces ( 2 ,:,:)% nx Ifaces ( 0 ,:,:)% nx = Ifaces ( 2 ,:,:)% nx Ifaces ( - 1 ,:,:)% nx = Ifaces ( 2 ,:,:)% nx Ifaces ( - 2 ,:,:)% nx = Ifaces ( 2 ,:,:)% nx Ifaces ( 1 ,:,:)% ny = Ifaces ( 2 ,:,:)% ny Ifaces ( 0 ,:,:)% ny = Ifaces ( 2 ,:,:)% ny Ifaces ( - 1 ,:,:)% ny = Ifaces ( 2 ,:,:)% ny Ifaces ( - 2 ,:,:)% ny = Ifaces ( 2 ,:,:)% ny Ifaces ( 1 ,:,:)% nz = Ifaces ( 2 ,:,:)% nz Ifaces ( 0 ,:,:)% nz = Ifaces ( 2 ,:,:)% nz Ifaces ( - 1 ,:,:)% nz = Ifaces ( 2 ,:,:)% nz Ifaces ( - 2 ,:,:)% nz = Ifaces ( 2 ,:,:)% nz end if if ( bc % imax_id ==- 7 ) then Ifaces ( imx + 0 ,:,:)% nx = Ifaces ( imx - 1 ,:,:)% nx Ifaces ( imx + 1 ,:,:)% nx = Ifaces ( imx - 1 ,:,:)% nx Ifaces ( imx + 2 ,:,:)% nx = Ifaces ( imx - 1 ,:,:)% nx Ifaces ( imx + 3 ,:,:)% nx = Ifaces ( imx - 1 ,:,:)% nx Ifaces ( imx + 0 ,:,:)% ny = Ifaces ( imx - 1 ,:,:)% ny Ifaces ( imx + 1 ,:,:)% ny = Ifaces ( imx - 1 ,:,:)% ny Ifaces ( imx + 2 ,:,:)% ny = Ifaces ( imx - 1 ,:,:)% ny Ifaces ( imx + 3 ,:,:)% ny = Ifaces ( imx - 1 ,:,:)% ny Ifaces ( imx + 0 ,:,:)% nz = Ifaces ( imx - 1 ,:,:)% nz Ifaces ( imx + 1 ,:,:)% nz = Ifaces ( imx - 1 ,:,:)% nz Ifaces ( imx + 2 ,:,:)% nz = Ifaces ( imx - 1 ,:,:)% nz Ifaces ( imx + 3 ,:,:)% nz = Ifaces ( imx - 1 ,:,:)% nz end if if ( bc % jmin_id ==- 7 ) then Jfaces (:, 1 ,:)% nx = Jfaces (:, 2 ,:)% nx Jfaces (:, 0 ,:)% nx = Jfaces (:, 2 ,:)% nx Jfaces (:, - 1 ,:)% nx = Jfaces (:, 2 ,:)% nx Jfaces (:, - 2 ,:)% nx = Jfaces (:, 2 ,:)% nx Jfaces (:, 1 ,:)% ny = Jfaces (:, 2 ,:)% ny Jfaces (:, 0 ,:)% ny = Jfaces (:, 2 ,:)% ny Jfaces (:, - 1 ,:)% ny = Jfaces (:, 2 ,:)% ny Jfaces (:, - 2 ,:)% ny = Jfaces (:, 2 ,:)% ny Jfaces (:, 1 ,:)% nz = Jfaces (:, 2 ,:)% nz Jfaces (:, 0 ,:)% nz = Jfaces (:, 2 ,:)% nz Jfaces (:, - 1 ,:)% nz = Jfaces (:, 2 ,:)% nz Jfaces (:, - 2 ,:)% nz = Jfaces (:, 2 ,:)% nz end if if ( bc % jmax_id ==- 7 ) then Jfaces (:, jmx + 0 ,:)% nx = Jfaces (:, jmx - 1 ,:)% nx Jfaces (:, jmx + 1 ,:)% nx = Jfaces (:, jmx - 1 ,:)% nx Jfaces (:, jmx + 2 ,:)% nx = Jfaces (:, jmx - 1 ,:)% nx Jfaces (:, jmx + 3 ,:)% nx = Jfaces (:, jmx - 1 ,:)% nx Jfaces (:, jmx + 0 ,:)% ny = Jfaces (:, jmx - 1 ,:)% ny Jfaces (:, jmx + 1 ,:)% ny = Jfaces (:, jmx - 1 ,:)% ny Jfaces (:, jmx + 2 ,:)% ny = Jfaces (:, jmx - 1 ,:)% ny Jfaces (:, jmx + 3 ,:)% ny = Jfaces (:, jmx - 1 ,:)% ny Jfaces (:, jmx + 0 ,:)% nz = Jfaces (:, jmx - 1 ,:)% nz Jfaces (:, jmx + 1 ,:)% nz = Jfaces (:, jmx - 1 ,:)% nz Jfaces (:, jmx + 2 ,:)% nz = Jfaces (:, jmx - 1 ,:)% nz Jfaces (:, jmx + 3 ,:)% nz = Jfaces (:, jmx - 1 ,:)% nz end if if ( bc % kmin_id ==- 7 ) then Kfaces (:,:, 1 )% nx = Kfaces (:,:, 2 )% nx Kfaces (:,:, 0 )% nx = Kfaces (:,:, 2 )% nx Kfaces (:,:, - 1 )% nx = Kfaces (:,:, 2 )% nx Kfaces (:,:, - 2 )% nx = Kfaces (:,:, 2 )% nx Kfaces (:,:, 1 )% ny = Kfaces (:,:, 2 )% ny Kfaces (:,:, 0 )% ny = Kfaces (:,:, 2 )% ny Kfaces (:,:, - 1 )% ny = Kfaces (:,:, 2 )% ny Kfaces (:,:, - 2 )% ny = Kfaces (:,:, 2 )% ny Kfaces (:,:, 1 )% nz = Kfaces (:,:, 2 )% nz Kfaces (:,:, 0 )% nz = Kfaces (:,:, 2 )% nz Kfaces (:,:, - 1 )% nz = Kfaces (:,:, 2 )% nz Kfaces (:,:, - 2 )% nz = Kfaces (:,:, 2 )% nz end if if ( bc % kmax_id ==- 7 ) then Kfaces (:,:, kmx + 0 )% nx = Kfaces (:,:, kmx - 1 )% nx Kfaces (:,:, kmx + 1 )% nx = Kfaces (:,:, kmx - 1 )% nx Kfaces (:,:, kmx + 2 )% nx = Kfaces (:,:, kmx - 1 )% nx Kfaces (:,:, kmx + 3 )% nx = Kfaces (:,:, kmx - 1 )% nx Kfaces (:,:, kmx + 0 )% ny = Kfaces (:,:, kmx - 1 )% ny Kfaces (:,:, kmx + 1 )% ny = Kfaces (:,:, kmx - 1 )% ny Kfaces (:,:, kmx + 2 )% ny = Kfaces (:,:, kmx - 1 )% ny Kfaces (:,:, kmx + 3 )% ny = Kfaces (:,:, kmx - 1 )% ny Kfaces (:,:, kmx + 0 )% nz = Kfaces (:,:, kmx - 1 )% nz Kfaces (:,:, kmx + 1 )% nz = Kfaces (:,:, kmx - 1 )% nz Kfaces (:,:, kmx + 2 )% nz = Kfaces (:,:, kmx - 1 )% nz Kfaces (:,:, kmx + 3 )% nz = Kfaces (:,:, kmx - 1 )% nz end if end subroutine normalize_face_normals subroutine compute_face_areas ( Ifaces , Jfaces , Kfaces , bc ) !< Compute face areas based on area vectors !< !< The face areas are computed using the face area vectors. !< Prior to using this subroutine, the face area vectors must !< computed and placed in the face normal variables. !< !< Since the area is given by abs(d1 x d2), the areas are !< calculated using the normal vectors calculated in !< compute_face_area_vectors, but before normalising them !----------------------------------------------------------- implicit none type ( facetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ), intent ( inout ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ), intent ( inout ) :: Kfaces !< Store face quantites for K faces: normal and area type ( boundarytype ), intent ( in ) :: bc Ifaces (:,:,:)% A = sqrt (( Ifaces (:,:,:)% nx ) ** 2 + ( Ifaces (:,:,:)% ny ) ** 2 + & ( Ifaces (:,:,:)% nz ) ** 2 ) Jfaces (:,:,:)% A = sqrt (( Jfaces (:,:,:)% nx ) ** 2 + ( Jfaces (:,:,:)% ny ) ** 2 + & ( Jfaces (:,:,:)% nz ) ** 2 ) Kfaces (:,:,:)% A = sqrt (( Kfaces (:,:,:)% nx ) ** 2 + ( Kfaces (:,:,:)% ny ) ** 2 + & ( Kfaces (:,:,:)% nz ) ** 2 ) ! Pole boundary conditions ! making sure face area is exactly equal zero if ( bc % imin_id ==- 7 ) Ifaces ( - 2 : 1 , :, :)% A = 0. if ( bc % imax_id ==- 7 ) Ifaces ( imx : imx + 3 , :, :)% A = 0. if ( bc % jmin_id ==- 7 ) Jfaces ( :, - 2 : 1 , :)% A = 0. if ( bc % jmax_id ==- 7 ) Jfaces ( :, jmx : jmx + 3 , :)% A = 0. if ( bc % kmin_id ==- 7 ) Kfaces ( :, :, - 2 : 1 )% A = 0. if ( bc % kmax_id ==- 7 ) Kfaces ( :, :, kmx : kmx + 3 )% A = 0. end subroutine compute_face_areas subroutine compute_face_area_vectors ( Ifaces , Jfaces , Kfaces , nodes ) !< Compute face area vectors !< !< The face area vectors denote the face area both in !< magnitude and direction. They are placed in the face !< normal variables for further calculation. !< !< The face normal is given by d1 x d2, where d1 and d2 are !< the diagonals of a face !----------------------------------------------------------- implicit none type ( facetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ), intent ( inout ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ), intent ( inout ) :: Kfaces !< Store face quantites for K faces: normal and area type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes !< Grid points real ( wp ) :: d1x , d2x , d1y , d2y , d1z , d2z integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 3 d1x = nodes ( i , j + 1 , k + 1 )% x - nodes ( i , j , k )% x d1y = nodes ( i , j + 1 , k + 1 )% y - nodes ( i , j , k )% y d1z = nodes ( i , j + 1 , k + 1 )% z - nodes ( i , j , k )% z d2x = nodes ( i , j , k + 1 )% x - nodes ( i , j + 1 , k )% x d2y = nodes ( i , j , k + 1 )% y - nodes ( i , j + 1 , k )% y d2z = nodes ( i , j , k + 1 )% z - nodes ( i , j + 1 , k )% z Ifaces ( i , j , k )% nx = 0.5 * ( d1y * d2z - d1z * d2y ) Ifaces ( i , j , k )% ny = 0.5 * ( d1z * d2x - d1x * d2z ) Ifaces ( i , j , k )% nz = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do do k = - 2 , kmx + 2 do j = - 2 , jmx + 3 do i = - 2 , imx + 2 d1x = nodes ( i + 1 , j , k + 1 )% x - nodes ( i , j , k )% x d1y = nodes ( i + 1 , j , k + 1 )% y - nodes ( i , j , k )% y d1z = nodes ( i + 1 , j , k + 1 )% z - nodes ( i , j , k )% z d2x = nodes ( i + 1 , j , k )% x - nodes ( i , j , k + 1 )% x d2y = nodes ( i + 1 , j , k )% y - nodes ( i , j , k + 1 )% y d2z = nodes ( i + 1 , j , k )% z - nodes ( i , j , k + 1 )% z Jfaces ( i , j , k )% nx = 0.5 * ( d1y * d2z - d1z * d2y ) Jfaces ( i , j , k )% ny = 0.5 * ( d1z * d2x - d1x * d2z ) Jfaces ( i , j , k )% nz = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do do k = - 2 , kmx + 3 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 d1x = nodes ( i + 1 , j + 1 , k )% x - nodes ( i , j , k )% x d1y = nodes ( i + 1 , j + 1 , k )% y - nodes ( i , j , k )% y d1z = nodes ( i + 1 , j + 1 , k )% z - nodes ( i , j , k )% z d2x = nodes ( i , j + 1 , k )% x - nodes ( i + 1 , j , k )% x d2y = nodes ( i , j + 1 , k )% y - nodes ( i + 1 , j , k )% y d2z = nodes ( i , j + 1 , k )% z - nodes ( i + 1 , j , k )% z Kfaces ( i , j , k )% nx = 0.5 * ( d1y * d2z - d1z * d2y ) Kfaces ( i , j , k )% ny = 0.5 * ( d1z * d2x - d1x * d2z ) Kfaces ( i , j , k )% nz = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do end subroutine compute_face_area_vectors subroutine compute_face_areas_and_normals ( Ifaces , Jfaces , Kfaces , nodes , bc ) !< Compute the face areas and normals !< !< This is the 2-dimensional version. In this case, the face !< areas default to edge lengths. !----------------------------------------------------------- implicit none type ( facetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ), intent ( inout ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ), intent ( inout ) :: Kfaces !< Store face quantites for K faces: normal and area type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes !< Grid points type ( boundarytype ), intent ( in ) :: bc !< boundary condition and fixed values call compute_face_area_vectors ( Ifaces , Jfaces , Kfaces , nodes ) call compute_face_areas ( Ifaces , Jfaces , Kfaces , bc ) call normalize_face_normals ( Ifaces , Jfaces , Kfaces , bc ) end subroutine compute_face_areas_and_normals function vol_tetrahedron ( p1 , p2 , p3 , p4 ) !< Compute the volume of a tetrahedron, given 4 points which !< are 1-D arrays !< Since we know that the determinant is to be evaluated of !< a 3x3 matrix, we write the expression itself !----------------------------------------------------------- implicit none real ( wp ), dimension (:), intent ( in ) :: p1 , p2 , p3 , p4 real ( wp ), dimension ( 1 : 3 , 1 : 3 ) :: A real ( wp ) :: vol_tetrahedron A (:, 1 ) = p1 - p4 A (:, 2 ) = p2 - p4 A (:, 3 ) = p3 - p4 !vol_tetrahedron = A(1,1) * (A(2,2)*A(3,3) - A(2,3)*A(3,2)) + & !                  A(1,2) * (A(2,3)*A(3,1) - A(2,1)*A(3,3)) + & !                  A(1,3) * (A(2,1)*A(3,2) - A(2,2)*A(3,1)) vol_tetrahedron = ( p4 ( 1 ) - p1 ( 1 )) * (( p2 ( 2 ) - p1 ( 2 )) * ( p3 ( 3 ) - p1 ( 3 )) - ( p2 ( 3 ) - p1 ( 3 )) * ( p3 ( 2 ) - p1 ( 2 ))) & + ( p4 ( 2 ) - p1 ( 2 )) * (( p2 ( 3 ) - p1 ( 3 )) * ( p3 ( 1 ) - p1 ( 1 )) - ( p2 ( 1 ) - p1 ( 1 )) * ( p3 ( 3 ) - p1 ( 3 ))) & + ( p4 ( 3 ) - p1 ( 3 )) * (( p2 ( 1 ) - p1 ( 1 )) * ( p3 ( 2 ) - p1 ( 2 )) - ( p2 ( 2 ) - p1 ( 2 )) * ( p3 ( 1 ) - p1 ( 1 ))) vol_tetrahedron = - vol_tetrahedron / 6. end function vol_tetrahedron function vol_hexahedron ( p_list ) !< Compute the volume of a hexahedron, given a list of points ! The points are arranged in a specific order. For the ! element i,j,k, the order of nodes required are: ! i,j,k ! i+1, j, k ! i+1, j+1, k ! i, j+1, k ! i, j, k+1 ! i+1, j, k+1 ! i+1, j+1, k+1 ! i, j+1, k+1 ! ! The hexahedron is to be split into 5 tetrahedrons. ! Source: Split hex into 5 tetrahedron: ! No assumptions about planarity seem to be made. All cuts ! were made with a plane containing only 3 vertices at a time. ! https://ieeexplore.ieee.org/ieee_pilot/articles/06/ttg2009061587/assets/img/article_1/fig_6/large.gif ! ! The indices of the 5 split tetrahedra can be visualised from ! the above link. But since the volume of each tetrahedron ! depends on the determinant calculated, it is IMPERATIVE to ! ensure that a \"correct\" order is followed for the 4 points. ! ! The logic to get the \"correct\" order is explained as ! follows (Refer wiki article on parallelepiped): ! The determinant is taken of a matrix of pi - p4, i = 1, 2, 3. ! Graphically it denotes the sides with p4 as common vertex, ! with direction outward from p4, i.e., directed from ! p4 to pi, i = 1, 2, 3 ! Hence, if you ensure that  cross(p1-p4, p2-p4) is along ! p3-p4, then the determinant will be positive. ! ! From the above link, a set of 5 tetrahedra was obtained. ! Each tetrahedra has 4 points, and in the function calls ! below, care was taken to ensure that the order is observed ! while passing parameters into the vol_tetrahedron function !----------------------------------------------------------- implicit none real ( wp ), dimension ( 1 : 3 , 1 : 8 ), intent ( in ) :: p_list real ( wp ) :: vol_hexahedron real ( wp ) :: vol_hexahedron1 vol_hexahedron1 = 0. vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 1 ), p_list (:, 5 ), & p_list (:, 8 ), p_list (:, 6 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 7 ), p_list (:, 8 ), & p_list (:, 6 ), p_list (:, 3 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 8 ), p_list (:, 4 ), & p_list (:, 1 ), p_list (:, 3 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 6 ), p_list (:, 1 ), & p_list (:, 3 ), p_list (:, 8 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 1 ), p_list (:, 2 ), & p_list (:, 6 ), p_list (:, 3 )) vol_hexahedron = 0. vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 2 ), p_list (:, 6 ), & p_list (:, 5 ), p_list (:, 7 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 8 ), p_list (:, 5 ), & p_list (:, 7 ), p_list (:, 4 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 5 ), p_list (:, 1 ), & p_list (:, 2 ), p_list (:, 4 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 7 ), p_list (:, 2 ), & p_list (:, 4 ), p_list (:, 5 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 2 ), p_list (:, 3 ), & p_list (:, 7 ), p_list (:, 4 )) vol_hexahedron = max ( vol_hexahedron , vol_hexahedron1 ) end function vol_hexahedron subroutine compute_volumes ( cells , nodes ) !< Compute the grid cell volumes !< Each grid is a hexahedron, whose volume is calculated by !< splitting it into 5 tetrahedrons, whose volume is known !----------------------------------------------------------- implicit none type ( celltype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( out ) :: cells !< Cell center quanties: volume and coordiantes of cell center type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes !< Grid points integer :: i , j , k real ( wp ), dimension ( 1 : 3 , 1 : 8 ) :: p_list cells (:,:,:)% volume = 1. do k = 0 , kmx + 0 do j = 0 , jmx + 0 do i = 0 , imx + 0 p_list (:, :) = 0. p_list (:, 1 ) = ( / nodes ( i , j , k )% x , nodes ( i , j , k )% y , nodes ( i , j , k )% z / ) p_list (:, 2 ) = ( / nodes ( i + 1 , j , k )% x , nodes ( i + 1 , j , k )% y , nodes ( i + 1 , j , k )% z / ) p_list (:, 3 ) = ( / nodes ( i + 1 , j + 1 , k )% x , nodes ( i + 1 , j + 1 , k )% y , nodes ( i + 1 , j + 1 , k )% z / ) p_list (:, 4 ) = ( / nodes ( i , j + 1 , k )% x , nodes ( i , j + 1 , k )% y , nodes ( i , j + 1 , k )% z / ) p_list (:, 5 ) = ( / nodes ( i , j , k + 1 )% x , nodes ( i , j , k + 1 )% y , nodes ( i , j , k + 1 )% z / ) p_list (:, 6 ) = ( / nodes ( i + 1 , j , k + 1 )% x , nodes ( i + 1 , j , k + 1 )% y , nodes ( i + 1 , j , k + 1 )% z / ) p_list (:, 7 ) = ( / nodes ( i + 1 , j + 1 , k + 1 )% x , nodes ( i + 1 , j + 1 , k + 1 )% y , nodes ( i + 1 , j + 1 , k + 1 )% z / ) p_list (:, 8 ) = ( / nodes ( i , j + 1 , k + 1 )% x , nodes ( i , j + 1 , k + 1 )% y , nodes ( i , j + 1 , k + 1 )% z / ) cells ( i , j , k )% volume = ( vol_hexahedron ( p_list )) if ( cells ( i , j , k )% volume <= 0.0 ) then if ( i == 0 . or . i == imx . or . j == 0 . or . j == jmx . or . k == 0 . or . k == kmx ) then !print*, \"Ghost Cell volume negative\" cells ( i , j , k )% volume = ( vol_hexahedron ( p_list )) else print * , process_id , i , j , k print * , \"negative volume :\" , ( vol_hexahedron ( p_list )) STOP end if end if end do end do end do if ( any ( cells (:,:,:)% volume == 0.0 )) then Fatal_error end if if ( any (( cells (:,:,:)% volume ) < 0.0 )) then Fatal_error end if end subroutine compute_volumes subroutine compute_ghost_cell_centroid ( cells , nodes ) !< Compute cell center of all cell including ghost cells implicit none type ( celltype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( out ) :: cells !< Cell center quanties: volume and coordiantes of cell center type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes !< Grid points integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 cells ( i , j , k )% centerx = 0.125 * ( nodes ( i , j , k )% x & + nodes ( i + 1 , j , k )% x & + nodes ( i + 1 , j + 1 , k )% x & + nodes ( i + 1 , j + 1 , k + 1 )% x & + nodes ( i + 1 , j , k + 1 )% x & + nodes ( i , j + 1 , k )% x & + nodes ( i , j + 1 , k + 1 )% x & + nodes ( i , j , k + 1 )% x & ) cells ( i , j , k )% centery = 0.125 * ( nodes ( i , j , k )% y & + nodes ( i + 1 , j , k )% y & + nodes ( i + 1 , j + 1 , k )% y & + nodes ( i + 1 , j + 1 , k + 1 )% y & + nodes ( i + 1 , j , k + 1 )% y & + nodes ( i , j + 1 , k )% y & + nodes ( i , j + 1 , k + 1 )% y & + nodes ( i , j , k + 1 )% y & ) cells ( i , j , k )% centerz = 0.125 * ( nodes ( i , j , k )% z & + nodes ( i + 1 , j , k )% z & + nodes ( i + 1 , j + 1 , k )% z & + nodes ( i + 1 , j + 1 , k + 1 )% z & + nodes ( i + 1 , j , k + 1 )% z & + nodes ( i , j + 1 , k )% z & + nodes ( i , j + 1 , k + 1 )% z & + nodes ( i , j , k + 1 )% z & ) end do end do end do end subroutine compute_ghost_cell_centroid subroutine setup_geometry ( cells , Ifaces , Jfaces , Kfaces , nodes , bc , dims ) !< Make the geometry module useful !< !< Allocates memory to the variables and initializes them. !----------------------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims type ( celltype ), dimension (:,:,:), allocatable , intent ( inout ) :: cells !< Cell center quanties: volume and coordiantes of cell center type ( facetype ), dimension (:,:,:), allocatable , intent ( inout ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension (:,:,:), allocatable , intent ( inout ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension (:,:,:), allocatable , intent ( inout ) :: Kfaces !< Store face quantites for K faces: normal and area type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes !< Grid points type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values DebugCall ( 'setup_geometry' ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx call allocate_memory ( cells , Ifaces , Jfaces , Kfaces ) call compute_face_areas_and_normals ( Ifaces , Jfaces , Kfaces , nodes , bc ) call compute_volumes ( cells , nodes ) call compute_ghost_cell_centroid ( cells , nodes ) end subroutine setup_geometry end module geometry","tags":"","loc":"sourcefile/geometry.f90.html","title":"geometry.f90 – FEST-3D"},{"text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~convergence.f90 convergence.f90 sourcefile~main.f90->sourcefile~convergence.f90 sourcefile~solver.f90 solver.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~convergence.f90->sourcefile~resnorm.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~convergence.f90->sourcefile~vartypes.f90 sourcefile~read.f90 read.f90 sourcefile~solver.f90->sourcefile~read.f90 sourcefile~bc.f90 bc.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~state.f90 state.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~solver.f90->sourcefile~geometry.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~time.f90 time.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~solver.f90->sourcefile~wall_dist.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~wall.f90 wall.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~cc.f90 CC.f90 sourcefile~solver.f90->sourcefile~cc.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~solver.f90->sourcefile~vartypes.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~grid.f90 grid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~layout.f90 layout.f90 sourcefile~solver.f90->sourcefile~layout.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~read.f90->sourcefile~vartypes.f90 sourcefile~bc.f90->sourcefile~vartypes.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~utils.f90 utils.f90 sourcefile~bc.f90->sourcefile~utils.f90 sourcefile~state.f90->sourcefile~vartypes.f90 sourcefile~check_output_control.f90 check_output_control.f90 sourcefile~state.f90->sourcefile~check_output_control.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~state.f90->sourcefile~utils.f90 sourcefile~geometry.f90->sourcefile~vartypes.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~scheme.f90->sourcefile~vartypes.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~slau.f90 slau.f90 sourcefile~scheme.f90->sourcefile~slau.f90 sourcefile~ausm.f90 ausm.f90 sourcefile~scheme.f90->sourcefile~ausm.f90 sourcefile~ausmup.f90 ausmUP.f90 sourcefile~scheme.f90->sourcefile~ausmup.f90 sourcefile~van_leer.f90 van_leer.f90 sourcefile~scheme.f90->sourcefile~van_leer.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~scheme.f90->sourcefile~utils.f90 sourcefile~ldfss0.f90 ldfss0.f90 sourcefile~scheme.f90->sourcefile~ldfss0.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~time.f90->sourcefile~vartypes.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~update.f90->sourcefile~gradients.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~wall_dist.f90 sourcefile~update.f90->sourcefile~vartypes.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~update.f90->sourcefile~face_interpolant.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~global_kkl.f90 sourcefile~update.f90->sourcefile~global_sst.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~update.f90->sourcefile~utils.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90->sourcefile~global_sa.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~wall.f90->sourcefile~vartypes.f90 sourcefile~wall.f90->sourcefile~utils.f90 sourcefile~cc.f90->sourcefile~wall_dist.f90 sourcefile~cc.f90->sourcefile~vartypes.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~resnorm.f90->sourcefile~vartypes.f90 sourcefile~resnorm.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90->sourcefile~vartypes.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~grid.f90->sourcefile~vartypes.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~layout.f90->sourcefile~vartypes.f90 sourcefile~viscous.f90->sourcefile~gradients.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~viscous.f90->sourcefile~vartypes.f90 sourcefile~viscous.f90->sourcefile~global_kkl.f90 sourcefile~viscous.f90->sourcefile~global_sst.f90 sourcefile~viscous.f90->sourcefile~utils.f90 sourcefile~viscous.f90->sourcefile~global_sa.f90 sourcefile~interface1.f90->sourcefile~vartypes.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~interface1.f90->sourcefile~utils.f90 var pansourcefilemainf90EfferentGraph = svgPanZoom('#sourcefilemainf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs main Source Code main.f90 Source Code program main !< Main program !------------------------------------------------- use solver , only : iterate_one_more_time_step use solver , only : control use convergence , only : converged use solver , only : start_run use solver , only : finish_run !--------Start---------! call start_run () do while (( control % current_iter <= control % max_iters ) . and . (. not . converged ( control )) . and . (. not . control % Halt )) call iterate_one_more_time_step () end do call finish_run () !--------Stop---------! end program main","tags":"","loc":"sourcefile/main.f90.html","title":"main.f90 – FEST-3D"},{"text":"Flux splitting scheme: AUSM+ This file depends on sourcefile~~van_leer.f90~~EfferentGraph sourcefile~van_leer.f90 van_leer.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~van_leer.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~van_leer.f90~~AfferentGraph sourcefile~van_leer.f90 van_leer.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~scheme.f90->sourcefile~van_leer.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules van_leer Source Code van_leer.f90 Source Code !< Flux splitting scheme: AUSM+ module van_leer !< !< Reference: Van Leer, B., Flux-vector splitting for the Euler equation. !< In Upwind and High-Resolution Schemes, Springer, Berlin, Heidelberg, pp. 80-89, 1997 !------------------------------------------------------------------- #include \"../../../debug.h\" #include \"../../../error.h\" use vartypes implicit none private public :: compute_fluxes contains subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input-argument direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at face integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus , F_minus real ( wp ) :: M_perp_left , M_perp_right real ( wp ) :: alpha_plus , alpha_minus real ( wp ) :: beta_left , beta_right real ( wp ) :: M_plus , M_minus real ( wp ) :: D_plus , D_minus real ( wp ) :: c_plus , c_minus real ( wp ) :: scrD_plus , scrD_minus real ( wp ) :: sound_speed_avg , face_normal_speeds DebugCall ( 'compute_flux' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( flow % gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( flow % gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_left ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_left ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_right ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_right ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! First construct the F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! First construct the F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * faces ( i , j , k )% A F_minus (:) = F_minus (:) * faces ( i , j , k )% A ! Get the total flux for a face Flux ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes end module van_leer","tags":"","loc":"sourcefile/van_leer.f90.html","title":"van_leer.f90 – FEST-3D"},{"text":"Flux splitting scheme: SLAU This file depends on sourcefile~~slau.f90~~EfferentGraph sourcefile~slau.f90 slau.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~slau.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~slau.f90~~AfferentGraph sourcefile~slau.f90 slau.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~scheme.f90->sourcefile~slau.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules slau Source Code slau.f90 Source Code !< Flux splitting scheme: SLAU module slau !< Shima, E., and Kitamura, K., “Parameter-Free Simple !< Low-Dissipation AUSM-Family Scheme for All Speeds,” !< AIAA Journal, vol. 49, pp. 1693–1709, 2011 !------------------------------------------------------------------- #include \"../../../debug.h\" #include \"../../../error.h\" use vartypes implicit none private public :: compute_fluxes contains subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at face integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus !< Right flux through the face real ( wp ), dimension ( 1 : dims % n_var ) :: F_minus !< Left flux through  the face real ( wp ) :: xi real ( wp ) :: vnabs real ( wp ) :: delp real ( wp ) :: delrho real ( wp ) :: fnG real ( wp ) :: pbar real ( wp ) :: Mcap real ( wp ) :: vtface real ( wp ) :: mass real ( wp ) :: HL , HR !< Enthalpy real ( wp ) :: uL , uR !< X-component of velocity real ( wp ) :: vL , vR !< Y-component of velocity real ( wp ) :: wL , wR !< Z-component of velocity real ( wp ) :: pL , pR !< Pressure real ( wp ) :: rL , rR !< Density real ( wp ) :: cL , cR !< Speed sound left/right real ( wp ) :: C !< Speed of sound at face real ( wp ) :: ML , MR !< Mach number left/right real ( wp ) :: VnL , VnR !< Face normal velocity left/right real ( wp ) :: betaL , betaR real ( wp ) :: alphaL , alphaR real ( wp ) :: VnabsL , VnabsR DebugCall ( 'compute_flux ' // trim ( f_dir )) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( flow % gm / ( flow % gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( flow % gm / ( flow % gm - 1. )) * pR / rR ) ! ---- speed of sound ---- cL = sqrt ( flow % gm * pL / rL ) cR = sqrt ( flow % gm * pR / rR ) C = 0.5 * ( cL + cR ) ! ---- delta quantities ---- delp = pR - pL !pL - pR delrho = rR - rL !rL - rR ! ---- face normal velocity ---- VnL = uL * faces ( i , j , k )% nx + vL * faces ( i , j , k )% ny + wL * faces ( i , j , k )% nz VnR = uR * faces ( i , j , k )% nx + vR * faces ( i , j , k )% ny + wR * faces ( i , j , k )% nz ! ---- Mach at face ---- ML = VnL / C MR = VnR / C ! ---- switch for supersonic flow ---- alphaL = max ( 0.0 , 1.0 - floor ( abs ( ML ))) alphaR = max ( 0.0 , 1.0 - floor ( abs ( MR ))) !Above two line of code is eqvivalent to following code !if(abs(ML)>=1.0) then !  alphaL = 0.0 !else !  alphaL=1.0 !end if !if(abs(MR)>=1.0) then !  alphaR=0.0 !else !  alphaR=1.0 !end if ! -- pressure factor -- betaL = ( 1.0 - alphaL ) * 0.5 * ( 1.0 + sign ( 1.0 , ML )) + ( alphaL ) * 0.25 * ( 2.0 - ML ) * (( ML + 1.0 ) ** 2 ) betaR = ( 1.0 - alphaR ) * 0.5 * ( 1.0 - sign ( 1.0 , MR )) + ( alphaR ) * 0.25 * ( 2.0 + MR ) * (( MR - 1.0 ) ** 2 ) ! -- xi calculation -- vtface = sqrt ( 0.5 * (( uL * uL ) + ( vL * vL ) + ( wL * wL ) + ( uR * uR ) + ( vR * vR ) + ( wR * wR ))) Mcap = min ( 1.0 , vtface / C ) Xi = ( 1.0 - Mcap ) ** 2 ! -- |Vn| -- Vnabs = ( rL * abs ( VnL ) + rR * abs ( VnR )) / ( rL + rR ) ! -- function G -- fnG = - 1.0 * max ( min ( ML , 0.0 ), - 1.0 ) * min ( max ( MR , 0.0 ), 1.0 ) ! -- Pressure -- pbar = 0.5 * (( pL + pR ) + ( betaL - betaR ) * ( pL - pR ) + ( 1.0 - xi ) * ( betaL + betaR - 1.0 ) * ( pL + pR )) ! -- mass -- !mass = 0.5*((rL*VnL + rR*VnR - Vnabs*delrho)*(1.0-fnG) - (Xi*delp/C)) VnabsL = ( 1.0 - fnG ) * Vnabs + fnG * abs ( VnL ) VnabsR = ( 1.0 - fnG ) * Vnabs + fnG * abs ( VnR ) mass = 0.5 * (( rL * ( VnL + VnabsL ) + rR * ( VnR - VnabsR )) - ( Xi * delp / C )) mass = mass * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) ! -- Turbulence variables mass flux -- if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Get the total flux for a face Flux ( i , j , k , :) = F_plus (:) + F_minus (:) ! -- Pressure flux addition -- Flux ( i , j , K , 2 ) = Flux ( i , j , k , 2 ) + ( pbar * faces ( i , j , k )% nx ) Flux ( i , j , K , 3 ) = Flux ( i , j , k , 3 ) + ( pbar * faces ( i , j , k )% ny ) Flux ( i , j , K , 4 ) = Flux ( i , j , k , 4 ) + ( pbar * faces ( i , j , k )% nz ) Flux ( i , j , k , :) = Flux ( i , j , k , :) * faces ( i , j , k )% A end do end do end do end subroutine compute_flux subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes end module slau","tags":"","loc":"sourcefile/slau.f90.html","title":"slau.f90 – FEST-3D"},{"text":"Inviscid flux calculation through faces This file depends on sourcefile~~scheme.f90~~EfferentGraph sourcefile~scheme.f90 scheme.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~ldfss0.f90 ldfss0.f90 sourcefile~scheme.f90->sourcefile~ldfss0.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~scheme.f90->sourcefile~vartypes.f90 sourcefile~ausmup.f90 ausmUP.f90 sourcefile~scheme.f90->sourcefile~ausmup.f90 sourcefile~van_leer.f90 van_leer.f90 sourcefile~scheme.f90->sourcefile~van_leer.f90 sourcefile~utils.f90 utils.f90 sourcefile~scheme.f90->sourcefile~utils.f90 sourcefile~slau.f90 slau.f90 sourcefile~scheme.f90->sourcefile~slau.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~ausm.f90 ausm.f90 sourcefile~scheme.f90->sourcefile~ausm.f90 sourcefile~face_interpolant.f90->sourcefile~vartypes.f90 sourcefile~face_interpolant.f90->sourcefile~utils.f90 sourcefile~weno.f90 weno.f90 sourcefile~face_interpolant.f90->sourcefile~weno.f90 sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~face_interpolant.f90->sourcefile~weno_nm.f90 sourcefile~ppm.f90 ppm.f90 sourcefile~face_interpolant.f90->sourcefile~ppm.f90 sourcefile~muscl.f90 muscl.f90 sourcefile~face_interpolant.f90->sourcefile~muscl.f90 sourcefile~ldfss0.f90->sourcefile~vartypes.f90 sourcefile~ausmup.f90->sourcefile~vartypes.f90 sourcefile~van_leer.f90->sourcefile~vartypes.f90 sourcefile~slau.f90->sourcefile~vartypes.f90 sourcefile~ausmp.f90->sourcefile~face_interpolant.f90 sourcefile~ausmp.f90->sourcefile~vartypes.f90 sourcefile~ausm.f90->sourcefile~vartypes.f90 sourcefile~weno.f90->sourcefile~vartypes.f90 sourcefile~weno_nm.f90->sourcefile~vartypes.f90 sourcefile~ppm.f90->sourcefile~vartypes.f90 sourcefile~muscl.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~scheme.f90~~AfferentGraph sourcefile~scheme.f90 scheme.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules scheme Source Code scheme.f90 Source Code !< Inviscid flux calculation through faces module scheme !< Inviscid flux calculation through faces #include \"../../../debug.h\" #include \"../../../error.h\" use vartypes use utils , only : alloc use face_interpolant , only : setup_interpolant_scheme use face_interpolant use ausmP , only : compute_fluxes_ausmP => compute_fluxes use ausmUP , only : compute_fluxes_ausmUP => compute_fluxes use slau , only : compute_fluxes_slau => compute_fluxes use ausm , only : compute_fluxes_ausm => compute_fluxes use ldfss0 , only : compute_fluxes_ldfss0 => compute_fluxes use van_leer , only : compute_fluxes_van_leer => compute_fluxes implicit none integer :: imx , jmx , kmx , n_var private ! Public members public :: setup_scheme public :: compute_fluxes public :: compute_residue contains subroutine setup_scheme ( residue , F , G , H , control , dims ) implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( extent ), intent ( in ) :: dims !< extent of the 3D domain real ( wp ), dimension (:, :, :, :), allocatable , intent ( out ), target :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), allocatable , intent ( out ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), allocatable , intent ( out ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), allocatable , intent ( out ) :: H !< Store fluxes throught the K faces imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var call setup_interpolant_scheme ( dims ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - Scheme' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - Scheme' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - Scheme' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - Scheme' ) end subroutine setup_scheme subroutine compute_fluxes ( F , G , H , Ifaces , Jfaces , Kfaces , scheme , flow , bc , dims ) implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< extent of the 3D domain real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values select case ( scheme % scheme_name ) case ( \"van_leer\" ) call compute_fluxes_van_leer ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case ( \"ausm\" ) call compute_fluxes_ausm ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case ( \"ausmP\" ) call compute_fluxes_ausmP ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case ( \"ausmUP\" ) call compute_fluxes_ausmUP ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case ( \"slau\" ) call compute_fluxes_slau ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case ( \"ldfss0\" ) call compute_fluxes_ldfss0 ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case default Fatal_error end select end subroutine compute_fluxes subroutine compute_residue ( residue , F , G , H , dims ) implicit none type ( extent ), intent ( in ) :: dims !< extent of the 3D domain real ( wp ), dimension (:, :, :, :), intent ( out ) :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), intent ( in ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: H !< Store fluxes throught the K faces integer :: i , j , k , l DebugCall ( 'compute_residue' ) do l = 1 , dims % n_var do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 residue ( i , j , k , l ) = ( F ( i + 1 , j , k , l ) - F ( i , j , k , l )) & + ( G ( i , j + 1 , k , l ) - G ( i , j , k , l )) & + ( H ( i , j , k + 1 , l ) - H ( i , j , k , l )) end do end do end do end do end subroutine compute_residue end module scheme","tags":"","loc":"sourcefile/scheme.f90.html","title":"scheme.f90 – FEST-3D"},{"text":"Flux splitting scheme: AUSM+-UP This file depends on sourcefile~~ausmup.f90~~EfferentGraph sourcefile~ausmup.f90 ausmUP.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~ausmup.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ausmup.f90~~AfferentGraph sourcefile~ausmup.f90 ausmUP.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~scheme.f90->sourcefile~ausmup.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ausmUP Source Code ausmUP.f90 Source Code !< Flux splitting scheme: AUSM+-UP module ausmUP !< !< Reference: Liou, M. S., “A sequel to AUSM, Part II: !< AUSM+-up for all speeds,” Journal of Computational Physics, !< vol. 214, 2006, pp. 137–170 !------------------------------------------------------------------- #include \"../../../debug.h\" #include \"../../../error.h\" use vartypes implicit none private public :: compute_fluxes contains subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at face integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus !< Right flux through the face real ( wp ), dimension ( 1 : dims % n_var ) :: F_minus !< Left flux through  the face real ( wp ) :: pbar real ( wp ) :: mass real ( wp ) :: HL , HR !< Enthalpy real ( wp ) :: uL , uR !< X-component of velocity real ( wp ) :: vL , vR !< Y-component of velocity real ( wp ) :: wL , wR !< Z-component of velocity real ( wp ) :: pL , pR !< Pressure real ( wp ) :: rL , rR !< Density real ( wp ) :: cL , cR !< Speed sound left/right real ( wp ) :: C !< Speed of sound at face real ( wp ) :: ML , MR !< Mach number left/right real ( wp ) :: VnL , VnR !< Face normal velocity left/right real ( wp ) :: betaL , betaR real ( wp ) :: alphaL , alphaR real ( wp ) :: FmL , FmR real ( wp ) :: Mface real ( wp ) :: Cs real ( wp ) :: Mb real ( wp ) :: Mo real ( wp ) :: fna real ( wp ) :: Pu real ( wp ) :: Mp real ( wp ) :: alfa real ( wp ), parameter :: Kp = 0.25 real ( wp ), parameter :: Ku = 0.75 real ( wp ), parameter :: sigma = 1.0 DebugCall ( 'compute_flux ' // trim ( f_dir )) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( flow % gm / ( flow % gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( flow % gm / ( flow % gm - 1. )) * pR / rR ) ! ---- face normal velocity ---- VnL = uL * faces ( i , j , k )% nx + vL * faces ( i , j , k )% ny + wL * faces ( i , j , k )% nz VnR = uR * faces ( i , j , k )% nx + vR * faces ( i , j , k )% ny + wR * faces ( i , j , k )% nz ! ---- speed of sound ---- cs = sqrt ( 2.0 * ( flow % gm - 1.0 ) * ( 0.5 * ( HL + HR )) / ( flow % gm + 1.0 )) cL = cs * cs / ( max ( cs , VnL )) cR = cs * cs / ( max ( cs , - VnR )) C = min ( cL , CR ) ! ---- Mach at face ---- ML = VnL / C MR = VnR / C Mb = sqrt ( 0.5 * (( VnL * VnL ) + ( VnR * VnR )) / ( C * C )) ! ---- function at face ---- Mo = sqrt ( min ( 1.0 , max ( Mb * Mb , flow % MInf * flow % MInf ))) fna = Mo * ( 2.0 - Mo ) alfa = 3.0 * ( - 4.0 + ( 5.0 * fna * fna )) / 1 6.0 ! ---- switch for supersonic flow ---- alphaL = max ( 0 , 1 - floor ( abs ( ML ))) alphaR = max ( 0 , 1 - floor ( abs ( MR ))) ! Compute '+' direction quantities FmL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL ) * ML ) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) betaL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL )) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) * ( 2.0 - ML ) ! Compute '-' direction quantities FmR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR ) * MR ) - alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) betaR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR )) + alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) * ( 2.0 + MR ) !AUSM+modification ! Compute '+' direction quantities FmL = FmL + alphaL * 0.125 * (( ML ** 2 - 1.0 ) ** 2 ) betaL = betaL + alphaL * alfa * (( ML ** 2 - 1.0 ) ** 2 ) * ML ! Compute '-' direction quantities FmR = FmR - alphaR * 0.125 * (( MR ** 2 - 1.0 ) ** 2 ) betaR = betaR - alphaR * alfa * (( MR ** 2 - 1.0 ) ** 2 ) * MR !AUSM+- modification Pu = - Ku * betaL * betaR * ( rL + rR ) * fna * C * ( VnR - VnL ) Mp = - 2.0 * Kp * max ( 1.0 - ( sigma * Mb * Mb ), 0.0 ) * ( pR - pL ) / ( fna * ( rL + rR ) * C * C ) if ( isnan ( Pu )) then print * , \"Nan:\" , f_qp_left ( i , j , k ,:), f_qp_right ( i , j , k ,:) end if ! mass coefficient Mface = FmL + FmR + Mp ! -- Pressure coeffient-- pbar = betaL * pL + betaR * pR + Pu ! -- mass -- if ( Mface > 0.0 ) then mass = Mface * C * rL else mass = Mface * c * rR end if mass = mass * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) !! -- Turbulence variables mass flux -- if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! total flux Flux ( i , j , k , :) = F_plus (:) + F_minus (:) ! Get the total flux for a face ! -- Pressure flux addition -- Flux ( i , j , K , 2 ) = Flux ( i , j , k , 2 ) + ( pbar * faces ( i , j , k )% nx ) Flux ( i , j , K , 3 ) = Flux ( i , j , k , 3 ) + ( pbar * faces ( i , j , k )% ny ) Flux ( i , j , K , 4 ) = Flux ( i , j , k , 4 ) + ( pbar * faces ( i , j , k )% nz ) Flux ( i , j , k , :) = Flux ( i , j , k , :) * faces ( i , j , k )% A end do end do end do end subroutine compute_flux subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes end module ausmUP","tags":"","loc":"sourcefile/ausmup.f90.html","title":"ausmUP.f90 – FEST-3D"},{"text":"Flux splitting scheme: AUSM+ This file depends on sourcefile~~ausmp.f90~~EfferentGraph sourcefile~ausmp.f90 ausmP.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~ausmp.f90->sourcefile~face_interpolant.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~ausmp.f90->sourcefile~vartypes.f90 sourcefile~face_interpolant.f90->sourcefile~vartypes.f90 sourcefile~weno.f90 weno.f90 sourcefile~face_interpolant.f90->sourcefile~weno.f90 sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~face_interpolant.f90->sourcefile~weno_nm.f90 sourcefile~utils.f90 utils.f90 sourcefile~face_interpolant.f90->sourcefile~utils.f90 sourcefile~ppm.f90 ppm.f90 sourcefile~face_interpolant.f90->sourcefile~ppm.f90 sourcefile~muscl.f90 muscl.f90 sourcefile~face_interpolant.f90->sourcefile~muscl.f90 sourcefile~weno.f90->sourcefile~vartypes.f90 sourcefile~weno_nm.f90->sourcefile~vartypes.f90 sourcefile~ppm.f90->sourcefile~vartypes.f90 sourcefile~muscl.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ausmp.f90~~AfferentGraph sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ausmP Source Code ausmP.f90 Source Code !< Flux splitting scheme: AUSM+ module ausmP !< Flux splitting scheme: AUSM+ module ausmP !< !< Reference: Liou, M. S., “A sequel to AUSM: AUSM+,” !< Journal of Computational Physics, vol. 129, pp. 364–382, 1996 !------------------------------------------------------------------- #include \"../../../debug.h\" #include \"../../../error.h\" use vartypes use face_interpolant , only : x_qp_left , x_qp_right use face_interpolant , only : y_qp_left , y_qp_right use face_interpolant , only : z_qp_left , z_qp_right implicit none private public :: compute_fluxes contains subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at face integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus !< Right flux through the face real ( wp ), dimension ( 1 : dims % n_var ) :: F_minus !< Left flux through  the face real ( wp ) :: pbar real ( wp ) :: mass real ( wp ) :: HL , HR !< Enthalpy real ( wp ) :: uL , uR !< X-component of velocity real ( wp ) :: vL , vR !< Y-component of velocity real ( wp ) :: wL , wR !< Z-component of velocity real ( wp ) :: pL , pR !< Pressure real ( wp ) :: rL , rR !< Density real ( wp ) :: cL , cR !< Speed sound left/right real ( wp ) :: C !< Speed of sound at face real ( wp ) :: ML , MR !< Mach number left/right real ( wp ) :: VnL , VnR !< Face normal velocity left/right real ( wp ) :: betaL , betaR real ( wp ) :: alphaL , alphaR real ( wp ) :: FmL , FmR real ( wp ) :: Mface real ( wp ) :: Cs DebugCall ( 'compute_flux ' // trim ( f_dir )) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( flow % gm / ( flow % gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( flow % gm / ( flow % gm - 1. )) * pR / rR ) ! ---- face normal velocity ---- VnL = uL * faces ( i , j , k )% nx + vL * faces ( i , j , k )% ny + wL * faces ( i , j , k )% nz VnR = uR * faces ( i , j , k )% nx + vR * faces ( i , j , k )% ny + wR * faces ( i , j , k )% nz ! ---- speed of sound ---- cs = sqrt ( 2.0 * ( flow % gm - 1.0 ) * ( 0.5 * ( HL + HR )) / ( flow % gm + 1.0 )) cL = cs * cs / ( max ( cs , abs ( VnL ))) cR = cs * cs / ( max ( cs , abs ( VnR ))) C = min ( cL , CR ) ! ---- Mach at face ---- ML = VnL / C MR = VnR / C ! ---- switch for supersonic flow ---- alphaL = max ( 0 , 1 - floor ( abs ( ML ))) alphaR = max ( 0 , 1 - floor ( abs ( MR ))) ! Compute '+' direction quantities FmL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL ) * ML ) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) betaL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL )) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) * ( 2.0 - ML ) ! Compute '-' direction quantities FmR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR ) * MR ) - alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) betaR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR )) + alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) * ( 2.0 + MR ) !AUSM+modification ! Compute '+' direction quantities FmL = FmL + alphaL * 0.1250 * (( ML ** 2 - 1.0 ) ** 2 ) betaL = betaL + alphaL * 0.1875 * (( ML ** 2 - 1.0 ) ** 2 ) * ML ! Compute '-' direction quantities FmR = FmR - alphaR * 0.1250 * (( MR ** 2 - 1.0 ) ** 2 ) betaR = betaR - alphaR * 0.1875 * (( MR ** 2 - 1.0 ) ** 2 ) * MR ! mass coefficient Mface = FmL + FmR ! -- Pressure coeffient-- pbar = betaL * pL + betaR * pR ! -- mass -- if ( Mface > 0.0 ) then mass = Mface * C * rL else mass = Mface * c * rR end if mass = mass * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) !! -- Turbulence variables mass flux -- if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! total flux Flux ( i , j , k , :) = F_plus (:) + F_minus (:) ! Get the total flux for a face ! -- Pressure flux addition -- Flux ( i , j , K , 2 ) = Flux ( i , j , k , 2 ) + ( pbar * faces ( i , j , k )% nx ) Flux ( i , j , K , 3 ) = Flux ( i , j , k , 3 ) + ( pbar * faces ( i , j , k )% ny ) Flux ( i , j , K , 4 ) = Flux ( i , j , k , 4 ) + ( pbar * faces ( i , j , k )% nz ) Flux ( i , j , k , :) = Flux ( i , j , k , :) * faces ( i , j , k )% A end do end do end do end subroutine compute_flux subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes end module ausmP","tags":"","loc":"sourcefile/ausmp.f90.html","title":"ausmP.f90 – FEST-3D"},{"text":"Flux splitting scheme: AUSM This file depends on sourcefile~~ausm.f90~~EfferentGraph sourcefile~ausm.f90 ausm.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~ausm.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ausm.f90~~AfferentGraph sourcefile~ausm.f90 ausm.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~scheme.f90->sourcefile~ausm.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ausm Source Code ausm.f90 Source Code !< Flux splitting scheme: AUSM module ausm !< !< Reference: Liou, M.S. and Steffen Jr, C.J., A new flux splitting scheme, !< Journal of Computational physics, vol. 107, no. 1, pp.23-39, 1993 !------------------------------------------------------------------- #include \"../../../debug.h\" #include \"../../../error.h\" use vartypes implicit none private public :: compute_fluxes contains subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input-argument direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variables at face integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus , F_minus real ( wp ) :: M_perp_left , M_perp_right real ( wp ) :: alpha_plus , alpha_minus real ( wp ) :: beta_left , beta_right real ( wp ) :: M_plus , M_minus real ( wp ) :: D_plus , D_minus real ( wp ) :: c_plus , c_minus real ( wp ) :: scrD_plus , scrD_minus real ( wp ) :: sound_speed_avg , face_normal_speeds real ( wp ) :: temp_c DebugCall ( 'compute_flux' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( flow % gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( flow % gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_left ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_left ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_right ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_right ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! AUSM modification temp_c = c_plus + c_minus c_plus = max ( 0. , temp_c ) c_minus = min ( 0. , temp_c ) ! F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * faces ( i , j , k )% A F_minus (:) = F_minus (:) * faces ( i , j , k )% A ! Get the total flux for a face Flux ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes end module ausm","tags":"","loc":"sourcefile/ausm.f90.html","title":"ausm.f90 – FEST-3D"},{"text":"Flux-splitting scheme: LDFSS This file depends on sourcefile~~ldfss0.f90~~EfferentGraph sourcefile~ldfss0.f90 ldfss0.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~ldfss0.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ldfss0.f90~~AfferentGraph sourcefile~ldfss0.f90 ldfss0.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~scheme.f90->sourcefile~ldfss0.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ldfss0 Source Code ldfss0.f90 Source Code !< Flux-splitting scheme: LDFSS module ldfss0 !< !< Reference: Edwards, J.R., A low-diffusion flux-splitting scheme !< for Navier-Stokes calculations, Computers & Fluids, vol. 26, !< no. 6, pp.635-659, 1997 !------------------------------------------------------------------- #include \"../../../debug.h\" #include \"../../../error.h\" use vartypes implicit none private public :: compute_fluxes contains subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input-argument direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at face integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus , F_minus real ( wp ) :: M_perp_left , M_perp_right real ( wp ) :: alpha_plus , alpha_minus real ( wp ) :: beta_left , beta_right real ( wp ) :: M_plus , M_minus real ( wp ) :: D_plus , D_minus real ( wp ) :: c_plus , c_minus real ( wp ) :: scrD_plus , scrD_minus real ( wp ) :: sound_speed_avg , face_normal_speeds real ( wp ) :: M_ldfss , M_plus_ldfss , M_minus_ldfss DebugCall ( 'compute_flux' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( flow % gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( flow % gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_left ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_left ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_right ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_right ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! LDFSS0 modification M_ldfss = 0.25 * beta_left * beta_right * & ( sqrt (( M_perp_left ** 2 + M_perp_right ** 2 ) * 0.5 ) & - 1 ) ** 2 M_plus_ldfss = M_ldfss * & ( 1 - ( f_qp_left ( i , j , k , 5 ) - f_qp_right ( i , j , k , 5 )) / & ( 2 * f_qp_left ( i , j , k , 1 ) * ( sound_speed_avg ** 2 ))) M_minus_ldfss = M_ldfss * & ( 1 - ( f_qp_left ( i , j , k , 5 ) - f_qp_right ( i , j , k , 5 )) / & ( 2 * f_qp_right ( i , j , k , 1 ) * ( sound_speed_avg ** 2 ))) c_plus = c_plus - M_plus_ldfss c_minus = c_minus + M_minus_ldfss ! F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * faces ( i , j , k )% A F_minus (:) = F_minus (:) * faces ( i , j , k )% A ! Get the total flux for a face Flux ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes end module ldfss0","tags":"","loc":"sourcefile/ldfss0.f90.html","title":"ldfss0.f90 – FEST-3D"},{"text":"Higher order face state reconstruction method: MUSCL. This file depends on sourcefile~~muscl.f90~~EfferentGraph sourcefile~muscl.f90 muscl.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~muscl.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~muscl.f90~~AfferentGraph sourcefile~muscl.f90 muscl.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~face_interpolant.f90->sourcefile~muscl.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~ausmp.f90->sourcefile~face_interpolant.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 var pansourcefilemusclf90AfferentGraph = svgPanZoom('#sourcefilemusclf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules muscl Source Code muscl.f90 Source Code !< Higher order face state reconstruction method: MUSCL. module muscl !< !<Reference:Hirsch, C., Numerical computation of internal !<and external flows: The fundamentals of computational fluid !<dynamics, Elsevier, 2007 !< !< MUSCL (Monotone Upwing Schemes for Scalar Conservation Laws is !< a scheme which replaces the piecewise constant approximation by !< reconstructing the states at the left and right side of each face. !< This is a one parameter upwind scheme which results in at most 3rd !< order accuracy. ! ! The MUSCL scheme alone creates non-physical oscillations near ! discontinuities like shocks. Hence, MUSCL is combined with ! some TVD (Total Variation Diminishing) to reduce such oscillations. ! TVD schemes also ensure that no new extrema of the state variables ! is created at the faces. !----------------------------------------------------------------- #include \"../../error.h\" #include \"../../debug.h\" use vartypes implicit none private real ( wp ) :: phi = 1.0 , kappa = 1. / 3. integer :: switch_L = 1 !< Limiter switch ! Public members public :: compute_muscl_states contains subroutine pressure_based_switching ( qp , f_qp_left , f_qp_right , pdif , flags , flow , dims ) !< Pressure based switching. !< User x,y, or z for I,J,or K face respectively !---------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive variable at cell faces real ( wp ), dimension ( 0 : dims % imx , 0 : dims % jmx , 0 : dims % kmx ), intent ( inout ) :: pdif !< pressure difference integer :: i , j , k , i_end , j_end , k_end integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ) :: pd2 DebugCall ( 'pressure_based_switching' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) i_end = dims % imx - 1 + i_f j_end = dims % jmx - 1 + j_f k_end = dims % kmx - 1 + k_f ! i_end and j_end denote number of faces ! Total number of cells including ghost_cells is ! (i_end+1) * j_end for xi faces and i_end*(j_end+1) for ! eta faces. ! Loop over cells (physical) do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 pd2 = abs ( qp ( i + i_f * 1 , j + j_f * 1 , k + k_f * 1 , 5 ) - & !pressure qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , 5 )) pdif ( i , j , k ) = 1 - ( pd2 / ( pd2 + flow % pressure_inf )) end do end do end do ! Update at ghost cells pdif (( 1 - i_f ):( 1 - i_f ) * ( dims % imx - 1 ), ( 1 - j_f ):( 1 - j_f ) * ( dims % jmx - 1 ), & ( 1 - k_f ):( 1 - k_f ) * ( dims % kmx - 1 )) = & pdif ( 1 : dims % imx - 1 - i_f * ( dims % imx - 2 ), 1 : dims % jmx - 1 - j_f * ( dims % jmx - 2 ), & 1 : dims % kmx - 1 - k_f * ( dims % kmx - 2 )) pdif (( 1 - i_f * ( - dims % imx + 1 )):( i_f ) + ( dims % imx - 1 ), ( 1 - j_f * ( - dims % jmx + 1 )):( j_f ) + ( dims % jmx - 1 ), & ( 1 - k_f * ( - dims % kmx + 1 )):( k_f ) + ( dims % kmx - 1 )) = & pdif ( 1 + i_f * ( dims % imx - 2 ): dims % imx - 1 , 1 + j_f * ( dims % jmx - 2 ): dims % jmx - 1 , & 1 + k_f * ( dims % kmx - 2 ): dims % kmx - 1 ) ! Loop over faces do k = 1 , dims % kmx - ( 1 - k_f ) do j = 1 , dims % jmx - ( 1 - j_f ) do i = 1 , dims % imx - ( 1 - i_f ) f_qp_left ( i , j , k , :) = qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :) + (& pdif ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 ) * ( & f_qp_left ( i , j , k , :) - qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :))) f_qp_right ( i , j , k , :) = qp ( i , j , k , :) - (& pdif ( i , j , k ) * ( & qp ( i , j , k , :) - f_qp_right ( i , j , k , :))) end do end do end do end subroutine pressure_based_switching subroutine compute_face_state ( qp , f_qp_left , f_qp_right , flags , lam_switch , turb_switch , dims ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< Flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive variable at cell faces integer , intent ( in ) :: lam_switch !< Limiter switch for laminar variables integer , intent ( in ) :: turb_switch !< Limiter switch for turbulent variables integer :: i , j , k , l !< integer used for DO loop integer :: ii , jj , kk !< Variable for ALFA family limiter real ( wp ) :: alpha !< Flags to determine face direction real ( wp ) :: psi1 , psi2 !< limiters real ( wp ) :: fd !< forward difference real ( wp ) :: bd !< backward difference real ( wp ) :: r !< ratio of differences DebugCall ( 'compute_face_state' ) alpha = 2. / 3. !Koren limiter phi = 1.0 kappa = 1. / 3. switch_L = lam_switch ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) do l = 1 , dims % n_var if ( l >= 6 ) then switch_L = turb_switch end if do k = 1 - kk , dims % kmx - 1 + kk do j = 1 - jj , dims % jmx - 1 + jj do i = 1 - ii , dims % imx - 1 + ii ! Cell based ! Koren limiter for now ! From paper: delta: forward difference 'fd' !             nabla: backward difference 'bd' fd = qp ( i + ii , j + jj , k + kk , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - ii , j - jj , k - kk , l ) r = fd / max ( bd , 1 e - 10 ) psi1 = max ( 0. , min ( 2 * r , alpha * ( r - 1.0 ) + 1.0 , 2. )) !alpha limiter !                psi1 = max(0., min(2*r,1.), min(r,2.))    ! superbee !                psi1 = ((r*r) + r)/((r*r) + 1.0)          ! Van-Albda !                psi1 = (abs(r) + r)/(abs(r) + 1.0)          ! Van-Leer r = bd / max ( fd , 1 e - 10 ) psi2 = max ( 0. , min ( 2 * r , alpha * ( r - 1.0 ) + 1.0 , 2. )) !                psi2 = max(0., min(2*r,1.), min(r,2.)) !                psi2 = ((r*r) + r)/((r*r) + 1.0)          ! Van-Albda !                psi2 = (abs(r) + r)/(abs(r) + 1.0)          ! Van-Leer psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) f_qp_left ( i + ii , j + jj , k + kk , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) f_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end subroutine compute_face_state subroutine compute_muscl_states ( qp , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , pdif , scheme , flow , dims ) !< Implement MUSCL scheme to get left and right states at !< each face. The computation is done through all cells !< and first level ghost cells !--------------------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face real ( wp ), dimension ( 0 : dims % imx , 0 : dims % jmx , 0 : dims % kmx ), intent ( inout ) :: pdif !< pressure difference type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. integer , dimension ( 3 ) :: flags !< Flags for direction flags = ( / 1 , 0 , 0 / ) call compute_face_state ( qp , x_qp_l , x_qp_r , flags , scheme % ilimiter_switch , scheme % itlimiter_switch , dims ) if ( scheme % iPB_switch == 1 ) then call pressure_based_switching ( qp , x_qp_l , x_qp_r , pdif , flags , flow , dims ) end if flags = ( / 0 , 1 , 0 / ) call compute_face_state ( qp , y_qp_l , y_qp_r , flags , scheme % jlimiter_switch , scheme % jtlimiter_switch , dims ) if ( scheme % jPB_switch == 1 ) then call pressure_based_switching ( qp , y_qp_l , y_qp_r , pdif , flags , flow , dims ) end if flags = ( / 0 , 0 , 1 / ) call compute_face_state ( qp , z_qp_l , z_qp_r , flags , scheme % klimiter_switch , scheme % ktlimiter_switch , dims ) if ( scheme % kPB_switch == 1 ) then call pressure_based_switching ( qp , z_qp_l , z_qp_r , pdif , flags , flow , dims ) end if end subroutine compute_muscl_states end module muscl","tags":"","loc":"sourcefile/muscl.f90.html","title":"muscl.f90 – FEST-3D"},{"text":"Higher face state reconstuction method: WENO This file depends on sourcefile~~weno.f90~~EfferentGraph sourcefile~weno.f90 weno.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~weno.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~weno.f90~~AfferentGraph sourcefile~weno.f90 weno.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~face_interpolant.f90->sourcefile~weno.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~ausmp.f90->sourcefile~face_interpolant.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 var pansourcefilewenof90AfferentGraph = svgPanZoom('#sourcefilewenof90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules weno Source Code weno.f90 Source Code !< Higher face state reconstuction method: WENO module weno !< !< Reference: 1 Shu, C.-W., “High-order Finite Difference and Finite Volume !< WENO Schemes and Discontinuous Galerkin Methods for CFD,” !< International Journal of Computational Fluid Dynamics, vol. 17, 2003, pp. 107–118. !< Reference: 2 Huang, W. F., Ren, Y. X., and Jiang, X., !<“A simple algorithm to improve the performance of the WENO scheme on non-uniform grids,” !<Acta Mechanica Sinica/Lixue Xuebao, 2017, pp. 1–11. !----------------------------------------------------------------- #include \"../../debug.h\" use vartypes implicit none private ! Public members public :: compute_weno_states contains subroutine compute_face_states ( qp , f_qp_left , f_qp_right , flags , dims ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive state variable at faces integer :: i , j , k , l integer :: i_f = 0 , j_f = 0 , k_f = 0 real ( wp ), dimension ( 3 ) :: P !< polynomial approximation real ( wp ), dimension ( 3 ) :: B !< smoothness factor real ( wp ), dimension ( 3 ) :: w !< wieght real ( wp ), dimension ( 3 ) :: g !< linear wieght real ( wp ), dimension ( - 2 : 2 ) :: u !< state_variable real ( wp ) :: eps = 1 e - 6 g ( 1 ) = 1.0 / 1 0.0 g ( 2 ) = 6.0 / 1 0.0 g ( 3 ) = 3.0 / 1 0.0 i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do l = 1 , dims % n_var do k = 1 - k_f , dims % kmx - 1 + k_f do j = 1 - j_f , dims % jmx - 1 + j_f do i = 1 - i_f , dims % imx - 1 + i_f U ( - 2 ) = qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , l ) !u_{i-2} U ( - 1 ) = qp ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f , l ) !u_{i-1} u ( 0 ) = qp ( i , j , k , l ) !u_{i} U ( 1 ) = qp ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f , l ) !u_{i+1} U ( 2 ) = qp ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f , l ) !u_{i+2} P ( 1 ) = ( 2.0 * U ( - 2 ) - 7.0 * U ( - 1 ) + 1 1.0 * U ( 0 )) / 6.0 P ( 2 ) = ( - 1.0 * U ( - 1 ) + 5.0 * U ( 0 ) + 2.0 * U ( 1 )) / 6.0 P ( 3 ) = ( 2.0 * U ( 0 ) + 5.0 * U ( 1 ) - 1.0 * U ( 2 )) / 6.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( U ( - 2 ) - 2.0 * U ( - 1 ) + U ( 0 )) ** 2 + ( 1.0 / 4.0 ) * ( U ( - 2 ) - 4.0 * U ( - 1 ) + 3.0 * U ( 0 )) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( U ( - 1 ) - 2.0 * U ( 0 ) + U ( 1 )) ** 2 + ( 1.0 / 4.0 ) * ( U ( - 1 ) - U ( 1 )) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( U ( 0 ) - 2.0 * U ( 1 ) + U ( 2 )) ** 2 + ( 1.0 / 4.0 ) * ( 3.0 * U ( 0 ) - 4.0 * U ( 1 ) + U ( 2 )) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = SUM ( w * P ) / SUM ( w ) P ( 1 ) = ( 2.0 * U ( 2 ) - 7.0 * U ( 1 ) + 1 1.0 * U ( 0 )) / 6.0 P ( 2 ) = ( - 1.0 * U ( 1 ) + 5.0 * U ( 0 ) + 2.0 * U ( - 1 )) / 6.0 P ( 3 ) = ( 2.0 * U ( 0 ) + 5.0 * U ( - 1 ) - 1.0 * U ( - 2 )) / 6.0 !B(1) = (13.0/12.0)*(U( 2)-2.0*U( 1)+U( 0))**2 + (1.0/4.0)*(    U(2)-4.0*U( 1)+3.0*U( 0))**2 !B(2) = (13.0/12.0)*(U( 1)-2.0*U( 0)+U(-1))**2 + (1.0/4.0)*(    U(1)-              U(-1))**2 !B(3) = (13.0/12.0)*(U( 0)-2.0*U(-1)+U(-2))**2 + (1.0/4.0)*(3.0*U(0)-4.0*U(-1)+    U(-2))**2 w ( 1 ) = g ( 1 ) / ( eps + B ( 3 )) ** 2 w ( 2 ) = g ( 2 ) / ( eps + B ( 2 )) ** 2 w ( 3 ) = g ( 3 ) / ( eps + B ( 1 )) ** 2 f_qp_right ( i , j , k , l ) = SUM ( w * P ) / SUM ( w ) end do end do end do end do end subroutine compute_face_states subroutine compute_weno_states ( qp , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , dims ) !< Call Weno scheme for all the three direction I,J, and K implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face integer , dimension ( 3 ) :: flags !< flags for different direction flags = ( / 1 , 0 , 0 / ) call compute_face_states ( qp , x_qp_l , x_qp_r , flags , dims ) flags = ( / 0 , 1 , 0 / ) call compute_face_states ( qp , y_qp_l , y_qp_r , flags , dims ) flags = ( / 0 , 0 , 1 / ) call compute_face_states ( qp , z_qp_l , z_qp_r , flags , dims ) end subroutine compute_weno_states end module weno","tags":"","loc":"sourcefile/weno.f90.html","title":"weno.f90 – FEST-3D"},{"text":"Higher face state reconstuction method: WENO for non uniform grids This file depends on sourcefile~~weno_nm.f90~~EfferentGraph sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~weno_nm.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~weno_nm.f90~~AfferentGraph sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~face_interpolant.f90->sourcefile~weno_nm.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~ausmp.f90->sourcefile~face_interpolant.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 var pansourcefileweno_nmf90AfferentGraph = svgPanZoom('#sourcefileweno_nmf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules weno_NM Source Code weno_NM.f90 Source Code !< Higher face state reconstuction method: WENO for non uniform grids module weno_NM !< !<Reference: 2 Huang, W. F., Ren, Y. X., and Jiang, X., !<“A simple algorithm to improve the performance of the WENO scheme on non-uniform grids,” !<Acta Mechanica Sinica/Lixue Xuebao, 2017, pp. 1–11. !----------------------------------------------------------------- #include \"../../debug.h\" use vartypes implicit none private ! Public members public :: compute_weno_NM_states contains subroutine compute_face_states ( qp , f_qp_left , f_qp_right , flags , cells , dims ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive state at faces type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume integer :: i , j , k , l integer :: i_f = 0 , j_f = 0 , k_f = 0 real ( wp ), dimension ( 3 ) :: P !< polynomial approximation real ( wp ), dimension ( 3 ) :: B !< smoothness factor real ( wp ), dimension ( 3 ) :: w !< wieght real ( wp ), dimension ( 3 ) :: g !< linear wieght real ( wp ), dimension ( - 2 : 2 ) :: u !<state_variable real ( wp ) :: eps = 1 e - 6 real ( wp ), dimension ( - 2 : 2 ) :: vol real ( wp ) :: U11 real ( wp ) :: U00 real ( wp ) :: U21 real ( wp ) :: U10 real ( wp ) :: U01 real ( wp ) :: U12 real ( wp ) :: alpha12 real ( wp ) :: alpha01 real ( wp ) :: alpha10 real ( wp ) :: alpha21 g ( 1 ) = 1.0 / 1 0.0 g ( 2 ) = 6.0 / 1 0.0 g ( 3 ) = 3.0 / 1 0.0 i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do l = 1 , dims % n_var do k = 1 - k_f , dims % kmx - 1 + k_f do j = 1 - j_f , dims % jmx - 1 + j_f do i = 1 - i_f , dims % imx - 1 + i_f U ( - 2 ) = qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , l ) !u_{i-2} U ( - 1 ) = qp ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f , l ) !u_{i-1} u ( 0 ) = qp ( i , j , k , l ) !u_{i} U ( 1 ) = qp ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f , l ) !u_{i+1} U ( 2 ) = qp ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f , l ) !u_{i+2} Vol ( - 2 ) = cells ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f )% volume !volume_{i-2} Vol ( - 1 ) = cells ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f )% volume !volume_{i-1} Vol ( 0 ) = cells ( i , j , k )% volume !volume_{i} Vol ( 1 ) = cells ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f )% volume !volume_{i+1} Vol ( 2 ) = cells ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f )% volume !volume_{i+2} alpha12 = Vol ( 2 ) / ( Vol ( 1 ) + Vol ( 2 )) alpha01 = Vol ( 1 ) / ( Vol ( 0 ) + Vol ( 1 )) alpha10 = Vol ( 0 ) / ( Vol ( - 1 ) + Vol ( 0 )) alpha21 = vol ( - 1 ) / ( Vol ( - 2 ) + Vol ( - 1 )) U01 = ( 1.0 - alpha01 ) * U ( 0 ) + alpha01 * U ( 1 ) U12 = ( 1.0 - alpha12 ) * U ( 1 ) + alpha12 * U ( 2 ) U10 = ( 1.0 - alpha10 ) * U ( - 1 ) + alpha10 * U ( 0 ) U21 = ( 1.0 - alpha21 ) * U ( - 2 ) + alpha21 * U ( - 1 ) U00 = U ( - 1 ) + ( 1.0 - alpha21 ) * ( U ( - 1 ) - U ( - 2 )) U11 = U ( 1 ) + alpha12 * ( U ( 1 ) - U ( 2 )) P ( 1 ) = ( 6.0 * U ( 0 ) - 1.0 * U10 - 2.0 * U00 ) / 3.0 P ( 2 ) = ( - 1.0 * U10 + 2.0 * U ( 0 ) + 2.0 * U01 ) / 3.0 P ( 3 ) = ( 2.0 * U01 + 2.0 * U ( 1 ) - 1.0 * U12 ) / 3.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 2.0 * U00 ) ** 2 + ( 1.0 / 4.0 ) * ( 4 * U ( 0 ) - 2.0 * U10 - 2.0 * U00 ) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 4.0 * U ( 0 ) + 2 * U01 ) ** 2 + ( 1.0 / 4.0 ) * ( - 2 * u10 + 2.0 * U01 ) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 4.0 * U ( 1 ) + 2 * U12 ) ** 2 + ( 1.0 / 4.0 ) * ( - 6 * U01 + 8.0 * U ( 1 ) - 2.0 * U12 ) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = SUM ( w * P ) / SUM ( w ) P ( 1 ) = ( 6.0 * U ( 0 ) - 1.0 * U01 - 2.0 * U11 ) / 3.0 P ( 2 ) = ( - 1.0 * U01 + 2.0 * U ( 0 ) + 2.0 * U10 ) / 3.0 P ( 3 ) = ( 2.0 * U10 + 2.0 * U ( - 1 ) - 1.0 * U21 ) / 3.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 2.0 * U11 ) ** 2 + ( 1.0 / 4.0 ) * ( 4 * U ( 0 ) - 2.0 * U01 - 2.0 * U11 ) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 4.0 * U ( 0 ) + 2 * U10 ) ** 2 + ( 1.0 / 4.0 ) * ( - 2 * u01 + 2.0 * U10 ) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 4.0 * U ( - 1 ) + 2 * U21 ) ** 2 + ( 1.0 / 4.0 ) * ( - 6 * U10 + 8.0 * U ( - 1 ) - 2.0 * U21 ) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_right ( i , j , k , l ) = SUM ( w * P ) / SUM ( w ) end do end do end do end do end subroutine compute_face_states subroutine compute_weno_NM_states ( qp , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , cells , dims ) !< Call Weno scheme for all the three direction I,J, and K implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells integer , dimension ( 3 ) :: flags !< flags for different directions flags = ( / 1 , 0 , 0 / ) call compute_face_states ( qp , x_qp_l , x_qp_r , flags , cells , dims ) flags = ( / 0 , 1 , 0 / ) call compute_face_states ( qp , y_qp_l , y_qp_r , flags , cells , dims ) flags = ( / 0 , 0 , 1 / ) call compute_face_states ( qp , z_qp_l , z_qp_r , flags , cells , dims ) end subroutine compute_weno_NM_states end module weno_NM","tags":"","loc":"sourcefile/weno_nm.f90.html","title":"weno_NM.f90 – FEST-3D"},{"text":"Interpolation of primitive variable from cell centers to faces This file depends on sourcefile~~face_interpolant.f90~~EfferentGraph sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~face_interpolant.f90->sourcefile~weno_nm.f90 sourcefile~muscl.f90 muscl.f90 sourcefile~face_interpolant.f90->sourcefile~muscl.f90 sourcefile~utils.f90 utils.f90 sourcefile~face_interpolant.f90->sourcefile~utils.f90 sourcefile~ppm.f90 ppm.f90 sourcefile~face_interpolant.f90->sourcefile~ppm.f90 sourcefile~weno.f90 weno.f90 sourcefile~face_interpolant.f90->sourcefile~weno.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~face_interpolant.f90->sourcefile~vartypes.f90 sourcefile~weno_nm.f90->sourcefile~vartypes.f90 sourcefile~muscl.f90->sourcefile~vartypes.f90 sourcefile~ppm.f90->sourcefile~vartypes.f90 sourcefile~weno.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~face_interpolant.f90~~AfferentGraph sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~ausmp.f90->sourcefile~face_interpolant.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 var pansourcefileface_interpolantf90AfferentGraph = svgPanZoom('#sourcefileface_interpolantf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules face_interpolant Source Code face_interpolant.f90 Source Code !< Interpolation of primitive variable from cell centers to faces module face_interpolant !< Interpolation of primitive variable from cell centers to faces #include \"../../debug.h\" #include \"../../error.h\" use vartypes use utils , only : alloc use muscl , only : compute_muscl_states use ppm , only : compute_ppm_states use weno , only : compute_weno_states use weno_NM , only : compute_weno_NM_states implicit none private real ( wp ), dimension (:, :, :, :), allocatable , target :: x_qp_left , x_qp_right !< Store primitive state at the I-face real ( wp ), dimension (:, :, :, :), allocatable , target :: y_qp_left , y_qp_right !< Store primitive state at the J-face real ( wp ), dimension (:, :, :, :), allocatable , target :: z_qp_left , z_qp_right !< Store primitive state at the K-face real ( wp ), dimension (:, :, :), allocatable :: pdif !< pressure difference !< Used for pressure based witch ! Public members public :: setup_interpolant_scheme public :: compute_face_interpolant public :: x_qp_left , x_qp_right public :: y_qp_left , y_qp_right public :: z_qp_left , z_qp_right public :: pdif contains subroutine setup_interpolant_scheme ( dims ) implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx call alloc ( x_qp_left , 0 , dims % imx + 1 , 1 , dims % jmx - 1 , 1 , dims % kmx - 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for x_qp_left.' ) call alloc ( x_qp_right , 0 , dims % imx + 1 , 1 , dims % jmx - 1 , 1 , dims % kmx - 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for x_qp_right.' ) call alloc ( y_qp_left , 1 , dims % imx - 1 , 0 , dims % jmx + 1 , 1 , dims % kmx - 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for y_qp_left.' ) call alloc ( y_qp_right , 1 , dims % imx - 1 , 0 , dims % jmx + 1 , 1 , dims % kmx - 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for y_qp_right.' ) call alloc ( z_qp_left , 1 , dims % imx - 1 , 1 , dims % jmx - 1 , 0 , dims % kmx + 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for z_qp_left.' ) call alloc ( z_qp_right , 1 , dims % imx - 1 , 1 , dims % jmx - 1 , 0 , dims % kmx + 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for z_qp_right.' ) call alloc ( pdif , 0 , dims % imx , 0 , dims % jmx , 0 , dims % kmx , & errmsg = 'Error: Unable to allocate memory for pdif' ) end subroutine setup_interpolant_scheme subroutine extrapolate_cell_averages_to_faces ( qp , dims ) implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center DebugCall ( 'extrapolate_cell_averages_to_faces' ) x_qp_left (:, :, :, :) = qp ( - 1 : dims % imx , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ) x_qp_right (:, :, :, :) = qp ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ) y_qp_left (:, :, :, :) = qp ( 1 : dims % imx - 1 , - 1 : dims % jmx , 1 : dims % kmx - 1 , 1 : dims % n_var ) y_qp_right (:, :, :, :) = qp ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ) z_qp_left (:, :, :, :) = qp ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , - 1 : dims % kmx , 1 : dims % n_var ) z_qp_right (:, :, :, :) = qp ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ) end subroutine extrapolate_cell_averages_to_faces subroutine compute_face_interpolant ( qp , cells , scheme , flow , dims ) implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Cell center quantities: volume, cellCenter type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. select case ( scheme % interpolant ) case ( \"none\" ) call extrapolate_cell_averages_to_faces ( qp , dims ) case ( \"ppm\" ) call compute_ppm_states ( qp , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , pdif , scheme , flow , dims ) case ( \"muscl\" ) call compute_muscl_states ( qp , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , pdif , scheme , flow , dims ) case ( \"weno\" ) call compute_weno_states ( qp , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , dims ) case ( \"weno_NM\" ) call compute_weno_NM_states ( qp , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , cells , dims ) case default Fatal_error end select end subroutine compute_face_interpolant end module face_interpolant","tags":"","loc":"sourcefile/face_interpolant.f90.html","title":"face_interpolant.f90 – FEST-3D"},{"text":"Higher order face state reconstruction method:PPM This file depends on sourcefile~~ppm.f90~~EfferentGraph sourcefile~ppm.f90 ppm.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~ppm.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ppm.f90~~AfferentGraph sourcefile~ppm.f90 ppm.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~face_interpolant.f90->sourcefile~ppm.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~face_interpolant.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~face_interpolant.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~scheme.f90 scheme.f90 sourcefile~update.f90->sourcefile~scheme.f90 sourcefile~scheme.f90->sourcefile~face_interpolant.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~scheme.f90->sourcefile~ausmp.f90 sourcefile~ausmp.f90->sourcefile~face_interpolant.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 var pansourcefileppmf90AfferentGraph = svgPanZoom('#sourcefileppmf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ppm Source Code ppm.f90 Source Code !< Higher order face state reconstruction method:PPM module ppm !< !<Reference: Colella, P. and Woodward, P.R., The piecewise !<parabolic method (PPM) for gas-dynamical simulations, Journal !<of computational physics, vol. 54, no. 1, pp.174-201, 1984 !------------------------------------------------------------------- use vartypes #include \"../../debug.h\" #include \"../../error.h\" implicit none private ! Public members public :: compute_ppm_states contains subroutine compute_face_estimates ( qp , f_qp_left , f_qp_right , flags , dims ) !< Subroutine to calculate state at the face, generalized for implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< Flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ),& 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive state at faces integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction DebugCall ( 'compute_face_estimates' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) ! Interior faces do k = ( 1 - k_f ), dims % kmx - 1 + 2 * k_f do j = ( 1 - j_f ), dims % jmx - 1 + 2 * j_f do i = ( 1 - i_f ), dims % imx - 1 + 2 * i_f f_qp_left ( i , j , k , :) = ( 7. * ( qp ( i , j , k , :) + & qp ( i - i_f , j - j_f , k - k_f , :)) - ( qp ( i + i_f , j + j_f , k + k_f , :) + & qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , :))) / 1 2. end do end do end do f_qp_right = f_qp_left end subroutine compute_face_estimates subroutine remove_extrema ( qp , f_qp_left , f_qp_right , flags , dims ) !< Remove extrema from the state estimated. !< Limiting the value in case of PPM implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ),& 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at faces integer :: i , j , k , l integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ) :: dqrl , dq6 DebugCall ( 'remove_extrema' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) ! Loop over cells (including ghost cells) do l = 1 , dims % n_var do k = 1 - k_f , dims % kmx - 1 + k_f do j = 1 - j_f , dims % jmx - 1 + j_f do i = 1 - i_f , dims % imx - 1 + i_f if (( f_qp_left ( i + i_f , j + j_f , k + k_f , l ) - qp ( i , j , k , l )) * & ( qp ( i , j , k , l ) - f_qp_right ( i , j , k , l )) <= 0 ) then f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = qp ( i , j , k , l ) f_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) else dqrl = f_qp_left ( i + i_f , j + j_f , k + k_f , l ) - f_qp_right ( i , j , k , l ) dq6 = 6. * ( qp ( i , j , k , l ) - 0.5 * ( f_qp_left ( i + i_f , j + j_f , k + k_f , l ) + & f_qp_right ( i , j , k , l ))) if ( dqrl * dq6 > dqrl * dqrl ) then f_qp_right ( i , j , k , l ) = 3. * qp ( i , j , k , l ) - & 2. * f_qp_left ( i + i_f , j + j_f , k + k_f , l ) else if ( - dqrl * dqrl > dqrl * dq6 ) then f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = 3. * qp ( i , j , k , l ) - & 2. * f_qp_right ( i , j , k , l ) end if end if end do end do end do end do end subroutine remove_extrema subroutine pressure_based_switching ( qp , f_qp_left , f_qp_right , pdif , flags , flow , dims ) !< Pressure based switching. !< User x,y, or z for I,J,or K face respectively !---------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ),& 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive state at faces real ( wp ), dimension ( 0 : dims % imx , 0 : dims % jmx , 0 : dims % kmx ), intent ( inout ) :: pdif !< pressure difference type ( flowtype ), intent ( in ) :: flow ! Character can be x or y or z integer :: i , j , k , i_end , j_end , k_end integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ) :: pd2 DebugCall ( 'pressure_based_switching' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) i_end = dims % imx - 1 + i_f j_end = dims % jmx - 1 + j_f k_end = dims % kmx - 1 + k_f ! i_end and j_end denote number of faces ! Total number of cells including ghost_cells is ! (i_end+1) * j_end for xi faces and i_end*(j_end+1) for ! eta faces. ! Loop over cells (physical) do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 pd2 = abs ( qp ( i + i_f * 1 , j + j_f * 1 , k + k_f * 1 , 5 ) - & qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , 5 )) pdif ( i , j , k ) = 1 - ( pd2 / ( pd2 + flow % pressure_inf )) end do end do end do ! Update at ghost cells pdif (( 1 - i_f ):( 1 - i_f ) * ( dims % imx - 1 ), ( 1 - j_f ):( 1 - j_f ) * ( dims % jmx - 1 ), & ( 1 - k_f ):( 1 - k_f ) * ( dims % kmx - 1 )) = & pdif ( 1 : dims % imx - 1 - i_f * ( dims % imx - 2 ), 1 : dims % jmx - 1 - j_f * ( dims % jmx - 2 ), & 1 : dims % kmx - 1 - k_f * ( dims % kmx - 2 )) pdif ((( dims % imx - 1 ) * i_f ) + 1 : dims % imx - 1 + i_f , & (( dims % jmx - 1 ) * j_f ) + 1 : dims % jmx - 1 + j_f , & (( dims % kmx - 1 ) * k_f ) + 1 : dims % kmx - 1 + k_f ) & = & pdif ( i_f * ( dims % imx - 2 ) + 1 : dims % imx - 1 , & j_f * ( dims % jmx - 2 ) + 1 : dims % jmx - 1 , & k_f * ( dims % kmx - 2 ) + 1 : dims % kmx - 1 ) ! Loop over faces do k = 1 , dims % kmx - ( 1 - k_f ) do j = 1 , dims % jmx - ( 1 - j_f ) do i = 1 , dims % imx - ( 1 - i_f ) f_qp_left ( i , j , k , :) = qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :) + (& pdif ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 ) * ( & f_qp_left ( i , j , k , :) - qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :))) f_qp_right ( i , j , k , :) = qp ( i , j , k , :) - (& pdif ( i , j , k ) * ( & qp ( i , j , k , :) - f_qp_right ( i , j , k , :))) end do end do end do end subroutine pressure_based_switching subroutine compute_ppm_states ( qp , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , pdif , scheme , flow , dims ) !< Call PPM face-state reconstruction for each face !< with optional call for remove extrema based on !< input limter switch and call pressure based switching !< based on input pressure based switch implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face real ( wp ), dimension ( 0 : dims % imx , 0 : dims % jmx , 0 : dims % kmx ), intent ( inout ) :: pdif !< pressure difference type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. integer , dimension ( 3 ) :: flags !< flags for different directions flags = ( / 1 , 0 , 0 / ) call compute_face_estimates ( qp , x_qp_l , x_qp_r , flags , dims ) if ( scheme % ilimiter_switch == 1 ) then call remove_extrema ( qp , x_qp_l , x_qp_r , flags , dims ) end if if ( scheme % iPB_switch == 1 ) then call pressure_based_switching ( qp , x_qp_l , x_qp_r , pdif , flags , flow , dims ) end if flags = ( / 0 , 1 , 0 / ) call compute_face_estimates ( qp , y_qp_l , y_qp_r , flags , dims ) if ( scheme % jlimiter_switch == 1 ) then call remove_extrema ( qp , y_qp_l , y_qp_r , flags , dims ) end if if ( scheme % jPB_switch == 1 ) then call pressure_based_switching ( qp , y_qp_l , y_qp_r , pdif , flags , flow , dims ) end if flags = ( / 0 , 0 , 1 / ) call compute_face_estimates ( qp , z_qp_l , z_qp_r , flags , dims ) if ( scheme % klimiter_switch == 1 ) then call remove_extrema ( qp , z_qp_l , z_qp_r , flags , dims ) end if if ( scheme % kPB_switch == 1 ) then call pressure_based_switching ( qp , z_qp_l , z_qp_r , pdif , flags , flow , dims ) end if end subroutine compute_ppm_states end module ppm","tags":"","loc":"sourcefile/ppm.f90.html","title":"ppm.f90 – FEST-3D"},{"text":"Setup boundary condition for the domain This file depends on sourcefile~~bc.f90~~EfferentGraph sourcefile~bc.f90 bc.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~utils.f90 utils.f90 sourcefile~bc.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~bc.f90->sourcefile~vartypes.f90 sourcefile~read_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~bc.f90~~AfferentGraph sourcefile~bc.f90 bc.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules bc Source Code bc.f90 Source Code !< Setup boundary condition for the domain module bc !< Setup boundary condition for the domain !------------------------------------------- use vartypes use utils , only : alloc use read_bc , only : read_fixed_values implicit none private public :: setup_bc contains subroutine setup_bc ( files , scheme , flow , bc , dims ) !< Initialization and allocate memory of boundary condition variables implicit none type ( filetype ), intent ( in ) :: files type ( schemetype ), intent ( in ) :: scheme type ( flowtype ), intent ( in ) :: flow type ( boundarytype ), intent ( inout ) :: bc type ( extent ), intent ( in ) :: dims !check for periodic bc if ( bc % PbcId ( 1 ) >= 0 ) bc % imin_id =- 10 if ( bc % PbcId ( 2 ) >= 0 ) bc % imax_id =- 10 if ( bc % PbcId ( 3 ) >= 0 ) bc % jmin_id =- 10 if ( bc % PbcId ( 4 ) >= 0 ) bc % jmax_id =- 10 if ( bc % PbcId ( 5 ) >= 0 ) bc % kmin_id =- 10 if ( bc % PbcId ( 6 ) >= 0 ) bc % kmax_id =- 10 ! assign name to each face bc % face_names ( 1 ) = \"imin\" bc % face_names ( 2 ) = \"imax\" bc % face_names ( 3 ) = \"jmin\" bc % face_names ( 4 ) = \"jmax\" bc % face_names ( 5 ) = \"kmin\" bc % face_names ( 6 ) = \"kmax\" bc % id ( 1 ) = bc % imin_id bc % id ( 2 ) = bc % imax_id bc % id ( 3 ) = bc % jmin_id bc % id ( 4 ) = bc % jmax_id bc % id ( 5 ) = bc % kmin_id bc % id ( 6 ) = bc % kmax_id bc % c2 = 1 + scheme % accur bc % c3 = 0.5 * scheme % accur bc % c1 = bc % c2 - bc % c3 call read_fixed_values ( files , scheme , flow , bc ) call alloc ( bc % make_F_flux_zero , 1 , dims % imx ) call alloc ( bc % make_G_flux_zero , 1 , dims % jmx ) call alloc ( bc % make_H_flux_zero , 1 , dims % kmx ) bc % make_F_flux_zero = 1 bc % make_G_flux_zero = 1 bc % make_H_flux_zero = 1 if ( bc % imin_id ==- 5 . or . bc % imin_id ==- 6 . or . bc % imin_id ==- 7 ) bc % make_F_flux_zero ( 1 ) = 0 if ( bc % jmin_id ==- 5 . or . bc % jmin_id ==- 6 . or . bc % jmin_id ==- 7 ) bc % make_G_flux_zero ( 1 ) = 0 if ( bc % kmin_id ==- 5 . or . bc % kmin_id ==- 6 . or . bc % kmin_id ==- 7 ) bc % make_H_flux_zero ( 1 ) = 0 if ( bc % imax_id ==- 5 . or . bc % imax_id ==- 6 . or . bc % imax_id ==- 7 ) bc % make_F_flux_zero ( dims % imx ) = 0 if ( bc % jmax_id ==- 5 . or . bc % jmax_id ==- 6 . or . bc % jmax_id ==- 7 ) bc % make_G_flux_zero ( dims % jmx ) = 0 if ( bc % kmax_id ==- 5 . or . bc % kmax_id ==- 6 . or . bc % kmax_id ==- 7 ) bc % make_H_flux_zero ( dims % kmx ) = 0 end subroutine setup_bc end module bc","tags":"","loc":"sourcefile/bc.f90.html","title":"bc.f90 – FEST-3D"},{"text":"A module contains generalized subroutine to copy variable in ghost cells This file depends on sourcefile~~copy_bc.f90~~EfferentGraph sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~copy_bc.f90~~AfferentGraph sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~ft_bc.f90->sourcefile~copy_bc.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~bc_primitive.f90->sourcefile~copy_bc.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 var pansourcefilecopy_bcf90AfferentGraph = svgPanZoom('#sourcefilecopy_bcf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules copy_bc Source Code copy_bc.f90 Source Code !< A module contains generalized subroutine to copy variable in ghost cells module copy_bc !< A module contains generalized subroutine to copy variable in ghost cells !------------------------------------------- use vartypes implicit none private public :: copy1 public :: copy3 contains subroutine copy1 ( var , type , face , dims ) !< Copy 1 layer of interior cell to first ghost cell layer implicit none type ( extent ), intent ( in ) :: dims character ( len =* ), intent ( in ) :: face !< Face over which boundary condition is being called character ( len =* ), intent ( in ) :: type !< Type of copy: flat, symmetry, anti-symmetry real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( inout ) :: var !< Varible over which these operation has to be performed real ( wp ) :: a2 = 1 integer :: imx , jmx , kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx select case ( type ) case ( \"anti\" ) a2 = - 1 case ( \"symm\" ) a2 = 1 case DEFAULT print * , \"ERROR: Wrong boundary condition type\" end select select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = a2 * var ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = a2 * var ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = a2 * var ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = a2 * var ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" end select end subroutine copy1 subroutine copy3 ( var , type , face , bc , dims ) !< Copy 3 layer of interior cell to three ghost cell layer implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Face over which boundary condition is being called character ( len =* ), intent ( in ) :: type !< Type of copy: flat, symmetry, anti-symmetry real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( inout ) :: var !< Varible over which these operation has to be performed real ( wp ) :: a1 = 1 real ( wp ) :: a2 = 1 real ( wp ) :: a3 = 0 integer :: i1 = 1 integer :: i2 = 2 integer :: i3 = 3 integer :: imx , jmx , kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx select case ( type ) case ( \"anti\" ) a1 = 1. ; i1 = 1 a2 = - 1. ; i2 = 2 a3 = 0. ; i3 = 3 case ( \"flat\" ) a1 = 1. ; i1 = 1 a2 = 1. ; i2 = 1 a3 = 0. ; i3 = 1 case ( \"symm\" ) a1 = bc % c1 ; i1 = 1 a2 = bc % c2 ; i2 = 2 a3 = bc % c3 ; i3 = 3 ! do nothing ! use default value continue case DEFAULT print * , \"ERROR: Wrong boundary condition type\" end select select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i1 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i1 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i2 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i2 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( - 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i3 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i3 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i1 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i1 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i2 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i2 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( imx + 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i3 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i3 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i1 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i1 + 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , - 1 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i2 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i2 + 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , - 2 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i3 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i3 + 1 , 1 : kmx - 1 )) / a1 case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i1 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i1 - 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , jmx + 1 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i2 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i2 - 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , jmx + 2 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i3 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i3 - 1 , 1 : kmx - 1 )) / a1 case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i1 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i1 + 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , - 1 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i2 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i2 + 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , - 2 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i3 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i3 + 1 )) / a1 case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i1 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i1 - 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 1 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i2 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i2 - 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 2 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i3 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i3 - 1 )) / a1 case DEFAULT print * , \"ERROR: wrong face for boundary condition\" end select end subroutine copy3 end module copy_bc","tags":"","loc":"sourcefile/copy_bc.f90.html","title":"copy_bc.f90 – FEST-3D"},{"text":"Apply boundary condition at every iteration This file depends on sourcefile~~bc_primitive.f90~~EfferentGraph sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~bc_primitive.f90->sourcefile~copy_bc.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~bc_primitive.f90->sourcefile~wall_dist.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~bc_primitive.f90->sourcefile~global_sst.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~bc_primitive.f90->sourcefile~vartypes.f90 sourcefile~ft_bc.f90->sourcefile~copy_bc.f90 sourcefile~ft_bc.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~utils.f90 utils.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~bc_primitive.f90~~AfferentGraph sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules bc_primitive Source Code bc_primitive.f90 Source Code !< Apply boundary condition at every iteration module bc_primitive !< Apply boundary condition at every iteration !------------------------------------------- #include \"../error.h\" use vartypes use wall_dist , only : dist use global_sst , only : beta1 use copy_bc , only : copy3 use FT_bc , only : flow_tangency implicit none private integer :: face_num integer :: current_iter , imx , jmx , kmx , n_var !< Number of the face : 1:imin, 2:imax, 3:jmin, 4:jmax, 5:kmin, 6:kmax character ( len = 32 ) :: turbulence , transition real ( wp ) :: gm , R_gas , mu_ref , T_ref , Sutherland_temp real ( wp ) :: x_speed_inf real ( wp ) :: y_speed_inf real ( wp ) :: z_speed_inf real ( wp ) :: density_inf real ( wp ) :: pressure_inf real ( wp ) :: tk_inf real ( wp ) :: tw_inf real ( wp ) :: te_inf real ( wp ) :: tv_inf real ( wp ) :: tgm_inf real ( wp ) :: tkl_inf real ( wp ), dimension (:, :, :, :), pointer :: qp real ( wp ), dimension (:, :, :), pointer :: density !< Rho pointer, point to slice of qp (:,:,:,1) real ( wp ), dimension (:, :, :), pointer :: x_speed !< U pointer, point to slice of qp (:,:,:,2) real ( wp ), dimension (:, :, :), pointer :: y_speed !< V pointer, point to slice of qp (:,:,:,3) real ( wp ), dimension (:, :, :), pointer :: z_speed !< W pointer, point to slice of qp (:,:,:,4) real ( wp ), dimension (:, :, :), pointer :: pressure !< P pointer, point to slice of qp (:,:,:,5) ! state variable turbulent real ( wp ), dimension (:, :, :), pointer :: tk !< TKE/mass real ( wp ), dimension (:, :, :), pointer :: tw !< Omega real ( wp ), dimension (:, :, :), pointer :: te !< Dissipation real ( wp ), dimension (:, :, :), pointer :: tv !< SA visocity real ( wp ), dimension (:, :, :), pointer :: tkl !< KL K-KL method real ( wp ), dimension (:, :, :), pointer :: tgm !< Intermittency of LCTM2015 public :: populate_ghost_primitive contains subroutine populate_ghost_primitive ( state , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) !< Populate the state variables in the ghost cell !< with particular value based on the boundary conditio !< being applied at that face implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: state !< state variables type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( flowtype ), intent ( in ) :: flow type ( boundarytype ), intent ( in ) :: bc integer :: i character ( len = 4 ) :: face imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = dims % n_var current_iter = control % current_iter turbulence = trim ( scheme % turbulence ) transition = trim ( scheme % transition ) mu_ref = flow % mu_ref gm = flow % gm R_gas = flow % R_gas T_ref = flow % T_ref sutherland_temp = flow % sutherland_temp x_speed_inf = flow % x_speed_inf y_speed_inf = flow % y_speed_inf z_speed_inf = flow % z_speed_inf density_inf = flow % density_inf pressure_inf = flow % pressure_inf tk_inf = flow % tk_inf tw_inf = flow % tw_inf te_inf = flow % te_inf tv_inf = flow % tv_inf tgm_inf = flow % tgm_inf tkl_inf = flow % tkl_inf qp ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => state (:, :, :, :) density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, n_var ) !          tgm_inf => qp_inf(n_var) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select do i = 1 , 6 face_num = i face = bc % face_names ( face_num ) select case ( bc % id ( face_num )) case ( - 1 ) call supersonic_inlet ( face , bc ) case ( - 2 ) call supersonic_outlet ( face , bc , dims ) case ( - 3 ) call subsonic_inlet ( face , bc , dims ) case ( - 4 ) call subsonic_outlet ( face , bc , dims ) case ( - 5 ) call wall ( face , bc , dims ) case ( - 6 ) call slip_wall ( face , Ifaces , Jfaces , Kfaces , bc , dims ) case ( - 7 ) call pole ( face , bc , dims ) case ( - 8 ) call far_field ( face , Ifaces , Jfaces , Kfaces , bc , dims ) case ( - 9 ) call periodic_bc ( face ) case ( - 11 ) call total_pressure ( face , Ifaces , Jfaces , Kfaces , bc , dims ) case Default if ( bc % id ( i ) >= 0 . or . bc % id ( i ) ==- 10 ) then continue !interface boundary else print * , \" boundary condition not recognised -> id is :\" , bc % id ( i ) end if end select end do !        qp(0,0,:,:) = 0.5*(qp(0,1,:,:)+qp(1,0,:,:)) !        qp(0,jmx,:,:) = 0.5*(qp(0,jmx-1,:,:)+qp(1,jmx,:,:)) !        qp(imx,0,:,:) = 0.5*(qp(imx,1,:,:)+qp(imx-1,0,:,:)) !        qp(imx,jmx,:,:) = 0.5*(qp(imx,jmx-1,:,:)+qp(imx-1,jmx,:,:)) !        qp(0,:,0,:) = 0.5*(qp(0,:,1,:)+qp(1,:,0,:)) !        qp(0,:,kmx,:) = 0.5*(qp(0,:,kmx-1,:)+qp(1,:,kmx,:)) !        qp(imx,:,0,:) = 0.5*(qp(imx,:,1,:)+qp(imx-1,:,0,:)) !        qp(imx,:,kmx,:) = 0.5*(qp(imx,:,jmx-1,:)+qp(imx-1,:,jmx,:)) qp (:, 0 , 0 ,:) = 0.33 * ( qp (:, 1 , 1 ,:) + qp (:, 0 , 1 ,:) + qp (:, 1 , 0 ,:)) qp (:, 0 , kmx ,:) = 0.33 * ( qp (:, 1 , kmx - 1 ,:) + qp (:, 0 , kmx - 1 ,:) + qp (:, 1 , kmx ,:)) qp (:, jmx , 0 ,:) = 0.33 * ( qp (:, jmx - 1 , 1 ,:) + qp (:, jmx , 1 ,:) + qp (:, jmx - 1 , 0 ,:)) qp (:, jmx , kmx ,:) = 0.33 * ( qp (:, jmx - 1 , kmx - 1 ,:) + qp (:, jmx , kmx - 1 ,:) + qp (:, jmx - 1 , kmx ,:)) qp ( imx , 0 ,:,:) = 0.33 * ( qp ( imx - 1 , 1 ,:,:) + qp ( imx - 1 , 0 ,:,:) + qp ( imx , 1 ,:,:)) qp ( 0 , 0 ,:,:) = 0.33 * ( qp ( 1 , 1 ,:,:) + qp ( 1 , 0 ,:,:) + qp ( 0 , 1 ,:,:)) qp ( 0 , jmx ,:,:) = 0.33 * ( qp ( 1 , jmx - 1 ,:,:) + qp ( 1 , jmx ,:,:) + qp ( 0 , jmx - 1 ,:,:)) qp ( imx , jmx ,:,:) = 0.33 * ( qp ( imx - 1 , jmx - 1 ,:,:) + qp ( imx - 1 , jmx ,:,:) + qp ( imx , jmx - 1 ,:,:)) qp ( 0 , 0 , 0 ,:) = 0.33 * ( qp ( 1 , 0 , 0 ,:) + qp ( 0 , 1 , 0 ,:) + qp ( 0 , 0 , 1 ,:)) qp ( imx , 0 , 0 ,:) = 0.33 * ( qp ( imx - 1 , 0 , 0 ,:) + qp ( imx , 1 , 0 ,:) + qp ( imx , 0 , 1 ,:)) qp ( 0 , jmx , 0 ,:) = 0.33 * ( qp ( 1 , jmx , 0 ,:) + qp ( 0 , jmx - 1 , 0 ,:) + qp ( 0 , jmx , 1 ,:)) qp ( 0 , 0 , kmx ,:) = 0.33 * ( qp ( 1 , 0 , kmx ,:) + qp ( 0 , 1 , kmx ,:) + qp ( 0 , 0 , kmx - 1 ,:)) qp ( imx , jmx , 0 ,:) = 0.33 * ( qp ( imx - 1 , jmx , 0 ,:) + qp ( imx , jmx - 1 , 0 ,:) + qp ( imx , jmx , 1 ,:)) qp ( imx , 0 , kmx ,:) = 0.33 * ( qp ( imx - 1 , 0 , kmx ,:) + qp ( imx , 1 , kmx ,:) + qp ( imx , 0 , kmx - 1 ,:)) qp ( 0 , jmx , kmx ,:) = 0.33 * ( qp ( 1 , jmx , kmx ,:) + qp ( 0 , jmx - 1 , kmx ,:) + qp ( 0 , jmx , kmx - 1 ,:)) qp ( imx , jmx , kmx ,:) = 0.33 * ( qp ( imx - 1 , jmx , kmx ,:) + qp ( imx , jmx - 1 , kmx ,:) + qp ( imx , jmx , kmx - 1 ,:)) end subroutine populate_ghost_primitive subroutine supersonic_inlet ( face , bc ) !< Supersonic inlet boundary condition !< All the values of state variables are fixed implicit none character ( len =* ), intent ( in ) :: face type ( boundarytype ), intent ( in ) :: bc !< Name of the face at which boundary condition is called if ( current_iter <= 2 ) then call fix ( density , bc % fixed_density , face ) call fix ( x_speed , bc % fixed_x_speed , face ) call fix ( y_speed , bc % fixed_y_speed , face ) call fix ( z_speed , bc % fixed_z_speed , face ) call fix ( pressure , bc % fixed_pressure , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if end subroutine supersonic_inlet subroutine supersonic_outlet ( face , bc , dims ) !< Supersonic outlet boundary condition. !< All the values of state variables are copied !< from inside the domain implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face , bc , dims ) call copy3 ( x_speed , \"flat\" , face , bc , dims ) call copy3 ( y_speed , \"flat\" , face , bc , dims ) call copy3 ( z_speed , \"flat\" , face , bc , dims ) call copy3 ( pressure , \"flat\" , face , bc , dims ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select end subroutine supersonic_outlet subroutine subsonic_inlet ( face , bc , dims ) !< Subsonic inlet boundary condition. !< All the state variables's value expect pressure !< is fixed and pressure is copied from inside the !< domain implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called if ( current_iter <= 2 ) then call fix ( density , bc % fixed_density , face ) call fix ( x_speed , bc % fixed_x_speed , face ) call fix ( y_speed , bc % fixed_y_speed , face ) call fix ( z_speed , bc % fixed_z_speed , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tw , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if call copy3 ( pressure , \"flat\" , face , bc , dims ) end subroutine subsonic_inlet subroutine subsonic_outlet ( face , bc , dims ) !< Subsonic outlet boundary condition. !< All the state variables's value expect pressure !< is copied from the inside of the domain and pressure !< is fixed implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face , bc , dims ) call copy3 ( x_speed , \"flat\" , face , bc , dims ) call copy3 ( y_speed , \"flat\" , face , bc , dims ) call copy3 ( z_speed , \"flat\" , face , bc , dims ) if ( current_iter <= 2 ) then call fix ( pressure , bc % fixed_pressure , face ) end if select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select end subroutine subsonic_outlet subroutine wall ( face , bc , dims ) !< Adiabatic/Isothermal wall boundary condition implicit none type ( extent ), intent ( in ) :: dims character ( len =* ), intent ( in ) :: face type ( boundarytype ), intent ( in ) :: bc !< Name of the face at which boundary condition is called call copy3 ( pressure , \"symm\" , face , bc , dims ) call temp_based_density ( bc % fixed_wall_temperature , face , bc , dims ) call no_slip ( face , bc , dims ) end subroutine wall subroutine slip_wall ( face , Ifaces , Jfaces , Kfaces , bc , dims ) !< Slip wall boundary condition. !< Maintain flow tangency implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal !< Name of the face at which boundary condition is called call copy3 ( density , \"symm\" , face , bc , dims ) call copy3 ( pressure , \"symm\" , face , bc , dims ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"symm\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"symm\" , face , bc , dims ) call copy3 ( tw , \"symm\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"symm\" , face , bc , dims ) call copy3 ( tkl , \"symm\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select call flow_tangency ( qp , face , Ifaces , Jfaces , Kfaces , dims ) end subroutine slip_wall subroutine pole ( face , bc , dims ) !< Boundary condition for the block face !< with zero area; turning into a pole implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face , bc , dims ) call copy3 ( x_speed , \"flat\" , face , bc , dims ) call copy3 ( y_speed , \"flat\" , face , bc , dims ) call copy3 ( z_speed , \"flat\" , face , bc , dims ) call copy3 ( pressure , \"flat\" , face , bc , dims ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select end subroutine pole subroutine fix ( var , fix_val , face ) !< Generalized subroutine to fix particular value !< at particular face implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) , intent ( out ) :: var !< Variable of which values are being fixed in the ghost cell real ( wp ), dimension ( 1 : 6 ) , intent ( in ) :: fix_val !< Amount of value that need to be fixed. character ( len =* ) , intent ( in ) :: face !< Name of the face at which boundary condition is called select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) var ( - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) var ( - 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) var ( imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) var ( imx + 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = fix_val ( 3 ) var ( 1 : imx - 1 , - 1 , 1 : kmx - 1 ) = fix_val ( 3 ) var ( 1 : imx - 1 , - 2 , 1 : kmx - 1 ) = fix_val ( 3 ) case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = fix_val ( 4 ) var ( 1 : imx - 1 , jmx + 1 , 1 : kmx - 1 ) = fix_val ( 4 ) var ( 1 : imx - 1 , jmx + 2 , 1 : kmx - 1 ) = fix_val ( 4 ) case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = fix_val ( 5 ) var ( 1 : imx - 1 , 1 : jmx - 1 , - 1 ) = fix_val ( 5 ) var ( 1 : imx - 1 , 1 : jmx - 1 , - 2 ) = fix_val ( 5 ) case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = fix_val ( 6 ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 1 ) = fix_val ( 6 ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 2 ) = fix_val ( 6 ) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine fix subroutine no_slip ( face , bc , dims ) !< No-slip wall boundary condition. All the !< component of velocity throught face is zero implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( x_speed , \"anti\" , face , bc , dims ) call copy3 ( y_speed , \"anti\" , face , bc , dims ) call copy3 ( z_speed , \"anti\" , face , bc , dims ) select case ( turbulence ) case ( \"none\" ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"anti\" , face , bc , dims ) case ( \"sst\" , 'sst2003' ) call copy3 ( tk , \"anti\" , face , bc , dims ) call set_omega_at_wall ( face ) case ( \"kkl\" ) call copy3 ( tk , \"anti\" , face , bc , dims ) call copy3 ( tkl , \"anti\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select end subroutine no_slip subroutine set_omega_at_wall ( face ) !< Set value of turbulence variable: omega (turbulenct dissipation rate). !< Value fixed is accourding to the SST turbulence model implicit none character ( len =* ), intent ( in ) :: face real ( wp ) :: T_face real ( wp ) :: mu real ( wp ) :: rho integer :: i , j , k , l select case ( face ) case ( \"imin\" ) do l = 1 , 3 do k = 1 , kmx - 1 do j = 1 , jmx - 1 T_face = 0.5 * (( pressure ( 0 , j , k ) / density ( 0 , j , k )) + ( pressure ( 1 , j , k ) / density ( 1 , j , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( 0 , j , k ) + density ( 1 , j , k )) tw ( 1 - l , j , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( 1 , j , k )) ** 2 ) - tw ( l , j , k ) end do end do end do case ( \"imax\" ) do l = 1 , 3 do k = 1 , kmx - 1 do j = 1 , jmx - 1 T_face = 0.5 * (( pressure ( imx - 1 , j , k ) / density ( imx - 1 , j , k )) + ( pressure ( imx , j , k ) / density ( imx , j , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( imx - 1 , j , k ) + density ( imx , j , k )) tw ( imx + l - 1 , j , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( imx - 1 , j , k )) ** 2 ) - tw ( imx - l , j , k ) end do end do end do case ( \"jmin\" ) do l = 1 , 3 do k = 1 , kmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , 0 , k ) / density ( i , 0 , k )) + ( pressure ( i , 1 , k ) / density ( i , 1 , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , 0 , k ) + density ( i , 1 , k )) tw ( i , 1 - l , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , 1 , k )) ** 2 ) - tw ( i , l , k ) end do end do end do case ( \"jmax\" ) do l = 1 , 3 do k = 1 , kmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , jmx - 1 , k ) / density ( i , jmx - 1 , k )) + ( pressure ( i , jmx , k ) / density ( i , jmx , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , jmx - 1 , k ) + density ( i , jmx , k )) tw ( i , jmx + l - 1 , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , jmx - 1 , k )) ** 2 ) - tw ( i , jmx - l , k ) end do end do end do case ( \"kmin\" ) do l = 1 , 3 do j = 1 , jmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , j , 0 ) / density ( i , j , 0 )) + ( pressure ( i , j , 1 ) / density ( i , j , 1 ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , j , 0 ) + density ( i , j , 1 )) tw ( i , j , 1 - l ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , j , 1 )) ** 2 ) - tw ( i , j , l ) end do end do end do case ( \"kmax\" ) do l = 1 , 3 do j = 1 , jmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , j , kmx - 1 ) / density ( i , j , kmx - 1 )) + ( pressure ( i , j , kmx ) / density ( i , j , kmx ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , j , kmx - 1 ) + density ( i , j , kmx )) tw ( i , j , kmx + l - 1 ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , j , kmx - 1 )) ** 2 ) - tw ( i , j , kmx - l ) end do end do end do end select end subroutine set_omega_at_wall subroutine far_field ( face , Ifaces , Jfaces , Kfaces , bc , dims ) !< Far-field Riemann boundary condition implicit none type ( extent ), intent ( in ) :: dims character ( len =* ), intent ( in ) :: face type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal type ( boundarytype ), intent ( in ) :: bc real ( wp ) :: cinf , cexp ! speed of sound real ( wp ) :: Rinf , Rexp ! Riemann invarient real ( wp ) :: Uninf , Unexp ! face normal speed real ( wp ) :: Unb ! normal velocity boundary real ( wp ) :: Cb ! speed of sound boundary real ( wp ) :: vel_diff real ( wp ) :: u , v , w real ( wp ) :: uf , vf , wf integer :: i , j , k real ( wp ) :: s integer , dimension ( 6 ) :: face_already_has_fixed_values = 0 !0=.no. face_already_has_fixed_values = 0 select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i-1,j,k) vf = y_speed_inf !y_speed(i-1,j,k) wf = z_speed_inf !z_speed(i-1,j,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i-1,j,k)/density(i-1,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Ifaces ( i , j , k )% nx ) + v * ( - Ifaces ( i , j , k )% ny ) + w * ( - Ifaces ( i , j , k )% nz ) Uninf = uf * ( - Ifaces ( i , j , k )% nx ) + vf * ( - Ifaces ( i , j , k )% ny ) + wf * ( - Ifaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i - 1 , j , k ) = x_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% nx ) y_speed ( i - 1 , j , k ) = y_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% ny ) z_speed ( i - 1 , j , k ) = z_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% nz ) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i - 1 , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i - 1 , j , k ) = ( density ( i - 1 , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 1 ) = 0 else vel_diff = Unb - Uninf x_speed ( i - 1 , j , k ) = x_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% nx ) y_speed ( i - 1 , j , k ) = y_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% ny ) z_speed ( i - 1 , j , k ) = z_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i - 1 , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i - 1 , j , k ) = ( density ( i - 1 , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 1 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 1 ) = 1 end if end do end do end do qp ( - 1 ,:,:,:) = qp ( 0 ,:,:,:) qp ( - 2 ,:,:,:) = qp ( 0 ,:,:,:) case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx , imx ! interior cell u = x_speed ( i - 1 , j , k ) v = y_speed ( i - 1 , j , k ) w = z_speed ( i - 1 , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i - 1 , j , k ) / density ( i - 1 , j , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Ifaces ( i , j , k )% nx ) + v * ( Ifaces ( i , j , k )% ny ) + w * ( Ifaces ( i , j , k )% nz ) Uninf = uf * ( Ifaces ( i , j , k )% nx ) + vf * ( Ifaces ( i , j , k )% ny ) + wf * ( Ifaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% nz ) s = pressure ( i - 1 , j , k ) / ( density ( i - 1 , j , k ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 2 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Ifaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Ifaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Ifaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 2 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 2 ) = 1 end if end do end do end do qp ( imx + 1 ,:,:,:) = qp ( imx ,:,:,:) qp ( imx + 2 ,:,:,:) = qp ( imx ,:,:,:) case ( \"jmin\" ) do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j-1,k) vf = y_speed_inf !y_speed(i,j-1,k) wf = z_speed_inf !z_speed(i,j-1,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j-1,k)/density(i,j-1,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Jfaces ( i , j , k )% nx ) + v * ( - Jfaces ( i , j , k )% ny ) + w * ( - Jfaces ( i , j , k )% nz ) Uninf = uf * ( - Jfaces ( i , j , k )% nx ) + vf * ( - Jfaces ( i , j , k )% ny ) + wf * ( - Jfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j - 1 , k ) = x_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% nx ) y_speed ( i , j - 1 , k ) = y_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% ny ) z_speed ( i , j - 1 , k ) = z_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% nz ) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i , j - 1 , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j - 1 , k ) = ( density ( i , j - 1 , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 3 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j - 1 , k ) = x_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% nx ) y_speed ( i , j - 1 , k ) = y_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% ny ) z_speed ( i , j - 1 , k ) = z_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j - 1 , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j - 1 , k ) = ( density ( i , j - 1 , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 3 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 3 ) = 1 end if end do end do end do qp (:, - 1 ,:,:) = qp (:, 0 ,:,:) qp (:, - 2 ,:,:) = qp (:, 0 ,:,:) case ( \"jmax\" ) do k = 1 , kmx - 1 do j = jmx , jmx do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j - 1 , k ) v = y_speed ( i , j - 1 , k ) w = z_speed ( i , j - 1 , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j - 1 , k ) / density ( i , j - 1 , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Jfaces ( i , j , k )% nx ) + v * ( Jfaces ( i , j , k )% ny ) + w * ( Jfaces ( i , j , k )% nz ) Uninf = uf * ( Jfaces ( i , j , k )% nx ) + vf * ( Jfaces ( i , j , k )% ny ) + wf * ( Jfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% nz ) s = pressure ( i , j - 1 , k ) / ( density ( i , j - 1 , k ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 4 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Jfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Jfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Jfaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 4 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 4 ) = 1 end if end do end do end do qp (:, jmx + 1 ,:,:) = qp (:, jmx ,:,:) qp (:, jmx + 2 ,:,:) = qp (:, jmx ,:,:) case ( \"kmin\" ) do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k-1) vf = y_speed_inf !y_speed(i,j,k-1) wf = z_speed_inf !z_speed(i,j,k-1) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j,k-1)/density(i,j,k-1)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Kfaces ( i , j , k )% nx ) + v * ( - Kfaces ( i , j , k )% ny ) + w * ( - Kfaces ( i , j , k )% nz ) Uninf = uf * ( - Kfaces ( i , j , k )% nx ) + vf * ( - Kfaces ( i , j , k )% ny ) + wf * ( - Kfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k - 1 ) = x_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% nx ) y_speed ( i , j , k - 1 ) = y_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% ny ) z_speed ( i , j , k - 1 ) = z_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% nz ) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i , j , k - 1 ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k - 1 ) = ( density ( i , j , k - 1 ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 5 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k - 1 ) = x_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% nx ) y_speed ( i , j , k - 1 ) = y_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% ny ) z_speed ( i , j , k - 1 ) = z_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k - 1 ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k - 1 ) = ( density ( i , j , k - 1 ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 5 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 5 ) = 1 end if end do end do end do qp (:,:, - 1 ,:) = qp (:,:, 0 ,:) qp (:,:, - 2 ,:) = qp (:,:, 0 ,:) case ( \"kmax\" ) do k = kmx , kmx do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k - 1 ) v = y_speed ( i , j , k - 1 ) w = z_speed ( i , j , k - 1 ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j , k - 1 ) / density ( i , j , k - 1 )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Kfaces ( i , j , k )% nx ) + v * ( Kfaces ( i , j , k )% ny ) + w * ( Kfaces ( i , j , k )% nz ) Uninf = uf * ( Kfaces ( i , j , k )% nx ) + vf * ( Kfaces ( i , j , k )% ny ) + wf * ( Kfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% nz ) s = pressure ( i , j , k - 1 ) / ( density ( i , j , k - 1 ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 6 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Kfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Kfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Kfaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 6 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 6 ) = 1 end if end do end do end do qp (:,:, kmx + 1 ,:) = qp (:,:, kmx ,:) qp (:,:, kmx + 2 ,:) = qp (:,:, kmx ,:) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine far_field subroutine total_pressure ( face , Ifaces , Jfaces , Kfaces , bc , dims ) !< Total Pressure Riemann boundary condition implicit none type ( extent ), intent ( in ) :: dims character ( len =* ), intent ( in ) :: face type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal type ( boundarytype ), intent ( in ) :: bc real ( wp ) :: cinf , cexp ! speed of sound real ( wp ) :: Rinf , Rexp ! Riemann invarient real ( wp ) :: Uninf , Unexp ! face normal speed real ( wp ) :: Unb ! normal velocity boundary real ( wp ) :: Cb ! speed of sound boundary real ( wp ) :: vel_diff real ( wp ) :: u , v , w real ( wp ) :: uf , vf , wf real ( wp ) :: Mb integer :: i , j , k select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i-1,j,k) vf = y_speed_inf !y_speed(i-1,j,k) wf = z_speed_inf !z_speed(i-1,j,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i-1,j,k)/density(i-1,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Ifaces ( i , j , k )% nx ) + v * ( - Ifaces ( i , j , k )% ny ) + w * ( - Ifaces ( i , j , k )% nz ) Uninf = uf * ( - Ifaces ( i , j , k )% nx ) + vf * ( - Ifaces ( i , j , k )% ny ) + wf * ( - Ifaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i - 1 , j , k ) = x_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% nx ) y_speed ( i - 1 , j , k ) = y_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% ny ) z_speed ( i - 1 , j , k ) = z_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i - 1 , j , k ) = x_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% nx ) y_speed ( i - 1 , j , k ) = y_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% ny ) z_speed ( i - 1 , j , k ) = z_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i - 1 , j , k ) ** 2 + y_speed ( i - 1 , j , k ) ** 2 + z_speed ( i - 1 , j , k ) ** 2 ) / Cb pressure ( i - 1 , j , k ) = bc % fixed_Tpressure ( 1 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i - 1 , j , k ) = gm * pressure ( i - 1 , j , k ) / ( Cb * Cb ) end do end do end do qp ( - 1 ,:,:,:) = qp ( 0 ,:,:,:) qp ( - 2 ,:,:,:) = qp ( 0 ,:,:,:) case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx , imx ! interior cell u = x_speed ( i - 1 , j , k ) v = y_speed ( i - 1 , j , k ) w = z_speed ( i - 1 , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i - 1 , j , k ) / density ( i - 1 , j , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Ifaces ( i , j , k )% nx ) + v * ( Ifaces ( i , j , k )% ny ) + w * ( Ifaces ( i , j , k )% nz ) Uninf = uf * ( Ifaces ( i , j , k )% nx ) + vf * ( Ifaces ( i , j , k )% ny ) + wf * ( Ifaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Ifaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Ifaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Ifaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = bc % fixed_Tpressure ( 2 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp ( imx + 1 ,:,:,:) = qp ( imx ,:,:,:) qp ( imx + 2 ,:,:,:) = qp ( imx ,:,:,:) case ( \"jmin\" ) do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j-1,k) vf = y_speed_inf !y_speed(i,j-1,k) wf = z_speed_inf !z_speed(i,j-1,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j-1,k)/density(i,j-1,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Jfaces ( i , j , k )% nx ) + v * ( - Jfaces ( i , j , k )% ny ) + w * ( - Jfaces ( i , j , k )% nz ) Uninf = uf * ( - Jfaces ( i , j , k )% nx ) + vf * ( - Jfaces ( i , j , k )% ny ) + wf * ( - Jfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j - 1 , k ) = x_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% nx ) y_speed ( i , j - 1 , k ) = y_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% ny ) z_speed ( i , j - 1 , k ) = z_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j - 1 , k ) = x_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% nx ) y_speed ( i , j - 1 , k ) = y_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% ny ) z_speed ( i , j - 1 , k ) = z_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j - 1 , k ) ** 2 + y_speed ( i , j - 1 , k ) ** 2 + z_speed ( i , j - 1 , k ) ** 2 ) / Cb pressure ( i , j - 1 , k ) = bc % fixed_Tpressure ( 3 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j - 1 , k ) = gm * pressure ( i , j - 1 , k ) / ( Cb * Cb ) end do end do end do qp (:, - 1 ,:,:) = qp (:, 0 ,:,:) qp (:, - 2 ,:,:) = qp (:, 0 ,:,:) case ( \"jmax\" ) do k = 1 , kmx - 1 do j = jmx , jmx do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j - 1 , k ) v = y_speed ( i , j - 1 , k ) w = z_speed ( i , j - 1 , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j - 1 , k ) / density ( i , j - 1 , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Jfaces ( i , j , k )% nx ) + v * ( Jfaces ( i , j , k )% ny ) + w * ( Jfaces ( i , j , k )% nz ) Uninf = uf * ( Jfaces ( i , j , k )% nx ) + vf * ( Jfaces ( i , j , k )% ny ) + wf * ( Jfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Jfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Jfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Jfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = bc % fixed_Tpressure ( 4 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp (:, jmx + 1 ,:,:) = qp (:, jmx ,:,:) qp (:, jmx + 2 ,:,:) = qp (:, jmx ,:,:) case ( \"kmin\" ) do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k-1) vf = y_speed_inf !y_speed(i,j,k-1) wf = z_speed_inf !z_speed(i,j,k-1) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j,k-1)/density(i,j,k-1)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Kfaces ( i , j , k )% nx ) + v * ( - Kfaces ( i , j , k )% ny ) + w * ( - Kfaces ( i , j , k )% nz ) Uninf = uf * ( - Kfaces ( i , j , k )% nx ) + vf * ( - Kfaces ( i , j , k )% ny ) + wf * ( - Kfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k - 1 ) = x_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% nx ) y_speed ( i , j , k - 1 ) = y_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% ny ) z_speed ( i , j , k - 1 ) = z_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k - 1 ) = x_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% nx ) y_speed ( i , j , k - 1 ) = y_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% ny ) z_speed ( i , j , k - 1 ) = z_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k - 1 ) = bc % fixed_Tpressure ( 5 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k - 1 ) = gm * pressure ( i , j , k - 1 ) / ( Cb * Cb ) end do end do end do qp (:,:, - 1 ,:) = qp (:,:, 0 ,:) qp (:,:, - 2 ,:) = qp (:,:, 0 ,:) case ( \"kmax\" ) do k = kmx , kmx do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k - 1 ) v = y_speed ( i , j , k - 1 ) w = z_speed ( i , j , k - 1 ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j , k - 1 ) / density ( i , j , k - 1 )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Kfaces ( i , j , k )% nx ) + v * ( Kfaces ( i , j , k )% ny ) + w * ( Kfaces ( i , j , k )% nz ) Uninf = uf * ( Kfaces ( i , j , k )% nx ) + vf * ( Kfaces ( i , j , k )% ny ) + wf * ( Kfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Kfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Kfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Kfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = bc % fixed_Tpressure ( 6 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp (:,:, kmx + 1 ,:) = qp (:,:, kmx ,:) qp (:,:, kmx + 2 ,:) = qp (:,:, kmx ,:) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine total_pressure subroutine temp_based_density ( temperature , face , bc , dims ) !< Specify the density in the ghost cell based on the !< temperature on the wall. Isothermal or adiabatic implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc real ( wp ), dimension ( 1 : 6 ) , intent ( in ) :: temperature character ( len =* ) , intent ( in ) :: face real ( wp ) :: stag_temp integer :: i , j , k select case ( face ) case ( \"imin\" ) if ( temperature ( 1 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i - 1 , j , k ) = pressure ( i - 1 , j , k ) / ( R_gas * stag_temp ) density ( i - 2 , j , k ) = pressure ( i - 2 , j , k ) / ( R_gas * stag_temp ) density ( i - 3 , j , k ) = pressure ( i - 3 , j , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 1 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 density ( i - 1 , j , k ) = pressure ( i - 1 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 0 , j , k ) / ( R_gas * density ( i + 0 , j , k ))))) density ( i - 2 , j , k ) = pressure ( i - 2 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 1 , j , k ) / ( R_gas * density ( i + 1 , j , k ))))) density ( i - 3 , j , k ) = pressure ( i - 3 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 2 , j , k ) / ( R_gas * density ( i + 2 , j , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case ( \"imax\" ) if ( temperature ( 2 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i + 1 , j , k ) = pressure ( i + 1 , j , k ) / ( R_gas * stag_temp ) density ( i + 2 , j , k ) = pressure ( i + 2 , j , k ) / ( R_gas * stag_temp ) density ( i + 3 , j , k ) = pressure ( i + 3 , j , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 2 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 density ( i + 1 , j , k ) = pressure ( i + 1 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 0 , j , k ) / ( R_gas * density ( i - 0 , j , k ))))) density ( i + 2 , j , k ) = pressure ( i + 2 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 1 , j , k ) / ( R_gas * density ( i - 1 , j , k ))))) density ( i + 3 , j , k ) = pressure ( i + 3 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 2 , j , k ) / ( R_gas * density ( i - 2 , j , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case ( \"jmin\" ) if ( temperature ( 3 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j - 1 , k ) = pressure ( i , j - 1 , k ) / ( R_gas * stag_temp ) density ( i , j - 2 , k ) = pressure ( i , j - 2 , k ) / ( R_gas * stag_temp ) density ( i , j - 3 , k ) = pressure ( i , j - 3 , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 3 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 density ( i , j - 1 , k ) = pressure ( i , j - 1 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 0 , k ) / ( R_gas * density ( i , j + 0 , k ))))) density ( i , j - 2 , k ) = pressure ( i , j - 2 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 1 , k ) / ( R_gas * density ( i , j + 1 , k ))))) density ( i , j - 3 , k ) = pressure ( i , j - 3 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 2 , k ) / ( R_gas * density ( i , j + 2 , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case ( \"jmax\" ) if ( temperature ( 4 ) < 0.0 ) then do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j + 1 , k ) = pressure ( i , j + 1 , k ) / ( R_gas * stag_temp ) density ( i , j + 2 , k ) = pressure ( i , j + 2 , k ) / ( R_gas * stag_temp ) density ( i , j + 3 , k ) = pressure ( i , j + 3 , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 4 ) > 1.0 ) then do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j + 1 , k ) = pressure ( i , j + 1 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 0 , k ) / ( R_gas * density ( i , j - 0 , k ))))) density ( i , j + 2 , k ) = pressure ( i , j + 2 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 1 , k ) / ( R_gas * density ( i , j - 1 , k ))))) density ( i , j + 3 , k ) = pressure ( i , j + 3 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 2 , k ) / ( R_gas * density ( i , j - 2 , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case ( \"kmin\" ) if ( temperature ( 5 ) < 0.0 ) then do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j , k - 1 ) = pressure ( i , j , k - 1 ) / ( R_gas * stag_temp ) density ( i , j , k - 2 ) = pressure ( i , j , k - 2 ) / ( R_gas * stag_temp ) density ( i , j , k - 3 ) = pressure ( i , j , k - 3 ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 5 ) > 1.0 ) then do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j , k - 1 ) = pressure ( i , j , k - 1 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 0 ) / ( R_gas * density ( i , j , k + 0 ))))) density ( i , j , k - 2 ) = pressure ( i , j , k - 2 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 1 ) / ( R_gas * density ( i , j , k + 1 ))))) density ( i , j , k - 3 ) = pressure ( i , j , k - 3 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 2 ) / ( R_gas * density ( i , j , k + 2 ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case ( \"kmax\" ) if ( temperature ( 6 ) < 0.0 ) then do k = kmx - 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j , k + 1 ) = pressure ( i , j , k + 1 ) / ( R_gas * stag_temp ) density ( i , j , k + 2 ) = pressure ( i , j , k + 2 ) / ( R_gas * stag_temp ) density ( i , j , k + 3 ) = pressure ( i , j , k + 3 ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 6 ) > 1.0 ) then do k = kmx - 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j , k + 1 ) = pressure ( i , j , k + 1 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 0 ) / ( R_gas * density ( i , j , k - 0 ))))) density ( i , j , k + 2 ) = pressure ( i , j , k + 2 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 1 ) / ( R_gas * density ( i , j , k - 1 ))))) density ( i , j , k + 3 ) = pressure ( i , j , k + 3 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 2 ) / ( R_gas * density ( i , j , k - 2 ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine temp_based_density subroutine periodic_bc ( face ) !< Single block periodic boundary condition. !< Not to be used for multiblock boundary condition implicit none character ( len =* ), intent ( in ) :: face select case ( trim ( face )) case ( 'imin' ) qp ( - 2 : 0 ,:,:,:) = qp ( imx - 3 : imx - 1 ,:,:,:) case ( 'imax' ) qp ( imx : imx + 2 ,:,:,:) = qp ( 1 : 3 ,:,:,:) case ( 'jmin' ) qp (:, - 2 : 0 ,:,:) = qp (:, jmx - 3 : jmx - 1 ,:,:) case ( 'jmax' ) qp (:, jmx : jmx + 2 ,:,:) = qp (:, 1 : 3 ,:,:) case ( 'kmin' ) qp (:,:, - 2 : 0 ,:) = qp (:,:, kmx - 3 : kmx - 1 ,:) case ( 'kmax' ) qp (:,:, kmx : kmx + 2 ,:) = qp (:,:, 1 : 3 ,:) case Default Fatal_error end select end subroutine periodic_bc end module bc_primitive","tags":"","loc":"sourcefile/bc_primitive.f90.html","title":"bc_primitive.f90 – FEST-3D"},{"text":"Apply flow tangency boundary condition This file depends on sourcefile~~ft_bc.f90~~EfferentGraph sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~ft_bc.f90->sourcefile~copy_bc.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~ft_bc.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ft_bc.f90~~AfferentGraph sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules FT_bc Source Code FT_bc.f90 Source Code !< Apply flow tangency boundary condition module FT_bc !< Apply flow tangency boundary condition !-------------------------------------------- use vartypes use copy_bc , only : copy3 implicit none private public :: flow_tangency contains subroutine flow_tangency ( qp , face , Ifaces , Jfaces , Kfaces , dims ) !< Apply flow tangency boundary condition implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp character ( len =* ), intent ( in ) :: face !< Face over which flow tangency condition has to be applied type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal real ( wp ) :: dot integer :: i integer :: j integer :: k integer :: l integer :: imx , jmx , kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do l = 1 , 3 dot = qp ( l , j , k , 2 ) * Ifaces ( 1 , j , k )% nx + qp ( l , j , k , 3 ) * Ifaces ( 1 , j , k )% ny + qp ( l , j , k , 4 ) * Ifaces ( 1 , j , k )% nz qp ( - l + 1 , j , k , 2 ) = qp ( l , j , k , 2 ) - ( 2.0 * dot * Ifaces ( 1 , j , k )% nx ) qp ( - l + 1 , j , k , 3 ) = qp ( l , j , k , 3 ) - ( 2.0 * dot * Ifaces ( 1 , j , k )% ny ) qp ( - l + 1 , j , k , 4 ) = qp ( l , j , k , 4 ) - ( 2.0 * dot * Ifaces ( 1 , j , k )% nz ) end do end do end do case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do l = 1 , 3 dot = qp ( imx - l , j , k , 2 ) * Ifaces ( imx , j , k )% nx + qp ( imx - l , j , k , 3 ) * Ifaces ( imx , j , k )% ny + qp ( imx - l , j , k , 4 ) * Ifaces ( imx , j , k )% nz qp ( imx + l - 1 , j , k , 2 ) = qp ( imx - l , j , k , 2 ) - ( 2.0 * dot * Ifaces ( imx , j , k )% nx ) qp ( imx + l - 1 , j , k , 3 ) = qp ( imx - l , j , k , 3 ) - ( 2.0 * dot * Ifaces ( imx , j , k )% ny ) qp ( imx + l - 1 , j , k , 4 ) = qp ( imx - l , j , k , 4 ) - ( 2.0 * dot * Ifaces ( imx , j , k )% nz ) end do end do end do case ( \"jmin\" ) do k = 1 , kmx - 1 do i = 1 , imx - 1 do l = 1 , 3 dot = qp ( i , l , k , 2 ) * Jfaces ( i , 1 , k )% nx + qp ( i , l , k , 3 ) * Jfaces ( i , 1 , k )% ny + qp ( i , l , k , 4 ) * Jfaces ( i , 1 , k )% nz qp ( i , - l + 1 , k , 2 ) = qp ( i , l , k , 2 ) - ( 2.0 * dot * Ifaces ( i , 1 , k )% nx ) qp ( i , - l + 1 , k , 3 ) = qp ( i , l , k , 3 ) - ( 2.0 * dot * Ifaces ( i , 1 , k )% ny ) qp ( i , - l + 1 , k , 4 ) = qp ( i , l , k , 4 ) - ( 2.0 * dot * Ifaces ( i , 1 , k )% nz ) end do end do end do case ( \"jmax\" ) do k = 1 , kmx - 1 do i = 1 , imx - 1 do l = 1 , 3 dot = qp ( i , jmx - l , k , 2 ) * Jfaces ( i , jmx , k )% nx + qp ( i , jmx - l , k , 3 ) * Jfaces ( i , jmx , k )% ny + qp ( i , jmx - l , k , 4 ) * Jfaces ( i , jmx , k )% nz qp ( i , jmx + l - 1 , k , 2 ) = qp ( i , jmx - l , k , 2 ) - ( 2.0 * dot * Ifaces ( i , jmx , k )% nx ) qp ( i , jmx + l - 1 , k , 3 ) = qp ( i , jmx - l , k , 3 ) - ( 2.0 * dot * Ifaces ( i , jmx , k )% ny ) qp ( i , jmx + l - 1 , k , 4 ) = qp ( i , jmx - l , k , 4 ) - ( 2.0 * dot * Ifaces ( i , jmx , k )% nz ) end do end do end do case ( \"kmin\" ) do j = 1 , jmx - 1 do i = 1 , imx - 1 do l = 1 , 3 dot = qp ( i , j , l , 2 ) * Kfaces ( i , j , 1 )% nx + qp ( i , j , l , 3 ) * Kfaces ( i , j , 1 )% ny + qp ( i , j , l , 4 ) * Kfaces ( i , j , 1 )% nz qp ( i , j , - l + 1 , 2 ) = qp ( i , j , l , 2 ) - ( 2.0 * dot * Ifaces ( i , j , 1 )% nx ) qp ( i , j , - l + 1 , 3 ) = qp ( i , j , l , 3 ) - ( 2.0 * dot * Ifaces ( i , j , 1 )% ny ) qp ( i , j , - l + 1 , 4 ) = qp ( i , j , l , 4 ) - ( 2.0 * dot * Ifaces ( i , j , 1 )% nz ) end do end do end do case ( \"kmax\" ) do j = 1 , jmx - 1 do i = 1 , imx - 1 do l = 1 , 3 dot = qp ( i , j , kmx - l , 2 ) * Kfaces ( i , j , kmx )% nx + qp ( i , j , kmx - l , 3 ) * Kfaces ( i , j , kmx )% ny + qp ( i , j , kmx - l , 4 ) * Kfaces ( i , j , kmx )% nz qp ( i , j , kmx + l - 1 , 2 ) = qp ( i , j , kmx - l , 2 ) - ( 2.0 * dot * Ifaces ( i , j , kmx )% nx ) qp ( i , j , kmx + l - 1 , 3 ) = qp ( i , j , kmx - l , 3 ) - ( 2.0 * dot * Ifaces ( i , j , kmx )% ny ) qp ( i , j , kmx + l - 1 , 4 ) = qp ( i , j , kmx - l , 4 ) - ( 2.0 * dot * Ifaces ( i , j , kmx )% nz ) end do end do end do end select end subroutine flow_tangency end module FT_bc","tags":"","loc":"sourcefile/ft_bc.f90.html","title":"FT_bc.f90 – FEST-3D"},{"text":"Get all the fixed values from the bc_**.md file This file depends on sourcefile~~read_bc.f90~~EfferentGraph sourcefile~read_bc.f90 read_bc.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~read_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read_bc.f90~~AfferentGraph sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc.f90 bc.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read_bc Source Code read_bc.f90 Source Code !< Get all the fixed values from the bc_**.md file module read_bc !< Get all the fixed values from the bc_**.md file !----------------------------------------------------- #include \"../error.h\" use vartypes implicit none private character ( len = STRING_BUFFER_LENGTH ) :: buf !< String to extract single line from the file public :: read_fixed_values contains subroutine read_fixed_values ( files , scheme , flow , bc ) !< Read fixed values for each block face implicit none type ( filetype ), intent ( in ) :: files type ( schemetype ), intent ( in ) :: scheme type ( flowtype ), intent ( in ) :: flow type ( boundarytype ), intent ( inout ) :: bc integer :: count = 0 call fill_fixed_values ( scheme , flow , bc ) open ( unit = files % BOUNDARY_CONDITIONS_FILE_UNIT , file = files % bcfile ) read ( files % BOUNDARY_CONDITIONS_FILE_UNIT , * ) read ( files % BOUNDARY_CONDITIONS_FILE_UNIT , * ) read ( files % BOUNDARY_CONDITIONS_FILE_UNIT , * ) do while ( count < 6 ) read ( files % BOUNDARY_CONDITIONS_FILE_UNIT , \"(A)\" ) buf if ( buf ( 1 : 1 ) == '#' ) then count = count + 1 call get_fixed_values ( files , scheme , flow , bc , count ) end if end do close ( files % BOUNDARY_CONDITIONS_FILE_UNIT ) end subroutine read_fixed_values subroutine get_fixed_values ( files , scheme , flow , bc , count ) !< Extract fixed value from the bc_**.md file implicit none type ( filetype ), intent ( in ) :: files type ( schemetype ), intent ( in ) :: scheme type ( flowtype ), intent ( in ) :: flow type ( boundarytype ), intent ( inout ) :: bc integer , intent ( in ) :: count real ( wp ) :: fix_val integer :: ios do while (. true .) read ( files % BOUNDARY_CONDITIONS_FILE_UNIT , \"(A)\" ) buf if ( buf ( 1 : 2 ) == '- ' ) then read ( buf ( index ( buf ( 3 :), ' ' ) + 3 :), * , iostat = ios ) fix_val select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_DENSITY\" ) call set_value ( bc % fixed_density , fix_val , flow % density_inf , count , ios ) case ( \"FIX_X_SPEED\" ) call set_value ( bc % fixed_x_speed , fix_val , flow % x_speed_inf , count , ios ) case ( \"FIX_Y_SPEED\" ) call set_value ( bc % fixed_y_speed , fix_val , flow % y_speed_inf , count , ios ) case ( \"FIX_Z_SPEED\" ) call set_value ( bc % fixed_z_speed , fix_val , flow % z_speed_inf , count , ios ) case ( \"FIX_PRESSURE\" ) call set_value ( bc % fixed_pressure , fix_val , flow % pressure_inf , count , ios ) case ( \"WALL_TEMPERATURE\" ) call set_value ( bc % fixed_wall_temperature , fix_val , 0.0 , count , ios ) case ( \"TOTAL_TEMPERATURE\" ) call set_value ( bc % fixed_Ttemperature , fix_val , 0.0 , count , ios ) case ( \"TOTAL_PRESSURE\" ) call set_value ( bc % fixed_Tpressure , fix_val , 0.0 , count , ios ) end select select case ( scheme % turbulence ) case ( \"none\" ) !do nothing continue case ( \"sst\" , 'tw' , 'sst2003' ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tk\" ) call set_value ( bc % fixed_tk , fix_val , flow % tk_inf , count , ios ) case ( \"FIX_tw\" ) call set_value ( bc % fixed_tw , fix_val , flow % tw_inf , count , ios ) case DEFAULT ! no a value to fix continue end select case ( \"kkl\" ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tk\" ) call set_value ( bc % fixed_tk , fix_val , flow % tk_inf , count , ios ) case ( \"FIX_tkl\" ) call set_value ( bc % fixed_tkl , fix_val , flow % tkl_inf , count , ios ) case DEFAULT ! no a value to fix continue end select case ( \"sa\" , \"saBC\" ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tv\" ) call set_value ( bc % fixed_tk , fix_val , flow % tv_inf , count , ios ) case DEFAULT ! no a value to fix continue end select end select else exit end if end do end subroutine get_fixed_values subroutine fill_fixed_values ( scheme , flow , bc ) !< Fill the Fixed_var array with with free-stream value !< or default values. implicit none type ( schemetype ), intent ( in ) :: scheme type ( flowtype ), intent ( in ) :: flow type ( boundarytype ), intent ( inout ) :: bc integer :: count integer :: ios =- 1 do count = 1 , 6 !case (\"FIX_DENSITY\") call set_value ( bc % fixed_density , flow % density_inf , flow % density_inf , count , ios ) !case (\"FIX_X_SPEED\") call set_value ( bc % fixed_x_speed , flow % x_speed_inf , flow % x_speed_inf , count , ios ) !case (\"FIX_Y_SPEED\") call set_value ( bc % fixed_y_speed , flow % y_speed_inf , flow % y_speed_inf , count , ios ) !case (\"FIX_Z_SPEED\") call set_value ( bc % fixed_z_speed , flow % z_speed_inf , flow % z_speed_inf , count , ios ) !case (\"FIX_PRESSURE\") call set_value ( bc % fixed_pressure , flow % pressure_inf , flow % pressure_inf , count , ios ) !case (\"WALL_TEMPERATURE\") call set_value ( bc % fixed_wall_temperature , 0.0 , 0.0 , count , ios ) !case (\"TOTAL_TEMPERATURE\") call set_value ( bc % fixed_Ttemperature , 0.0 , 0.0 , count , ios ) !case (\"TOTAL_PRESSURE\") call set_value ( bc % fixed_Tpressure , 0.0 , 0.0 , count , ios ) select case ( scheme % turbulence ) case ( \"none\" ) !do nothing continue case ( \"sst\" , 'tw' , 'sst2003' ) !case (\"FIX_tk\") call set_value ( bc % fixed_tk , flow % tk_inf , flow % tk_inf , count , ios ) !case (\"FIX_tw\") call set_value ( bc % fixed_tw , flow % tw_inf , flow % tw_inf , count , ios ) case ( \"kkl\" ) !case (\"FIX_tk\") call set_value ( bc % fixed_tk , flow % tk_inf , flow % tk_inf , count , ios ) !case (\"FIX_tkl\") call set_value ( bc % fixed_tkl , flow % tkl_inf , flow % tkl_inf , count , ios ) case ( \"sa\" , \"saBC\" ) !case (\"FIX_tv\") call set_value ( bc % fixed_tk , flow % tv_inf , flow % tv_inf , count , ios ) case DEFAULT Fatal_error end select end do end subroutine fill_fixed_values subroutine set_value ( fixed_var , fix_val , inf_val , count , ios ) !< Set particular value to the Fixed_var variable implicit none integer , intent ( in ) :: ios integer , intent ( in ) :: count real ( wp ) , intent ( in ) :: fix_val real ( wp ) , intent ( in ) :: inf_val real ( wp ) , intent ( out ), dimension (:) :: fixed_var if ( ios == 0 ) then fixed_var ( count ) = fix_val else fixed_var ( count ) = inf_val end if end subroutine set_value end module read_bc","tags":"","loc":"sourcefile/read_bc.f90.html","title":"read_bc.f90 – FEST-3D"},{"text":"Reconstruct the boundary face in case of 4th and 5th order methods This file depends on sourcefile~~boundary_state_reconstruction.f90~~EfferentGraph sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~face_interpolant.f90 face_interpolant.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~face_interpolant.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~vartypes.f90 sourcefile~face_interpolant.f90->sourcefile~vartypes.f90 sourcefile~weno.f90 weno.f90 sourcefile~face_interpolant.f90->sourcefile~weno.f90 sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~face_interpolant.f90->sourcefile~weno_nm.f90 sourcefile~utils.f90 utils.f90 sourcefile~face_interpolant.f90->sourcefile~utils.f90 sourcefile~ppm.f90 ppm.f90 sourcefile~face_interpolant.f90->sourcefile~ppm.f90 sourcefile~muscl.f90 muscl.f90 sourcefile~face_interpolant.f90->sourcefile~muscl.f90 sourcefile~weno.f90->sourcefile~vartypes.f90 sourcefile~weno_nm.f90->sourcefile~vartypes.f90 sourcefile~ppm.f90->sourcefile~vartypes.f90 sourcefile~muscl.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~boundary_state_reconstruction.f90~~AfferentGraph sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules boundary_state_reconstruction Source Code boundary_state_reconstruction.f90 Source Code !< Reconstruct the boundary face in case of 4th and 5th order methods module boundary_state_reconstruction !< Reconstruct the boundary face in case of 4th and 5th order higher order !< face state reconstruction method. Since the limited information !< is available at the boundaries, the boundary face is limiter to !< 3rd order accurate and is reconstructed using MUSCL Scheme even when !< rest of the domain is using WENO or PPM #include \"../debug.h\" #include \"../error.h\" use vartypes use face_interpolant , only : x_qp_left , x_qp_right use face_interpolant , only : y_qp_left , y_qp_right use face_interpolant , only : z_qp_left , z_qp_right implicit none private integer :: ppm_flag = 0 !< Flag to check if reconstruction is required integer :: switch_L = 1 !< Limiter switch integer :: imx , jmx , kmx , n_var public :: reconstruct_boundary_state contains subroutine reconstruct_boundary_state ( qp , control , scheme , bc , dims ) !< Call reconstruction based on the flag and boundary condition implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc DebugCall ( 'recons_boundary_state' ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var if ( scheme % interpolant == 'ppm' . or . scheme % interpolant == 'weno' . or . scheme % interpolant == 'weno_NM' ) ppm_flag = 1 if ( bc % imin_id ==- 7 . or . bc % jmin_id ==- 7 . or . bc % kmin_id ==- 7 ) ppm_flag = 1 if ( bc % imax_id ==- 7 . or . bc % jmax_id ==- 7 . or . bc % kmax_id ==- 7 ) ppm_flag = 1 if ( scheme % interpolant /= 'none' ) then if ( bc % imin_id < 0 . and . bc % imin_id /=- 10 ) then DebugCall ( 'recons_bndry_state: imin' ) call reconstruct_imin ( qp , scheme , bc ) end if if ( bc % imax_id < 0 . and . bc % imax_id /=- 10 ) then DebugCall ( 'recons_bndry_state: imax' ) call reconstruct_imax ( qp , scheme , bc ) end if if ( bc % jmin_id < 0 . and . bc % jmin_id /=- 10 ) then DebugCall ( 'recons_bndry_state: jmin' ) call reconstruct_jmin ( qp , scheme , bc ) end if if ( bc % jmax_id < 0 . and . bc % jmax_id /=- 10 ) then DebugCall ( 'recons_bndry_state: jmax' ) call reconstruct_jmax ( qp , scheme , bc ) end if if ( bc % kmin_id < 0 . and . bc % kmin_id /=- 10 ) then DebugCall ( 'recons_bndry_state: kmin' ) call reconstruct_kmin ( qp , scheme , bc ) end if if ( bc % kmax_id < 0 . and . bc % kmax_id /=- 10 ) then DebugCall ( 'recons_bndry_state: kmax' ) call reconstruct_kmax ( qp , scheme , bc ) end if end if end subroutine reconstruct_boundary_state subroutine reconstruct_imin ( qp , scheme , bc ) !< Reconstruct state at the IMIN boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc integer :: i , j , k , l real ( wp ) :: psi1 , psi2 , fd , bd , r real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % ilimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % itlimiter_switch do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! reconstruct first cell faces for ppm scheme fd = qp ( i + 1 , j , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - 1 , j , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right state of firsrt interior cell x_qp_left ( i + 1 , j , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) ! left face of first interior cell x_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end if if ( bc % imin_id ==- 8 . or . bc % imin_id ==- 9 ) then x_qp_left ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) x_qp_right ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) else ! right face of first ghost cell x_qp_left ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_imin subroutine reconstruct_imax ( qp , scheme , bc ) !< Reconstruct state at the IMAX boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc integer :: i , j , k , l real ( wp ) :: psi1 , psi2 , fd , bd , r real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % ilimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % itlimiter_switch do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 fd = qp ( i + 1 , j , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - 1 , j , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last interior cell x_qp_left ( i + 1 , j , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) ! left face of last interior cell x_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end if if ( bc % imax_id ==- 8 . or . bc % imax_id ==- 9 ) then x_qp_left ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) x_qp_right ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) else x_qp_right ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_imax subroutine reconstruct_jmin ( qp , scheme , bc ) !< Reconstruct state at the JMIN boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc integer :: i , j , k , l real ( wp ) :: psi1 , psi2 , fd , bd , r real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % jlimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % jtlimiter_switch do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 fd = qp ( i , j + 1 , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j - 1 , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of first j cell y_qp_left ( i , j + 1 , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of first j cell y_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( bc % jmin_id ==- 8 . or . bc % jmin_id ==- 9 ) then y_qp_left ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var ) y_qp_right ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var ) else y_qp_left ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_jmin subroutine reconstruct_jmax ( qp , scheme , bc ) !< Reconstruct state at the JMAX boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc integer :: i , j , k , l real ( wp ) :: psi1 , psi2 , fd , bd , r real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % jlimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % jtlimiter_switch do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 fd = qp ( i , j + 1 , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j - 1 , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last j cell y_qp_left ( i , j + 1 , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of last j cell y_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( bc % jmax_id ==- 8 . or . bc % jmax_id ==- 9 ) then y_qp_left ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) y_qp_right ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) else y_qp_right ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_jmax subroutine reconstruct_kmin ( qp , scheme , bc ) !< Reconstruct state at the KMIN boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc real ( wp ) :: psi1 , psi2 , fd , bd , r integer :: i , j , k , l real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % klimiter_switch if ( ppm_flag == 1 ) then do k = 1 , 1 do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % ktlimiter_switch if ( l < 6 ) switch_L = scheme % klimiter_switch do j = 1 , jmx - 1 do i = 1 , imx - 1 fd = qp ( i , j , k + 1 , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j , k - 1 , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of first k cell z_qp_left ( i , j , k + 1 , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of first k cell z_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( bc % kmin_id ==- 8 . or . bc % kmin_id ==- 9 ) then z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var ) z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var ) else z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var )) end if end subroutine reconstruct_kmin subroutine reconstruct_kmax ( qp , scheme , bc ) !< Reconstruct state at the KMAX boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc real ( wp ) :: psi1 , psi2 , fd , bd , r integer :: i , j , k , l real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % klimiter_switch do k = kmx - 1 , kmx - 1 do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % ktlimiter_switch if ( l < 6 ) switch_L = scheme % klimiter_switch do j = 1 , jmx - 1 do i = 1 , imx - 1 ! left face of kmx ghost cell z_qp_right ( i , j , k + 1 , l ) = 0.5 * ( qp ( i , j , k , l ) + qp ( i , j , k + 1 , l )) if ( ppm_flag == 1 ) then fd = qp ( i , j , k + 1 , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j , k - 1 , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last k interior cell z_qp_left ( i , j , k + 1 , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of last k cell z_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end if end do end do end do end do if ( bc % kmax_id ==- 8 . or . bc % kmax_id ==- 9 ) then z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) else z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var )) end if end subroutine reconstruct_kmax end module boundary_state_reconstruction","tags":"","loc":"sourcefile/boundary_state_reconstruction.f90.html","title":"boundary_state_reconstruction.f90 – FEST-3D"},{"text":"Calculate the distance from the wall \n for each cell-center in the domain This file depends on sourcefile~~wall_dist.f90~~EfferentGraph sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~utils.f90 utils.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~wall_dist.f90~~AfferentGraph sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~plusgs.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~wall_dist.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~cc.f90 CC.f90 sourcefile~solver.f90->sourcefile~cc.f90 sourcefile~time.f90 time.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output_tec.f90->sourcefile~wall_dist.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~wall_dist.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~cc.f90->sourcefile~wall_dist.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output_tec_node.f90->sourcefile~wall_dist.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~lusgs.f90->sourcefile~wall_dist.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~source.f90->sourcefile~wall_dist.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output_vtk.f90->sourcefile~wall_dist.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~bc_primitive.f90->sourcefile~wall_dist.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 var pansourcefilewall_distf90AfferentGraph = svgPanZoom('#sourcefilewall_distf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules wall_dist Source Code wall_dist.f90 Source Code !< Calculate the distance from the wall !< for each cell-center in the domain module wall_dist !< Calculate the distance from the wall !< for each cell-center in the domain use vartypes use utils , only : alloc #include \"../debug.h\" #include \"../error.h\" implicit none private integer :: n_surfnodes !< Number of surfce node points real ( wp ), private , dimension (:) , allocatable :: wall_x !< X component of wall surface node point real ( wp ), private , dimension (:) , allocatable :: wall_y !< Y component of wall surface node point real ( wp ), private , dimension (:) , allocatable :: wall_z !< Z component of wall surface node point real ( wp ), dimension (:, :, :), allocatable :: dist integer :: imx , jmx , kmx public :: setup_wall_dist public :: find_wall_dist public :: dist contains subroutine setup_wall_dist ( files , dims ) !< Allocate memory to the wall_distance variables !< and read the surface node file implicit none type ( filetype ), intent ( in ) :: files type ( extent ), intent ( in ) :: dims imx = dims % imx jmx = dims % jmx kmx = dims % kmx DebugCall ( 'setup_wall_dist' ) call setup_nodefile ( files ) call alloc ( wall_x , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( wall_y , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( wall_z , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( dist , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , & \"ERROR: unale to allocate memory to 'Dist' variable \" ) call read_destroy_nodefile ( files ) end subroutine setup_wall_dist subroutine setup_nodefile ( files ) !< Open and read first line of surface_node_point file implicit none type ( filetype ), intent ( in ) :: files integer :: ios open ( files % NODESURF_FILE_UNIT , file = files % surface_node_points , status = 'old' , IOSTAT = ios ) if ( ios /= 0 ) then print * , \"!!! -->file containg surface nodepoints not found\" Fatal_error end if read ( files % NODESURF_FILE_UNIT , * ) n_surfnodes end subroutine setup_nodefile subroutine read_destroy_nodefile ( files ) !< Read, and close surface_node_point file implicit none type ( filetype ), intent ( in ) :: files integer :: i do i = 1 , n_surfnodes read ( files % NODESURF_FILE_UNIT , * ) wall_x ( i ), wall_y ( i ), wall_z ( i ) end do close ( files % NODESURF_FILE_UNIT ) end subroutine read_destroy_nodefile subroutine find_wall_dist ( nodes , dims ) !< Determine the minimum wall distance from the wall surface node points implicit none type ( extent ), intent ( in ) :: dims type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes integer :: i , j , k , n real ( wp ) :: current_dist real ( wp ), dimension (:,:,:), allocatable :: node_dist DebugCall ( 'find_wall_dist' ) call alloc ( node_dist , - 2 , imx + 3 , - 2 , jmx + 3 , - 2 , kmx + 3 ) do k = - 2 , dims % kmx + 3 do j = - 2 , dims % jmx + 3 do i = - 2 , dims % imx + 3 node_dist ( i , j , k ) = 1.e+20 do n = 1 , n_surfnodes current_dist = sqrt (( wall_x ( n ) - nodes ( i , j , k )% x ) ** 2 & + ( wall_y ( n ) - nodes ( i , j , k )% y ) ** 2 & + ( wall_z ( n ) - nodes ( i , j , k )% z ) ** 2 & ) node_dist ( i , j , k ) = min ( node_dist ( i , j , k ), current_dist ) end do end do end do end do do k =- 2 , dims % kmx + 2 do j =- 2 , dims % jmx + 2 do i =- 2 , dims % imx + 2 dist ( i , j , k ) = 0.125 * ( node_dist ( i , j , k )& + node_dist ( i , j + 1 , k )& + node_dist ( i , j + 1 , k + 1 )& + node_dist ( i , j , k + 1 )& + node_dist ( i + 1 , j , k + 1 )& + node_dist ( i + 1 , j , k )& + node_dist ( i + 1 , j + 1 , k )& + node_dist ( i + 1 , j + 1 , k + 1 )& ) end do end do end do deallocate ( node_dist ) DebugCall ( 'find_wall_dist-> complete' ) end subroutine find_wall_dist end module wall_dist","tags":"","loc":"sourcefile/wall_dist.f90.html","title":"wall_dist.f90 – FEST-3D"},{"text":"Detect all the grid points on the wall boundary condition This file depends on sourcefile~~wall.f90~~EfferentGraph sourcefile~wall.f90 wall.f90 sourcefile~utils.f90 utils.f90 sourcefile~wall.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~wall.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~wall.f90~~AfferentGraph sourcefile~wall.f90 wall.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules wall Source Code wall.f90 Source Code !< Detect all the grid points on the wall boundary condition module wall !< Detect all the grid points on the wall boundary condition !< and store them in a single file use vartypes use mpi use utils , only : alloc #include \"../debug.h\" #include \"../error.h\" private integer :: ierr !< Integer to store error integer :: new_type !< Create new type for MPI integer :: thisfile !< File hadler integer , parameter :: maxlen = 70 !< Maximum length for string real ( wp ), private , dimension (:, :), allocatable , target :: wallc !< Centre of wall surface real ( wp ), private , dimension (:), pointer :: wall_x !< X coordiante of center of wall surface real ( wp ), private , dimension (:), pointer :: wall_y !< Y coordiante of center of wall surface real ( wp ), private , dimension (:), pointer :: wall_z !< Z coordiante of center of wall surface integer , dimension ( 6 ) :: no_slip_flag = 0 !< Flag to detect wall integer , public :: n_wall !< Number of points on the wall integer , public :: total_n_wall !< Total number of points on the block across all processes character ( len = maxlen ), dimension (:), allocatable :: str !< Store all wall corridnate of current process in a string vector character ( len = maxlen ) :: line !< Line to write in output file character , parameter :: lf = Achar ( 10 ) !< End of line character ! For gather all the data to process 0 integer , dimension (:), allocatable :: n_wall_buf !< Store n_wall points of all processors in a array form integer , dimension (:), allocatable :: write_flag !< Check if current processor has any wall points to write integer :: imx , jmx , kmx public :: write_surfnode contains subroutine write_surfnode ( files , nodes , control , bc , dims ) !< Extract and write the wall surface node points !< in a file shared by all the MPI processes implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( in ) :: control type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes integer :: count integer :: i imx = dims % imx jmx = dims % jmx kmx = dims % kmx call setup_surface ( files , control , bc ) call surface_points ( nodes ) call MPI_GATHER ( n_wall , 1 , MPI_Integer , n_wall_buf , 1 , & MPI_integer , 0 , MPI_COMM_WORLD , ierr ) total_n_wall = sum ( n_wall_buf (:)) call MPI_Bcast ( total_n_wall , 1 , MPI_Integer , 0 , & MPI_COMM_WORLD , ierr ) call MPI_Bcast ( n_wall_buf , control % total_process , MPI_Integer , 0 , & MPI_COMM_WORLD , ierr ) write_flag = 0 count = 0 do i = 1 , control % total_process if ( n_wall_buf ( i ) > 0 ) then write_flag ( i ) = count count = count + 1 end if end do call MPI_TYPE_CONTIGUOUS ( maxlen , MPI_Character , new_type , ierr ) call MPI_TYPE_COMMIT ( new_type , ierr ) if ( process_id == 0 ) then write ( line , '(I0)' ) total_n_wall line ( len ( line ): len ( line )) = lf call MPI_FILE_WRITE_shared ( thisfile , line , 1 , & new_type , & MPI_STATUS_IGNORE , ierr ) end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) if ( n_wall > 0 ) then do i = 1 , n_wall write ( line , '(3(ES18.10E3,4x))' ) wall_x ( i ), wall_y ( i ), wall_z ( i ) line ( len ( line ): len ( line )) = lf call MPI_FILE_WRITE_shared ( thisfile , line , 1 , & new_type , & MPI_STATUS_IGNORE , ierr ) end do end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) call MPI_FILE_CLOSE ( thisfile , ierr ) end subroutine write_surfnode subroutine allocate_memory ( control ) !< Allocate memory to str and wallc variable array implicit none type ( controltype ), intent ( in ) :: control DebugCall ( 'setup_surface' ) n_wall = - 1 n_wall = (( jmx ) * ( kmx ) * ( NO_SLIP_flag ( 1 )) & + ( jmx ) * ( kmx ) * ( NO_SLIP_flag ( 2 )) & + ( kmx ) * ( imx ) * ( NO_SLIP_flag ( 3 )) & + ( kmx ) * ( imx ) * ( NO_SLIP_flag ( 4 )) & + ( imx ) * ( jmx ) * ( NO_SLIP_flag ( 5 )) & + ( imx ) * ( jmx ) * ( NO_SLIP_flag ( 6 )) & ) allocate ( str ( 1 : n_wall )) call alloc ( wallc , 1 , n_wall , 1 , 3 ,& errmsg = 'Error: Unable to allocate memory for wallc' ) allocate ( n_wall_buf ( 1 : control % total_process )) allocate ( write_flag ( 1 : control % total_process )) end subroutine allocate_memory subroutine link_aliases () !< Link pointers wall_x, wall_y, wall_z to wallc implicit none DebugCall ( 'link_aliases' ) wall_x ( 1 : n_wall ) => wallc ( 1 : n_wall , 1 ) wall_y ( 1 : n_wall ) => wallc ( 1 : n_wall , 2 ) wall_z ( 1 : n_wall ) => wallc ( 1 : n_wall , 3 ) end subroutine link_aliases subroutine setup_surface ( files , control , bc ) !< Open MPI_shared write file, allocate memory and !< setup pointers implicit none type ( boundarytype ), intent ( in ) :: bc type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( in ) :: control integer :: stat DebugCall ( 'setup_surface' ) if ( process_id == 0 ) then open ( files % NODESURF_FILE_UNIT , file = files % surface_node_points , iostat = stat ) if ( stat == 0 ) close ( files % NODESURF_FILE_UNIT , status = 'delete' ) end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) call MPI_FILE_OPEN ( MPI_COMM_WORLD , files % surface_node_points , & MPI_MODE_WRONLY + MPI_MODE_CREATE + MPI_MODE_EXCL , & MPI_INFO_NULL , thisfile , ierr ) call find_wall ( bc ) call allocate_memory ( control ) call link_aliases () end subroutine setup_surface subroutine find_wall ( bc ) !< Setup wall flag for all six boundary of the block implicit none type ( boundarytype ), intent ( in ) :: bc integer :: i NO_slip_flag = 0 do i = 1 , 6 if ( bc % id ( i ) ==- 5 ) NO_SLIP_FLAG ( i ) = 1 end do end subroutine find_wall subroutine surface_points ( nodes ) !< Extract surface points and store them !< in a string vector str(ind) implicit none type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes integer :: OL integer :: i , j , k , ind integer :: im = 1 , ix = 1 integer :: jm = 1 , jx = 1 integer :: km = 1 , kx = 1 DebugCall ( 'surface_points' ) ind = 0 do OL = 1 , 6 if ( NO_SLIP_flag ( OL ) == 1 ) then select case ( OL ) case ( 1 ) km = 1 jm = 1 im = 1 kx = kmx jx = jmx ix = 1 case ( 2 ) km = 1 jm = 1 im = imx kx = kmx jx = jmx ix = imx case ( 3 ) km = 1 jm = 1 im = 1 kx = kmx jx = 1 ix = imx case ( 4 ) km = 1 jm = jmx im = 1 kx = kmx jx = jmx ix = imx case ( 5 ) km = 1 jm = 1 im = 1 kx = 1 jx = jmx ix = imx case ( 6 ) km = kmx jm = 1 im = 1 kx = kmx jx = jmx ix = imx case DEFAULT Fatal_error km = 1 jm = 1 im = 1 kx = - 1 jx = - 1 ix = - 1 end select do k = km , kx do j = jm , jx do i = im , ix ind = ind + 1 wall_x ( ind ) = nodes ( i , j , k )% x wall_y ( ind ) = nodes ( i , j , k )% y wall_z ( ind ) = nodes ( i , j , k )% z write ( str ( ind ), '(3(f0.16, 4x))' ) wall_x ( ind ), wall_y ( ind ), wall_z ( ind ) end do end do end do end if end do end subroutine surface_points end module wall","tags":"","loc":"sourcefile/wall.f90.html","title":"wall.f90 – FEST-3D"},{"text":"Check for the input from the output_control.md file This file depends on sourcefile~~check_output_control.f90~~EfferentGraph sourcefile~check_output_control.f90 check_output_control.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~check_output_control.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~check_output_control.f90~~AfferentGraph sourcefile~check_output_control.f90 check_output_control.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~read_output.f90->sourcefile~check_output_control.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~check_output_control.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules check_output_control Source Code check_output_control.f90 Source Code !< Check for the input from the output_control.md file module check_output_control !< Check for the input from the output_control.md file use vartypes implicit none private public :: verify_write_control public :: verify_read_control contains subroutine verify_write_control ( control , scheme , flow ) !< Verify all the variable being asked to write in the output file. !< This is a fail-safe subroutine which do not allow to write the incorrect input variable implicit none type ( controltype ), intent ( inout ) :: control type ( schemetype ) , intent ( in ) :: scheme type ( flowtype ) , intent ( in ) :: flow integer :: n character ( len =* ), parameter :: err = \"Control Error: can't write variable - \" do n = 1 , control % w_count select case ( trim ( lcase ( control % w_list ( n )))) case ( 'velocity' , 'vel' , 'speed' , 'u' , 'v' ) control % w_list ( n ) = \"Velocity\" case ( 'density' , 'rho' ) control % w_list ( n ) = \"Density\" case ( 'pressure' , 'presssure' , 'p' ) control % w_list ( n ) = \"Pressure\" case ( 'mu' , 'viscosity' , 'mu_l' , 'laminar_viscosity' , 'muv' , 'mu_v' ) if ( flow % mu_ref /= 0.0 ) then control % w_list ( n ) = \"Mu\" else print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end if case ( 'mu_t' , 'turbulent_viscosity' , 'mut' ) if ( scheme % turbulence /= 'none' ) then control % w_list ( n ) = \"Mu_t\" else print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end if case ( 'tke' , 'tk' , 'turbulent_kinetic_enrgy' , 'k' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) control % w_list ( n ) = \"TKE\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'omega' , 'tw' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) control % w_list ( n ) = \"Omega\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dissipation' , 'te' , 'teps' , 'eps' ) select case ( trim ( scheme % turbulence )) case ( 'ke' ) control % w_list ( n ) = \"Dissipation\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'kl' ) select case ( trim ( scheme % turbulence )) case ( 'kkl' ) control % w_list ( n ) = \"Kl\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'tv' ) select case ( trim ( scheme % turbulence )) case ( 'sa' , 'saBC' ) control % w_list ( n ) = \"tv\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'wall_distance' , 'dist' , 'wall_dist' , 'wdist' ) if ( scheme % turbulence /= \"none\" ) then control % w_list ( n ) = \"Wall_distance\" else print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end if case ( 'resnorm' ) control % w_list ( n ) = \"Resnorm\" case ( 'tke_residue' ) control % w_list ( n ) = \"TKE_residue\" case ( 'omega_residue' ) control % w_list ( n ) = \"Omega_residue\" case ( 'tv_residue' ) control % w_list ( n ) = \"Tv_residue\" case ( 'mass_residue' ) control % w_list ( n ) = \"Mass_residue\" case ( 'x_mom_residue' ) control % w_list ( n ) = \"X_mom_residue\" case ( 'y_mom_residue' ) control % w_list ( n ) = \"Y_mom_residue\" case ( 'z_mom_residue' ) control % w_list ( n ) = \"Z_mom_residue\" case ( 'energy_residue' ) control % w_list ( n ) = \"Energy_residue\" case ( 'f1' ) if ( trim ( scheme % turbulence ) == 'sst' . or . trim ( scheme % turbulence ) == 'sst2003' ) then control % w_list ( n ) = \"F1\" else control % w_list ( n ) = 'do not write' end if case ( 'dudx' ) control % w_list ( n ) = \"Dudx\" case ( 'dudy' ) control % w_list ( n ) = \"Dudy\" case ( 'dudz' ) control % w_list ( n ) = \"Dudz\" case ( 'dvdx' ) control % w_list ( n ) = \"Dvdx\" case ( 'dvdy' ) control % w_list ( n ) = \"Dvdy\" case ( 'dvdz' ) control % w_list ( n ) = \"Dvdz\" case ( 'dwdx' ) control % w_list ( n ) = \"Dwdx\" case ( 'dwdy' ) control % w_list ( n ) = \"Dwdy\" case ( 'dwdz' ) control % w_list ( n ) = \"Dwdz\" case ( 'dTdx' ) control % w_list ( n ) = \"DTdx\" case ( 'dTdy' ) control % w_list ( n ) = \"DTdy\" case ( 'dTdz' ) control % w_list ( n ) = \"DTdz\" case ( 'dtkdx' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) control % w_list ( n ) = \"Dtkdx\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtkdy' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) control % w_list ( n ) = \"Dtkdy\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtkdz' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) control % w_list ( n ) = \"Dtkdz\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtwdx' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) control % w_list ( n ) = \"Dtwdx\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtwdy' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) control % w_list ( n ) = \"Dtwdy\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtwdz' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) control % w_list ( n ) = \"Dtwdz\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtedx' ) select case ( trim ( scheme % turbulence )) case ( 'ke' ) control % w_list ( n ) = \"Dtedx\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtedy' ) select case ( trim ( scheme % turbulence )) case ( 'ke' ) control % w_list ( n ) = \"Dtedy\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtedz' ) select case ( trim ( scheme % turbulence )) case ( 'ke' ) control % w_list ( n ) = \"Dtedz\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtkldx' ) select case ( trim ( scheme % turbulence )) case ( 'kkl' ) control % w_list ( n ) = \"Dtkldx\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtkldy' ) select case ( trim ( scheme % turbulence )) case ( 'kkl' ) control % w_list ( n ) = \"Dtkldy\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtkldz' ) select case ( trim ( scheme % turbulence )) case ( 'kkl' ) control % w_list ( n ) = \"Dtkldz\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtvdx' ) select case ( trim ( scheme % turbulence )) case ( 'sa' , 'saBC' ) control % w_list ( n ) = \"Dtvdx\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtvdy' ) select case ( trim ( scheme % turbulence )) case ( 'sa' , 'saBC' ) control % w_list ( n ) = \"Dtvdy\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtvdz' ) select case ( trim ( scheme % turbulence )) case ( 'sa' , 'saBC' ) control % w_list ( n ) = \"Dtvdz\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'intermittency' ) select case ( trim ( scheme % turbulence )) case ( 'saBC' ) control % w_list ( n ) = \"Intermittency\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'tgm' ) select case ( trim ( scheme % transition )) case ( 'lctm2015' ) control % w_list ( n ) = \"tgm\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'extravar1' , 'extravar2' , 'extravar3' , 'extravar4' , 'extravar5' ) control % w_list ( n ) = trim ( lcase ( control % w_list ( n ))) case Default print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select end do end subroutine verify_write_control subroutine verify_read_control ( control , scheme ) !< Verify all the variable being asked to read in the output file. !< This is a fail-safe subroutine which do not allow to read the incorrect input variable. !< Based on previous flow type some varible might be skipped implicit none type ( controltype ), intent ( inout ) :: control type ( schemetype ) , intent ( in ) :: scheme integer :: n character ( len =* ), parameter :: err = \"Control Error: can't read variable - \" do n = 1 , control % r_count select case ( trim ( lcase ( control % r_list ( n )))) case ( 'velocity' , 'vel' , 'speed' , 'u' , 'v' ) control % r_list ( n ) = \"Velocity\" case ( 'density' , 'rho' ) control % r_list ( n ) = \"Density\" case ( 'pressure' , 'presssure' , 'p' ) control % r_list ( n ) = \"Pressure\" case ( 'mu' , 'viscosity' , 'mu_l' , 'laminar_viscosity' , 'muv' , 'mu_v' ) control % r_list ( n ) = \"do not read\" ! if (flow%mu_ref/=0.0) then !   control%r_list(n) = \"Mu\" ! else !   print*, err//trim(control%r_list(n))//\" from file\" !   control%r_list(n) = \"do not read\" ! end if case ( 'mu_t' , 'turbulent_viscosity' , 'mut' ) control % r_list ( n ) = \"do not read\" !if (scheme%turbulence/='none') then !  control%r_list(n) = \"Mu_t\" !else !  print*, err//trim(control%r_list(n))//\" from file\" !  control%r_list(n) = \"do not read\" !end if case ( 'tke' , 'tk' , 'turbulent_kinetic_enrgy' , 'k' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) select case ( trim ( control % previous_flow_type )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) control % r_list ( n ) = \"TKE\" end select case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case ( 'omega' , 'tw' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) select case ( trim ( control % previous_flow_type )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) control % r_list ( n ) = \"Omega\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case ( 'dissipation' , 'te' , 'teps' , 'eps' ) select case ( trim ( scheme % turbulence )) case ( 'ke' ) select case ( trim ( control % previous_flow_type )) case ( 'ke' ) control % r_list ( n ) = \"Dissipation\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case ( 'kl' ) select case ( trim ( scheme % turbulence )) case ( 'kkl' ) select case ( trim ( control % previous_flow_type )) case ( 'kkl' ) control % r_list ( n ) = \"Kl\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case ( 'tv' ) select case ( trim ( scheme % turbulence )) case ( 'sa' , 'saBC' ) select case ( trim ( control % previous_flow_type )) case ( 'sa' , 'saBC' ) control % r_list ( n ) = \"tv\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case ( 'wall_distance' , 'dist' , 'wall_dist' , 'wdist' ) control % r_list ( n ) = \"do not read\" !if(scheme%turbulence/=\"none\") then !  control%r_list(n) = \"Wall_distance\" !else !  print*, err//trim(control%r_list(n))//\" from file\" !  control%r_list(n) = \"do not read\" !end if case ( 'intermittency' ) select case ( trim ( scheme % turbulence )) case ( 'saBC' ) select case ( trim ( control % previous_flow_type )) case ( 'saBC' ) control % r_list ( n ) = \"Intermittency\" case DEFAULT print * , err // trim ( control % r_list ( n )) // \" to file\" control % r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( control % r_list ( n )) // \" to file\" control % r_list ( n ) = \"do not read\" end select case ( 'tgm' ) select case ( trim ( scheme % transition )) case ( 'lctm2015' ) select case ( trim ( control % previous_flow_type )) case ( 'sst' , 'sst2003' ) control % r_list ( n ) = \"tgm\" case DEFAULT print * , err // trim ( control % r_list ( n )) // \" to file\" control % r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( control % r_list ( n )) // \" to file\" control % r_list ( n ) = \"do not read\" end select case ( 'resnorm' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Resnorm\" case ( 'tke_residue' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"TKE_residue\" case ( 'omega_residue' ) control % r_list ( n ) = \"do not read\" !control%w_list(n) = \"Omega_residue\" case ( 'f1' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"F1\" case ( 'dudx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dudx\" case ( 'dudy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dudy\" case ( 'dudz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dudz\" case ( 'dvdx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dvdx\" case ( 'dvdy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dvdy\" case ( 'dvdz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dvdz\" case ( 'dwdx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dwdx\" case ( 'dwdy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dwdy\" case ( 'dwdz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dwdz\" case ( 'dTdx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"DTdx\" case ( 'dTdy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"DTdy\" case ( 'dTdz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"DTdz\" case ( 'dtkdx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtkdx\" case ( 'dtkdy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtkdy\" case ( 'dtkdz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtkdz\" case ( 'dtwdx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtwdx\" case ( 'dtwdy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtwdy\" case ( 'dtwdz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtwdz\" case ( 'extravar1' , 'extravar2' , 'extravar3' , 'extravar4' , 'extravar5' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = trim(lcase(control%w_list(n))) case Default print * , err // trim ( control % r_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select end do end subroutine verify_read_control function lcase ( text ) result ( res ) !< Make the whole string to lower case CHARACTER ( len =* ), intent ( in ) :: text !< Input string of any case character ( len = STRING_BUFFER_LENGTH ) :: res !< Output string of lower case integer :: I , C res = text DO I = 1 , LEN ( TEXT ) C = INDEX ( \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , TEXT ( I : I )) IF ( C . GT . 0 ) res ( I : I ) = \"abcdefghijklmnopqrstuvwxyz\" ( C : C ) END DO end function lcase end module check_output_control","tags":"","loc":"sourcefile/check_output_control.f90.html","title":"check_output_control.f90 – FEST-3D"},{"text":"Writing solution in the output file in tecplot format with\n node data instead of cell-center data. This file depends on sourcefile~~write_output_tec_node.f90~~EfferentGraph sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~write_output_tec_node.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~write_output_tec_node.f90->sourcefile~wall_dist.f90 sourcefile~utils.f90 utils.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~write_output_tec_node.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~write_output_tec_node.f90~~AfferentGraph sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules write_output_tec_node Source Code write_output_tec_node.f90 Source Code !< Writing solution in the output file in tecplot format with !< node data instead of cell-center data. module write_output_tec_node !< Writing solution in the output file in tecplot format with !< node data instead of cell-center data. !--------------------------------------------------------- ! This module write state + other variable in output file !--------------------------------------------------------- #include \"../../debug.h\" #include \"../../error.h\" use vartypes use viscosity , only : mu use viscosity , only : mu_t use wall_dist , only : dist use global_sst , only : sst_F1 use gradients , only : gradu_x use gradients , only : gradu_y use gradients , only : gradu_z use gradients , only : gradv_x use gradients , only : gradv_y use gradients , only : gradv_z use gradients , only : gradw_x use gradients , only : gradw_y use gradients , only : gradw_z use gradients , only : gradT_x use gradients , only : gradT_y use gradients , only : gradT_z use gradients , only : gradtk_x use gradients , only : gradtk_y use gradients , only : gradtk_z use gradients , only : gradtw_x use gradients , only : gradtw_y use gradients , only : gradtw_z use utils implicit none private integer :: OUT_FILE_UNIT integer :: i , j , k character ( len =* ), parameter :: format = \"(35e25.15)\" integer :: imx , jmx , kmx real ( wp ), dimension (:, :, :), pointer :: density !< Rho pointer, point to slice of qp (:,:,:,1) real ( wp ), dimension (:, :, :), pointer :: x_speed !< U pointer, point to slice of qp (:,:,:,2) real ( wp ), dimension (:, :, :), pointer :: y_speed !< V pointer, point to slice of qp (:,:,:,3) real ( wp ), dimension (:, :, :), pointer :: z_speed !< W pointer, point to slice of qp (:,:,:,4) real ( wp ), dimension (:, :, :), pointer :: pressure !< P pointer, point to slice of qp (:,:,:,5) real ( wp ), dimension (:, :, :), pointer :: tk !< TKE, point to slice of qp (:,:,:,6) real ( wp ), dimension (:, :, :), pointer :: tw !< Omega, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: te !< Dissipation, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: tv !< SA visocity, point to slice of qp (:,:,:,6) real ( wp ), dimension (:, :, :), pointer :: tkl !< KL K-KL method, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: tgm !< Intermittency of LCTM2015, point to slice of qp (:,:,:,8) public :: write_file contains subroutine write_file ( file_handler , state , nodes , control , scheme , dims ) !< Write output file in the tecplot format with node data implicit none integer , intent ( in ) :: file_handler type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: state integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" DebugCall ( \"write_file\" ) OUT_FILE_UNIT = file_handler imx = dims % imx jmx = dims % jmx kmx = dims % kmx density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 8 ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call write_header ( control ) call write_grid ( nodes ) do n = 1 , control % w_count select case ( trim ( control % w_list ( n ))) case ( 'Velocity' ) call write_scalar ( x_speed , \"u\" , - 2 ) call write_scalar ( y_speed , \"v\" , - 2 ) call write_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) ! case('Wall_distance') !   call write_scalar(dist, \"Wall_dist\", 1) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'do not write' ) ! do not write continue case Default print * , err // trim ( control % w_list ( n )) // \" to file\" end select end do end subroutine write_file subroutine write_header ( control ) !< Write the header in the output file implicit none type ( controltype ), intent ( in ) :: control integer :: n integer :: total DebugCall ( 'write_output_vtk: write_header' ) write ( OUT_FILE_UNIT , '(a)' ) \"variables = x y z \" total = 3 do n = 1 , control % w_count select case ( trim ( control % w_list ( n ))) case ( 'Velocity' ) write ( OUT_FILE_UNIT , '(a)' ) \" u v w \" total = total + 3 case ( 'do not write' ) !skip continue case Default write ( OUT_FILE_UNIT , '(a)' ) trim ( control % w_list ( n )) // \" \" total = total + 1 end select end do write ( OUT_FILE_UNIT , '(a,i4.4,3(a,i5.5),a)' ) \"zone T=block\" , process_id , \"  i=\" , imx , \" j=\" , jmx , \" k=\" , kmx - 1 , \" Datapacking=Block\" write ( OUT_FILE_UNIT , * ) \"Varlocation=([1-3]=Nodal)\" write ( OUT_FILE_UNIT , '(a,i2.2,a)' ) \"Varlocation=([4-\" , total , \"]=Nodal)\" write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"STRANDID=\" , 1 write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"SOLUTIONTIME=\" , control % checkpoint_iter_count end subroutine write_header subroutine write_grid ( nodes ) !< Write grid information in the output file implicit none type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes ! write grid point coordinates DebugCall ( 'write_output_tec_node: write_grid' ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% x , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% y , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% z , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) end subroutine write_grid subroutine write_scalar ( var , name , index ) !< Write scalar variable in the output file implicit none integer , intent ( in ) :: index real ( wp ), dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( 'write_scalar' // trim ( name )) write ( OUT_FILE_UNIT , format ) ((( 0.25 * ( var ( i , j , k ) + var ( i - 1 , j , k )& + var ( i , j - 1 , k ) + var ( i - 1 , j - 1 , k ))& , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) end subroutine write_scalar end module write_output_tec_node","tags":"","loc":"sourcefile/write_output_tec_node.f90.html","title":"write_output_tec_node.f90 – FEST-3D"},{"text":"Vtk module to write the solution in the vtk format This file depends on sourcefile~~write_output_vtk.f90~~EfferentGraph sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~write_output_vtk.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~write_output_vtk.f90->sourcefile~wall_dist.f90 sourcefile~utils.f90 utils.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~write_output_vtk.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~write_output_vtk.f90~~AfferentGraph sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules write_output_vtk Source Code write_output_vtk.f90 Source Code !< Vtk module to write the solution in the vtk format module write_output_vtk !< Vtk module to write the solution in the vtk format !--------------------------------------------------------- ! This module write state + other variable in output file !--------------------------------------------------------- #include \"../../debug.h\" #include \"../../error.h\" use vartypes use viscosity , only : mu use viscosity , only : mu_t use wall_dist , only : dist use global_sst , only : sst_F1 use gradients , only : gradu_x use gradients , only : gradu_y use gradients , only : gradu_z use gradients , only : gradv_x use gradients , only : gradv_y use gradients , only : gradv_z use gradients , only : gradw_x use gradients , only : gradw_y use gradients , only : gradw_z use gradients , only : gradT_x use gradients , only : gradT_y use gradients , only : gradT_z use gradients , only : gradtk_x use gradients , only : gradtk_y use gradients , only : gradtk_z use gradients , only : gradtw_x use gradients , only : gradtw_y use gradients , only : gradtw_z use utils implicit none private integer :: OUT_FILE_UNIT integer :: i , j , k integer :: imx , jmx , kmx real ( wp ), dimension (:, :, :), pointer :: density !< Rho pointer, point to slice of qp (:,:,:,1) real ( wp ), dimension (:, :, :), pointer :: x_speed !< U pointer, point to slice of qp (:,:,:,2) real ( wp ), dimension (:, :, :), pointer :: y_speed !< V pointer, point to slice of qp (:,:,:,3) real ( wp ), dimension (:, :, :), pointer :: z_speed !< W pointer, point to slice of qp (:,:,:,4) real ( wp ), dimension (:, :, :), pointer :: pressure !< P pointer, point to slice of qp (:,:,:,5) real ( wp ), dimension (:, :, :), pointer :: tk !< TKE, point to slice of qp (:,:,:,6) real ( wp ), dimension (:, :, :), pointer :: tw !< Omega, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: te !< Dissipation, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: tv !< SA visocity, point to slice of qp (:,:,:,6) real ( wp ), dimension (:, :, :), pointer :: tkl !< KL K-KL method, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: tgm !< Intermittency of LCTM2015, point to slice of qp (:,:,:,8) public :: write_file contains subroutine write_file ( file_handler , state , nodes , control , scheme , dims ) !< Write the header and variables in the file \"process_xx.dat\" implicit none integer , intent ( in ) :: file_handler type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: state integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" DebugCall ( \"write_file\" ) OUT_FILE_UNIT = file_handler imx = dims % imx jmx = dims % jmx kmx = dims % kmx density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 8 ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call write_header ( control % Write_data_format ) call write_grid ( nodes ) do n = 1 , control % w_count select case ( trim ( control % w_list ( n ))) case ( 'Velocity' ) call write_velocity () case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) case ( 'tgm' ) call write_scalar ( tgm , \"tgm\" , - 2 ) case ( 'Dissipation' ) call write_scalar ( te , \"Dissipation\" , - 2 ) case ( 'Wall_distance' ) call write_scalar ( dist , \"dist\" , - 2 ) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'do not write' ) ! do nothing continue case Default print * , err // trim ( control % w_list ( n )) // \" to file\" end select end do end subroutine write_file subroutine write_header ( Write_data_format ) !< Write the header in the output file in the tecplot format implicit none character ( len =* ), intent ( in ) :: Write_data_format DebugCall ( \"write_header\" ) write ( OUT_FILE_UNIT , fmt = '(a)' ) '# vtk DataFile Version 3.1' write ( OUT_FILE_UNIT , '(a)' ) 'cfd-iitm output' ! comment line write ( OUT_FILE_UNIT , '(a)' ) trim ( Write_data_format ) write ( OUT_FILE_UNIT , '(a)' ) 'DATASET STRUCTURED_GRID' !write(OUT_FILE_UNIT, *) end subroutine write_header subroutine write_grid ( nodes ) !< Write the grid information in the output file implicit none type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes ! write grid point coordinates DebugCall ( \"write_grid\" ) write ( OUT_FILE_UNIT , fmt = '(a, i0, a, i0, a, i0)' ) & 'DIMENSIONS ' , imx , ' ' , jmx , ' ' , kmx write ( OUT_FILE_UNIT , fmt = '(a, i0, a)' ) & 'POINTS ' , imx * jmx * kmx , ' DOUBLE' do k = 1 , kmx do j = 1 , jmx do i = 1 , imx write ( OUT_FILE_UNIT , fmt = '(f0.16, a, f0.16, a, f0.16)' ) & nodes ( i , j , k )% x , ' ' , nodes ( i , j , k )% y , ' ' , nodes ( i , j , k )% z end do end do end do write ( OUT_FILE_UNIT , * ) end subroutine write_grid subroutine write_velocity () !< Write the velocity vector in the output file implicit none DebugCall ( \"write_velocity\" ) ! Cell data ! Writing Velocity write ( OUT_FILE_UNIT , fmt = '(a, i0)' ) 'CELL_DATA ' , ( imx - 1 ) * ( jmx - 1 ) * ( kmx - 1 ) write ( OUT_FILE_UNIT , '(a)' ) 'VECTORS Velocity FLOAT' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( OUT_FILE_UNIT , fmt = '(ES27.16E4, a, ES27.16E4, a, ES27.16E4)' ) & x_speed ( i , j , k ), ' ' , y_speed ( i , j , k ), ' ' , z_speed ( i , j , k ) end do end do end do write ( OUT_FILE_UNIT , * ) end subroutine write_velocity subroutine write_scalar ( var , name , index ) !< Write the scalar variable in the output file implicit none integer , intent ( in ) :: index real ( wp ), dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( \"write_scalar: \" // trim ( name )) write ( OUT_FILE_UNIT , '(a)' ) 'SCALARS ' // trim ( name ) // ' FLOAT' write ( OUT_FILE_UNIT , '(a)' ) 'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( OUT_FILE_UNIT , fmt = '(ES25.16E4)' ) var ( i , j , k ) end do end do end do write ( OUT_FILE_UNIT , * ) end subroutine write_scalar end module write_output_vtk","tags":"","loc":"sourcefile/write_output_vtk.f90.html","title":"write_output_vtk.f90 – FEST-3D"},{"text":"Tecplot module to write the solution in the tecplot format This file depends on sourcefile~~write_output_tec.f90~~EfferentGraph sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~write_output_tec.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~write_output_tec.f90->sourcefile~wall_dist.f90 sourcefile~utils.f90 utils.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~write_output_tec.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~write_output_tec.f90~~AfferentGraph sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules write_output_tec Source Code write_output_tec.f90 Source Code !< Tecplot module to write the solution in the tecplot format module write_output_tec !< Tecplot module to write the solution in the tecplot format !--------------------------------------------------------- ! This module write state + other variable in output file !--------------------------------------------------------- #include \"../../debug.h\" #include \"../../error.h\" use vartypes use viscosity , only : mu use viscosity , only : mu_t use wall_dist , only : dist use global_sst , only : sst_F1 use gradients , only : gradu_x use gradients , only : gradu_y use gradients , only : gradu_z use gradients , only : gradv_x use gradients , only : gradv_y use gradients , only : gradv_z use gradients , only : gradw_x use gradients , only : gradw_y use gradients , only : gradw_z use gradients , only : gradT_x use gradients , only : gradT_y use gradients , only : gradT_z use gradients , only : gradtk_x use gradients , only : gradtk_y use gradients , only : gradtk_z use gradients , only : gradtw_x use gradients , only : gradtw_y use gradients , only : gradtw_z use utils implicit none private integer :: OUT_FILE_UNIT integer :: i , j , k character ( len =* ), parameter :: format = \"(1ES28.15E4)\" integer :: imx , jmx , kmx real ( wp ), dimension (:, :, :), pointer :: density !< Rho pointer, point to slice of qp (:,:,:,1) real ( wp ), dimension (:, :, :), pointer :: x_speed !< U pointer, point to slice of qp (:,:,:,2) real ( wp ), dimension (:, :, :), pointer :: y_speed !< V pointer, point to slice of qp (:,:,:,3) real ( wp ), dimension (:, :, :), pointer :: z_speed !< W pointer, point to slice of qp (:,:,:,4) real ( wp ), dimension (:, :, :), pointer :: pressure !< P pointer, point to slice of qp (:,:,:,5) real ( wp ), dimension (:, :, :), pointer :: tk !< TKE, point to slice of qp (:,:,:,6) real ( wp ), dimension (:, :, :), pointer :: tw !< Omega, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: te !< Dissipation, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: tv !< SA visocity, point to slice of qp (:,:,:,6) real ( wp ), dimension (:, :, :), pointer :: tkl !< KL K-KL method, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: tgm !< Intermittency of LCTM2015, point to slice of qp (:,:,:,8) public :: write_file contains subroutine write_file ( file_handler , state , nodes , control , scheme , dims ) !< Write the header and variables in the file \"process_xx.dat\". implicit none integer , intent ( in ) :: file_handler type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: state integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" DebugCall ( \"write_file\" ) OUT_FILE_UNIT = file_handler imx = dims % imx jmx = dims % jmx kmx = dims % kmx density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 8 ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call write_header ( control ) call write_grid ( nodes ) do n = 1 , control % w_count select case ( trim ( control % w_list ( n ))) case ( 'Velocity' ) call write_scalar ( x_speed , \"u\" , - 2 ) call write_scalar ( y_speed , \"v\" , - 2 ) call write_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) case ( 'tgm' ) call write_scalar ( tgm , \"tgm\" , - 2 ) case ( 'Wall_distance' ) call write_scalar ( dist , \"Wall_dist\" , - 2 ) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'do not write' ) ! do not write continue case Default print * , err // trim ( control % w_list ( n )) // \" to file\" end select end do end subroutine write_file subroutine write_header ( control ) !< Write the header in the output file in the tecplot format implicit none type ( controltype ), intent ( in ) :: control integer :: n integer :: total DebugCall ( \"write_header\" ) write ( OUT_FILE_UNIT , '(a)' ) \"variables = x y z \" total = 3 do n = 1 , control % w_count select case ( trim ( control % w_list ( n ))) case ( 'Velocity' ) write ( OUT_FILE_UNIT , '(a)' ) \" u v w \" total = total + 3 case ( 'do not write' ) !skip continue case Default write ( OUT_FILE_UNIT , '(a)' ) trim ( control % w_list ( n )) // \" \" total = total + 1 end select end do write ( OUT_FILE_UNIT , '(a,i4.4,3(a,i5.5),a)' ) \"zone T=block\" , process_id , \"  i=\" , imx , \" j=\" , jmx , \" k=\" , kmx , \" Datapacking=Block\" write ( OUT_FILE_UNIT , * ) \"Varlocation=([1-3]=Nodal)\" write ( OUT_FILE_UNIT , '(a,i2.2,a)' ) \"Varlocation=([4-\" , total , \"]=CELLCENTERED)\" write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"STRANDID=\" , 1 write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"SOLUTIONTIME=\" , control % checkpoint_iter_count end subroutine write_header subroutine write_grid ( nodes ) !< Write the grid information in the output file implicit none type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes ! write grid point coordinates DebugCall ( \"write_grid\" ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% x , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% y , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% z , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) end subroutine write_grid subroutine write_scalar ( var , name , index ) !< Write the scalar variable in the output file implicit none integer , intent ( in ) :: index real ( wp ), dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( \"write_scalar: \" // trim ( name )) write ( OUT_FILE_UNIT , format ) ((( var ( i , j , k ), i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine write_scalar end module write_output_tec","tags":"","loc":"sourcefile/write_output_tec.f90.html","title":"write_output_tec.f90 – FEST-3D"},{"text":"Check, create, and purge folder in the time_directory folder This file depends on sourcefile~~dump_solution.f90~~EfferentGraph sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~layout.f90 layout.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~utils.f90 utils.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~dump_solution.f90->sourcefile~vartypes.f90 sourcefile~layout.f90->sourcefile~vartypes.f90 sourcefile~write_output.f90->sourcefile~utils.f90 sourcefile~write_output.f90->sourcefile~vartypes.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~write_output_tec_node.f90->sourcefile~vartypes.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~write_output_tec_node.f90->sourcefile~wall_dist.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~write_output_tec_node.f90->sourcefile~gradients.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~write_output_vtk.f90->sourcefile~vartypes.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~write_output_vtk.f90->sourcefile~wall_dist.f90 sourcefile~write_output_vtk.f90->sourcefile~gradients.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90->sourcefile~vartypes.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~write_output_tec.f90->sourcefile~wall_dist.f90 sourcefile~write_output_tec.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 var pansourcefiledump_solutionf90EfferentGraph = svgPanZoom('#sourcefiledump_solutionf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~dump_solution.f90~~AfferentGraph sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules dump_solution Source Code dump_solution.f90 Source Code !<  Check, create, and purge folder in the time_directory folder module dump_solution !< This module contians subroutine that !<  1. check if point of dumping condition is arrived. !<  2. create particular folder for dump. !<  3. dump data in that folder. !<  4. purge folders if required. !------------------------------------------ #include \"../../debug.h\" #include \"../../error.h\" use vartypes use utils use write_output , only : write_file use layout , only : process_id implicit none private character ( len = FILE_NAME_LENGTH ) :: dump_dirname !< Name(check point number) of the directory to create character ( len = FILE_NAME_LENGTH ) :: purge_dirname !< Name(check point number) of the directory to remove public :: checkpoint contains subroutine checkpoint ( files , qp , nodes , control , scheme , dims ) !< Create a checkpoint dump file if the time has come !----------------------------------------------------------- implicit none type ( filetype ), intent ( inout ) :: files type ( extent ), intent ( in ) :: dims type ( controltype ), intent ( inout ) :: control type ( schemetype ), intent ( in ) :: scheme type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp DebugCall ( 'checkpoint' ) if ( control % checkpoint_iter . ne . 0 ) then if ( mod ( control % current_iter , control % checkpoint_iter ) == 0 & . or . control % current_iter == control % max_iters ) then call make_dump_dir ( control ) call dump_data ( files , qp , nodes , control , scheme , dims ) print * , \"writing data at: \" , control % current_iter , control % checkpoint_iter_count call purge_dump_dir ( control ) control % checkpoint_iter_count = control % checkpoint_iter_count + 1 end if end if end subroutine checkpoint subroutine create_directory ( dirname ) !< Create a directory to keep the solution files from all the processor implicit none character ( len =* ), intent ( in ) :: dirname character ( len = FILE_NAME_LENGTH ) :: mkdircmd mkdircmd = 'mkdir -p ' // trim ( dirname ) call system ( mkdircmd ) end subroutine create_directory subroutine remove_directory ( dirname ) !< Remove a directory implicit none character ( len =* ), intent ( in ) :: dirname character ( len = FILE_NAME_LENGTH ) :: rmdircmd rmdircmd = 'rm -rf ' // trim ( dirname ) call system ( rmdircmd ) end subroutine remove_directory subroutine purge_dump_dir ( control ) !< Purge the directory based on the input implicit none type ( controltype ), intent ( in ) :: control integer :: purge_num purge_num = control % checkpoint_iter_count - control % purge_write if ( control % purge_write /= 0 . and . purge_num > 0 ) then write ( purge_dirname , '(A,I4.4)' ) 'time_directories/' , purge_num call remove_directory ( purge_dirname ) end if end subroutine purge_dump_dir subroutine make_dump_dir ( control ) !< Solution directory and sub-directory in created with particular number implicit none type ( controltype ), intent ( in ) :: control write ( dump_dirname , '(A,I4.4)' ) 'time_directories/' , control % checkpoint_iter_count call create_directory ( dump_dirname ) call create_directory ( trim ( dump_dirname ) // '/restart' ) end subroutine make_dump_dir subroutine dump_data ( files , qp , nodes , control , scheme , dims ) !< Call to write save files in the directory implicit none type ( filetype ), intent ( inout ) :: files type ( extent ), intent ( in ) :: dims type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp DebugCall ( 'dump_solution: dump_data' ) write ( files % restartfile , '(A,I2.2)' ) trim ( dump_dirname ) // '/restart/process_' , process_id write ( files % outfile , '(A,I2.2)' ) trim ( dump_dirname ) // '/process_' , process_id call write_restart_log ( files , scheme , control ) call write_file ( files , qp , nodes , control , scheme , dims ) end subroutine dump_data subroutine write_restart_log ( files , scheme , control ) !< Call to write log file in the subdirectory \"restart\". !< It is useful information while restarting the solver implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme open ( files % RESTART_FILE_UNIT , file = files % restartfile ) select case ( scheme % turbulence ) case ( 'none' ) write ( files % RESTART_FILE_UNIT , '(A)' ) 'viscous' case ( 'sst' , 'sst2003' , 'kkl' , 'ke' , 'kw' , 'sa' , 'saBC' , 'des-sst' ) write ( files % RESTART_FILE_UNIT , '(A)' ) trim ( scheme % turbulence ) case DEFAULT Fatal_error end select call write_initial_resnorm ( files , control ) close ( files % RESTART_FILE_UNIT ) end subroutine write_restart_log subroutine write_initial_resnorm ( files , control ) !< Writing Initial resnorom in the log file to !< maintian continuity of resnorm while restrarting implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( in ) :: control integer :: i write ( files % RESTART_FILE_UNIT , '(I0)' ) control % current_iter + control % last_iter do i = 1 , control % n_var + 1 write ( files % RESTART_FILE_UNIT , '(f0.16)' ) control % previous_res ( i ) end do end subroutine write_initial_resnorm end module dump_solution","tags":"","loc":"sourcefile/dump_solution.f90.html","title":"dump_solution.f90 – FEST-3D"},{"text":"Open/close and call other modules for writing solution This file depends on sourcefile~~write_output.f90~~EfferentGraph sourcefile~write_output.f90 write_output.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~utils.f90 utils.f90 sourcefile~write_output.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~write_output.f90->sourcefile~vartypes.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~write_output_tec_node.f90->sourcefile~vartypes.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~write_output_tec_node.f90->sourcefile~wall_dist.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~write_output_tec_node.f90->sourcefile~gradients.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~write_output_vtk.f90->sourcefile~vartypes.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~write_output_vtk.f90->sourcefile~wall_dist.f90 sourcefile~write_output_vtk.f90->sourcefile~gradients.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90->sourcefile~vartypes.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~write_output_tec.f90->sourcefile~wall_dist.f90 sourcefile~write_output_tec.f90->sourcefile~gradients.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~vartypes.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~viscosity.f90->sourcefile~wall_dist.f90 sourcefile~viscosity.f90->sourcefile~gradients.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~vartypes.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~vartypes.f90 sourcefile~copy_bc.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~write_output.f90~~AfferentGraph sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules write_output Source Code write_output.f90 Source Code !< Open/close and call other modules for writing solution module write_output !< Open/close and call other modules for writing solution !< based on the input: type of file, either vtk or tecplot !< modules are called #include \"../../debug.h\" #include \"../../error.h\" use vartypes use utils use write_output_vtk , only : write_file_vtk => write_file use write_output_tec , only : write_file_tec => write_file use write_output_tec_node , only : write_file_tec_nodal => write_file implicit none private character ( len = 16 ) :: data_format character ( len = 16 ) :: file_format public write_file contains subroutine setup_file ( control ) !< Setup the file type based on the input implicit none type ( controltype ), intent ( in ) :: control DebugCall ( 'write_output_vtk: setup_file' ) if ( control % write_file_format == \"vtk\" ) then file_format = \".vtk\" elseif ( control % write_file_format == \"tecplot\" . or . control % write_file_format == \"tecplot_nodal\" ) then file_format = \".dat\" else print * , \"File format not recoganised. Accepted formats are\" print * , \"'vtk', 'tecplot' and 'tecplot_nodal' \" end if if ( control % write_data_format == \"ASCII\" ) then data_format = \"formatted\" elseif ( control % write_data_format == \"BINARY\" ) then data_format = \"unformatted\" else print * , \"Data format not recoganised. Accepted formats are\" print * , \"'ASCII' and 'BINARY' \" end if end subroutine setup_file subroutine open_file ( file_handler , filename ) !< Open the file to write the solution implicit none integer , intent ( in ) :: file_handler character ( len =* ), intent ( in ) :: filename DebugCall ( 'write_output: open_file' ) open ( file_handler , file = trim ( filename ) // trim ( file_format ) // '.part' , form = trim ( data_format )) end subroutine open_file subroutine close_file ( file_handler , filename ) !< Close the file after writing solution. implicit none integer , intent ( in ) :: file_handler character ( len =* ), intent ( in ) :: filename DebugCall ( 'write_output_vtk: close_file' ) call rename ( trim ( filename ) // trim ( file_format ) // '.part' , trim ( filename ) // trim ( file_format )) close ( file_handler ) end subroutine close_file subroutine write_file ( files , qp , nodes , control , scheme , dims ) !< Writing output in the file according to the input file type implicit none type ( filetype ), intent ( in ) :: files type ( extent ), intent ( in ) :: dims type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp integer :: file_handler file_handler = files % OUT_FILE_UNIT call setup_file ( control ) call open_file ( file_handler , files % outfile ) select case ( control % write_file_format ) case ( 'vtk' ) call write_file_vtk ( file_handler , qp , nodes , control , scheme , dims ) case ( 'tecplot' ) call write_file_tec ( file_handler , qp , nodes , control , scheme , dims ) case ( 'tecplot_nodal' ) call write_file_tec_nodal ( file_handler , qp , nodes , control , scheme , dims ) case DEFAULT Fatal_error end select call close_file ( file_handler , files % outfile ) end subroutine write_file end module write_output","tags":"","loc":"sourcefile/write_output.f90.html","title":"write_output.f90 – FEST-3D"},{"text":"Read the restart file in the vtk format This file depends on sourcefile~~read_output_vtk.f90~~EfferentGraph sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~utils.f90 utils.f90 sourcefile~read_output_vtk.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~read_output_vtk.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read_output_vtk.f90~~AfferentGraph sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~read_output.f90->sourcefile~read_output_vtk.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read_output_vtk Source Code read_output_vtk.f90 Source Code !< Read the restart file in the vtk format module read_output_vtk !< Read the restart file in the vtk format !--------------------------------------------------------- ! This module read state + other variable in output file !--------------------------------------------------------- #include \"../../debug.h\" #include \"../../error.h\" use vartypes use utils implicit none private integer :: IN_FILE_UNIT integer :: imx , jmx , kmx integer :: i , j , k real ( wp ), dimension (:, :, :), pointer :: density !< Rho pointer, point to slice of qp (:,:,:,1) real ( wp ), dimension (:, :, :), pointer :: x_speed !< U pointer, point to slice of qp (:,:,:,2) real ( wp ), dimension (:, :, :), pointer :: y_speed !< V pointer, point to slice of qp (:,:,:,3) real ( wp ), dimension (:, :, :), pointer :: z_speed !< W pointer, point to slice of qp (:,:,:,4) real ( wp ), dimension (:, :, :), pointer :: pressure !< P pointer, point to slice of qp (:,:,:,5) real ( wp ), dimension (:, :, :), pointer :: tk !< TKE, point to slice of qp (:,:,:,6) real ( wp ), dimension (:, :, :), pointer :: tw !< Omega, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: te !< Dissipation, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: tv !< SA visocity, point to slice of qp (:,:,:,6) real ( wp ), dimension (:, :, :), pointer :: tkl !< KL K-KL method, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: tgm !< Intermittency of LCTM2015, point to slice of qp (:,:,:,8) public :: read_file contains subroutine read_file ( file_handler , state , control , scheme , dims ) !< Read all the variable for the vtk restart file implicit none integer , intent ( in ) :: file_handler type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: state integer :: n IN_FILE_UNIT = file_handler imx = dims % imx jmx = dims % jmx kmx = dims % kmx density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 8 ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call read_header () call read_grid () do n = 1 , control % r_count select case ( trim ( control % r_list ( n ))) case ( 'Velocity' ) call read_velocity () case ( 'Density' ) call read_scalar ( density , 'Density' , - 2 ) case ( 'Pressure' ) call read_scalar ( pressure , 'Pressure' , - 2 ) case ( 'TKE' ) call read_scalar ( tk , 'TKE' , - 2 ) case ( 'Omega' ) call read_scalar ( tw , 'Omega' , - 2 ) case ( 'Kl' ) call read_scalar ( tkl , 'Kl' , - 2 ) case ( 'tv' ) call read_scalar ( tv , 'tv' , - 2 ) case ( 'tgm' ) call read_scalar ( tgm , 'tgm' , - 2 ) case ( 'do not read' ) call skip_scalar () case Default Print * , \"read error: list var : \" // trim ( control % r_list ( n )) end select end do end subroutine read_file subroutine read_header () !< Skip read the header in the vtk file implicit none DebugCall ( 'read_output_vtk: read_header' ) read ( IN_FILE_UNIT , * ) !'# vtk DataFile Version 3.1' read ( IN_FILE_UNIT , * ) !'cfd-iitm output'   ! comment line read ( IN_FILE_UNIT , * ) !trim(read_data_format) read ( IN_FILE_UNIT , * ) !'DATASET STRUCTURED_GRID' !read(IN_FILE_UNIT, *) end subroutine read_header subroutine read_grid () !< Skip the grid read in the restart file implicit none ! read grid point coordinates DebugCall ( 'read_output_vtk: read_grid' ) read ( IN_FILE_UNIT , * ) !'DIMENSIONS ', imx, ' ', jmx, ' ', kmx read ( IN_FILE_UNIT , * ) !'POINTS ', imx*jmx*kmx, ' DOUBLE' do k = 1 , kmx do j = 1 , jmx do i = 1 , imx read ( IN_FILE_UNIT , * ) !point(i, j, k)%x, ' ', point(i, j, k)%y, ' ', point(i, j, k)%z end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_grid subroutine read_velocity () !< Read velocity vector from the vtk file implicit none DebugCall ( 'read_output_vtk: read_velocity' ) read ( IN_FILE_UNIT , * ) !'CELL_DATA ', (imx-1)*(jmx-1)*(kmx-1) read ( IN_FILE_UNIT , * ) !'VECTORS Velocity FLOAT' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) x_speed ( i , j , k ), y_speed ( i , j , k ), z_speed ( i , j , k ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_velocity subroutine read_scalar ( var , name , index ) !< Read scalar from the vtk file implicit none integer , intent ( in ) :: index real ( wp ), dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( out ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( 'read_output_vtk' // trim ( name )) read ( IN_FILE_UNIT , * ) !'SCALARS '//trim(name)//' FLOAT' read ( IN_FILE_UNIT , * ) !'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) var ( i , j , k ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_scalar subroutine skip_scalar () !< Skip read scalar from the vtk file implicit none DebugCall ( 'read_output_vtk: skip_scalar' ) read ( IN_FILE_UNIT , * ) !'SCALARS '//trim(name)//' FLOAT' read ( IN_FILE_UNIT , * ) !'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine skip_scalar end module read_output_vtk","tags":"","loc":"sourcefile/read_output_vtk.f90.html","title":"read_output_vtk.f90 – FEST-3D"},{"text":"Read the restart file in the tecplot format This file depends on sourcefile~~read_output_tec.f90~~EfferentGraph sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~utils.f90 utils.f90 sourcefile~read_output_tec.f90->sourcefile~utils.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~read_output_tec.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read_output_tec.f90~~AfferentGraph sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read_output_tec Source Code read_output_tec.f90 Source Code !< Read the restart file in the tecplot format module read_output_tec !< Read the restart file in the tecplot format !--------------------------------------------------------- ! This module read state + other variable in output file !--------------------------------------------------------- #include \"../../debug.h\" #include \"../../error.h\" use vartypes use utils implicit none private integer :: IN_FILE_UNIT integer :: imx , jmx , kmx integer :: i , j , k real ( wp ), dimension (:, :, :), pointer :: density !< Rho pointer, point to slice of qp (:,:,:,1) real ( wp ), dimension (:, :, :), pointer :: x_speed !< U pointer, point to slice of qp (:,:,:,2) real ( wp ), dimension (:, :, :), pointer :: y_speed !< V pointer, point to slice of qp (:,:,:,3) real ( wp ), dimension (:, :, :), pointer :: z_speed !< W pointer, point to slice of qp (:,:,:,4) real ( wp ), dimension (:, :, :), pointer :: pressure !< P pointer, point to slice of qp (:,:,:,5) real ( wp ), dimension (:, :, :), pointer :: tk !< TKE, point to slice of qp (:,:,:,6) real ( wp ), dimension (:, :, :), pointer :: tw !< Omega, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: te !< Dissipation, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: tv !< SA visocity, point to slice of qp (:,:,:,6) real ( wp ), dimension (:, :, :), pointer :: tkl !< KL K-KL method, point to slice of qp (:,:,:,7) real ( wp ), dimension (:, :, :), pointer :: tgm !< Intermittency of LCTM2015, point to slice of qp (:,:,:,8) public :: read_file contains subroutine read_file ( file_handler , state , control , scheme , dims ) !< Read all the variable for the tecplot restart file implicit none integer , intent ( in ) :: file_handler type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: state integer :: n IN_FILE_UNIT = file_handler imx = dims % imx jmx = dims % jmx kmx = dims % kmx density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 8 ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call read_header ( control ) call read_grid () do n = 1 , control % r_count select case ( trim ( control % r_list ( n ))) case ( 'Velocity' ) call read_scalar ( x_speed , \"u\" , - 2 ) call read_scalar ( y_speed , \"v\" , - 2 ) call read_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call read_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call read_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'TKE' ) call read_scalar ( tk , 'TKE' , - 2 ) case ( 'Omega' ) call read_scalar ( tw , 'Omega' , - 2 ) case ( 'Kl' ) call read_scalar ( tkl , 'Kl' , - 2 ) case ( 'tv' ) call read_scalar ( tv , 'tv' , - 2 ) case ( 'tgm' ) call read_scalar ( tgm , 'tgm' , - 2 ) case ( 'do not read' ) call skip_scalar () case Default Print * , \"read error: list var : \" // trim ( control % r_list ( n )) end select end do end subroutine read_file subroutine read_header ( control ) !< Skip read the header in the tecplot file implicit none type ( controltype ), intent ( in ) :: control integer :: n DebugCall ( 'read_output_tec: read_header' ) read ( IN_FILE_UNIT , * ) !\"variables = x y z \" do n = 1 , control % r_count read ( IN_FILE_UNIT , * ) !trim(w_list(n)) end do read ( IN_FILE_UNIT , * ) ! \"zone T=block\" ... read ( IN_FILE_UNIT , * ) !\"Varlocation=([1-3]=Nodal)\" read ( IN_FILE_UNIT , * ) !\"Varlocation=([4-\",total,\"]=CELLCENTERED)\" read ( IN_FILE_UNIT , * ) !\"STRANDID\" read ( IN_FILE_UNIT , * ) !\"SolutionTime\" end subroutine read_header subroutine read_grid () !< Skip the grid read in the restart file implicit none real ( wp ) :: dummy ! read grid point coordinates DebugCall ( 'read_output_tec: read_grid' ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) end subroutine read_grid subroutine read_scalar ( var , name , index ) !< Read scalar from the tecplot file implicit none integer , intent ( in ) :: index real ( wp ), dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( out ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( 'read_output_tec' // trim ( name )) read ( IN_FILE_UNIT , * ) ((( var ( i , j , k ), i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine read_scalar subroutine skip_scalar () !< Skip read scalar from the tecplot file implicit none real ( wp ) :: dummy DebugCall ( 'read_output_tec: skip_scalar' ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine skip_scalar end module read_output_tec","tags":"","loc":"sourcefile/read_output_tec.f90.html","title":"read_output_tec.f90 – FEST-3D"},{"text":"This module read input control files which include:\n   1. control.md\n   2. fvscheme.md\n   3. flow.md\n   4. res_control.md\n   5. state_read_write_control.md This file depends on sourcefile~~read.f90~~EfferentGraph sourcefile~read.f90 read.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~read.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read.f90~~AfferentGraph sourcefile~read.f90 read.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~read.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read Source Code read.f90 Source Code !< This module read input control files which include: !<   1. control.md !<   2. fvscheme.md !<   3. flow.md !<   4. res_control.md !<   5. state_read_write_control.md module read !< This module read input control files which include: !<   1. control.md !<   2. fvscheme.md !<   3. flow.md !<   4. res_control.md !<   5. state_read_write_control.md !------------------------------------------------------ #include \"../../debug.h\" use vartypes implicit none private public :: read_input_and_controls contains subroutine read_input_and_controls ( files , control , scheme , flow ) !< Read all the input control files implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control type ( schemetype ), intent ( inout ) :: scheme type ( flowtype ), intent ( inout ) :: flow call read_controls ( files , control ) call read_scheme ( files , scheme ) call read_flow ( files , control , flow ) call read_output_control ( files , control ) call read_Res_list ( files , control ) end subroutine read_input_and_controls subroutine get_next_token ( token_file_unit , buf ) !< Extract the next token from the config file !< !< Each token is on a separate line. !< There may be multiple comments (lines beginning with #) !< and blank lines in between. !< The purpose of this subroutine is to ignore all these !< lines and return the next \"useful\" line. !----------------------------------------------------------- implicit none integer , intent ( in ) :: token_file_unit character ( len = STRING_BUFFER_LENGTH ), intent ( out ) :: buf integer :: ios do read ( token_file_unit , '(A)' , iostat = ios ) buf if ( ios /= 0 ) then print * , 'Error while reading config file.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH stop end if if ( index ( buf , '#' ) == 1 ) then ! The current line begins with a hash ! Ignore it continue else if ( len_trim ( buf ) == 0 ) then ! The current line is empty ! Ignore it continue else ! A new token has been found ! Break out exit end if end do end subroutine get_next_token subroutine read_controls ( files , control ) !< Read control.md file !--------------------------------------------- implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control character ( len = STRING_BUFFER_LENGTH ) :: buf DebugCall ( 'read_controls' ) open ( files % CONTROL_FILE_UNIT , file = files % control_file , status = 'old' , action = 'read' ) !ignoring file header read ( files % CONTROL_FILE_UNIT , * ) read ( files % CONTROL_FILE_UNIT , * ) read ( files % CONTROL_FILE_UNIT , * ) ! READ CFL call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % CFL DebugInfo ( \"CFL = \" // trim ( buf )) ! READ start_from call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % start_from DebugInfo ( 'Start from  level = ' // trim ( buf )) ! READ max_iters call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % max_iters DebugInfo ( 'Stop at iteration = ' // trim ( buf )) ! READ checkpoint_iter call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % checkpoint_iter DebugInfo ( ' Solution write interval = ' // trim ( buf )) ! READ write_file_format call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % write_file_format DebugInfo ( 'Solution file format  = ' // trim ( buf )) ! READ write_data_format call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % write_data_format DebugInfo ( 'solution file data format = ' // trim ( buf )) ! READ read_file_format call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % read_file_format DebugInfo ( 'Restart file format  = ' // trim ( buf )) ! READ_read data_format call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % read_data_format DebugInfo ( 'Restart file data format = ' // trim ( buf )) ! READ write_percision call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % write_percision DebugInfo ( 'File write percision = ' // trim ( buf )) ! READ purge_write call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % purge_write DebugInfo ( 'Purge folder more then  = ' // trim ( buf )) ! READ res_write_interval call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % res_write_interval DebugInfo ( 'resnorm write interval  = ' // trim ( buf )) ! READ tolerance call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % tolerance , control % tolerance_type DebugInfo ( trim ( control % tolerance_type ) // ' Tolerance  = ' // trim ( buf )) ! READ DEBUG_LEVEL call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % DEBUG_LEVEL DebugInfo ( 'DEBUG_LEVEL = ' // trim ( buf )) close ( files % CONTROL_FILE_UNIT ) end subroutine read_controls subroutine read_scheme ( files , scheme ) !< Read fvscheme.md control file !-------------------------------------------- implicit none type ( filetype ), intent ( in ) :: files type ( schemetype ), intent ( inout ) :: scheme character ( len = STRING_BUFFER_LENGTH ) :: buf integer :: ios DebugCall ( 'read_scheme' ) open ( files % SCHEME_FILE_UNIT , file = files % scheme_file , status = 'old' , action = 'read' ) ! ignoring file header read ( files % SCHEME_FILE_UNIT , * ) read ( files % SCHEME_FILE_UNIT , * ) read ( files % SCHEME_FILE_UNIT , * ) ! read scheme name call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % scheme_name DebugInfo ( 'scheme_name = ' // trim ( buf )) ! read interpolant call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % interpolant scheme % interpolant = trim ( scheme % interpolant ) DebugInfo ( 'interpolant = ' // trim ( buf )) ! read ilimiter and PB switch call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % ilimiter_switch , scheme % jlimiter_switch , scheme % klimiter_switch , & scheme % iPB_switch , scheme % jPB_switch , scheme % kPB_switch DebugInfo ( 'ilimiter switch = ' // trim ( buf ) ) DebugInfo ( 'jlimiter switch = ' // trim ( buf ) ) DebugInfo ( 'klimiter switch = ' // trim ( buf ) ) DebugInfo ( 'PB switch = ' // trim ( buf ) ) ! read turbulent limiter call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % itlimiter_switch , scheme % jtlimiter_switch , scheme % ktlimiter_switch DebugInfo ( 'ilimiter switch = ' // trim ( buf ) ) DebugInfo ( 'jlimiter switch = ' // trim ( buf ) ) DebugInfo ( 'klimiter switch = ' // trim ( buf ) ) ! read turbulence model call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % turbulence DebugInfo ( 'Turbulence Model = ' // trim ( buf )) ! read transition model call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % transition DebugInfo ( 'Transition Model = ' // trim ( buf )) ! read time stepping method call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * , iostat = ios ) scheme % time_stepping_method , scheme % global_time_step if ( ios /= 0 ) then read ( buf , * ) scheme % time_stepping_method scheme % global_time_step = - 1 end if DebugInfo ( 'time_stepping_method = ' // trim ( buf )) DebugInfo ( 'global_time_step = ' // trim ( buf )) ! read time integration method call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % time_step_accuracy DebugInfo ( 'time_step_accuracy  = ' // trim ( buf )) ! read higher order boundary call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % accur DebugInfo ( 'higher order boundary  = ' // trim ( buf )) close ( files % SCHEME_FILE_UNIT ) end subroutine read_scheme subroutine read_flow ( files , control , flow ) !< Read flow.md control file !-------------------------------------------- implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control type ( flowtype ), intent ( inout ) :: flow character ( len = STRING_BUFFER_LENGTH ) :: buf DebugCall ( 'read_flow' ) open ( files % FLOW_FILE_UNIT , file = files % flow_file , status = 'old' , action = 'read' ) ! ignoring file header read ( files % FLOW_FILE_UNIT , * ) read ( files % FLOW_FILE_UNIT , * ) read ( files % FLOW_FILE_UNIT , * ) ! read number of variable call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) control % n_var DebugInfo ( 'Number of variables = ' // trim ( buf )) ! read rho_inf call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % density_inf DebugInfo ( 'free_stream_density = ' // trim ( buf )) ! read u_inf call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % x_speed_inf DebugInfo ( 'free_stream_x_speed = ' // trim ( buf )) ! read v_inf call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % y_speed_inf DebugInfo ( 'free_stream_y_speed = ' // trim ( buf )) ! read w_inf call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % z_speed_inf DebugInfo ( 'free_stream_z_speed = ' // trim ( buf )) ! read P_inf call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % pressure_inf DebugInfo ( 'free_stream_pressure = ' // trim ( buf )) ! read turbulence intensity in percentage call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % tu_inf DebugInfo ( 'free_stream_Turb_intensity = ' // trim ( buf )) ! read viscosity ratio call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % mu_ratio_inf DebugInfo ( 'free_stream_mu_ratio = ' // trim ( buf )) ! read intermittency call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % tgm_inf DebugInfo ( 'free_stream_Intermittency = ' // trim ( buf )) ! read reference viscosity call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % mu_ref DebugInfo ( 'mu_reference = ' // trim ( buf )) ! Type of variation for viscosity call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % mu_variation DebugInfo ( 'mu_variation = ' // trim ( buf )) ! read T_red call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % T_ref DebugInfo ( 'T_reference = ' // trim ( buf )) ! read Sutherland temp call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % Sutherland_temp DebugInfo ( 'Sutherland temperature = ' // trim ( buf )) ! read prandtl number call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % Pr , flow % tPr DebugInfo ( 'Prandtl Number = ' // trim ( buf )) ! read gamma call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % gm DebugInfo ( 'gamma = ' // trim ( buf )) ! read universal gas constant call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % R_gas DebugInfo ( 'R_gas = ' // trim ( buf )) close ( files % FLOW_FILE_UNIT ) end subroutine read_flow subroutine read_output_control ( files , control ) !< Read output_contorl.md file implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control integer :: i character ( len = 64 ) :: buf integer :: ios logical :: ok call get_rw_count ( files , control ) inquire ( files % OUTIN_FILE_UNIT , opened = ok ) if ( ok ) close ( files % OUTIN_FILE_UNIT ) !call close_file(files%OUTIN_FILE_UNIT) open ( files % OUTIN_FILE_UNIT , file = files % outin_file , status = 'old' , action = 'read' ) ! variables to write do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do do i = 1 , control % w_count read ( files % OUTIN_FILE_UNIT , * ) buf read ( buf , * ) control % w_list ( i ) end do ! restart variables to read do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do do i = 1 , control % r_count read ( files % OUTIN_FILE_UNIT , * ) buf read ( buf , * ) control % r_list ( i ) end do if ( control % r_count == 0 ) control % r_list = control % w_list close ( files % OUTIN_FILE_UNIT ) end subroutine read_output_control subroutine get_rw_count ( files , control ) !< Get read/write count implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control integer :: ios character ( len = 64 ) :: buf logical :: ok control % r_count = 0 control % w_count = 0 inquire ( files % OUTIN_FILE_UNIT , opened = ok ) if ( ok ) close ( files % OUTIN_FILE_UNIT ) !call close_file(files%OUTIN_FILE_UNIT) open ( files % OUTIN_FILE_UNIT , file = files % outin_file , status = 'old' , action = 'read' ) ! write list dimension do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do control % w_count = 0 do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '}' ) EXIT if ( is_iostat_end ( ios )) EXIT control % w_count = control % w_count + 1 end do if ( control % w_count > 0 ) then allocate ( control % w_list ( 1 : control % w_count )) else control % w_count = 3 allocate ( control % w_list ( 1 : control % w_count )) control % w_list ( 1 ) = \"Velocity\" control % w_list ( 2 ) = \"Density\" control % w_list ( 3 ) = \"Pressure\" end if ! read list dimesnion do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do control % r_count = 0 do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '}' ) EXIT if ( is_iostat_end ( ios )) EXIT control % r_count = control % r_count + 1 end do if ( control % r_count == 0 ) then allocate ( control % r_list ( 1 : control % w_count )) else allocate ( control % r_list ( 1 : control % r_count )) end if close ( files % OUTIN_FILE_UNIT ) end subroutine get_rw_count subroutine get_count_within_braces ( handler , count ) !< Get number of variables between two curly braces implicit none integer , intent ( in ) :: handler !< File handler from which list number is extracted integer , intent ( out ) :: count !< Extracted count integer :: skip ! skipping lines outside braces skip = get_number_of_line ( '{' , handler ) ! finding actual count if any count = get_number_of_line ( '}' , handler ) end subroutine get_count_within_braces function get_number_of_line ( till , infile ) result ( number ) !< Get number of lines till some character like \"#\" implicit none integer , intent ( in ) :: infile character ( len = 1 ), intent ( in ) :: till character ( len = 64 ) :: buf integer :: ios integer :: number number = 0 do while (. true .) read ( infile , * , iostat = ios ) buf if ( trim ( buf ) == till ) EXIT if ( is_iostat_end ( ios )) EXIT number = number + 1 end do end function get_number_of_line subroutine read_Res_list ( files , control ) !< Read Residual file: res_control.md implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control integer :: i integer :: skip logical :: ok open ( files % RES_CONTROL_FILE_UNIT , file = files % res_control_file , status = 'old' , action = 'read' ) call get_count_within_braces ( files % RES_CONTROL_FILE_UNIT , control % Res_count ) !call close_file(files%RES_CONTROL_FILE_UNIT) inquire ( files % RES_CONTROL_FILE_UNIT , opened = ok ) if ( ok ) close ( files % RES_CONTROL_FILE_UNIT ) open ( files % RES_CONTROL_FILE_UNIT , file = files % res_control_file , status = 'old' , action = 'read' ) ! skipping line skip = get_number_of_line ( '{' , files % RES_CONTROL_FILE_UNIT ) !reading vaules if ( control % Res_count == 0 ) then allocate ( control % Res_list ( 1 : 2 )) control % Res_count = 2 control % Res_list ( 1 ) = \"Mass_abs\" control % Res_list ( 2 ) = \"Resnorm_abs\" else allocate ( control % Res_list ( 1 : control % Res_count )) end if do i = 1 , control % Res_count read ( files % RES_CONTROL_FILE_UNIT , * ) control % Res_list ( i ) end do close ( files % RES_CONTROL_FILE_UNIT ) end subroutine read_Res_list end module read","tags":"","loc":"sourcefile/read.f90.html","title":"read.f90 – FEST-3D"},{"text":"Read output files from the restart folder This file depends on sourcefile~~read_output.f90~~EfferentGraph sourcefile~read_output.f90 read_output.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~utils.f90 utils.f90 sourcefile~read_output.f90->sourcefile~utils.f90 sourcefile~check_output_control.f90 check_output_control.f90 sourcefile~read_output.f90->sourcefile~check_output_control.f90 sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output.f90->sourcefile~read_output_vtk.f90 sourcefile~vartypes.f90 vartypes.f90 sourcefile~read_output.f90->sourcefile~vartypes.f90 sourcefile~read_output_tec.f90->sourcefile~utils.f90 sourcefile~read_output_tec.f90->sourcefile~vartypes.f90 sourcefile~check_output_control.f90->sourcefile~vartypes.f90 sourcefile~read_output_vtk.f90->sourcefile~utils.f90 sourcefile~read_output_vtk.f90->sourcefile~vartypes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read_output.f90~~AfferentGraph sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read_output Source Code read_output.f90 Source Code !< Read output files from the restart folder module read_output !< Read output files from the restart folder !--------------------------------------------------------- ! This module read state + other variable in output file !--------------------------------------------------------- #include \"../../debug.h\" #include \"../../error.h\" use vartypes use read_output_vtk , only : read_file_vtk => read_file use read_output_tec , only : read_file_tec => read_file use check_output_control , only : verify_read_control use utils implicit none private !< Free-stream velocity magnitude character ( len = 8 ) :: file_format !< Read file format character ( len = 16 ) :: data_format !< Read file data type public :: read_file contains subroutine read_file ( files , qp , control , scheme , dims ) !< Read restart file implicit none type ( filetype ), intent ( inout ) :: files type ( extent ), intent ( in ) :: dims type ( controltype ), intent ( inout ) :: control type ( schemetype ) , intent ( in ) :: scheme real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: qp call setup_file ( control ) call open_file ( files , control ) call read_restart_file ( files % RESTART_FILE_UNIT , control ) call verify_read_control ( control , scheme ) select case ( control % read_file_format ) case ( 'vtk' ) call read_file_vtk ( files % IN_FILE_UNIT , qp , control , scheme , dims ) case ( 'tecplot' ) call read_file_tec ( files % IN_FILE_UNIT , qp , control , scheme , dims ) case DEFAULT Fatal_error end select call close_file ( files ) end subroutine read_file subroutine setup_file ( control ) !< Steup the file to read the restart state. implicit none type ( controltype ), intent ( in ) :: control DebugCall ( 'setup_file' ) if ( control % read_file_format == \"vtk\" ) then file_format = \".vtk\" elseif ( control % read_file_format == \"tecplot\" ) then file_format = \".dat\" else print * , \"File format not recoganised. Accepted formats are\" print * , \"'vtk' and 'tecplot' \" end if if ( control % read_data_format == \"ASCII\" ) then data_format = \"formatted\" elseif ( control % read_data_format == \"BINARY\" ) then data_format = \"unformatted\" else print * , \"Data format not recoganised. Accepted formats are\" print * , \"'ASCII' and 'BINARY' \" end if end subroutine setup_file subroutine open_file ( files , control ) !< Open file from the restart folder implicit none type ( filetype ), intent ( inout ) :: files type ( controltype ), intent ( in ) :: control DebugCall ( 'open_file' ) write ( files % restartfile , '(A,I4.4,A,I2.2)' ) 'time_directories/' , control % start_from ,& '/restart/process_' , process_id open ( files % IN_FILE_UNIT , file = trim ( files % infile ) // trim ( file_format )) !, form=trim(data_format)) open ( files % RESTART_FILE_UNIT , file = files % restartfile , status = 'old' ) end subroutine open_file subroutine close_file ( files ) !< Close the file after reading implicit none type ( filetype ), intent ( in ) :: files DebugCall ( 'close_files' ) close ( files % IN_FILE_UNIT ) close ( files % RESTART_FILE_UNIT ) end subroutine close_file subroutine read_restart_file ( RESTART_FILE_UNIT , control ) !< Read the sub-directory log file in the restart folder implicit none integer , intent ( in ) :: RESTART_FILE_UNIT type ( controltype ), intent ( inout ) :: control integer :: i read ( RESTART_FILE_UNIT , * ) control % previous_flow_type read ( RESTART_FILE_UNIT , * ) control % last_iter do i = 1 , control % n_var + 1 read ( RESTART_FILE_UNIT , * ) control % previous_res ( i ) end do end subroutine read_restart_file end module read_output","tags":"","loc":"sourcefile/read_output.f90.html","title":"read_output.f90 – FEST-3D"},{"text":"Declare all the constants used by SA turbulence model Files dependent on this one sourcefile~~global_sa.f90~~AfferentGraph sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~global_sa.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~time.f90 time.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~plusgs.f90->sourcefile~global_sa.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~viscous.f90->sourcefile~global_sa.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~source.f90->sourcefile~global_sa.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~lusgs.f90->sourcefile~global_sa.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 var pansourcefileglobal_saf90AfferentGraph = svgPanZoom('#sourcefileglobal_saf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules global_sa Source Code global_sa.f90 Source Code !< Declare all the constants used by SA turbulence model module global_sa !< Declare all the constants used by SA turbulence model use iso_fortran_env , only : wp => real64 real ( wp ), parameter :: cb1 = 0.1355 real ( wp ), parameter :: cb2 = 0.6220 real ( wp ), parameter :: cw2 = 0.3 real ( wp ), parameter :: cw3 = 2.0 real ( wp ), parameter :: cv1 = 7.1 real ( wp ), parameter :: ct3 = 1.2 real ( wp ), parameter :: ct4 = 0.5 real ( wp ), parameter :: sigma_sa = 2. / 3. real ( wp ), parameter :: kappa_sa = 0.41 real ( wp ), parameter :: cw1 = ( cb1 / ( kappa_sa ** 2 )) + (( 1 + cb2 ) / sigma_sa ) real ( wp ), parameter :: cv1_3 = cv1 ** 3 real ( wp ), parameter :: cw3_6 = cw3 ** 6 end module global_sa","tags":"","loc":"sourcefile/global_sa.f90.html","title":"global_sa.f90 – FEST-3D"},{"text":"Declare all the constants used by SST turbulence model Files dependent on this one sourcefile~~global_sst.f90~~AfferentGraph sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~global_sst.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~time.f90 time.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~plusgs.f90->sourcefile~global_sst.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~viscous.f90->sourcefile~global_sst.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~lusgs.f90->sourcefile~global_sst.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~source.f90->sourcefile~global_sst.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~bc_primitive.f90->sourcefile~global_sst.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 var pansourcefileglobal_sstf90AfferentGraph = svgPanZoom('#sourcefileglobal_sstf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules global_sst Source Code global_sst.f90 Source Code !< Declare all the constants used by SST turbulence model module global_sst !< Declare all the constants used by SST turbulence model use iso_fortran_env , only : wp => real64 real ( wp ), parameter :: sigma_k1 = 0.85 real ( wp ), parameter :: sigma_k2 = 1.0 real ( wp ), parameter :: sigma_w1 = 0.5 real ( wp ), parameter :: sigma_w2 = 0.856 real ( wp ), parameter :: beta1 = 0.075 real ( wp ), parameter :: beta2 = 0.0828 real ( wp ), parameter :: bstar = 0.09 real ( wp ), parameter :: kappa = 0.41 real ( wp ), parameter :: a1 = 0.31 real ( wp ) :: gama1 = ( beta1 / bstar ) - (( sigma_w1 * ( kappa ** 2 )) / sqrt ( bstar )) real ( wp ) :: gama2 = ( beta2 / bstar ) - (( sigma_w2 * ( kappa ** 2 )) / sqrt ( bstar )) ! to be used after blending with F1 real ( wp ) :: beta real ( wp ) :: sigma_w real ( wp ) :: sigma_k real ( wp ) :: gama ! blending function real ( wp ), dimension (:,:,:), allocatable , target :: sst_F1 end module global_sst","tags":"","loc":"sourcefile/global_sst.f90.html","title":"global_sst.f90 – FEST-3D"},{"text":"Declare all the constants used by k-kL turbulence model Files dependent on this one sourcefile~~global_kkl.f90~~AfferentGraph sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~global_kkl.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~viscous.f90 viscous.f90 sourcefile~update.f90->sourcefile~viscous.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~time.f90 time.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~plusgs.f90->sourcefile~global_kkl.f90 sourcefile~plusgs.f90->sourcefile~viscosity.f90 sourcefile~viscous.f90->sourcefile~global_kkl.f90 sourcefile~viscous.f90->sourcefile~viscosity.f90 sourcefile~source.f90->sourcefile~global_kkl.f90 sourcefile~source.f90->sourcefile~viscosity.f90 sourcefile~lusgs.f90->sourcefile~global_kkl.f90 sourcefile~lusgs.f90->sourcefile~viscosity.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output_tec_node.f90->sourcefile~viscosity.f90 sourcefile~time.f90->sourcefile~viscosity.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output_tec.f90->sourcefile~viscosity.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~viscous.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output_vtk.f90->sourcefile~viscosity.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 var pansourcefileglobal_kklf90AfferentGraph = svgPanZoom('#sourcefileglobal_kklf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules global_kkl Source Code global_kkl.f90 Source Code !< Declare all the constants used by k-kL turbulence model module global_kkl !< Declare all the constants used by k-kL turbulence model use iso_fortran_env , only : wp => real64 real ( wp ), parameter :: zeta1 = 1.2 real ( wp ), parameter :: zeta2 = 0.97 real ( wp ), parameter :: zeta3 = 0.13 real ( wp ), parameter :: sigma_k = 1.0 real ( wp ), parameter :: sigma_phi = 1.0 real ( wp ), parameter :: cmu = 0.09 real ( wp ), parameter :: kappa = 0.41 real ( wp ), parameter :: c11 = 1 0.0 real ( wp ), parameter :: c12 = 1.3 real ( wp ), parameter :: cd1 = 4.7 real ( wp ) :: cphi1 real ( wp ) :: cphi2 real ( wp ) :: fphi real ( wp ) :: eta end module global_kkl","tags":"","loc":"sourcefile/global_kkl.f90.html","title":"global_kkl.f90 – FEST-3D"},{"text":"type, public :: singlesub Contents Variables imin imax il iu jmin jmax jl ju kmin kmax kl ku sig Source Code singlesub Components Type Visibility Attributes Name Initial integer, public :: imin integer, public :: imax integer, public :: il integer, public :: iu integer, public :: jmin integer, public :: jmax integer, public :: jl integer, public :: ju integer, public :: kmin integer, public :: kmax integer, public :: kl integer, public :: ku integer, public :: sig = 1 Source Code type :: singlesub integer :: imin , imax , il , iu integer :: jmin , jmax , jl , ju integer :: kmin , kmax , kl , ku integer :: sig = 1 end type singlesub","tags":"","loc":"type/singlesub.html","title":"singlesub – FEST-3D "},{"text":"type, public :: nodetype Contents Variables x y z Source Code nodetype Components Type Visibility Attributes Name Initial real(kind=wp), public :: x real(kind=wp), public :: y real(kind=wp), public :: z Source Code type , public :: nodetype real ( wp ) :: x real ( wp ) :: y real ( wp ) :: z end type nodetype","tags":"","loc":"type/nodetype.html","title":"nodetype – FEST-3D "},{"text":"type, public :: extent Contents Variables imx jmx kmx n_var Source Code extent Components Type Visibility Attributes Name Initial integer, public :: imx integer, public :: jmx integer, public :: kmx integer, public :: n_var Source Code type , public :: extent integer :: imx integer :: jmx integer :: kmx integer :: n_var end type extent","tags":"","loc":"type/extent.html","title":"extent – FEST-3D "},{"text":"type, public :: celltype Contents Variables volume centerx centery centerz Source Code celltype Components Type Visibility Attributes Name Initial real(kind=wp), public :: volume Store cell volume real(kind=wp), public :: centerx real(kind=wp), public :: centery real(kind=wp), public :: centerz Store Cell-center location Source Code type , public :: celltype real ( wp ) :: volume !< Store cell volume real ( wp ) :: centerx real ( wp ) :: centery real ( wp ) :: centerz !< Store Cell-center location end type celltype","tags":"","loc":"type/celltype.html","title":"celltype – FEST-3D "},{"text":"type, public :: facetype Contents Variables A nx ny nz Source Code facetype Components Type Visibility Attributes Name Initial real(kind=wp), public :: A Store magnitude of face area vector of direction faces real(kind=wp), public :: nx real(kind=wp), public :: ny real(kind=wp), public :: nz Store unit face normal vector for all faces Source Code type , public :: facetype real ( wp ) :: A !< Store magnitude of face area vector of direction faces real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz !< Store unit face normal vector for all faces end type facetype","tags":"","loc":"type/facetype.html","title":"facetype – FEST-3D "},{"text":"type, public :: filetype Contents Variables CONFIG_FILE_UNIT GRID_FILE_UNIT BOUNDARY_CONDITIONS_FILE_UNIT IN_FILE_UNIT OUT_FILE_UNIT RESNORM_FILE_UNIT LAYOUT_FILE_UNIT NODESURF_FILE_UNIT RES_CONTROL_FILE_UNIT CONTROL_FILE_UNIT SCHEME_FILE_UNIT FLOW_FILE_UNIT RESTART_FILE_UNIT OUTIN_FILE_UNIT MAP_FILE_UNIT PERIODIC_FILE_UNIT STOP_FILE_UNIT control_file scheme_file flow_file outin_file layout_file nodefile_temp surface_node_points res_control_file resnorm_file stop_file mapfile periodicfile gridfile bcfile outfile infile restartfile Source Code filetype Components Type Visibility Attributes Name Initial integer, public :: CONFIG_FILE_UNIT = 16 Handler unit for config.md file integer, public :: GRID_FILE_UNIT = 17 Handler for input Gridfile; eg: grid_00.txt integer, public :: BOUNDARY_CONDITIONS_FILE_UNIT = 18 Handler for Boundary condition file; eg: bc_00.md Handler no longer in use integer, public :: IN_FILE_UNIT = 19 Handler for restart file for block: eg: time_drectories/0001/process_00.dat integer, public :: OUT_FILE_UNIT = 20 Handler for output file for each block integer, public :: RESNORM_FILE_UNIT = 21 Handler for Residual output file. filename: time_directories/aux/resnorm integer, public :: LAYOUT_FILE_UNIT = 31 Handler for input multi-block layout and boundary condition file. integer, public :: NODESURF_FILE_UNIT = 32 Handler for storing node point on the wall Handler no longer in use integer, public :: RES_CONTROL_FILE_UNIT = 34 Handler for residual control file. filename: system/res_control.md Handler NO longer in user ; info is handled using print*, command integer, public :: CONTROL_FILE_UNIT = 36 Handler for input system/control.md file integer, public :: SCHEME_FILE_UNIT = 37 Handler for input system/fvscheme.md file integer, public :: FLOW_FILE_UNIT = 38 Handler for input system/flow.md  file integer, public :: RESTART_FILE_UNIT = 39 Handler for Restart file in Restart folder. eg: time_directories/0001/Restart/process_00 integer, public :: OUTIN_FILE_UNIT = 40 Handler for file which controls what variables will be read or stored. system/output_control.md integer, public :: MAP_FILE_UNIT = 41 Handler for input multi-block mapping file with index and direction. integer, public :: PERIODIC_FILE_UNIT = 42 Handler for input periodic boundary condition file integer, public :: STOP_FILE_UNIT = 43 Handler for Stop file character(len=FILE_NAME_LENGTH), public :: control_file = \"system/control.md\" FILENAME string: Control file character(len=FILE_NAME_LENGTH), public :: scheme_file = \"system/fvscheme.md\" FILENAME string: Scheme file character(len=FILE_NAME_LENGTH), public :: flow_file = \"system/flow.md\" FILENAME string: FLow condition file character(len=FILE_NAME_LENGTH), public :: outin_file = \"system/output_control.md\" FILENAME string: Ouput/Input variable control file character(len=FILE_NAME_LENGTH), public :: layout_file = 'system/mesh/layout/layout.md' FILENAME string: Multiple layout/boundary condition file character(len=FILE_NAME_LENGTH), public :: nodefile_temp = \"scratch.dat\" FILENAME string: Temperory file for nodesurface points character(len=FILE_NAME_LENGTH), public :: surface_node_points = 'time_directories/aux/surfnode.dat' FILENAME string: Wall surface node points character(len=FILE_NAME_LENGTH), public :: res_control_file = 'system/res_control.md' FILENAME string: Residual write control file character(len=FILE_NAME_LENGTH), public :: resnorm_file = 'time_directories/aux/resnorm' FILENAME string: Residual output file character(len=FILE_NAME_LENGTH), public :: stop_file = 'system/stopfile' FILENAME string: Halt/stop file character(len=FILE_NAME_LENGTH), public :: mapfile = 'system/mesh/layout/mapping.txt' FILENAME string: Detailed multiblock mapping file with indicies and direction information at interface character(len=FILE_NAME_LENGTH), public :: periodicfile = 'system/mesh/layout/periodic.txt' FILENAME string: Multiblock periodic boundary condition detials character(len=FILE_NAME_LENGTH), public :: gridfile FILENAME string: Grid file character(len=FILE_NAME_LENGTH), public :: bcfile FILENAME string: single block boundary condition detials character(len=FILE_NAME_LENGTH), public :: outfile FILENAME string: single block solution output file character(len=FILE_NAME_LENGTH), public :: infile FILENAME string: single block solution input file character(len=FILE_NAME_LENGTH), public :: restartfile FILENAME string: single block restart file Source Code type , public :: filetype !        integer :: FILE_NAME_LENGTH = 64 !        !< Length of string used for defining any filename integer :: CONFIG_FILE_UNIT = 16 !< Handler unit for config.md file integer :: GRID_FILE_UNIT = 17 !< Handler for input Gridfile; eg: grid_00.txt integer :: BOUNDARY_CONDITIONS_FILE_UNIT = 18 !< Handler for Boundary condition file; eg: bc_00.md !integer, parameter :: STATE_FILE_UNIT = 10 !< __Handler no longer in use__ integer :: IN_FILE_UNIT = 19 !< Handler for restart file for block: eg: time_drectories/0001/process_00.dat integer :: OUT_FILE_UNIT = 20 !< Handler for output file for each block integer :: RESNORM_FILE_UNIT = 21 !< Handler for Residual output file. filename: time_directories/aux/resnorm integer :: LAYOUT_FILE_UNIT = 31 !< Handler for input multi-block layout and boundary condition file. integer :: NODESURF_FILE_UNIT = 32 !< Handler for storing node point on the wall !integer, parameter ::   WALL_DIST_FILE_UNIT = 33 !< __Handler no longer in use__ integer :: RES_CONTROL_FILE_UNIT = 34 !< Handler for residual control file. filename: system/res_control.md !integer, parameter ::        INFO_FILE_UNIT = 35 !< __Handler NO longer in user__; info is handled using print*, command integer :: CONTROL_FILE_UNIT = 36 !< Handler for input system/control.md file integer :: SCHEME_FILE_UNIT = 37 !< Handler for input system/fvscheme.md file integer :: FLOW_FILE_UNIT = 38 !< Handler for input system/flow.md  file integer :: RESTART_FILE_UNIT = 39 !< Handler for Restart file in Restart folder. eg: time_directories/0001/Restart/process_00 integer :: OUTIN_FILE_UNIT = 40 !< Handler for file which controls what variables will be read or stored. system/output_control.md integer :: MAP_FILE_UNIT = 41 !< Handler for input multi-block mapping file with index and direction. integer :: PERIODIC_FILE_UNIT = 42 !< Handler for input periodic boundary condition file integer :: STOP_FILE_UNIT = 43 !< Handler for Stop file !file names character ( len = FILE_NAME_LENGTH ) :: control_file = \"system/control.md\" !< FILENAME string: Control file character ( len = FILE_NAME_LENGTH ) :: scheme_file = \"system/fvscheme.md\" !< FILENAME string: Scheme file character ( len = FILE_NAME_LENGTH ) :: flow_file = \"system/flow.md\" !< FILENAME string: FLow condition file character ( len = FILE_NAME_LENGTH ) :: outin_file = \"system/output_control.md\" !< FILENAME string: Ouput/Input variable control file character ( len = FILE_NAME_LENGTH ) :: layout_file = 'system/mesh/layout/layout.md' !< FILENAME string: Multiple layout/boundary condition file character ( len = FILE_NAME_LENGTH ) :: nodefile_temp = \"scratch.dat\" !< FILENAME string: Temperory file for nodesurface points character ( len = FILE_NAME_LENGTH ) :: surface_node_points = 'time_directories/aux/surfnode.dat' !< FILENAME string: Wall surface node points character ( len = FILE_NAME_LENGTH ) :: res_control_file = 'system/res_control.md' !< FILENAME string: Residual write control file character ( len = FILE_NAME_LENGTH ) :: resnorm_file = 'time_directories/aux/resnorm' !< FILENAME string: Residual output file character ( len = FILE_NAME_LENGTH ) :: stop_file = 'system/stopfile' !< FILENAME string: Halt/stop file character ( len = FILE_NAME_LENGTH ) :: mapfile = 'system/mesh/layout/mapping.txt' !< FILENAME string: Detailed multiblock mapping file with indicies and direction information at interface character ( len = FILE_NAME_LENGTH ) :: periodicfile = 'system/mesh/layout/periodic.txt' !< FILENAME string: Multiblock periodic boundary condition detials character ( len = FILE_NAME_LENGTH ) :: gridfile !< FILENAME string: Grid file character ( len = FILE_NAME_LENGTH ) :: bcfile !< FILENAME string: single block boundary condition detials character ( len = FILE_NAME_LENGTH ) :: outfile !< FILENAME string: single block solution output file character ( len = FILE_NAME_LENGTH ) :: infile !< FILENAME string: single block solution input file character ( len = FILE_NAME_LENGTH ) :: restartfile !< FILENAME string: single block restart file end type filetype","tags":"","loc":"type/filetype.html","title":"filetype – FEST-3D "},{"text":"type, public :: controltype Contents Variables CFL start_from min_iter max_iters checkpoint_iter checkpoint_iter_count current_iter res_write_interval purge_write last_iter write_percision write_data_format write_file_format read_data_format read_file_format tolerance tolerance_type DEBUG_LEVEL previous_flow_type n_var r_list w_list r_count w_count Res_list Res_count total_process process_id want_to_stop Halt previous_res Source Code controltype Components Type Visibility Attributes Name Initial real(kind=wp), public :: CFL = 1.0 Courant–Friedrichs–Lewy (CFL) (Read from input) integer, public :: start_from = 0 Number of the folder (in time_directories) to load stored state from to restart computation integer, public :: min_iter = 1 Minimum iteration value, starting iteration value integer, public :: max_iters = 1 Maximum iteration value, stop after these many iteration integer, public :: checkpoint_iter = 0 Write interval for output file. Number of iteration after which solver will dump/store a state in a folder in time_directories integer, public :: checkpoint_iter_count = 0 Counter of folder number to write in time_directories/ integer, public :: current_iter = 0 Current iteration number integer, public :: res_write_interval = 10 Write resnorm after every \"res_write_interval\" iteration integer, public :: purge_write = 1 Remove unwanted folder. If Purge_write=2, latest two folder in time_direcotires are kept and 0=no purge integer, public :: last_iter = 0 Last iteration that is stored in the restart file integer, public :: write_percision = 6 Number of place after decimal. Only used for resnorm file character(len=FORMAT_LENGTH), public :: write_data_format = 'ASCII' write data type. Either ASCII or BINARY character(len=FORMAT_LENGTH), public :: write_file_format = 'tecplot' Write file type. Either vtk or tecplot character(len=FORMAT_LENGTH), public :: read_data_format = 'ASCII' Read data type in file. Either ASCII or BINARY character(len=FORMAT_LENGTH), public :: read_file_format = 'tecplot' Read file type. Either vtk or tecplot real(kind=wp), public :: tolerance = 1e-14 Minimum value of resnorm after which simulation stop character(len=STRING_BUFFER_LENGTH), public :: tolerance_type = \"abs\" Type of tolerance to check:absolute or relative integer, public :: DEBUG_LEVEL = 1 Debug level is an input from the control file.\n 5-> important calls only, and, \n 1-> all the calls character(len=STRING_BUFFER_LENGTH), public :: previous_flow_type = \"none\" Type of flow:inviscid, laminar, etc, stored in the load file integer, public :: n_var = 5 character(len=STRING_BUFFER_LENGTH), public, dimension(:), allocatable :: r_list Read variable list character(len=STRING_BUFFER_LENGTH), public, dimension(:), allocatable :: w_list Write variable list integer, public :: r_count = 0 Number of variable to read from the restart file integer, public :: w_count = 0 Number of variable to write in the output file character(len=STRING_BUFFER_LENGTH), public, dimension(:), allocatable :: Res_list Write residual variable list integer, public :: Res_count No of residual variable to save integer, public :: total_process = 1 Total number of process to be used for computation integer, public :: process_id = 0 Id no. of each processor assinged by MPICH library integer, public :: want_to_stop = 0 0: continue the solver; 1=Stop the solver logical, public :: Halt = .FALSE. Logical value used to stop the solver in main program file. real(kind=wp), public, dimension(:), allocatable :: previous_res starting resnrom of previous run Source Code type , public :: controltype real ( wp ) :: CFL = 1.0 !< Courant–Friedrichs–Lewy (CFL) (Read from input) integer :: start_from = 0 !< Number of the folder (in time_directories) to load stored state from to restart computation integer :: min_iter = 1 !< Minimum iteration value, starting iteration value integer :: max_iters = 1 !< Maximum iteration value, stop after these many iteration integer :: checkpoint_iter = 0 !< Write interval for output file. Number of iteration after which solver will dump/store a state in a folder in time_directories integer :: checkpoint_iter_count = 0 !< Counter of folder number to write in time_directories/ integer :: current_iter = 0 !< Current iteration number integer :: res_write_interval = 10 !< Write resnorm after every \"res_write_interval\" iteration integer :: purge_write = 1 !< Remove unwanted folder. If Purge_write=2, latest two folder in time_direcotires are kept and 0=no purge integer :: last_iter = 0 !< Last iteration that is stored in the restart file integer :: write_percision = 6 !< Number of place after decimal. Only used for resnorm file character ( len = FORMAT_LENGTH ) :: write_data_format = 'ASCII' !< write data type. Either ASCII or BINARY character ( len = FORMAT_LENGTH ) :: write_file_format = 'tecplot' !< Write file type. Either vtk or tecplot character ( len = FORMAT_LENGTH ) :: read_data_format = 'ASCII' !< Read data type in file. Either ASCII or BINARY character ( len = FORMAT_LENGTH ) :: read_file_format = 'tecplot' !< Read file type. Either vtk or tecplot real ( wp ) :: tolerance = 1 e - 14 !< Minimum value of resnorm after which simulation stop character ( len = STRING_BUFFER_LENGTH ) :: tolerance_type = \"abs\" !< Type of tolerance to check:absolute or relative integer , public :: DEBUG_LEVEL = 1 !< Debug level is an input from the control file. !< 5-> important calls only, and, !< 1-> all the calls character ( len = STRING_BUFFER_LENGTH ) :: previous_flow_type = \"none\" !< Type of flow:inviscid, laminar, etc, stored in the load file integer :: n_var = 5 ! Freestram variable used to read file before inf pointer are linked and allocated character ( len = STRING_BUFFER_LENGTH ), dimension (:), allocatable :: r_list !< Read variable list character ( len = STRING_BUFFER_LENGTH ), dimension (:), allocatable :: w_list !< Write variable list integer :: r_count = 0 !< Number of variable to read from the restart file integer :: w_count = 0 !< Number of variable to write in the output file character ( len = STRING_BUFFER_LENGTH ), dimension (:), allocatable :: Res_list !< Write residual variable list integer :: Res_count !< No of residual variable to save integer :: total_process = 1 !< Total number of process to be used for computation integer :: process_id = 0 !< Id no. of each processor assinged by MPICH library integer :: want_to_stop = 0 !< 0: continue the solver; 1=Stop the solver logical :: Halt = . FALSE . !< Logical value used to stop the solver in main program file. real ( wp ), dimension (:), allocatable :: previous_res !< starting resnrom of previous run end type controltype","tags":"","loc":"type/controltype.html","title":"controltype – FEST-3D "},{"text":"type, public :: schemetype Contents Variables scheme_name interpolant global_time_step time_stepping_method time_step_accuracy ilimiter_switch jlimiter_switch klimiter_switch itlimiter_switch jtlimiter_switch ktlimiter_switch iPB_switch jPB_switch kPB_switch turbulence transition accur Source Code schemetype Components Type Visibility Attributes Name Initial character(len=STRING_BUFFER_LENGTH), public :: scheme_name = 'ausm' Flux Scheme to use: ausm, ldfss0, vanleer, ausmup, ausmp, slau character(len=STRING_BUFFER_LENGTH), public :: interpolant = 'muscl' Face state reconstruction  method to user: muscl, ppm, none, weno, and wenoNM real(kind=wp), public :: global_time_step = 1e-5 Value of global time step to march the solution with character, public :: time_stepping_method = 'l' Either local time stepping or global time stepping character(len=STRING_BUFFER_LENGTH), public :: time_step_accuracy = 'implicit' Type of time_integration scheme: RK4, none(firt order explicit) implicit, integer, public :: ilimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for I direction faces. integer, public :: jlimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for J direction faces. integer, public :: klimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for K direction faces. integer, public :: itlimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for I direction faces. integer, public :: jtlimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for J direction faces. integer, public :: ktlimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for K direction faces. integer, public :: iPB_switch = 0 Turn on/off application of pressure based switching for higher order methods for I direction faces. integer, public :: jPB_switch = 0 Turn on/off application of pressure based switching for higher order methods for J direction faces. integer, public :: kPB_switch = 0 Turn on/off application of pressure based switching for higher order methods for K direction faces. character(len=8), public :: turbulence = 'none' Store Turbulence model name character(len=8), public :: transition = 'none' Store Transition model name integer, public :: accur = 1 Switch for higher order boundary condition Source Code type , public :: schemetype character ( len = STRING_BUFFER_LENGTH ) :: scheme_name = 'ausm' !< Flux Scheme to use: ausm, ldfss0, vanleer, ausmup, ausmp, slau character ( len = STRING_BUFFER_LENGTH ) :: interpolant = 'muscl' !< Face state reconstruction  method to user: muscl, ppm, none, weno, and wenoNM real ( wp ) :: global_time_step = 1 e - 5 !< Value of global time step to march the solution with character :: time_stepping_method = 'l' !< Either local time stepping or global time stepping character ( len = STRING_BUFFER_LENGTH ) :: time_step_accuracy = 'implicit' !< Type of time_integration scheme: RK4, none(firt order explicit) implicit, integer :: ilimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for I direction faces. integer :: jlimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for J direction faces. integer :: klimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for K direction faces. integer :: itlimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for I direction faces. integer :: jtlimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for J direction faces. integer :: ktlimiter_switch = 1 !< Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for K direction faces. integer :: iPB_switch = 0 !< Turn on/off application of pressure based switching for higher order methods for I direction faces. integer :: jPB_switch = 0 !< Turn on/off application of pressure based switching for higher order methods for J direction faces. integer :: kPB_switch = 0 !< Turn on/off application of pressure based switching for higher order methods for K direction faces. character ( len = 8 ) :: turbulence = 'none' !< Store Turbulence model name character ( len = 8 ) :: transition = 'none' !< Store Transition model name integer :: accur = 1 !< Switch for higher order boundary condition end type schemetype","tags":"","loc":"type/schemetype.html","title":"schemetype – FEST-3D "},{"text":"type, public :: flowtype Contents Variables density_inf x_speed_inf y_speed_inf z_speed_inf pressure_inf tk_inf tw_inf te_inf tv_inf tkl_inf tu_inf tgm_inf vel_mag MInf Reynolds_number mu_ratio_inf Turb_intensity_inf gm R_gas mu_ref mu_variation T_ref Sutherland_temp Pr tPr Source Code flowtype Components Type Visibility Attributes Name Initial real(kind=wp), public :: density_inf = 1.2 Read freestream Density from control file real(kind=wp), public :: x_speed_inf = 100.0 Read freestream U from control file real(kind=wp), public :: y_speed_inf = 0.0 Read freestream V from control file real(kind=wp), public :: z_speed_inf = 0.0 Read freestream W from control file real(kind=wp), public :: pressure_inf = 101325 Read freestream Pressure from control file real(kind=wp), public :: tk_inf = 0.0 Read freestream turbulent kinetic energy rate from control file real(kind=wp), public :: tw_inf = 0.0 Read freestream turbulent dissipation rate from control file real(kind=wp), public :: te_inf = 0.0 Read freestream turbulent dissipation from control file real(kind=wp), public :: tv_inf = 0.0 Read freestream turbulent viscosity(SA) from control file real(kind=wp), public :: tkl_inf = 0.0 Read freestream kL variable from control file real(kind=wp), public :: tu_inf = 1.0 Read freestream turbulence intensity (percentage) from control file real(kind=wp), public :: tgm_inf = 1.0 Read freestream turbulence intermittency from control file real(kind=wp), public :: vel_mag = 100.0 Calulated freestream Velocity Magnitude from control file real(kind=wp), public :: MInf = 0.0 Calulated freestream Mach number real(kind=wp), public :: Reynolds_number = 0.0 Calculated free_stream Reynolds_number real(kind=wp), public :: mu_ratio_inf = 1.0 Read freestream turbulent viscosity to molecular viscosity ratio real(kind=wp), public :: Turb_intensity_inf = 0.01 Calculate free_stream turbulence intensity real(kind=wp), public :: gm = 1.4 Gamma commonly 1.4 real(kind=wp), public :: R_gas = 287 Univarsal gas constant real(kind=wp), public :: mu_ref = 0.0 Molecular viscoity reference character(len=FILE_NAME_LENGTH), public :: mu_variation = \"constant\" Type of viscosity variaiton: Sutherland or constant real(kind=wp), public :: T_ref = 300 Reference Temperature of flow for viscosity calculation real(kind=wp), public :: Sutherland_temp = 110 Sutherland temperature for viscosity calculation real(kind=wp), public :: Pr = 0.7 prandtl number real(kind=wp), public :: tPr = 0.9 turbulent Prandtl number Source Code type , public :: flowtype real ( wp ) :: density_inf = 1.2 !< Read freestream Density from control file real ( wp ) :: x_speed_inf = 10 0.0 !< Read freestream U from control file real ( wp ) :: y_speed_inf = 0.0 !< Read freestream V from control file real ( wp ) :: z_speed_inf = 0.0 !< Read freestream W from control file real ( wp ) :: pressure_inf = 101325 !< Read freestream Pressure from control file real ( wp ) :: tk_inf = 0.0 !< Read freestream turbulent kinetic energy rate from control file real ( wp ) :: tw_inf = 0.0 !< Read freestream turbulent dissipation rate from control file real ( wp ) :: te_inf = 0.0 !< Read freestream turbulent dissipation from control file real ( wp ) :: tv_inf = 0.0 !< Read freestream turbulent viscosity(SA) from control file real ( wp ) :: tkl_inf = 0.0 !< Read freestream kL variable from control file real ( wp ) :: tu_inf = 1.0 !< Read freestream turbulence intensity (percentage) from control file real ( wp ) :: tgm_inf = 1.0 !< Read freestream turbulence intermittency from control file real ( wp ) :: vel_mag = 10 0.0 !< Calulated freestream Velocity Magnitude from control file real ( wp ) :: MInf = 0.0 !< Calulated freestream Mach number real ( wp ) :: Reynolds_number = 0.0 !< Calculated free_stream Reynolds_number real ( wp ) :: mu_ratio_inf = 1.0 !< Read freestream turbulent viscosity to molecular viscosity ratio real ( wp ) :: Turb_intensity_inf = 0.01 !< Calculate free_stream turbulence intensity real ( wp ) :: gm = 1.4 !< Gamma commonly 1.4 real ( wp ) :: R_gas = 287 !< Univarsal gas constant real ( wp ) :: mu_ref = 0.0 !< Molecular viscoity reference character ( len = FILE_NAME_LENGTH ) :: mu_variation = \"constant\" !< Type of viscosity variaiton: Sutherland or constant real ( wp ) :: T_ref = 300 !< Reference Temperature of flow for viscosity calculation real ( wp ) :: Sutherland_temp = 110 !< Sutherland temperature for viscosity calculation real ( wp ) :: Pr = 0.7 !< prandtl number real ( wp ) :: tPr = 0.9 !< turbulent Prandtl number end type flowtype","tags":"","loc":"type/flowtype.html","title":"flowtype – FEST-3D "},{"text":"type, public :: boundarytype Contents Variables imin_id imax_id jmin_id jmax_id kmin_id kmax_id face_names id c1 c2 c3 fixed_density fixed_pressure fixed_x_speed fixed_y_speed fixed_z_speed fixed_tk fixed_tw fixed_te fixed_tv fixed_tkl fixed_tgm fixed_wall_temperature fixed_Tpressure fixed_Ttemperature ilo ihi jlo jhi klo khi dir_switch otherface make_F_flux_zero make_G_flux_zero make_H_flux_zero PbcId Source Code boundarytype Components Type Visibility Attributes Name Initial integer, public :: imin_id Boundary condition number/ID at imin for particulat processor integer, public :: imax_id Boundary condition number/ID at imax for particulat processor integer, public :: jmin_id Boundary condition number/ID at jmin for particulat processor integer, public :: jmax_id Boundary condition number/ID at jmax for particulat processor integer, public :: kmin_id Boundary condition number/ID at kmin for particulat processor integer, public :: kmax_id Boundary condition number/ID at kmax for particulat processor character(len=4), public, dimension(6) :: face_names Store name of all six boundary faces integer, public, dimension(6) :: id Store the boundary condition ID of all six faces real(kind=wp), public :: c1 First coefficient user for higher order boundary condition real(kind=wp), public :: c2 Second coefficient user for higher order boundary condition real(kind=wp), public :: c3 Third coefficient user for higher order boundary condition real(kind=wp), public, dimension(6) :: fixed_density = 0. Density value to fix at particular boundary real(kind=wp), public, dimension(6) :: fixed_pressure = 0. Pressure value to fix at particular boundary real(kind=wp), public, dimension(6) :: fixed_x_speed = 0. X component of velocity to fix at particular boundary condition real(kind=wp), public, dimension(6) :: fixed_y_speed = 0. Y component of velocity to fix at particular boundary condition real(kind=wp), public, dimension(6) :: fixed_z_speed = 0. Z component of velocity to fix at particular boundary condition real(kind=wp), public, dimension(6) :: fixed_tk = 0. Turbulent kinetic energy value to fix at particular boundary condition real(kind=wp), public, dimension(6) :: fixed_tw = 0. Turbulent kinetic energy dissiaption rate value to fix at particular boundary condition(k-omega and SST model) real(kind=wp), public, dimension(6) :: fixed_te = 0. Turbulent kinetic energy dissiaption value to fix at particular boundary condition (K-eplision model) real(kind=wp), public, dimension(6) :: fixed_tv = 0. Turbulent viscosity varialble value to fix at particular boundary condition (for SA turbulence model) real(kind=wp), public, dimension(6) :: fixed_tkl = 0. (Turbulent kinetic energy x length) varialble value to fix at particular boundary condition (for k-kL turbulence model) real(kind=wp), public, dimension(6) :: fixed_tgm = 0. Fixed intermittency value to apply at particular boundary condition (for SST2003-gamma transition model) real(kind=wp), public, dimension(6) :: fixed_wall_temperature = 0. Fixed wall temperature value to apply at isothermal wall boundary condition. real(kind=wp), public, dimension(6) :: fixed_Tpressure = 0. Fixed Total Pressure value to apply at particular boundary condition real(kind=wp), public, dimension(6) :: fixed_Ttemperature = 0. Fixed Total Temperature value to apply at particular boundary condition integer, public, dimension(6) :: ilo Store the lower and upper bound of the indecies of I loop for the interface mapping integer, public, dimension(6) :: ihi Store the lower and upper bound of the indecies of I loop for the interface mapping integer, public, dimension(6) :: jlo Store the lower and upper bound of the indecies of J loop for the interface mapping integer, public, dimension(6) :: jhi Store the lower and upper bound of the indecies of J loop for the interface mapping integer, public, dimension(6) :: klo Store the lower and upper bound of the indecies of K loop for the interface mapping integer, public, dimension(6) :: khi Store the lower and upper bound of the indecies of K loop for the interface mapping integer, public, dimension(6) :: dir_switch = 0 Switch for each boundary face. Activated only if ( for eg I-direction in the mapping is mapped with J-direction) integer, public, dimension(6) :: otherface Store the face number with which the current interface is connected. integer, public, dimension(:), allocatable :: make_F_flux_zero Store zero to boundary face, which has wall ID, to make F flux zero integer, public, dimension(:), allocatable :: make_G_flux_zero Store zero to boundary face, which has wall ID, to make G flux zero integer, public, dimension(:), allocatable :: make_H_flux_zero Store zero to boundary face, which has wall ID, to make H flux zero integer, public, dimension(6) :: PbcId = -1 Block ID for Periodic boundary condition Source Code type :: boundarytype integer :: imin_id !< Boundary condition number/ID at imin for particulat processor integer :: imax_id !< Boundary condition number/ID at imax for particulat processor integer :: jmin_id !< Boundary condition number/ID at jmin for particulat processor integer :: jmax_id !< Boundary condition number/ID at jmax for particulat processor integer :: kmin_id !< Boundary condition number/ID at kmin for particulat processor integer :: kmax_id !< Boundary condition number/ID at kmax for particulat processor character ( len = 4 ), dimension ( 6 ) :: face_names !< Store name of all six boundary faces integer , dimension ( 6 ) :: id !< Store the boundary condition ID of all six faces real ( wp ) :: c1 !< First coefficient user for higher order boundary condition real ( wp ) :: c2 !< Second coefficient user for higher order boundary condition real ( wp ) :: c3 !< Third coefficient user for higher order boundary condition ! store fix values for 6 faces of domain real ( wp ), dimension ( 6 ) :: fixed_density = 0. !< Density value to fix at particular boundary real ( wp ), dimension ( 6 ) :: fixed_pressure = 0. !< Pressure value to fix at particular boundary real ( wp ), dimension ( 6 ) :: fixed_x_speed = 0. !< X component of velocity to fix at particular boundary condition real ( wp ), dimension ( 6 ) :: fixed_y_speed = 0. !< Y component of velocity to fix at particular boundary condition real ( wp ), dimension ( 6 ) :: fixed_z_speed = 0. !< Z component of velocity to fix at particular boundary condition real ( wp ), dimension ( 6 ) :: fixed_tk = 0. !< Turbulent kinetic energy value to fix at particular boundary condition real ( wp ), dimension ( 6 ) :: fixed_tw = 0. !< Turbulent kinetic energy dissiaption rate value to fix at particular boundary condition(k-omega and SST model) real ( wp ), dimension ( 6 ) :: fixed_te = 0. !< Turbulent kinetic energy dissiaption value to fix at particular boundary condition (K-eplision model) real ( wp ), dimension ( 6 ) :: fixed_tv = 0. !< Turbulent viscosity varialble value to fix at particular boundary condition (for SA turbulence model) real ( wp ), dimension ( 6 ) :: fixed_tkl = 0. !< (Turbulent kinetic energy x length) varialble value to fix at particular boundary condition (for k-kL turbulence model) real ( wp ), dimension ( 6 ) :: fixed_tgm = 0. !<  Fixed intermittency value to apply at particular boundary condition (for SST2003-gamma transition model) real ( wp ), dimension ( 6 ) :: fixed_wall_temperature = 0. !<  Fixed wall temperature value to apply at isothermal wall boundary condition. real ( wp ), dimension ( 6 ) :: fixed_Tpressure = 0. !<  Fixed Total Pressure value to apply at particular boundary condition real ( wp ), dimension ( 6 ) :: fixed_Ttemperature = 0. !<  Fixed Total Temperature value to apply at particular boundary condition !interface mapping integer , dimension ( 6 ) :: ilo , ihi !< Store the lower and upper bound of the indecies of I loop for the interface mapping integer , dimension ( 6 ) :: jlo , jhi !< Store the lower and upper bound of the indecies of J loop for the interface mapping integer , dimension ( 6 ) :: klo , khi !< Store the lower and upper bound of the indecies of K loop for the interface mapping integer , dimension ( 6 ) :: dir_switch = 0 !< Switch for each boundary face. Activated only if ( for eg I-direction in the mapping is mapped with J-direction) integer , dimension ( 6 ) :: otherface !< Store the face number with which the current interface is connected. !zero flux faces integer , dimension (:), allocatable :: make_F_flux_zero !< Store zero to boundary face, which has wall ID, to make F flux zero integer , dimension (:), allocatable :: make_G_flux_zero !< Store zero to boundary face, which has wall ID, to make G flux zero integer , dimension (:), allocatable :: make_H_flux_zero !< Store zero to boundary face, which has wall ID, to make H flux zero !periodic boundary condition integer , dimension ( 6 ) :: PbcId = - 1 !< Block ID for Periodic boundary condition end type boundarytype","tags":"","loc":"type/boundarytype.html","title":"boundarytype – FEST-3D "},{"text":"public subroutine setup_interface(control, dims) Allocate memory for the data communication between processors Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters: n_var type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~setup_interface~~CallsGraph proc~setup_interface setup_interface interface~alloc alloc proc~setup_interface->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_interface~~CalledByGraph proc~setup_interface setup_interface proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_interface Source Code subroutine setup_interface ( control , dims ) !< Allocate memory for the data communication between processors implicit none type ( controltype ), intent ( in ) :: control !< Control parameters: n_var type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer :: imx , jmx , kmx , n_var character ( len =* ), parameter :: errmsg = \"module: interface, subrouinte setup\" !< Error message imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var ibuf_size = ( jmx - 1 ) * ( kmx - 1 ) * n_var * layers jbuf_size = ( imx - 1 ) * ( kmx - 1 ) * n_var * layers kbuf_size = ( imx - 1 ) * ( jmx - 1 ) * n_var * layers call alloc ( imin_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imin_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_recv_buf , 1 , kbuf_size , errmsg ) end subroutine setup_interface","tags":"","loc":"proc/setup_interface.html","title":"setup_interface – FEST-3D"},{"text":"public subroutine apply_interface(qp, control, bc, dims) MPISEND_RECV call to exchange interface infromation between\n connected blocks. Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2,1:dims%n_var) :: qp Store primitive variable at cell center type( controltype ), intent(in) :: control Control parameters type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~apply_interface~~CallsGraph proc~apply_interface apply_interface mpi_sendrecv mpi_sendrecv proc~apply_interface->mpi_sendrecv proc~apply_periodic_bc apply_periodic_bc proc~apply_interface->proc~apply_periodic_bc debugcall debugcall proc~apply_interface->debugcall proc~apply_periodic_bc->mpi_sendrecv proc~apply_periodic_bc->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~apply_interface~~CalledByGraph proc~apply_interface apply_interface proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~apply_interface proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocapply_interfaceCalledByGraph = svgPanZoom('#procapply_interfaceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_interface Source Code subroutine apply_interface ( qp , control , bc , dims ) !< MPISEND_RECV call to exchange interface infromation between !< connected blocks. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ) :: qp !< Store primitive variable at cell center type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 integer :: imx , jmx , kmx , n_var imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var !---------------------------------------------------------- ! call pattern is change for first block = 0 ! to avoid O-Grid infinite loop for mpi communication call !----------------------------------------------------------- if ( mod ( control % process_id , 2 ) == 0 ) then !--- IMAX ---! if ( bc % imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if !--- IMIN ---! DebugCall ( 'apply_interface' ) if ( bc % imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if else !--- IMIN ---! DebugCall ( 'apply_interface' ) if ( bc % imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if !--- IMAX ---! if ( bc % imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if end if !--- JMIN ---! if ( bc % jmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % jmin_id , tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % jmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 3 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if end if !--- JMAX ---! if ( bc % jmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % jmax_id , tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % jmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 4 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if end if !--- KMIN ---! if ( bc % kmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % kmin_id , tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % kmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 5 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if end if !--- KMAX ---! if ( bc % kmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % kmax_id , tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % kmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( bc % dir_switch ( 6 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end if call apply_periodic_bc ( qp , control , bc , dims ) end subroutine apply_interface","tags":"","loc":"proc/apply_interface.html","title":"apply_interface – FEST-3D"},{"text":"private subroutine apply_periodic_bc(qp, control, bc, dims) If a block is connected to another block in perodic\nfashion, this subroutine will take care of that boundary condition. Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2,1:dims%n_var) :: qp Store primitive variable at cell center type( controltype ), intent(in) :: control Control parameters type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~apply_periodic_bc~~CallsGraph proc~apply_periodic_bc apply_periodic_bc mpi_sendrecv mpi_sendrecv proc~apply_periodic_bc->mpi_sendrecv debugcall debugcall proc~apply_periodic_bc->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~apply_periodic_bc~~CalledByGraph proc~apply_periodic_bc apply_periodic_bc proc~apply_interface apply_interface proc~apply_interface->proc~apply_periodic_bc proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~apply_interface proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocapply_periodic_bcCalledByGraph = svgPanZoom('#procapply_periodic_bcCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_periodic_bc Source Code subroutine apply_periodic_bc ( qp , control , bc , dims ) !<If a block is connected to another block in perodic !<fashion, this subroutine will take care of that boundary condition. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ) :: qp !< Store primitive variable at cell center integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 integer :: imx , jmx , kmx , n_var DebugCall ( 'apply_periodic_boundary_condition' ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var if ( bc % PbcId ( 1 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 1 ), tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 1 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if if ( bc % PbcId ( 2 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 2 ), tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 2 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if !--- JMIN ---! if ( bc % PbcId ( 3 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 3 ), tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 3 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if !--- JMAX ---! if ( bc % PbcId ( 4 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 4 ), tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 4 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if !--- KMIN ---! if ( bc % PbcId ( 5 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 5 ), tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 5 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if !--- KMAX ---! if ( bc % PbcId ( 6 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 6 ), tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , bc % PbcId ( 6 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end subroutine apply_periodic_bc","tags":"","loc":"proc/apply_periodic_bc.html","title":"apply_periodic_bc – FEST-3D"},{"text":"private subroutine alloc_rank1_real(var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank1_real~~CalledByGraph proc~alloc_rank1_real alloc_rank1_real interface~alloc alloc interface~alloc->proc~alloc_rank1_real proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_gradients setup_gradients proc~setup_gradients->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->interface~alloc proc~setup_state setup_state proc~setup_state->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~setupcc setupCC proc~setupcc->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs->interface~alloc proc~setup_interpolant_scheme->interface~alloc proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_gradients proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_scheme proc~setup_solver->proc~setup_state proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_update proc~setup_solver->proc~setupcc proc~setup_solver->proc~setup_time proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_resnorm->proc~allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run proc~abort_run abort_run proc~abort_run->proc~finish_run var panprocalloc_rank1_realCalledByGraph = svgPanZoom('#procalloc_rank1_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_rank1_real Source Code subroutine alloc_rank1_real ( var , start1 , stop1 , errmsg ) !< Allcoate 1-Dimensional array of type: real implicit none real , dimension (:), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 stop end if end subroutine alloc_rank1_real","tags":"","loc":"proc/alloc_rank1_real.html","title":"alloc_rank1_real – FEST-3D"},{"text":"private subroutine alloc_rank2_real(var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank2_real~~CalledByGraph proc~alloc_rank2_real alloc_rank2_real interface~alloc alloc interface~alloc->proc~alloc_rank2_real proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_gradients setup_gradients proc~setup_gradients->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->interface~alloc proc~setup_state setup_state proc~setup_state->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~setupcc setupCC proc~setupcc->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs->interface~alloc proc~setup_interpolant_scheme->interface~alloc proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_gradients proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_scheme proc~setup_solver->proc~setup_state proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_update proc~setup_solver->proc~setupcc proc~setup_solver->proc~setup_time proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_resnorm->proc~allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run proc~abort_run abort_run proc~abort_run->proc~finish_run var panprocalloc_rank2_realCalledByGraph = svgPanZoom('#procalloc_rank2_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_rank2_real Source Code subroutine alloc_rank2_real ( var , start1 , stop1 , start2 , stop2 , errmsg ) !< Allcoate 2-Dimensional array of type: real implicit none real , dimension (:, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 stop end if end subroutine alloc_rank2_real","tags":"","loc":"proc/alloc_rank2_real.html","title":"alloc_rank2_real – FEST-3D"},{"text":"private subroutine alloc_rank3_real(var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank3_real~~CalledByGraph proc~alloc_rank3_real alloc_rank3_real interface~alloc alloc interface~alloc->proc~alloc_rank3_real proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_gradients setup_gradients proc~setup_gradients->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->interface~alloc proc~setup_state setup_state proc~setup_state->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~setupcc setupCC proc~setupcc->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs->interface~alloc proc~setup_interpolant_scheme->interface~alloc proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_gradients proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_scheme proc~setup_solver->proc~setup_state proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_update proc~setup_solver->proc~setupcc proc~setup_solver->proc~setup_time proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_resnorm->proc~allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run proc~abort_run abort_run proc~abort_run->proc~finish_run var panprocalloc_rank3_realCalledByGraph = svgPanZoom('#procalloc_rank3_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_rank3_real Source Code subroutine alloc_rank3_real ( var , start1 , stop1 , start2 , stop2 , & start3 , stop3 , errmsg ) !< Allcoate 3-Dimensional array of type: real implicit none real , dimension (:, :, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 , start3 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 , stop3 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 , start3 : stop3 ), & stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 , stop3 - start3 + 1 stop end if end subroutine alloc_rank3_real","tags":"","loc":"proc/alloc_rank3_real.html","title":"alloc_rank3_real – FEST-3D"},{"text":"private subroutine alloc_rank4_real(var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, errmsg) Allcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank4_real~~CalledByGraph proc~alloc_rank4_real alloc_rank4_real interface~alloc alloc interface~alloc->proc~alloc_rank4_real proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_gradients setup_gradients proc~setup_gradients->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->interface~alloc proc~setup_state setup_state proc~setup_state->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~setupcc setupCC proc~setupcc->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs->interface~alloc proc~setup_interpolant_scheme->interface~alloc proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_gradients proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_scheme proc~setup_solver->proc~setup_state proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_update proc~setup_solver->proc~setupcc proc~setup_solver->proc~setup_time proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_resnorm->proc~allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run proc~abort_run abort_run proc~abort_run->proc~finish_run var panprocalloc_rank4_realCalledByGraph = svgPanZoom('#procalloc_rank4_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_rank4_real Source Code subroutine alloc_rank4_real ( var , start1 , stop1 , start2 , stop2 , & start3 , stop3 , start4 , stop4 , errmsg ) !< Allcoate 4-Dimensional array of type: real implicit none real , dimension (:, :, :, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 , start3 , start4 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 , stop3 , stop4 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 , start3 : stop3 , & start4 : stop4 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 , stop3 - stop3 + 1 , & stop4 - start4 + 1 stop end if end subroutine alloc_rank4_real","tags":"","loc":"proc/alloc_rank4_real.html","title":"alloc_rank4_real – FEST-3D"},{"text":"private subroutine alloc_rank5_real(var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, errmsg) Allcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank5_real~~CalledByGraph proc~alloc_rank5_real alloc_rank5_real interface~alloc alloc interface~alloc->proc~alloc_rank5_real proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_gradients setup_gradients proc~setup_gradients->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->interface~alloc proc~setup_state setup_state proc~setup_state->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~setupcc setupCC proc~setupcc->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs->interface~alloc proc~setup_interpolant_scheme->interface~alloc proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_gradients proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_scheme proc~setup_solver->proc~setup_state proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_update proc~setup_solver->proc~setupcc proc~setup_solver->proc~setup_time proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_resnorm->proc~allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run proc~abort_run abort_run proc~abort_run->proc~finish_run var panprocalloc_rank5_realCalledByGraph = svgPanZoom('#procalloc_rank5_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_rank5_real Source Code subroutine alloc_rank5_real ( var , start1 , stop1 , start2 , stop2 , & start3 , stop3 , start4 , stop4 , start5 , stop5 , errmsg ) !< Allcoate 5-Dimensional array of type: real implicit none real , dimension (:, :, :, :, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 , start3 , start4 , start5 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 , stop3 , stop4 , stop5 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 , start3 : stop3 , & start4 : stop4 , start5 : stop5 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 , stop3 - stop3 + 1 , & stop4 - start4 + 1 , stop5 - start5 + 1 stop end if end subroutine alloc_rank5_real","tags":"","loc":"proc/alloc_rank5_real.html","title":"alloc_rank5_real – FEST-3D"},{"text":"private subroutine alloc_rank6_real(var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, start6, stop6, errmsg) Allcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :,:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension integer, intent(in) :: start6 Starting index of Var array's dimension integer, intent(in) :: stop6 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank6_real~~CalledByGraph proc~alloc_rank6_real alloc_rank6_real interface~alloc alloc interface~alloc->proc~alloc_rank6_real proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_gradients setup_gradients proc~setup_gradients->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->interface~alloc proc~setup_state setup_state proc~setup_state->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~setupcc setupCC proc~setupcc->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs->interface~alloc proc~setup_interpolant_scheme->interface~alloc proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_gradients proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_scheme proc~setup_solver->proc~setup_state proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_update proc~setup_solver->proc~setupcc proc~setup_solver->proc~setup_time proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_resnorm->proc~allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run proc~abort_run abort_run proc~abort_run->proc~finish_run var panprocalloc_rank6_realCalledByGraph = svgPanZoom('#procalloc_rank6_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_rank6_real Source Code subroutine alloc_rank6_real ( var , start1 , stop1 , start2 , stop2 , & !< Allcoate 6-Dimensional array of type: real start3 , stop3 , start4 , stop4 , start5 , stop5 , start6 , stop6 , errmsg ) implicit none real , dimension (:, :, :, :, :,:), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 , start3 , start4 , start5 , start6 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 , stop3 , stop4 , stop5 , stop6 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 , start3 : stop3 , & start4 : stop4 , start5 : stop5 , start6 : stop6 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 , stop3 - stop3 + 1 , & stop4 - start4 + 1 , stop5 - start5 + 1 stop end if end subroutine alloc_rank6_real","tags":"","loc":"proc/alloc_rank6_real.html","title":"alloc_rank6_real – FEST-3D"},{"text":"private subroutine alloc_rank1_integer(var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank1_integer~~CalledByGraph proc~alloc_rank1_integer alloc_rank1_integer interface~alloc alloc interface~alloc->proc~alloc_rank1_integer proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_gradients setup_gradients proc~setup_gradients->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->interface~alloc proc~setup_state setup_state proc~setup_state->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~setupcc setupCC proc~setupcc->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs->interface~alloc proc~setup_interpolant_scheme->interface~alloc proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_gradients proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_scheme proc~setup_solver->proc~setup_state proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_update proc~setup_solver->proc~setupcc proc~setup_solver->proc~setup_time proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_resnorm->proc~allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run proc~abort_run abort_run proc~abort_run->proc~finish_run var panprocalloc_rank1_integerCalledByGraph = svgPanZoom('#procalloc_rank1_integerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_rank1_integer Source Code subroutine alloc_rank1_integer ( var , start1 , stop1 , errmsg ) !< Allcoate 1-Dimensional array of type: integer implicit none integer , dimension (:), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 stop end if end subroutine alloc_rank1_integer","tags":"","loc":"proc/alloc_rank1_integer.html","title":"alloc_rank1_integer – FEST-3D"},{"text":"private subroutine alloc_rank2_integer(var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank2_integer~~CalledByGraph proc~alloc_rank2_integer alloc_rank2_integer interface~alloc alloc interface~alloc->proc~alloc_rank2_integer proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_gradients setup_gradients proc~setup_gradients->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->interface~alloc proc~setup_state setup_state proc~setup_state->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~setupcc setupCC proc~setupcc->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs->interface~alloc proc~setup_interpolant_scheme->interface~alloc proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_gradients proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_scheme proc~setup_solver->proc~setup_state proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_update proc~setup_solver->proc~setupcc proc~setup_solver->proc~setup_time proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_resnorm->proc~allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run proc~abort_run abort_run proc~abort_run->proc~finish_run var panprocalloc_rank2_integerCalledByGraph = svgPanZoom('#procalloc_rank2_integerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_rank2_integer Source Code subroutine alloc_rank2_integer ( var , start1 , stop1 , start2 , stop2 , errmsg ) !< Allcoate 2-Dimensional array of type: integer implicit none integer , dimension (:, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 ), stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 stop end if end subroutine alloc_rank2_integer","tags":"","loc":"proc/alloc_rank2_integer.html","title":"alloc_rank2_integer – FEST-3D"},{"text":"private subroutine alloc_rank3_integer(var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank3_integer~~CalledByGraph proc~alloc_rank3_integer alloc_rank3_integer interface~alloc alloc interface~alloc->proc~alloc_rank3_integer proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_gradients setup_gradients proc~setup_gradients->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->interface~alloc proc~setup_state setup_state proc~setup_state->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~setupcc setupCC proc~setupcc->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs->interface~alloc proc~setup_interpolant_scheme->interface~alloc proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_gradients proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_scheme proc~setup_solver->proc~setup_state proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_update proc~setup_solver->proc~setupcc proc~setup_solver->proc~setup_time proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_resnorm->proc~allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run proc~abort_run abort_run proc~abort_run->proc~finish_run var panprocalloc_rank3_integerCalledByGraph = svgPanZoom('#procalloc_rank3_integerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code alloc_rank3_integer Source Code subroutine alloc_rank3_integer ( var , start1 , stop1 , start2 , stop2 , & start3 , stop3 , errmsg ) !< Allcoate 3-Dimensional array of type: integer implicit none integer , dimension (:, :, :), intent ( inout ), allocatable :: var !< Variable to which memory is allocated integer , intent ( in ) :: start1 , start2 , start3 !< Starting index of Var array's dimension integer , intent ( in ) :: stop1 , stop2 , stop3 !< Last index of Var array's dimension integer :: mem_stat !< Status of the memory allocation process character ( len =* ), intent ( in ), optional :: errmsg !< Error message to print if mem_stat is not 0(successful) allocate ( var ( start1 : stop1 , start2 : stop2 , start3 : stop3 ), & stat = mem_stat ) if ( mem_stat /= 0 ) then if ( present ( errmsg )) then print * , errmsg else print * , 'Error: Could not allocate memory.' end if print * , 'Required extent: ' , stop1 - start1 + 1 , & stop2 - start2 + 1 , stop3 - start3 + 1 stop end if end subroutine alloc_rank3_integer","tags":"","loc":"proc/alloc_rank3_integer.html","title":"alloc_rank3_integer – FEST-3D"},{"text":"public interface alloc Calls interface~~alloc~~CallsGraph interface~alloc alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~alloc~~CalledByGraph interface~alloc alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_gradients setup_gradients proc~setup_gradients->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->interface~alloc proc~setup_state setup_state proc~setup_state->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~setupcc setupCC proc~setupcc->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs->interface~alloc proc~setup_interpolant_scheme->interface~alloc proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_gradients proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_scheme proc~setup_solver->proc~setup_state proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_update proc~setup_solver->proc~setupcc proc~setup_solver->proc~setup_time proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_resnorm->proc~allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run proc~abort_run abort_run proc~abort_run->proc~finish_run var paninterfaceallocCalledByGraph = svgPanZoom('#interfaceallocCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures alloc_rank1_real alloc_rank2_real alloc_rank3_real alloc_rank4_real alloc_rank5_real alloc_rank6_real alloc_rank1_integer alloc_rank2_integer alloc_rank3_integer Module Procedures private subroutine alloc_rank1_real (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_real (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_real (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank4_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, errmsg) Allcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank5_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, errmsg) Allcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank6_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, start6, stop6, errmsg) Allcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :,:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension integer, intent(in) :: start6 Starting index of Var array's dimension integer, intent(in) :: stop6 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank1_integer (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_integer (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_integer (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful)","tags":"","loc":"interface/alloc.html","title":"alloc – FEST-3D"},{"text":"public function Flux(ql, qr, du, inputs) Calculate the total flux through face for laminar flow. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql left state real(kind=wp), intent(in), dimension(1:n_var) :: qr right state real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:7) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Contents Source Code Flux Source Code function Flux ( ql , qr , du , inputs ) !< Calculate the total flux through face for laminar flow. !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !<left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !<right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: U !< conservative variables real ( wp ), dimension ( 1 : n_var ) :: W !< new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P !< primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 1 : 5 ) = U ( 1 : 5 ) + du ( 1 : 5 ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux = Flux * Area end function Flux","tags":"","loc":"proc/flux.html","title":"Flux – FEST-3D"},{"text":"public function SpectralRadius(ql, qr, inputs, c1, c2, eps) Calculated spectral radius Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql left state real(kind=wp), intent(in), dimension(1:n_var) :: qr right state real(kind=wp), intent(in), dimension(1:7) :: inputs real(kind=wp), intent(in), dimension(1:3) :: c1 cell center 1 real(kind=wp), intent(in), dimension(1:3) :: c2 cell center 2 real(kind=wp), intent(in) :: eps Return Value real(kind=wp) Called by proc~~spectralradius~~CalledByGraph proc~spectralradius SpectralRadius proc~update_sst_variables update_SST_variables proc~update_sst_variables->proc~spectralradius proc~update_sa_variables update_SA_variables proc~update_sa_variables->proc~spectralradius proc~update_laminar_variables update_laminar_variables proc~update_laminar_variables->proc~spectralradius proc~update_lctm2015 update_lctm2015 proc~update_lctm2015->proc~spectralradius proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_sst_variables proc~update_with_plusgs->proc~update_sa_variables proc~update_with_plusgs->proc~update_laminar_variables proc~update_with_plusgs->proc~update_lctm2015 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocspectralradiusCalledByGraph = svgPanZoom('#procspectralradiusCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SpectralRadius Source Code function SpectralRadius ( ql , qr , inputs , c1 , c2 , eps ) !< Calculated spectral radius implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !<left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !<right state real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : 3 ) , intent ( in ) :: c1 !<cell center 1 real ( wp ), dimension ( 1 : 3 ) , intent ( in ) :: c2 !<cell center 2 real ( wp ) , intent ( in ) :: eps ! local variables real ( wp ) :: SpectralRadius real ( wp ) :: NormalSpeed real ( wp ) :: SpeedOfSound real ( wp ) :: vis real ( wp ) :: mu real ( wp ) :: rho real ( wp ) :: distance !extract inputs real ( wp ) :: Area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mm real ( wp ) :: tm Area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mm = inputs ( 6 ) tm = inputs ( 7 ) ! in state vector q (2-4) are the cell center velocity NormalSpeed = 0.5 * ( ( ( ql ( 2 ) + qr ( 2 ) ) * nx ) & + ( ( ql ( 3 ) + qr ( 3 ) ) * ny ) & + ( ( ql ( 4 ) + qr ( 4 ) ) * nz ) & ) NormalSpeed = abs ( NormalSpeed ) SpeedOfSound = 0.5 * ( sqrt ( gm * ql ( 5 ) / ql ( 1 )) + sqrt ( gm * qr ( 5 ) / qr ( 1 )) ) ! visocus part mu = mm / Pr + tm / tPr rho = 0.5 * ( ql ( 1 ) + qr ( 1 ) ) distance = sqrt (( c1 ( 1 ) - c2 ( 1 )) ** 2 + ( c1 ( 2 ) - c2 ( 2 )) ** 2 + ( c1 ( 3 ) - c2 ( 3 )) ** 2 ) vis = 2.0 * gm * ( mm / pr + tm / tpr ) / ( rho * distance ) SpectralRadius = ( 0.5 * (( 1.0 + eps ) * NormalSpeed & + sqrt ((( eps - 1.0 ) ** 2 ) * ( NormalSpeed ** 2 ) & + 4 * eps * ( SpeedOfSound ** 2 ))) + vis ) * Area end function SpectralRadius","tags":"","loc":"proc/spectralradius.html","title":"SpectralRadius – FEST-3D"},{"text":"public function SSTFlux(ql, qr, du, inputs) Calculate the total flux through face for turbulent flow (SST) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:8) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Called by proc~~sstflux~~CalledByGraph proc~sstflux SSTFlux proc~update_sst_variables update_SST_variables proc~update_sst_variables->proc~sstflux proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_sst_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsstfluxCalledByGraph = svgPanZoom('#procsstfluxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SSTFlux Source Code function SSTFlux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent flow (SST) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 8 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: SSTFlux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtkdx real ( wp ) :: dtkdy real ( wp ) :: dtkdz real ( wp ) :: dtwdx real ( wp ) :: dtwdy real ( wp ) :: dtwdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: sigma_k real ( wp ) :: sigma_w real ( wp ) :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux = Flux * Area SSTFlux = Flux end function SSTFlux","tags":"","loc":"proc/sstflux.html","title":"SSTFlux – FEST-3D"},{"text":"public function SAFlux(ql, qr, du, inputs) Calculate the total flux through face for turbulent flow (SA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:7) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Called by proc~~saflux~~CalledByGraph proc~saflux SAFlux proc~update_sa_variables update_SA_variables proc~update_sa_variables->proc~saflux proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_sa_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsafluxCalledByGraph = svgPanZoom('#procsafluxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SAFlux Source Code function SAFlux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent flow (SA) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: SAFlux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtvdx real ( wp ) :: dtvdy real ( wp ) :: dtvdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: muCap area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) ! viscous terms muCap = 0.25 * ( P ( 1 ) + W ( 1 )) * ( P ( 6 ) + W ( 6 )) mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtvdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtvdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtvdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz tmu = 0.5 * ( W ( 6 ) + P ( 6 )) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + muCap ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ) / sigma_sa Flux = Flux * Area SAFlux = Flux end function SAFlux","tags":"","loc":"proc/saflux.html","title":"SAFlux – FEST-3D"},{"text":"public function lctm2015flux(ql, qr, du, inputs) Calculate the total flux through face for turbulent/transition flow (LCTM2015) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:8) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Called by proc~~lctm2015flux~~CalledByGraph proc~lctm2015flux lctm2015flux proc~update_lctm2015 update_lctm2015 proc~update_lctm2015->proc~lctm2015flux proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_lctm2015 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproclctm2015fluxCalledByGraph = svgPanZoom('#proclctm2015fluxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code lctm2015flux Source Code function lctm2015flux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent/transition flow (LCTM2015) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 8 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: lctm2015flux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtkdx real ( wp ) :: dtkdy real ( wp ) :: dtkdz real ( wp ) :: dtwdx real ( wp ) :: dtwdy real ( wp ) :: dtwdz real ( wp ) :: dtgmdx real ( wp ) :: dtgmdy real ( wp ) :: dtgmdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: sigma_k real ( wp ) :: sigma_w real ( wp ) :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 8 ) = ql ( 1 ) * ql ( 8 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 8 ) = U ( 8 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) W ( 8 ) = max ( W ( 8 ), 0.0 ) !W(8) = min(W(8), 1.0) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) Flux ( 8 ) = ( W ( 8 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume dtgmdx = ( P ( 8 ) - W ( 8 ) ) * nx * Area / Volume dtgmdy = ( P ( 8 ) - W ( 8 ) ) * ny * Area / Volume dtgmdz = ( P ( 8 ) - W ( 8 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux ( 8 ) = Flux ( 8 ) + ( mmu + tmu ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ) Flux = Flux * Area lctm2015flux = Flux end function lctm2015flux","tags":"","loc":"proc/lctm2015flux.html","title":"lctm2015flux – FEST-3D"},{"text":"public subroutine setup_plusgs(control, scheme, flow, dims) Allocate array memory for data communication Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~setup_plusgs~~CallsGraph proc~setup_plusgs setup_plusgs interface~alloc alloc proc~setup_plusgs->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_plusgs~~CalledByGraph proc~setup_plusgs setup_plusgs proc~setup_update setup_update proc~setup_update->proc~setup_plusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_update proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_plusgs Source Code subroutine setup_plusgs ( control , scheme , flow , dims ) !< Allocate array memory for data communication implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx character ( len =* ), parameter :: errmsg = \"module: LUSGS, subrouinte setup\" !< Error message imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var gm = flow % gm mu_ref = flow % mu_ref Reynolds_number = flow % Reynolds_number free_stream_tu = flow % tu_inf tk_inf = flow % tk_inf tkl_inf = flow % tkl_inf tpr = flow % tpr pr = flow % pr MInf = flow % MInf R_gas = flow % R_gas call alloc ( delQ , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) call alloc ( delQstar , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) if ( mu_ref == 0.0 . or . scheme % turbulence == 'none' ) then call alloc ( dummy , 0 , imx , 0 , jmx , 0 , kmx ) dummy = 0.0 end if if ( mu_ref == 0.0 ) then mmu => dummy else mmu => mu end if if ( trim ( scheme % turbulence ) == 'none' ) then tmu => dummy else tmu => mu_t end if end subroutine setup_plusgs","tags":"","loc":"proc/setup_plusgs.html","title":"setup_plusgs – FEST-3D"},{"text":"public subroutine update_with_plusgs(qp, delta_t, cells, Ifaces, Jfaces, Kfaces, residue, scheme, dims) Time-integrate with LU_SGS method Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center type( schemetype ), intent(in) :: scheme finite-volume Schemes type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_with_plusgs~~CallsGraph proc~update_with_plusgs update_with_plusgs proc~update_sst_variables update_SST_variables proc~update_with_plusgs->proc~update_sst_variables proc~update_sa_variables update_SA_variables proc~update_with_plusgs->proc~update_sa_variables proc~update_laminar_variables update_laminar_variables proc~update_with_plusgs->proc~update_laminar_variables proc~update_lctm2015 update_lctm2015 proc~update_with_plusgs->proc~update_lctm2015 proc~sstflux SSTFlux proc~update_sst_variables->proc~sstflux proc~spectralradius SpectralRadius proc~update_sst_variables->proc~spectralradius proc~saflux SAFlux proc~update_sa_variables->proc~saflux proc~update_sa_variables->proc~spectralradius proc~update_laminar_variables->proc~spectralradius proc~lctm2015flux lctm2015flux proc~update_lctm2015->proc~lctm2015flux proc~update_lctm2015->proc~spectralradius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_with_plusgs~~CalledByGraph proc~update_with_plusgs update_with_plusgs proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_with_plusgs Source Code subroutine update_with_plusgs ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , residue , scheme , dims ) !< Time-integrate with LU_SGS method implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal select case ( trim ( scheme % turbulence )) case ( 'none' ) call update_laminar_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'sst' , 'sst2003' ) select case ( trim ( scheme % transition )) case ( 'none' , 'bc' ) call update_SST_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'lctm2015' ) call update_lctm2015 ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case DEFAULT Fatal_error end select case ( 'kkl' ) !          call update_KKL_variables() case ( 'sa' , 'saBC' ) call update_SA_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case Default Fatal_error end select end subroutine update_with_plusgs","tags":"","loc":"proc/update_with_plusgs.html","title":"update_with_plusgs – FEST-3D"},{"text":"public subroutine update_laminar_variables(qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update laminar flow with LU-SGS scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_laminar_variables~~CallsGraph proc~update_laminar_variables update_laminar_variables proc~spectralradius SpectralRadius proc~update_laminar_variables->proc~spectralradius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_laminar_variables~~CalledByGraph proc~update_laminar_variables update_laminar_variables proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_laminar_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_laminar_variablesCalledByGraph = svgPanZoom('#procupdate_laminar_variablesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_laminar_variables Source Code subroutine update_laminar_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update laminar flow with LU-SGS scheme implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 5 ) :: deltaU real ( wp ) :: D real ( wp ), dimension ( 1 : 5 ) :: conservativeQ real ( wp ), dimension ( 1 : 5 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 5 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 5 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 5 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 5 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 5 ) :: Q2 real ( wp ), dimension ( 1 : 5 ) :: Q3 real ( wp ), dimension ( 1 : 5 ) :: Q4 real ( wp ), dimension ( 1 : 5 ) :: Q5 real ( wp ), dimension ( 1 : 5 ) :: Q6 real ( wp ), dimension ( 1 : 5 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 5 ) :: DQ1 real ( wp ), dimension ( 1 : 5 ) :: DQ2 real ( wp ), dimension ( 1 : 5 ) :: DQ3 real ( wp ), dimension ( 1 : 5 ) :: DQ4 real ( wp ), dimension ( 1 : 5 ) :: DQ5 real ( wp ), dimension ( 1 : 5 ) :: DQ6 real ( wp ), dimension ( 1 : 7 ) :: Flist1 real ( wp ), dimension ( 1 : 7 ) :: Flist2 real ( wp ), dimension ( 1 : 7 ) :: Flist3 real ( wp ), dimension ( 1 : 7 ) :: Flist4 real ( wp ), dimension ( 1 : 7 ) :: Flist5 real ( wp ), dimension ( 1 : 7 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: eps real ( wp ) :: M real ( wp ) :: VMag real ( wp ) :: SoundMag real ( wp ) :: u , v , w , r , p , H real ( wp ) :: factor real ( wp ), dimension ( 1 : 5 , 1 : 5 ) :: PrecondInv !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 5 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 5 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 5 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = Flux ( Q3 , Q0 , DQ0 , Flist3 ) r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) !deltaU(1:5) = -residue(i,j,k,1:5) & deltaU ( 1 : 5 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 5 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 5 )) ) delQstar ( i , j , k , 1 : 5 ) = deltaU ( 1 : 5 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 5 ) DQ5 = delQ ( i , j + 1 , k , 1 : 5 ) DQ6 = delQ ( i , j , k + 1 , 1 : 5 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = Flux ( Q6 , Q0 , DQ0 , Flist6 ) r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) delQ ( i , j , k , 1 : 5 ) = delQstar ( i , j , k , 1 : 5 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 5 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) ! add new change into conservative solution conservativeQ ( 1 : 5 ) = conservativeQ ( 1 : 5 ) + delQ ( i , j , k , 1 : 5 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) end do end do end do end subroutine update_laminar_variables","tags":"","loc":"proc/update_laminar_variables.html","title":"update_laminar_variables – FEST-3D"},{"text":"public subroutine update_SST_variables(qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (SST) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_sst_variables~~CallsGraph proc~update_sst_variables update_SST_variables proc~sstflux SSTFlux proc~update_sst_variables->proc~sstflux proc~spectralradius SpectralRadius proc~update_sst_variables->proc~spectralradius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_sst_variables~~CalledByGraph proc~update_sst_variables update_SST_variables proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_sst_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_sst_variablesCalledByGraph = svgPanZoom('#procupdate_sst_variablesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_SST_variables Source Code subroutine update_SST_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (SST) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 7 ) :: deltaU real ( wp ), dimension ( 1 : 7 ) :: D real ( wp ), dimension ( 1 : 7 ) :: conservativeQ real ( wp ), dimension ( 1 : 7 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 7 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 7 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 7 ) :: Q2 real ( wp ), dimension ( 1 : 7 ) :: Q3 real ( wp ), dimension ( 1 : 7 ) :: Q4 real ( wp ), dimension ( 1 : 7 ) :: Q5 real ( wp ), dimension ( 1 : 7 ) :: Q6 real ( wp ), dimension ( 1 : 7 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 7 ) :: DQ1 real ( wp ), dimension ( 1 : 7 ) :: DQ2 real ( wp ), dimension ( 1 : 7 ) :: DQ3 real ( wp ), dimension ( 1 : 7 ) :: DQ4 real ( wp ), dimension ( 1 : 7 ) :: DQ5 real ( wp ), dimension ( 1 : 7 ) :: DQ6 real ( wp ), dimension ( 1 : 8 ) :: Flist1 real ( wp ), dimension ( 1 : 8 ) :: Flist2 real ( wp ), dimension ( 1 : 8 ) :: Flist3 real ( wp ), dimension ( 1 : 8 ) :: Flist4 real ( wp ), dimension ( 1 : 8 ) :: Flist5 real ( wp ), dimension ( 1 : 8 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: beta real ( wp ) :: eps real ( wp ) :: M real ( wp ) :: VMag real ( wp ) :: SoundMag real ( wp ) :: u , v , w , r , p , kk , ww , H real ( wp ) :: factor real ( wp ), dimension ( 1 : 7 , 1 : 7 ) :: PrecondInv ! intermittency real ( wp ) :: De , Dp De = 0.0 Dp = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SSTFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SSTFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SSTFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SSTFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SSTFlux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) kk = Q0 ( 6 ) ww = Q0 ( 7 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * kk * VMag * VMag / 2.0 PrecondInv ( 7 , 1 ) = 0.0 - factor * ww * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * kk * ( - u ) PrecondInv ( 7 , 2 ) = 0.0 - factor * ww * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * kk * ( - v ) PrecondInv ( 7 , 3 ) = 0.0 - factor * ww * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * kk * ( - w ) PrecondInv ( 7 , 4 ) = 0.0 - factor * ww * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * kk * ( 1. ) PrecondInv ( 7 , 5 ) = 0.0 - factor * ww * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * kk * ( - 1. ) PrecondInv ( 7 , 6 ) = 0.0 - factor * ww * ( - 1. ) PrecondInv ( 1 , 7 ) = 0.0 - factor * 1 * ( 0. ) PrecondInv ( 2 , 7 ) = 0.0 - factor * u * ( 0. ) PrecondInv ( 3 , 7 ) = 0.0 - factor * v * ( 0. ) PrecondInv ( 4 , 7 ) = 0.0 - factor * w * ( 0. ) PrecondInv ( 5 , 7 ) = 0.0 - factor * H * ( 0. ) PrecondInv ( 6 , 7 ) = 0.0 - factor * kk * ( 0. ) PrecondInv ( 7 , 7 ) = 1.0 - factor * ww * ( 0. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 7 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SSTFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SSTFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SSTFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SSTFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SSTFlux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) kk = Q0 ( 6 ) ww = Q0 ( 7 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * kk * VMag * VMag / 2.0 PrecondInv ( 7 , 1 ) = 0.0 - factor * ww * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * kk * ( - u ) PrecondInv ( 7 , 2 ) = 0.0 - factor * ww * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * kk * ( - v ) PrecondInv ( 7 , 3 ) = 0.0 - factor * ww * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * kk * ( - w ) PrecondInv ( 7 , 4 ) = 0.0 - factor * ww * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * kk * ( 1. ) PrecondInv ( 7 , 5 ) = 0.0 - factor * ww * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * kk * ( - 1. ) PrecondInv ( 7 , 6 ) = 0.0 - factor * ww * ( - 1. ) PrecondInv ( 1 , 7 ) = 0.0 - factor * 1 * ( 0. ) PrecondInv ( 2 , 7 ) = 0.0 - factor * u * ( 0. ) PrecondInv ( 3 , 7 ) = 0.0 - factor * v * ( 0. ) PrecondInv ( 4 , 7 ) = 0.0 - factor * w * ( 0. ) PrecondInv ( 5 , 7 ) = 0.0 - factor * H * ( 0. ) PrecondInv ( 6 , 7 ) = 0.0 - factor * kk * ( 0. ) PrecondInv ( 7 , 7 ) = 1.0 - factor * ww * ( 0. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if end do end do end do end subroutine update_SST_variables","tags":"","loc":"proc/update_sst_variables.html","title":"update_SST_variables – FEST-3D"},{"text":"public subroutine update_SA_variables(qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (SA) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_sa_variables~~CallsGraph proc~update_sa_variables update_SA_variables proc~saflux SAFlux proc~update_sa_variables->proc~saflux proc~spectralradius SpectralRadius proc~update_sa_variables->proc~spectralradius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_sa_variables~~CalledByGraph proc~update_sa_variables update_SA_variables proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_sa_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_sa_variablesCalledByGraph = svgPanZoom('#procupdate_sa_variablesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_SA_variables Source Code subroutine update_SA_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (SA) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 6 ) :: deltaU real ( wp ), dimension ( 1 : 6 ) :: D real ( wp ), dimension ( 1 : 6 ) :: conservativeQ real ( wp ), dimension ( 1 : 6 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 6 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 6 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 6 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 6 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 6 ) :: Q2 real ( wp ), dimension ( 1 : 6 ) :: Q3 real ( wp ), dimension ( 1 : 6 ) :: Q4 real ( wp ), dimension ( 1 : 6 ) :: Q5 real ( wp ), dimension ( 1 : 6 ) :: Q6 real ( wp ), dimension ( 1 : 6 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 6 ) :: DQ1 real ( wp ), dimension ( 1 : 6 ) :: DQ2 real ( wp ), dimension ( 1 : 6 ) :: DQ3 real ( wp ), dimension ( 1 : 6 ) :: DQ4 real ( wp ), dimension ( 1 : 6 ) :: DQ5 real ( wp ), dimension ( 1 : 6 ) :: DQ6 real ( wp ), dimension ( 1 : 7 ) :: Flist1 real ( wp ), dimension ( 1 : 7 ) :: Flist2 real ( wp ), dimension ( 1 : 7 ) :: Flist3 real ( wp ), dimension ( 1 : 7 ) :: Flist4 real ( wp ), dimension ( 1 : 7 ) :: Flist5 real ( wp ), dimension ( 1 : 7 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: eps real ( wp ) :: M real ( wp ) :: VMag real ( wp ) :: SoundMag real ( wp ) :: u , v , w , p , H , tv !r real ( wp ) :: factor real ( wp ), dimension ( 1 : 6 , 1 : 6 ) :: PrecondInv real ( wp ) :: fv1 real ( wp ) :: fv2 real ( wp ) :: fw real ( wp ) :: g real ( wp ) :: r real ( wp ) :: dist_i real ( wp ) :: dist_i_2 real ( wp ) :: Ji real ( wp ) :: Ji_2 real ( wp ) :: Ji_3 real ( wp ) :: S real ( wp ) :: Omega real ( wp ) :: k2 real ( wp ) :: inv_k2_d2 real ( wp ) :: Shat real ( wp ) :: inv_Shat real ( wp ) :: nu real ( wp ) :: glim real ( wp ) :: g_6 real ( wp ) :: dfv1 real ( wp ) :: dfv2 real ( wp ) :: dfw real ( wp ) :: dShat real ( wp ) :: dr real ( wp ) :: dg real ( wp ) :: density !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 6 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 6 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 6 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SAFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SAFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SAFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SAFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SAFlux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) tv = Q0 ( 6 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * tv * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * tv * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * tv * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * tv * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * tv * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * tv * ( - 1. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * cells ( i , j , k )% volume ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * cells ( i , j , k )% volume ! --  end of source term -- ! deltaU ( 1 : 6 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 6 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 6 )) ) delQstar ( i , j , k , 1 : 6 ) = deltaU ( 1 : 6 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 6 ) DQ5 = delQ ( i , j + 1 , k , 1 : 6 ) DQ6 = delQ ( i , j , k + 1 , 1 : 6 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SAFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SAFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SAFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SAFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SAFlux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) tv = Q0 ( 6 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * tv * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * tv * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * tv * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * tv * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * tv * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * tv * ( - 1. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * cells ( i , j , k )% volume ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * cells ( i , j , k )% volume ! --  end of source term -- ! delQ ( i , j , k , 1 : 6 ) = delQstar ( i , j , k , 1 : 6 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 6 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) ! add new change into conservative solution conservativeQ ( 1 : 6 ) = conservativeQ ( 1 : 6 ) + delQ ( i , j , k , 1 : 6 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) end do end do end do end subroutine update_SA_variables","tags":"","loc":"proc/update_sa_variables.html","title":"update_SA_variables – FEST-3D"},{"text":"public subroutine update_lctm2015(qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS/transition (LCTM2015) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_lctm2015~~CallsGraph proc~update_lctm2015 update_lctm2015 proc~lctm2015flux lctm2015flux proc~update_lctm2015->proc~lctm2015flux proc~spectralradius SpectralRadius proc~update_lctm2015->proc~spectralradius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_lctm2015~~CalledByGraph proc~update_lctm2015 update_lctm2015 proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_lctm2015 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_lctm2015CalledByGraph = svgPanZoom('#procupdate_lctm2015CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_lctm2015 Source Code subroutine update_lctm2015 ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS/transition (LCTM2015) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 8 ) :: deltaU real ( wp ), dimension ( 1 : 8 ) :: D real ( wp ), dimension ( 1 : 8 ) :: conservativeQ real ( wp ), dimension ( 1 : 8 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 8 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 8 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 8 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 8 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 8 ) :: Q2 real ( wp ), dimension ( 1 : 8 ) :: Q3 real ( wp ), dimension ( 1 : 8 ) :: Q4 real ( wp ), dimension ( 1 : 8 ) :: Q5 real ( wp ), dimension ( 1 : 8 ) :: Q6 real ( wp ), dimension ( 1 : 8 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 8 ) :: DQ1 real ( wp ), dimension ( 1 : 8 ) :: DQ2 real ( wp ), dimension ( 1 : 8 ) :: DQ3 real ( wp ), dimension ( 1 : 8 ) :: DQ4 real ( wp ), dimension ( 1 : 8 ) :: DQ5 real ( wp ), dimension ( 1 : 8 ) :: DQ6 real ( wp ), dimension ( 1 : 8 ) :: Flist1 real ( wp ), dimension ( 1 : 8 ) :: Flist2 real ( wp ), dimension ( 1 : 8 ) :: Flist3 real ( wp ), dimension ( 1 : 8 ) :: Flist4 real ( wp ), dimension ( 1 : 8 ) :: Flist5 real ( wp ), dimension ( 1 : 8 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: beta real ( wp ) :: eps real ( wp ) :: M real ( wp ) :: VMag real ( wp ) :: SoundMag real ( wp ) :: u , v , w , r , p , kk , ww , H , im real ( wp ) :: factor real ( wp ), dimension ( 1 : 8 , 1 : 8 ) :: PrecondInv real ( wp ), dimension ( 1 : 8 , 1 : 8 ) :: Identity ! intermittency real ( wp ) :: Fonset1 real ( wp ) :: Fonset2 real ( wp ) :: Fonset3 real ( wp ) :: Fonset real ( wp ) :: Rev real ( wp ) :: RT real ( wp ) :: Fturb real ( wp ) :: Re_theta real ( wp ) :: TuL real ( wp ) :: strain real ( wp ) :: vort real ( wp ) :: Dp , De real ( wp ) :: Fpg real ( wp ) :: density Dp = 0.0 De = 0.0 !Identity matrix Identity = 0.0 do i = 1 , 8 Identity ( i , i ) = 1.0 end do !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 8 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 8 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 8 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) kk = Q0 ( 6 ) ww = Q0 ( 7 ) im = Q0 ( 8 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) !preconditing start PrecondInv (:, 1 ) = VMag * VMag / 2.0 PrecondInv (:, 2 ) = - u PrecondInv (:, 3 ) = - v PrecondInv (:, 4 ) = - w PrecondInv (:, 5 ) = 1.0 PrecondInv (:, 6 ) = - 1.0 PrecondInv (:, 7 ) = 0.0 PrecondInv (:, 8 ) = 0.0 PrecondInv ( 2 ,:) = u * PrecondInv ( 2 ,:) PrecondInv ( 3 ,:) = v * PrecondInv ( 3 ,:) PrecondInv ( 4 ,:) = w * PrecondInv ( 4 ,:) PrecondInv ( 5 ,:) = H * PrecondInv ( 5 ,:) PrecondInv ( 6 ,:) = kk * PrecondInv ( 6 ,:) PrecondInv ( 7 ,:) = ww * PrecondInv ( 7 ,:) PrecondInv ( 8 ,:) = im * PrecondInv ( 8 ,:) PrecondInv = Identity - ( factor * PrecondInv ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*cells(i,j,k)%volume) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) Fpg = 1.0 !max(Fpg, 0.0) TuL = min ( 10 0.0 * sqrt ( 2.0 * qp ( i , j , k , 6 ) / 3.0 ) / ( qp ( i , j , k , 7 ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) Rev = density * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density * qp ( i , j , k , 6 ) / ( mu ( i , j , k ) * qp ( i , j , k , 7 )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * cells ( i , j , k )% volume ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 8 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 8 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 8 )) ) delQstar ( i , j , k , 1 : 8 ) = deltaU ( 1 : 8 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 8 ) DQ5 = delQ ( i , j + 1 , k , 1 : 8 ) DQ6 = delQ ( i , j , k + 1 , 1 : 8 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) !preconditing start PrecondInv (:, 1 ) = VMag * VMag / 2.0 PrecondInv (:, 2 ) = - u PrecondInv (:, 3 ) = - v PrecondInv (:, 4 ) = - w PrecondInv (:, 5 ) = 1.0 PrecondInv (:, 6 ) = - 1.0 PrecondInv (:, 7 ) = 0.0 PrecondInv (:, 8 ) = 0.0 PrecondInv ( 2 ,:) = u * PrecondInv ( 2 ,:) PrecondInv ( 3 ,:) = v * PrecondInv ( 3 ,:) PrecondInv ( 4 ,:) = w * PrecondInv ( 4 ,:) PrecondInv ( 5 ,:) = H * PrecondInv ( 5 ,:) PrecondInv ( 6 ,:) = kk * PrecondInv ( 6 ,:) PrecondInv ( 7 ,:) = ww * PrecondInv ( 7 ,:) PrecondInv ( 8 ,:) = im * PrecondInv ( 8 ,:) PrecondInv = Identity - ( factor * PrecondInv ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*cells(i,j,k)%volume) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) Fpg = 1.0 !max(Fpg, 0.0) TuL = min ( 10 0.0 * sqrt ( 2.0 * qp ( i , j , k , 6 ) / 3.0 ) / ( qp ( i , j , k , 7 ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) Rev = density * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density * qp ( i , j , k , 6 ) / ( mu ( i , j , k ) * qp ( i , j , k , 7 )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * cells ( i , j , k )% volume ) delQ ( i , j , k , 1 : 8 ) = delQstar ( i , j , k , 1 : 8 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 8 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) conservativeQ ( 8 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 8 ) ! add new change into conservative solution conservativeQ ( 1 : n_var ) = conservativeQ ( 1 : n_var ) + delQ ( i , j , k , 1 : n_var ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0.0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0.0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if qp ( i , j , k , 8 ) = conservativeQ ( 8 ) / conservativeQ ( 1 ) qp ( i , j , k , 8 ) = max ( qp ( i , j , k , 8 ), 0.0 ) !qp(i,j,k,8) = min(qp(i,j,k,8), 1.0) end do end do end do end subroutine update_lctm2015","tags":"","loc":"proc/update_lctm2015.html","title":"update_lctm2015 – FEST-3D"},{"text":"public subroutine setup_gradients(control, scheme, flow, dims) Memoery allocation to the gradient variables and \n setup pointer to the slice to the main gradient variable\n based on the various models being used. Setup Pointer to the main array which stores gradient \n all variables with x, y, z Setup Pointer to the main array which stores gradient \n all variables with x, y, z Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~setup_gradients~~CallsGraph proc~setup_gradients setup_gradients interface~alloc alloc proc~setup_gradients->interface~alloc debugcall debugcall proc~setup_gradients->debugcall aerrmsg aerrmsg proc~setup_gradients->aerrmsg proc~get_n_grad get_n_grad proc~setup_gradients->proc~get_n_grad proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~get_n_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_gradients~~CalledByGraph proc~setup_gradients setup_gradients proc~setup_solver setup_solver proc~setup_solver->proc~setup_gradients proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_gradients Source Code subroutine setup_gradients ( control , scheme , flow , dims ) !< Memoery allocation to the gradient variables and !< setup pointer to the slice to the main gradient variable !< based on the various models being used. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ) , intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ) , intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx DebugCall ( \"setup_gradients\" ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var R_gas = flow % R_gas if ( flow % mu_ref /= 0 ) then call get_n_grad ( scheme ) !call allocate_memory() call alloc ( gradqp_x , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_x\" )) call alloc ( gradqp_y , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_y\" )) call alloc ( gradqp_z , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_z\" )) ! Linking pointer to laminar gradients !call setup_laminar_grad() DebugCall ( 'setup_laminar_grad' ) !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z gradu_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 1 ) gradv_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 2 ) gradw_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 3 ) gradT_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 4 ) gradu_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 1 ) gradv_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 2 ) gradw_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 3 ) gradT_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 4 ) gradu_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 1 ) gradv_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 2 ) gradw_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 3 ) gradT_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 4 ) ! Linking pointer to turbulent gradients select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) !call setup_sa_grad() DebugCall ( \"setup_sa_grad\" ) gradtv_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtv_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtv_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) case ( 'sst' , 'sst2003' ) !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z DebugCall ( 'setup_sst_grad' ) gradtk_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtw_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 6 ) gradtk_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtw_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 6 ) gradtk_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) gradtw_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 6 ) case ( 'kkl' ) !call setup_kkl_grad() DebugCall ( 'setup_kkl_grad' ) gradtk_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtkl_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 6 ) gradtk_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtkl_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 6 ) gradtk_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) gradtkl_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 6 ) case DEFAULT Fatal_error end select !Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) !call setup_lctm2015_grad() gradtgm_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, n_grad ) gradtgm_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, n_grad ) gradtgm_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, n_grad ) case ( 'none' , 'bc' ) !do nothing continue case DEFAULT Fatal_error end Select end if end subroutine setup_gradients","tags":"","loc":"proc/setup_gradients.html","title":"setup_gradients – FEST-3D"},{"text":"public subroutine get_n_grad(scheme) Set number of variables for which\n gradient is required based on the\n being used Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme finite-volume Schemes Calls proc~~get_n_grad~~CallsGraph proc~get_n_grad get_n_grad debugcall debugcall proc~get_n_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_n_grad~~CalledByGraph proc~get_n_grad get_n_grad proc~setup_gradients setup_gradients proc~setup_gradients->proc~get_n_grad proc~setup_solver setup_solver proc~setup_solver->proc~setup_gradients proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_n_grad Source Code subroutine get_n_grad ( scheme ) !< Set number of variables for which !< gradient is required based on the !< being used implicit none type ( schemetype ) , intent ( in ) :: scheme !< finite-volume Schemes DebugCall ( \"get_n_grad\" ) select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) n_grad = 5 case ( 'sst' , 'sst2003' ) n_grad = 6 case ( 'kkl' ) n_grad = 6 case DEFAULT Fatal_error end select !Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) n_grad = n_grad + 1 case ( 'none' , 'bc' ) n_grad = n_grad + 0 case DEFAULT Fatal_error end Select end subroutine get_n_grad","tags":"","loc":"proc/get_n_grad.html","title":"get_n_grad – FEST-3D"},{"text":"public subroutine evaluate_all_gradients(qp, Temp, cells, Ifaces, Jfaces, Kfaces, scheme, bc, dims) Call to all the required gradients and \n apply boundary condition for ghost cell\n gradients Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), Target :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2) :: Temp Store Temperature variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( schemetype ), intent(in) :: scheme finite-volume Schemes type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~evaluate_all_gradients~~CallsGraph proc~evaluate_all_gradients evaluate_all_gradients debugcall debugcall proc~evaluate_all_gradients->debugcall proc~compute_gradient_g compute_gradient_G proc~evaluate_all_gradients->proc~compute_gradient_g proc~apply_gradient_bc apply_gradient_bc proc~evaluate_all_gradients->proc~apply_gradient_bc proc~compute_gradient_g->debugcall proc~apply_gradient_bc->debugcall proc~apply_gradient_bc_face apply_gradient_bc_face proc~apply_gradient_bc->proc~apply_gradient_bc_face Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~evaluate_all_gradients~~CalledByGraph proc~evaluate_all_gradients evaluate_all_gradients proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocevaluate_all_gradientsCalledByGraph = svgPanZoom('#procevaluate_all_gradientsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code evaluate_all_gradients Source Code subroutine evaluate_all_gradients ( qp , Temp , cells , Ifaces , Jfaces , Kfaces , scheme , bc , dims ) !< Call to all the required gradients and !< apply boundary condition for ghost cell !< gradients implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), Target :: qp !< Store primitive variable at cell center real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Temp !< Store Temperature variable at cell center type ( schemetype ) , intent ( in ) :: scheme !< finite-volume Schemes type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :), pointer :: x_speed !< U pointer, point to slice of qp (:,:,:,2) real ( wp ), dimension (:, :, :), pointer :: y_speed !< V pointer, point to slice of qp (:,:,:,3) real ( wp ), dimension (:, :, :), pointer :: z_speed !< W pointer, point to slice of qp (:,:,:,4) real ( wp ), dimension (:, :, :), pointer :: tk !< TKE/mass real ( wp ), dimension (:, :, :), pointer :: tw !< Omega real ( wp ), dimension (:, :, :), pointer :: tv !< SA visocity real ( wp ), dimension (:, :, :), pointer :: tkl !< KL K-KL method real ( wp ), dimension (:, :, :), pointer :: tgm !< Intermittency of LCTM2015 DebugCall ( 'evaluate_all_gradients' ) x_speed ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 2 ) y_speed ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 3 ) z_speed ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 4 ) !call compute_gradient_G(gradu_x, qp(:,:,:,2), cells, Ifaces, Jfaces, Kfaces, dims, 'x') call compute_gradient_G ( gradu_x , x_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradv_x , y_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradw_x , z_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradT_x , Temp , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) !call compute_gradient_G(gradu_y, qp(:,:,:,2), cells, Ifaces, Jfaces, Kfaces, dims, 'y') call compute_gradient_G ( gradu_y , x_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) call compute_gradient_G ( gradv_y , y_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) call compute_gradient_G ( gradw_y , z_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) call compute_gradient_G ( gradT_y , Temp , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) if ( dims % kmx > 2 ) then call compute_gradient_G ( gradu_z , x_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) call compute_gradient_G ( gradv_z , y_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) call compute_gradient_G ( gradw_z , z_speed , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) !call compute_gradient_T(gradT_z         , cells, Ifaces, Jfaces, Kfaces, dims, 'z') call compute_gradient_G ( gradT_z , Temp , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) else gradqp_z = 0.0 end if select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) tv ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 6 ) call compute_gradient_G ( gradtv_x , tv , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtv_y , tv , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtv_z , tv , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) end if case ( 'sst' , 'sst2003' ) tk ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 6 ) tw ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 7 ) call compute_gradient_G ( gradtk_x , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtw_x , tw , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtk_y , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) call compute_gradient_G ( gradtw_y , tw , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtk_z , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) call compute_gradient_G ( gradtw_z , tw , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) end if case ( 'kkl' ) tk ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 6 ) tkl ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 7 ) call compute_gradient_G ( gradtk_x , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtkl_x , tkl , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtk_y , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) call compute_gradient_G ( gradtkl_y , tkl , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtk_z , tk , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) call compute_gradient_G ( gradtkl_z , tkl , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) end if case DEFAULT Fatal_error end select select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ) => qp (:, :, :, 8 ) call compute_gradient_G ( gradtgm_x , tgm , cells , Ifaces , Jfaces , Kfaces , dims , 'x' ) call compute_gradient_G ( gradtgm_y , tgm , cells , Ifaces , Jfaces , Kfaces , dims , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtgm_z , tgm , cells , Ifaces , Jfaces , Kfaces , dims , 'z' ) end if case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call apply_gradient_bc ( qp , temp , cells , Ifaces , Jfaces , Kfaces , bc , dims ) end subroutine evaluate_all_gradients","tags":"","loc":"proc/evaluate_all_gradients.html","title":"evaluate_all_gradients – FEST-3D"},{"text":"public subroutine compute_gradient_G(grad, var, cells, Ifaces, Jfaces, Kfaces, dims, dir) Compute gradient of any input scalar Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension( 0:dims%imx  , 0:dims%jmx  , 0:dims%kmx  ) :: grad Output variable storing the graident of var real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: var Input variable of which graident is required type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims character(len=*), intent(in) :: dir Direction with respect to which gradients are calculated Calls proc~~compute_gradient_g~~CallsGraph proc~compute_gradient_g compute_gradient_G debugcall debugcall proc~compute_gradient_g->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_gradient_g~~CalledByGraph proc~compute_gradient_g compute_gradient_G proc~evaluate_all_gradients evaluate_all_gradients proc~evaluate_all_gradients->proc~compute_gradient_g proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_gradient_gCalledByGraph = svgPanZoom('#proccompute_gradient_gCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_gradient_G Source Code subroutine compute_gradient_G ( grad , var , cells , Ifaces , Jfaces , Kfaces , dims , dir ) !<  Compute gradient of any input scalar implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( 0 : dims % imx , 0 : dims % jmx , 0 : dims % kmx ), intent ( out ) :: grad !< Output variable storing the graident of var real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: var !< Input variable of which graident is required character ( len =* ) , intent ( in ) :: dir !< Direction with respect to which gradients are calculated type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i integer :: j integer :: k DebugCall ( 'compute_gradient_G' ) grad (:,:,:) = 0.0 select case ( dir ) case ( 'x' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Ifaces ( i , j , k )% nx * Ifaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Jfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Kfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Ifaces ( i + 1 , j , k )% nx * Ifaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Jfaces ( i , j + 1 , k )% nx * Jfaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Kfaces ( i , j , k + 1 )% nx * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case ( 'y' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Ifaces ( i , j , k )% ny * Ifaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Jfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Kfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Ifaces ( i + 1 , j , k )% ny * Ifaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Jfaces ( i , j + 1 , k )% ny * Jfaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Kfaces ( i , j , k + 1 )% ny * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case ( 'z' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Ifaces ( i , j , k )% nz * Ifaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Jfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Kfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Ifaces ( i + 1 , j , k )% nz * Ifaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Jfaces ( i , j + 1 , k )% nz * Jfaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Kfaces ( i , j , k + 1 )% nz * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case DEFAULT print * , \"ERROR: gradient direction error\" Fatal_error end select if ( any ( isnan ( grad ))) then Fatal_error end if end subroutine compute_gradient_G","tags":"","loc":"proc/compute_gradient_g.html","title":"compute_gradient_G – FEST-3D"},{"text":"public subroutine apply_gradient_bc(qp, Temp, cells, Ifaces, Jfaces, Kfaces, bc, dims) Call same subroutine for all the face\n Apply/set value of all gradient in the ghost cells\n gradqp_G = (qp_I - qp_G) Area_W unit_normal_G/(volume_G)\n volume_G = volume_I Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2, 1:dims%n_var) :: qp Input variable of which graident is required real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2) :: Temp Intput Temperature variable type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~apply_gradient_bc~~CallsGraph proc~apply_gradient_bc apply_gradient_bc debugcall debugcall proc~apply_gradient_bc->debugcall proc~apply_gradient_bc_face apply_gradient_bc_face proc~apply_gradient_bc->proc~apply_gradient_bc_face Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~apply_gradient_bc~~CalledByGraph proc~apply_gradient_bc apply_gradient_bc proc~evaluate_all_gradients evaluate_all_gradients proc~evaluate_all_gradients->proc~apply_gradient_bc proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocapply_gradient_bcCalledByGraph = svgPanZoom('#procapply_gradient_bcCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_gradient_bc Source Code subroutine apply_gradient_bc ( qp , temp , cells , Ifaces , Jfaces , Kfaces , bc , dims ) !< Call same subroutine for all the face !< Apply/set value of all gradient in the ghost cells !< gradqp_G = (qp_I - qp_G)*Area_W*unit_normal_G/(volume_G) !< volume_G = volume_I !----------------------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Input variable of which graident is required real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Temp !< Intput Temperature variable type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal type ( boundarytype ), intent ( in ) :: bc type ( singlesub ) :: domain DebugCall ( 'apply_gradient_bc' ) domain % imin = 1 domain % imax = 1 domain % jmin = 1 domain % jmax = dims % jmx - 1 domain % kmin = 1 domain % kmax = dims % kmx - 1 domain % il = 1 ; domain % jl = 0 ; domain % kl = 0 domain % iu = 0 ; domain % ju = 0 ; domain % ku = 0 domain % sig = 1 call apply_gradient_bc_face ( qp , temp , cells , Ifaces , dims , domain , bc % imin_id , bc % fixed_wall_temperature ( 1 )) domain % imin = dims % imx domain % imax = dims % imx domain % jmin = 1 domain % jmax = dims % jmx - 1 domain % kmin = 1 domain % kmax = dims % kmx - 1 domain % il = 0 ; domain % jl = 0 ; domain % kl = 0 domain % iu = 1 ; domain % ju = 0 ; domain % ku = 0 domain % sig = - 1 call apply_gradient_bc_face ( qp , temp , cells , Ifaces , dims , domain , bc % imax_id , bc % fixed_wall_temperature ( 2 )) domain % imin = 1 domain % imax = dims % imx - 1 domain % jmin = 1 domain % jmax = 1 domain % kmin = 1 domain % kmax = dims % kmx - 1 domain % il = 0 ; domain % jl = 1 ; domain % kl = 0 domain % iu = 0 ; domain % ju = 0 ; domain % ku = 0 domain % sig = 1 call apply_gradient_bc_face ( qp , temp , cells , Jfaces , dims , domain , bc % jmin_id , bc % fixed_wall_temperature ( 3 )) domain % imin = 1 domain % imax = dims % imx - 1 domain % jmin = dims % jmx domain % jmax = dims % jmx domain % kmin = 1 domain % kmax = dims % kmx - 1 domain % il = 0 ; domain % jl = 0 ; domain % kl = 0 domain % iu = 0 ; domain % ju = 1 ; domain % ku = 0 domain % sig = - 1 call apply_gradient_bc_face ( qp , temp , cells , Jfaces , dims , domain , bc % jmax_id , bc % fixed_wall_temperature ( 4 )) domain % imin = 1 domain % imax = dims % imx - 1 domain % jmin = 1 domain % jmax = dims % jmx - 1 domain % kmin = 1 domain % kmax = 1 domain % il = 0 ; domain % jl = 0 ; domain % kl = 1 domain % iu = 0 ; domain % ju = 0 ; domain % ku = 0 domain % sig = 1 call apply_gradient_bc_face ( qp , temp , cells , Kfaces , dims , domain , bc % kmin_id , bc % fixed_wall_temperature ( 5 )) domain % imin = 1 domain % imax = dims % imx - 1 domain % jmin = 1 domain % jmax = dims % jmx - 1 domain % kmin = dims % kmx domain % kmax = dims % kmx domain % il = 0 ; domain % jl = 0 ; domain % kl = 0 domain % iu = 0 ; domain % ju = 0 ; domain % ku = 1 domain % sig = - 1 call apply_gradient_bc_face ( qp , temp , cells , Kfaces , dims , domain , bc % kmax_id , bc % fixed_wall_temperature ( 6 )) end subroutine apply_gradient_bc","tags":"","loc":"proc/apply_gradient_bc.html","title":"apply_gradient_bc – FEST-3D"},{"text":"public subroutine apply_gradient_bc_face(qp, Temp, cells, faces, dims, domain, bc_id, fixed_temp) Call same subroutine for all the face\n Apply/set value of all gradient in the ghost cells\n gradqp_G = (qp_I - qp_G) Area_W unit_normal_G/(volume_G)\n volume_G = volume_I Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2, 1:dims%n_var) :: qp Input variable of which graident is required real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2) :: Temp Intput Temperature variable type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: faces Input varaible which stores any(I,J,K) faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx type( singlesub ), intent(in) :: domain flags for direction integer, intent(in) :: bc_id real(kind=wp), intent(in) :: fixed_temp Called by proc~~apply_gradient_bc_face~~CalledByGraph proc~apply_gradient_bc_face apply_gradient_bc_face proc~apply_gradient_bc apply_gradient_bc proc~apply_gradient_bc->proc~apply_gradient_bc_face proc~evaluate_all_gradients evaluate_all_gradients proc~evaluate_all_gradients->proc~apply_gradient_bc proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocapply_gradient_bc_faceCalledByGraph = svgPanZoom('#procapply_gradient_bc_faceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_gradient_bc_face Source Code subroutine apply_gradient_bc_face ( qp , temp , cells , faces , dims , domain , bc_id , fixed_temp ) !< Call same subroutine for all the face !< Apply/set value of all gradient in the ghost cells !< gradqp_G = (qp_I - qp_G)*Area_W*unit_normal_G/(volume_G) !< volume_G = volume_I !----------------------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( singlesub ), intent ( in ) :: domain !< flags for direction real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Input variable of which graident is required real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Temp !< Intput Temperature variable type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: faces !< Input varaible which stores any(I,J,K) faces' area and unit normal integer , intent ( in ) :: bc_id real ( wp ), intent ( in ) :: fixed_temp real ( wp ), dimension ( n_grad ) :: qp_I real ( wp ), dimension ( n_grad ) :: qp_G real ( wp ) :: T_I real ( wp ) :: T_G real ( wp ) :: c_x real ( wp ) :: c_y real ( wp ) :: c_z integer :: i , j , k , l real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: dot integer :: il , jl , kl integer :: iu , ju , ku il = domain % il jl = domain % jl kl = domain % kl iu = domain % iu ju = domain % ju ku = domain % ku do k = domain % kmin , domain % kmax do j = domain % jmin , domain % jmax do i = domain % imin , domain % imax nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz c_x = faces ( i , j , k )% A * nx / cells ( i - iu , j - ju , k - ku )% volume c_y = faces ( i , j , k )% A * ny / cells ( i - iu , j - ju , k - ku )% volume c_z = faces ( i , j , k )% A * nz / cells ( i - iu , j - ju , k - ku )% volume T_I = Temp ( i - iu , j - ju , k - ku ) T_G = Temp ( i - il , j - jl , k - kl ) qp_I = qp ( i - iu , j - ju , k - ku , 2 : dims % n_var ) qp_G = qp ( i - il , j - jl , k - kl , 2 : dims % n_var ) ! normal component of gradient gradqp_x ( i - il , j - jl , k - kl ,:) = domain % sig * ( qp_I - qp_G ) * c_x gradqp_y ( i - il , j - jl , k - kl ,:) = domain % sig * ( qp_I - qp_G ) * c_y gradqp_z ( i - il , j - jl , k - kl ,:) = domain % sig * ( qp_I - qp_G ) * c_z gradqp_x ( i - il , j - jl , k - kl , 4 ) = domain % sig * ( T_I - T_G ) * c_x gradqp_y ( i - il , j - jl , k - kl , 4 ) = domain % sig * ( T_I - T_G ) * c_y gradqp_z ( i - il , j - jl , k - kl , 4 ) = domain % sig * ( T_I - T_G ) * c_z if ( bc_id ==- 5 . and . ( fixed_temp < 1. . and . fixed_temp >= 0. )) then gradqp_x ( i - il , j - jl , k - kl , 4 ) = - gradqp_x ( i - iu , j - ju , k - ku , 4 ) gradqp_y ( i - il , j - jl , k - kl , 4 ) = - gradqp_y ( i - iu , j - ju , k - ku , 4 ) gradqp_z ( i - il , j - jl , k - kl , 4 ) = - gradqp_z ( i - iu , j - ju , k - ku , 4 ) end if !parallel component of gradient do l = 1 , n_grad dot = ( gradqp_x ( i - iu , j - ju , k - ku , l ) * nx ) + ( gradqp_y ( i - iu , j - ju , k - ku , l ) * ny ) + ( gradqp_z ( i - iu , j - ju , k - ku , l ) * nz ) gradqp_x ( i - il , j - jl , k - kl , l ) = gradqp_x ( i - il , j - jl , k - kl , l ) + ( gradqp_x ( i - iu , j - ju , k - ku , l ) - dot * nx ) gradqp_y ( i - il , j - jl , k - kl , l ) = gradqp_y ( i - il , j - jl , k - kl , l ) + ( gradqp_y ( i - iu , j - ju , k - ku , l ) - dot * ny ) gradqp_z ( i - il , j - jl , k - kl , l ) = gradqp_z ( i - il , j - jl , k - kl , l ) + ( gradqp_z ( i - iu , j - ju , k - ku , l ) - dot * nz ) end do end do end do end do end subroutine apply_gradient_bc_face","tags":"","loc":"proc/apply_gradient_bc_face.html","title":"apply_gradient_bc_face – FEST-3D"},{"text":"private function write_time(time_in_seconds) result(string) Particular format to write time in output log file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: time_in_seconds Time to output Return Value character(len=64) Time as string in particlar format Called by proc~~write_time~~CalledByGraph proc~write_time write_time proc~destroy_time destroy_time proc~destroy_time->proc~write_time proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver program~main main program~main->proc~finish_run proc~abort_run abort_run proc~abort_run->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_time Source Code function write_time ( time_in_seconds ) result ( string ) !< Particular format to write time in output log file implicit none real ( wp ), intent ( in ) :: time_in_seconds !< Time to output character ( len = 64 ) :: string !< Time as string in particlar format if ( time_in_seconds > 86400 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 8640 0. , \"days\" elseif ( time_in_seconds > 3600 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 360 0. , \"Hr.\" elseif ( time_in_seconds > 60 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 6 0. , \"Min.\" elseif ( time_in_seconds > 0 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds , \"Sec.\" else write ( string , '(A)' ) \"Not Valid\" end if end function write_time","tags":"","loc":"proc/write_time.html","title":"write_time – FEST-3D"},{"text":"public subroutine setup_time(delta_t, control, dims) Allocate memeroy and setup initial clock Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:,:,:), allocatable :: delta_t Local time increment value at each cell center type( controltype ), intent(in) :: control Control parameters type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~setup_time~~CallsGraph proc~setup_time setup_time interface~alloc alloc proc~setup_time->interface~alloc debugcall debugcall proc~setup_time->debugcall proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_time~~CalledByGraph proc~setup_time setup_time proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_time Source Code subroutine setup_time ( delta_t , control , dims ) !< Allocate memeroy and setup initial clock implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension (:,:,:), allocatable , intent ( out ) :: delta_t !< Local time increment value at each cell center DebugCall ( 'initmisc' ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var call alloc ( delta_t , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , & errmsg = 'Error: Unable to allocate memory for delta_t.' ) CALL SYSTEM_CLOCK ( COUNT_RATE = nb_ticks_sec , COUNT_MAX = nb_ticks_max ) CALL SYSTEM_CLOCK ( COUNT = nb_ticks_initial ) CALL CPU_TIME ( t1 ) end subroutine setup_time","tags":"","loc":"proc/setup_time.html","title":"setup_time – FEST-3D"},{"text":"public subroutine destroy_time(control) Deallocate memory and find simulation time. Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters Calls proc~~destroy_time~~CallsGraph proc~destroy_time destroy_time mpi_gather mpi_gather proc~destroy_time->mpi_gather proc~write_time write_time proc~destroy_time->proc~write_time interface~alloc alloc proc~destroy_time->interface~alloc debugcall debugcall proc~destroy_time->debugcall proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_time~~CalledByGraph proc~destroy_time destroy_time proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver program~main main program~main->proc~finish_run proc~abort_run abort_run proc~abort_run->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_time Source Code subroutine destroy_time ( control ) !< Deallocate memory and find simulation time. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters real ( wp ), dimension (:), allocatable :: total_time !< Total time of executation for each block integer :: ierr !< error variable for mpi communication DebugCall ( 'deallocate_misc' ) !simlulation clock data if ( control % process_id == 0 ) write ( * , '(A)' ) '>> TIME <<' if ( control % process_id == 0 ) write ( * , '(A)' ) \"Simulation Clock : \" // trim ( write_time ( sim_clock )) call alloc ( total_time , 1 , control % total_process ) CALL CPU_TIME ( t2 ) CALL SYSTEM_CLOCK ( COUNT = nb_ticks_final ) nb_ticks = nb_ticks_final - nb_ticks_initial IF ( nb_ticks_final < nb_ticks_initial ) & nb_ticks = nb_ticks + nb_ticks_max elapsed_time = REAL ( nb_ticks ) / nb_ticks_sec cpu_time_elapsed = t2 - t1 write ( * , '(A,I0,A)' ) 'process: ' , control % process_id ,& \" > SYSTEM clock <: \" // trim ( write_time ( elapsed_time )) // & \" /-\\ CPU time <: \" // trim ( write_time ( cpu_time_elapsed )) !total time including all blocks call MPI_GATHER ( elapsed_time , 1 , MPI_DOUBLE_PRECISION , & total_time , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierr ) if ( control % process_id == 0 ) print * , \"Total SYSTEM clock: \" , trim ( write_time ( sum ( total_time ))) call MPI_GATHER ( cpu_time_elapsed , 1 , MPI_DOUBLE_PRECISION , & total_time , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierr ) if ( control % process_id == 0 ) print * , \"Total CPU time    : \" , trim ( write_time ( sum ( total_time ))) end subroutine destroy_time","tags":"","loc":"proc/destroy_time.html","title":"destroy_time – FEST-3D"},{"text":"private subroutine compute_local_time_step(qp, delta_t, cells, Ifaces, Jfaces, Kfaces, CFL, scheme, flow, dims) Compute the time step to be used at each cell center Local time stepping can be used to get the solution \n advance towards steady state faster. If only the steady\n state solution is required, i.e., transients are \n irrelevant, use local time stepping. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces real(kind=wp), intent(in) :: CFL CFL number type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_local_time_step~~CallsGraph proc~compute_local_time_step compute_local_time_step proc~add_viscous_time add_viscous_time proc~compute_local_time_step->proc~add_viscous_time debugcall debugcall proc~compute_local_time_step->debugcall proc~add_turbulent_time add_turbulent_time proc~compute_local_time_step->proc~add_turbulent_time proc~add_viscous_time->debugcall proc~add_turbulent_time->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_local_time_step~~CalledByGraph proc~compute_local_time_step compute_local_time_step proc~compute_global_time_step compute_global_time_step proc~compute_global_time_step->proc~compute_local_time_step proc~compute_time_step compute_time_step proc~compute_time_step->proc~compute_local_time_step proc~compute_time_step->proc~compute_global_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_local_time_stepCalledByGraph = svgPanZoom('#proccompute_local_time_stepCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_local_time_step Source Code subroutine compute_local_time_step ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , scheme , flow , dims ) !< Compute the time step to be used at each cell center !< !< Local time stepping can be used to get the solution !< advance towards steady state faster. If only the steady !< state solution is required, i.e., transients are !< irrelevant, use local time stepping. !----------------------------------------------------------- implicit none real ( wp ), intent ( in ) :: CFL !< CFL number type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ) :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum real ( wp ) :: x_sound_speed_avg , y_sound_speed_avg , z_sound_speed_avg integer :: i , j , k DebugCall ( 'compute_local_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! For orientation, refer to the report. The standard i,j,k ! direction are marked. All orientation notations are w.r.t ! to the perspective shown in the image. ! Faces with lower index x_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * x_qp_left ( i , j , k , 5 ) / & x_qp_left ( i , j , k , 1 )) + & sqrt ( flow % gm * x_qp_right ( i , j , k , 5 ) / & x_qp_right ( i , j , k , 1 )) ) y_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * y_qp_left ( i , j , k , 5 ) / & y_qp_left ( i , j , k , 1 )) + & sqrt ( flow % gm * y_qp_right ( i , j , k , 5 ) / & y_qp_right ( i , j , k , 1 )) ) z_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * z_qp_left ( i , j , k , 5 ) / & z_qp_left ( i , j , k , 1 )) + & sqrt ( flow % gm * z_qp_right ( i , j , k , 5 ) / & z_qp_right ( i , j , k , 1 )) ) ! For left face: i.e., lower index face along xi direction lmx1 = abs ( & ( qp ( i , j , k , 2 ) * Ifaces ( i , j , k )% nx ) + & ( qp ( i , j , k , 3 ) * Ifaces ( i , j , k )% ny ) + & ( qp ( i , j , k , 4 ) * Ifaces ( i , j , k )% nz )) + & x_sound_speed_avg ! For front face, i.e., lower index face along eta direction lmx2 = abs ( & ( qp ( i , j , k , 2 ) * Jfaces ( i , j , k )% nx ) + & ( qp ( i , j , k , 3 ) * Jfaces ( i , j , k )% ny ) + & ( qp ( i , j , k , 4 ) * Jfaces ( i , j , k )% nz )) + & y_sound_speed_avg ! For bottom face, i.e., lower index face along zeta direction lmx3 = abs ( & ( qp ( i , j , k , 2 ) * Kfaces ( i , j , k )% nx ) + & ( qp ( i , j , k , 3 ) * Kfaces ( i , j , k )% ny ) + & ( qp ( i , j , k , 4 ) * Kfaces ( i , j , k )% nz )) + & z_sound_speed_avg ! Faces with higher index x_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * x_qp_left ( i + 1 , j , k , 5 ) / x_qp_left ( i + 1 , j , k , 1 )) + & sqrt ( flow % gm * x_qp_right ( i + 1 , j , k , 5 ) / x_qp_right ( i + 1 , j , k , 1 )) ) y_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * y_qp_left ( i , j + 1 , k , 5 ) / y_qp_left ( i , j + 1 , k , 1 )) + & sqrt ( flow % gm * y_qp_right ( i , j + 1 , k , 5 ) / y_qp_right ( i , j + 1 , k , 1 )) ) z_sound_speed_avg = 0.5 * ( sqrt ( flow % gm * z_qp_left ( i , j , k + 1 , 5 ) / z_qp_left ( i , j , k + 1 , 1 )) + & sqrt ( flow % gm * z_qp_right ( i , j , k + 1 , 5 ) / z_qp_right ( i , j , k + 1 , 1 )) ) ! For right face, i.e., higher index face along xi direction lmx4 = abs ( & ( qp ( i + 1 , j , k , 2 ) * Ifaces ( i + 1 , j , k )% nx ) + & !x_speed*xnx ( qp ( i + 1 , j , k , 3 ) * Ifaces ( i + 1 , j , k )% ny ) + & !y_speed*xny ( qp ( i + 1 , j , k , 4 ) * Ifaces ( i + 1 , j , k )% nz )) + & !z_speed*xnz x_sound_speed_avg ! For back face, i.e., higher index face along eta direction lmx5 = abs ( & ( qp ( i , j + 1 , k , 2 ) * Jfaces ( i , j + 1 , k )% nx ) + & ( qp ( i , j + 1 , k , 3 ) * Jfaces ( i , j + 1 , k )% ny ) + & ( qp ( i , j + 1 , k , 4 ) * Jfaces ( i , j + 1 , k )% nz )) + & y_sound_speed_avg ! For top face, i.e., higher index face along zeta direction lmx6 = abs ( & ( qp ( i , j , k + 1 , 2 ) * Kfaces ( i , j , k + 1 )% nx ) + & ( qp ( i , j , k + 1 , 3 ) * Kfaces ( i , j , k + 1 )% ny ) + & ( qp ( i , j , k + 1 , 4 ) * Kfaces ( i , j , k + 1 )% nz )) + & z_sound_speed_avg lmxsum = ( Ifaces ( i , j , k )% A * lmx1 ) + & ( Jfaces ( i , j , k )% A * lmx2 ) + & ( Kfaces ( i , j , k )% A * lmx3 ) + & ( Ifaces ( i + 1 , j , k )% A * lmx4 ) + & ( Jfaces ( i , j + 1 , k )% A * lmx5 ) + & ( Kfaces ( i , j , k + 1 )% A * lmx6 ) delta_t ( i , j , k ) = 1. / lmxsum delta_t ( i , j , k ) = delta_t ( i , j , k ) * cells ( i , j , k )% volume * CFL end do end do end do if ( flow % mu_ref /= 0.0 ) then call add_viscous_time ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , flow , dims ) end if if ( flow % mu_ref /= 0 . and . trim ( scheme % turbulence ) /= 'none' ) then call add_turbulent_time ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , flow , dims ) end if end subroutine compute_local_time_step","tags":"","loc":"proc/compute_local_time_step.html","title":"compute_local_time_step – FEST-3D"},{"text":"private subroutine compute_global_time_step(qp, delta_t, cells, Ifaces, Jfaces, Kfaces, CFL, scheme, flow, dims) Compute a common time step to be used at all cell centers Global time stepping is generally used to get time \n accurate solutions; transients can be studied by \n employing this strategy. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces real(kind=wp), intent(in) :: CFL CFL number type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_global_time_step~~CallsGraph proc~compute_global_time_step compute_global_time_step proc~compute_local_time_step compute_local_time_step proc~compute_global_time_step->proc~compute_local_time_step debugcall debugcall proc~compute_global_time_step->debugcall proc~compute_local_time_step->debugcall proc~add_viscous_time add_viscous_time proc~compute_local_time_step->proc~add_viscous_time proc~add_turbulent_time add_turbulent_time proc~compute_local_time_step->proc~add_turbulent_time proc~add_viscous_time->debugcall proc~add_turbulent_time->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_global_time_step~~CalledByGraph proc~compute_global_time_step compute_global_time_step proc~compute_time_step compute_time_step proc~compute_time_step->proc~compute_global_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_global_time_stepCalledByGraph = svgPanZoom('#proccompute_global_time_stepCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_global_time_step Source Code subroutine compute_global_time_step ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , scheme , flow , dims ) !< Compute a common time step to be used at all cell centers !< !< Global time stepping is generally used to get time !< accurate solutions; transients can be studied by !< employing this strategy. !<----------------------------------------------------------- implicit none real ( wp ), intent ( in ) :: CFL !< CFL number type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces DebugCall ( 'compute_global_time_step' ) if ( scheme % global_time_step > 0 ) then delta_t = scheme % global_time_step else call compute_local_time_step ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , scheme , flow , dims ) ! The global time step is the minimum of all the local time ! steps. delta_t = minval ( delta_t ) end if end subroutine compute_global_time_step","tags":"","loc":"proc/compute_global_time_step.html","title":"compute_global_time_step – FEST-3D"},{"text":"public subroutine compute_time_step(qp, delta_t, CFL, cells, Ifaces, Jfaces, Kfaces, scheme, flow, dims) Compute the time step to be used This calls either compute_global_time_step() or \n compute_local_time_step() based on what \n time_stepping_method is set to. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center real(kind=wp), intent(in) :: CFL CFL number type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_time_step~~CallsGraph proc~compute_time_step compute_time_step proc~compute_local_time_step compute_local_time_step proc~compute_time_step->proc~compute_local_time_step proc~update_simulation_clock update_simulation_clock proc~compute_time_step->proc~update_simulation_clock debugcall debugcall proc~compute_time_step->debugcall proc~compute_global_time_step compute_global_time_step proc~compute_time_step->proc~compute_global_time_step proc~compute_local_time_step->debugcall proc~add_viscous_time add_viscous_time proc~compute_local_time_step->proc~add_viscous_time proc~add_turbulent_time add_turbulent_time proc~compute_local_time_step->proc~add_turbulent_time proc~compute_global_time_step->proc~compute_local_time_step proc~compute_global_time_step->debugcall proc~add_viscous_time->debugcall proc~add_turbulent_time->debugcall var panproccompute_time_stepCallsGraph = svgPanZoom('#proccompute_time_stepCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_time_step~~CalledByGraph proc~compute_time_step compute_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_time_step Source Code subroutine compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) !< Compute the time step to be used !< !< This calls either compute_global_time_step() or !< compute_local_time_step() based on what !< time_stepping_method is set to. !----------------------------------------------------------- implicit none real ( wp ), intent ( in ) :: CFL !< CFL number type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces DebugCall ( 'compute_time_step' ) if ( scheme % time_stepping_method . eq . 'g' ) then call compute_global_time_step ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , scheme , flow , dims ) else if ( scheme % time_stepping_method . eq . 'l' ) then call compute_local_time_step ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , scheme , flow , dims ) else print * , 'In compute_time_step: value for time_stepping_method (' // scheme % time_stepping_method // ') not recognized.' Fatal_error end if !update_simulation clock call update_simulation_clock ( delta_t , scheme , dims ) end subroutine compute_time_step","tags":"","loc":"proc/compute_time_step.html","title":"compute_time_step – FEST-3D"},{"text":"public subroutine update_simulation_clock(delta_t, scheme, dims) Update the simulation clock It is sometimes useful to know what the simulation time is\n  at every iteration so that a comparison with an analytical\n  solution is possible. Since, the global timesteps used may\n  not be uniform, we need to track this explicitly. Of course, it makes sense to track this only if the time \n  stepping is global and not local. If the time stepping is\n  local, the simulation clock is set to -1. If it is global\n  it is incremented according to the time step found. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( schemetype ), intent(in) :: scheme finite-volume Schemes: time stepping methods type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Called by proc~~update_simulation_clock~~CalledByGraph proc~update_simulation_clock update_simulation_clock proc~compute_time_step compute_time_step proc~compute_time_step->proc~update_simulation_clock proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_simulation_clockCalledByGraph = svgPanZoom('#procupdate_simulation_clockCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_simulation_clock Source Code subroutine update_simulation_clock ( delta_t , scheme , dims ) !<  Update the simulation clock !< !<  It is sometimes useful to know what the simulation time is !<  at every iteration so that a comparison with an analytical !<  solution is possible. Since, the global timesteps used may !<  not be uniform, we need to track this explicitly. !< !<  Of course, it makes sense to track this only if the time !<  stepping is global and not local. If the time stepping is !<  local, the simulation clock is set to -1. If it is global !<  it is incremented according to the time step found. !----------------------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes: time stepping methods real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center if ( scheme % time_stepping_method . eq . 'g' . and . sim_clock >= 0. ) then sim_clock = sim_clock + minval ( delta_t ) else if ( scheme % time_stepping_method . eq . 'l' ) then sim_clock = - 1 end if end subroutine update_simulation_clock","tags":"","loc":"proc/update_simulation_clock.html","title":"update_simulation_clock – FEST-3D"},{"text":"private subroutine add_viscous_time(qp, delta_t, cells, Ifaces, Jfaces, Kfaces, CFL, flow, dims) Addition to local time step due to viscous effects Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces real(kind=wp), intent(in) :: CFL CFL number type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~add_viscous_time~~CallsGraph proc~add_viscous_time add_viscous_time debugcall debugcall proc~add_viscous_time->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~add_viscous_time~~CalledByGraph proc~add_viscous_time add_viscous_time proc~compute_local_time_step compute_local_time_step proc~compute_local_time_step->proc~add_viscous_time proc~compute_global_time_step compute_global_time_step proc~compute_global_time_step->proc~compute_local_time_step proc~compute_time_step compute_time_step proc~compute_time_step->proc~compute_local_time_step proc~compute_time_step->proc~compute_global_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_viscous_timeCalledByGraph = svgPanZoom('#procadd_viscous_timeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_viscous_time Source Code subroutine add_viscous_time ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , flow , dims ) !< Addition to local time step due to viscous effects implicit none real ( wp ), intent ( in ) :: CFL !< CFL number type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ) :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum integer :: i , j , k DebugCall ( 'add_viscous_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! Faces with lower index ! For left face: i.e., lower index face along xi direction lmx1 = mu ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i - 1 , j , k )% centerx - cells ( i , j , k )% centerx ) * Ifaces ( i , j , k )% nx ) + & (( cells ( i - 1 , j , k )% centery - cells ( i , j , k )% centery ) * Ifaces ( i , j , k )% ny ) + & (( cells ( i - 1 , j , k )% centerz - cells ( i , j , k )% centerz ) * Ifaces ( i , j , k )% nz ))) ! For front face, i.e., lower index face along eta direction lmx2 = mu ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i , j - 1 , k )% centerx - cells ( i , j , k )% centerx ) * Jfaces ( i , j , k )% nx ) + & (( cells ( i , j - 1 , k )% centery - cells ( i , j , k )% centery ) * Jfaces ( i , j , k )% ny ) + & (( cells ( i , j - 1 , k )% centerz - cells ( i , j , k )% centerz ) * Jfaces ( i , j , k )% nz ))) ! For bottom face, i.e., lower index face along zeta direction lmx3 = mu ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i , j , k - 1 )% centerx - cells ( i , j , k )% centerx ) * Kfaces ( i , j , k )% nx ) + & (( cells ( i , j , k - 1 )% centery - cells ( i , j , k )% centery ) * Kfaces ( i , j , k )% ny ) + & (( cells ( i , j , k - 1 )% centerz - cells ( i , j , k )% centerz ) * Kfaces ( i , j , k )% nz ))) ! For right face, i.e., higher index face along xi direction lmx4 = mu ( i + 1 , j , k ) / ( qp ( i + 1 , j , k , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i + 1 , j , k )% centerx ) * Ifaces ( i + 1 , j , k )% nx ) + & (( cells ( i , j , k )% centery - cells ( i + 1 , j , k )% centery ) * Ifaces ( i + 1 , j , k )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i + 1 , j , k )% centerz ) * Ifaces ( i + 1 , j , k )% nz ))) ! For back face, i.e., higher index face along eta direction lmx5 = mu ( i , j + 1 , k ) / ( qp ( i , j + 1 , k , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i , j + 1 , k )% centerx ) * Jfaces ( i , j + 1 , k )% nx ) + & (( cells ( i , j , k )% centery - cells ( i , j + 1 , k )% centery ) * Jfaces ( i , j + 1 , k )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i , j + 1 , k )% centerz ) * Jfaces ( i , j + 1 , k )% nz ))) ! For top face, i.e., higher index face along zeta direction lmx6 = mu ( i , j , k + 1 ) / ( qp ( i , j , k + 1 , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i , j , k + 1 )% centerx ) * Kfaces ( i , j , k + 1 )% nx ) + & (( cells ( i , j , k )% centery - cells ( i , j , k + 1 )% centery ) * Kfaces ( i , j , k + 1 )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i , j , k + 1 )% centerz ) * Kfaces ( i , j , k + 1 )% nz ))) lmxsum = ( Ifaces ( i , j , k )% A * lmx1 ) + & ( Jfaces ( i , j , k )% A * lmx2 ) + & ( Kfaces ( i , j , k )% A * lmx3 ) + & ( Ifaces ( i + 1 , j , k )% A * lmx4 ) + & ( Jfaces ( i , j + 1 , k )% A * lmx5 ) + & ( Kfaces ( i , j , k + 1 )% A * lmx6 ) lmxsum = flow % gm * lmxsum / flow % Pr lmxsum = 2. / ( lmxsum + ( 2. * CFL * cells ( i , j , k )% volume / delta_t ( i , j , k ))) delta_t ( i , j , k ) = CFL * ( lmxsum * cells ( i , j , k )% volume ) end do end do end do end subroutine add_viscous_time","tags":"","loc":"proc/add_viscous_time.html","title":"add_viscous_time – FEST-3D"},{"text":"private subroutine add_turbulent_time(qp, delta_t, cells, Ifaces, Jfaces, Kfaces, CFL, flow, dims) Addition to local time step due to turbulence Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces real(kind=wp), intent(in) :: CFL CFL number type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~add_turbulent_time~~CallsGraph proc~add_turbulent_time add_turbulent_time debugcall debugcall proc~add_turbulent_time->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~add_turbulent_time~~CalledByGraph proc~add_turbulent_time add_turbulent_time proc~compute_local_time_step compute_local_time_step proc~compute_local_time_step->proc~add_turbulent_time proc~compute_global_time_step compute_global_time_step proc~compute_global_time_step->proc~compute_local_time_step proc~compute_time_step compute_time_step proc~compute_time_step->proc~compute_local_time_step proc~compute_time_step->proc~compute_global_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_turbulent_timeCalledByGraph = svgPanZoom('#procadd_turbulent_timeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_turbulent_time Source Code subroutine add_turbulent_time ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , CFL , flow , dims ) !< Addition to local time step due to turbulence implicit none real ( wp ), intent ( in ) :: CFL !< CFL number type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ) :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum integer :: i , j , k DebugCall ( 'add_viscous_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! Faces with lower index ! For left face: i.e., lower index face along xi direction lmx1 = mu_t ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i - 1 , j , k )% centerx - cells ( i , j , k )% centerx ) * Ifaces ( i , j , k )% nx ) + & (( cells ( i - 1 , j , k )% centery - cells ( i , j , k )% centery ) * Ifaces ( i , j , k )% ny ) + & (( cells ( i - 1 , j , k )% centerz - cells ( i , j , k )% centerz ) * Ifaces ( i , j , k )% nz ))) ! For front face, i.e., lower index face along eta direction lmx2 = mu_t ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i , j - 1 , k )% centerx - cells ( i , j , k )% centerx ) * Jfaces ( i , j , k )% nx ) + & (( cells ( i , j - 1 , k )% centery - cells ( i , j , k )% centery ) * Jfaces ( i , j , k )% ny ) + & (( cells ( i , j - 1 , k )% centerz - cells ( i , j , k )% centerz ) * Jfaces ( i , j , k )% nz ))) ! For bottom face, i.e., lower index face along zeta direction lmx3 = mu_t ( i , j , k ) / ( qp ( i , j , k , 1 ) * abs ( & (( cells ( i , j , k - 1 )% centerx - cells ( i , j , k )% centerx ) * Kfaces ( i , j , k )% nx ) + & (( cells ( i , j , k - 1 )% centery - cells ( i , j , k )% centery ) * Kfaces ( i , j , k )% ny ) + & (( cells ( i , j , k - 1 )% centerz - cells ( i , j , k )% centerz ) * Kfaces ( i , j , k )% nz ))) ! For right face, i.e., higher index face along xi direction lmx4 = mu_t ( i + 1 , j , k ) / ( qp ( i + 1 , j , k , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i + 1 , j , k )% centerx ) * Ifaces ( i + 1 , j , k )% nx ) + & (( cells ( i , j , k )% centery - cells ( i + 1 , j , k )% centery ) * Ifaces ( i + 1 , j , k )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i + 1 , j , k )% centerz ) * Ifaces ( i + 1 , j , k )% nz ))) ! For back face, i.e., higher index face along eta direction lmx5 = mu_t ( i , j + 1 , k ) / ( qp ( i , j + 1 , k , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i , j + 1 , k )% centerx ) * Jfaces ( i , j + 1 , k )% nx ) + & (( cells ( i , j , k )% centery - cells ( i , j + 1 , k )% centery ) * Jfaces ( i , j + 1 , k )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i , j + 1 , k )% centerz ) * Jfaces ( i , j + 1 , k )% nz ))) ! For top face, i.e., higher index face along zeta direction lmx6 = mu_t ( i , j , k + 1 ) / ( qp ( i , j , k + 1 , 1 ) * abs ( & (( cells ( i , j , k )% centerx - cells ( i , j , k + 1 )% centerx ) * Kfaces ( i , j , k + 1 )% nx ) + & (( cells ( i , j , k )% centery - cells ( i , j , k + 1 )% centery ) * Kfaces ( i , j , k + 1 )% ny ) + & (( cells ( i , j , k )% centerz - cells ( i , j , k + 1 )% centerz ) * Kfaces ( i , j , k + 1 )% nz ))) lmxsum = ( Ifaces ( i , j , k )% A * lmx1 ) + & ( Jfaces ( i , j , k )% A * lmx2 ) + & ( Kfaces ( i , j , k )% A * lmx3 ) + & ( Ifaces ( i + 1 , j , k )% A * lmx4 ) + & ( Jfaces ( i , j + 1 , k )% A * lmx5 ) + & ( Kfaces ( i , j , k + 1 )% A * lmx6 ) lmxsum = flow % gm * lmxsum / flow % tPr lmxsum = 2. / ( lmxsum + ( 2. * CFL * cells ( i , j , k )% volume / delta_t ( i , j , k ))) delta_t ( i , j , k ) = CFL * ( lmxsum * cells ( i , j , k )% volume ) end do end do end do end subroutine add_turbulent_time","tags":"","loc":"proc/add_turbulent_time.html","title":"add_turbulent_time – FEST-3D"},{"text":"private function sound_speed_inf(flow) result(a) Return the free stream speed of sound. Arguments Type Intent Optional Attributes Name type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. Return Value real(kind=wp) output variable: speed of sound Called by proc~~sound_speed_inf~~CalledByGraph proc~sound_speed_inf sound_speed_inf proc~init_infinity_values init_infinity_values proc~init_infinity_values->proc~sound_speed_inf proc~setup_state setup_state proc~setup_state->proc~init_infinity_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code sound_speed_inf Source Code function sound_speed_inf ( flow ) result ( a ) !< Return the free stream speed of sound. !----------------------------------------------------------- implicit none type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ) :: a !< output variable: speed of sound a = sqrt ( flow % gm * flow % pressure_inf / flow % density_inf ) end function sound_speed_inf","tags":"","loc":"proc/sound_speed_inf.html","title":"sound_speed_inf – FEST-3D"},{"text":"public subroutine setup_state(files, qp, control, scheme, flow, dims) Setup the state module.\n This subroutine should be run before the state variables\n are initilized. This subroutine allocates the memory for \n state variables and sets up the aliases to refer to the \n components of the state Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files Files' name and handler real(kind=wp), intent(inout), dimension(:,:,:,:), allocatable, target :: qp Store primitive variable at cell center type( controltype ), intent(inout) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(inout) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(inout) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~setup_state~~CallsGraph proc~setup_state setup_state aerrmsg aerrmsg proc~setup_state->aerrmsg proc~initstate initstate proc~setup_state->proc~initstate interface~alloc alloc proc~setup_state->interface~alloc proc~init_infinity_values init_infinity_values proc~setup_state->proc~init_infinity_values debugcall debugcall proc~setup_state->debugcall proc~set_n_var_value set_n_var_value proc~setup_state->proc~set_n_var_value proc~initstate->debugcall proc~verify_write_control verify_write_control proc~initstate->proc~verify_write_control proc~init_state_with_infinity_values init_state_with_infinity_values proc~initstate->proc~init_state_with_infinity_values proc~read_file~3 read_file proc~initstate->proc~read_file~3 proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~init_infinity_values->debugcall proc~sound_speed_inf sound_speed_inf proc~init_infinity_values->proc~sound_speed_inf proc~set_n_var_value->debugcall proc~lcase lcase proc~verify_write_control->proc~lcase proc~init_state_with_infinity_values->debugcall proc~verify_read_control verify_read_control proc~read_file~3->proc~verify_read_control read_file_tec read_file_tec proc~read_file~3->read_file_tec proc~open_file~2 open_file proc~read_file~3->proc~open_file~2 proc~read_restart_file read_restart_file proc~read_file~3->proc~read_restart_file proc~close_file~2 close_file proc~read_file~3->proc~close_file~2 read_file_vtk read_file_vtk proc~read_file~3->read_file_vtk proc~setup_file~3 setup_file proc~read_file~3->proc~setup_file~3 proc~verify_read_control->proc~lcase proc~open_file~2->debugcall proc~close_file~2->debugcall proc~setup_file~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_state~~CalledByGraph proc~setup_state setup_state proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_state Source Code subroutine setup_state ( files , qp , control , scheme , flow , dims ) !< Setup the state module. !< This subroutine should be run before the state variables !< are initilized. This subroutine allocates the memory for !< state variables and sets up the aliases to refer to the !< components of the state !----------------------------------------------------------- implicit none type ( filetype ), intent ( inout ) :: files !< Files' name and handler type ( controltype ), intent ( inout ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( inout ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( inout ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension (:,:,:,:), allocatable , intent ( inout ), target :: qp !< Store primitive variable at cell center DebugCall ( \"setup_state\" ) n_var = control % n_var imx = dims % imx jmx = dims % jmx kmx = dims % kmx call set_n_var_value ( control , scheme ) dims % n_var = control % n_var !call allocate_memory(qp) call alloc ( qp , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var , AErrMsg ( \"qp\" )) allocate ( control % previous_res ( 1 : control % n_var + 1 )) !call link_aliases(scheme) call init_infinity_values ( scheme , flow ) call initstate ( files , qp , control , scheme , flow , dims ) end subroutine setup_state","tags":"","loc":"proc/setup_state.html","title":"setup_state – FEST-3D"},{"text":"private subroutine init_infinity_values(scheme, flow) Set the values of the infinity variables \"qp_inf\" Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme finite-volume Schemes: turbulence, transition model, etc type( flowtype ), intent(inout) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. Calls proc~~init_infinity_values~~CallsGraph proc~init_infinity_values init_infinity_values proc~sound_speed_inf sound_speed_inf proc~init_infinity_values->proc~sound_speed_inf debugcall debugcall proc~init_infinity_values->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_infinity_values~~CalledByGraph proc~init_infinity_values init_infinity_values proc~setup_state setup_state proc~setup_state->proc~init_infinity_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_infinity_values Source Code subroutine init_infinity_values ( scheme , flow ) !< Set the values of the infinity variables \"qp_inf\" !----------------------------------------------------------- implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes: turbulence, transition model, etc type ( flowtype ), intent ( inout ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. DebugCall ( \"init_infinity_values\" ) flow % vel_mag = sqrt ( flow % x_speed_inf ** 2 + flow % y_speed_inf ** 2 + flow % z_speed_inf ** 2 ) flow % MInf = flow % vel_mag / sqrt ( flow % gm * flow % pressure_inf / flow % density_inf ) flow % Reynolds_number = flow % density_inf * flow % vel_mag * 1.0 / flow % mu_ref flow % Turb_intensity_inf = flow % tu_inf / 100 select case ( trim ( scheme % turbulence )) case ( \"none\" ) continue case ( \"sst\" , \"sst2003\" , \"bsl\" ) flow % tk_inf = 1.5 * (( flow % Vel_mag * flow % Turb_Intensity_inf ) ** 2 ) flow % tw_inf = flow % density_inf * flow % tk_inf / ( flow % mu_ref * flow % mu_ratio_inf ) case ( \"kkl\" ) flow % tk_inf = 9 * ( 1 e - 9 ) * ( sound_speed_inf ( flow ) ** 2 ) flow % tkl_inf = 1.5589 * ( 1 e - 6 ) * ( flow % mu_ref * sound_speed_inf ( flow )) / flow % density_inf case ( \"sa\" ) flow % tv_inf = flow % mu_ratio_inf * flow % mu_ref / flow % density_inf case ( \"saBC\" ) flow % tv_inf = 0.005 * flow % mu_ratio_inf * flow % mu_ref / flow % density_inf case ( \"kw\" ) flow % tk_inf = 1.5 * (( flow % Vel_mag * flow % Turb_Intensity_inf ) ** 2 ) flow % tw_inf = flow % density_inf * flow % tk_inf / ( flow % mu_ref * flow % mu_ratio_inf ) case ( \"ke\" ) flow % tk_inf = 1.5 * (( flow % Vel_mag * flow % Turb_Intensity_inf ) ** 2 ) flow % tw_inf = 0.09 * flow % density_inf * flow % tk_inf * flow % tk_inf / ( flow % mu_ref * flow % mu_ratio_inf ) case ( \"des-sst\" ) flow % tk_inf = 1.5 * (( flow % Vel_mag * flow % Turb_Intensity_inf ) ** 2 ) flow % tw_inf = flow % density_inf * flow % tk_inf / ( flow % mu_ref * flow % mu_ratio_inf ) case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select end subroutine init_infinity_values","tags":"","loc":"proc/init_infinity_values.html","title":"init_infinity_values – FEST-3D"},{"text":"private subroutine initstate(files, qp, control, scheme, flow, dims) Initialize the state.\n If load file(start_from) is 0, then the state should be \n set to the infinity values. Otherwise, read the state_file\n to get the state values Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files Files' name and handler real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center type( controltype ), intent(inout) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~initstate~~CallsGraph proc~initstate initstate proc~verify_write_control verify_write_control proc~initstate->proc~verify_write_control debugcall debugcall proc~initstate->debugcall proc~init_state_with_infinity_values init_state_with_infinity_values proc~initstate->proc~init_state_with_infinity_values proc~read_file~3 read_file proc~initstate->proc~read_file~3 proc~lcase lcase proc~verify_write_control->proc~lcase proc~init_state_with_infinity_values->debugcall proc~verify_read_control verify_read_control proc~read_file~3->proc~verify_read_control read_file_tec read_file_tec proc~read_file~3->read_file_tec proc~open_file~2 open_file proc~read_file~3->proc~open_file~2 proc~read_restart_file read_restart_file proc~read_file~3->proc~read_restart_file proc~close_file~2 close_file proc~read_file~3->proc~close_file~2 read_file_vtk read_file_vtk proc~read_file~3->read_file_vtk proc~setup_file~3 setup_file proc~read_file~3->proc~setup_file~3 proc~verify_read_control->proc~lcase proc~open_file~2->debugcall proc~close_file~2->debugcall proc~setup_file~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initstate~~CalledByGraph proc~initstate initstate proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initstate Source Code subroutine initstate ( files , qp , control , scheme , flow , dims ) !< Initialize the state. !< If load file(start_from) is 0, then the state should be !< set to the infinity values. Otherwise, read the state_file !< to get the state values !----------------------------------------------------------- implicit none type ( filetype ), intent ( inout ) :: files !< Files' name and handler type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( controltype ), intent ( inout ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: qp !< Store primitive variable at cell center DebugCall ( \"initstate\" ) call verify_write_control ( control , scheme , flow ) if ( control % start_from . eq . 0 ) then ! Set the state to the infinity values call init_state_with_infinity_values ( qp , scheme , flow , dims ) else write ( files % infile , '(a,i4.4,a,i2.2)' ) & \"time_directories/\" , control % start_from , \"/process_\" , process_id ! Set the state to the infinity values so if some ! variable are not restart variable they get free_stream value call init_state_with_infinity_values ( qp , scheme , flow , dims ) call read_file ( files , qp , control , scheme , dims ) end if end subroutine initstate","tags":"","loc":"proc/initstate.html","title":"initstate – FEST-3D"},{"text":"private subroutine init_state_with_infinity_values(qp, scheme, flow, dims) Initialize the state based on the infinity values Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~init_state_with_infinity_values~~CallsGraph proc~init_state_with_infinity_values init_state_with_infinity_values debugcall debugcall proc~init_state_with_infinity_values->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_state_with_infinity_values~~CalledByGraph proc~init_state_with_infinity_values init_state_with_infinity_values proc~initstate initstate proc~initstate->proc~init_state_with_infinity_values proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocinit_state_with_infinity_valuesCalledByGraph = svgPanZoom('#procinit_state_with_infinity_valuesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_state_with_infinity_values Source Code subroutine init_state_with_infinity_values ( qp , scheme , flow , dims ) !< Initialize the state based on the infinity values !----------------------------------------------------------- implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: qp !< Store primitive variable at cell center DebugCall ( \"init_state_with_infinity_values\" ) !density = density_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 ) = flow % density_inf !x_speed = x_speed_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 2 ) = flow % x_speed_inf !y_speed = y_speed_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 3 ) = flow % y_speed_inf !z_speed = z_speed_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 4 ) = flow % z_speed_inf !pressure = pressure_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 5 ) = flow % pressure_inf select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) !tk = tk_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 6 ) = flow % tk_inf !tw = tw_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 7 ) = flow % tw_inf case ( \"kkl\" ) !tk = tk_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 6 ) = flow % tk_inf !tkl = tkl_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 7 ) = flow % tkl_inf case ( \"sa\" , \"saBC\" ) !tv = tv_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 6 ) = flow % tv_inf case ( \"ke\" ) !tk = tk_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 6 ) = flow % tk_inf !te = te_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 7 ) = flow % te_inf case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) !tgm = tgm_inf qp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 8 ) = flow % tgm_inf case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine init_state_with_infinity_values","tags":"","loc":"proc/init_state_with_infinity_values.html","title":"init_state_with_infinity_values – FEST-3D"},{"text":"private subroutine set_n_var_value(control, scheme) Set number of variable to solver for based on\n the tubulence and transition model being used Arguments Type Intent Optional Attributes Name type( controltype ), intent(inout) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes Calls proc~~set_n_var_value~~CallsGraph proc~set_n_var_value set_n_var_value debugcall debugcall proc~set_n_var_value->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_n_var_value~~CalledByGraph proc~set_n_var_value set_n_var_value proc~setup_state setup_state proc~setup_state->proc~set_n_var_value proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_n_var_value Source Code subroutine set_n_var_value ( control , scheme ) !< Set number of variable to solver for based on !< the tubulence and transition model being used implicit none type ( controltype ), intent ( inout ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes DebugCall ( \"set_n_var_value\" ) select case ( trim ( scheme % turbulence )) case ( 'none' ) n_var = 5 case ( 'sa' , 'saBC' ) n_var = 6 case ( 'sst' , \"sst2003\" , 'bsl' , 'kw' , 'ke' , 'kkl' , 'Des-kw' ) n_var = 7 case DEFAULT n_var = 5 end select !Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) n_var = n_var + 1 case ( 'bc' , 'none' ) n_var = n_var + 0 case DEFAULT Fatal_error end Select control % n_var = n_var end subroutine set_n_var_value","tags":"","loc":"proc/set_n_var_value.html","title":"set_n_var_value – FEST-3D"},{"text":"public subroutine setupCC(scheme, cells, Ifaces, Jfaces, Kfaces, dims) Allocate memory for the cell center variable only in case of transition model Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Calls proc~~setupcc~~CallsGraph proc~setupcc setupCC interface~alloc alloc proc~setupcc->interface~alloc debugcall debugcall proc~setupcc->debugcall aerrmsg aerrmsg proc~setupcc->aerrmsg proc~find_ccnormal find_CCnormal proc~setupcc->proc~find_ccnormal proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~compute_gradient compute_gradient proc~find_ccnormal->proc~compute_gradient Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setupcc~~CalledByGraph proc~setupcc setupCC proc~setup_solver setup_solver proc~setup_solver->proc~setupcc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setupCC Source Code subroutine setupCC ( scheme , cells , Ifaces , Jfaces , Kfaces , dims ) !< Allocate memory for the cell center variable only in case of transition model implicit none type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal DebugCall ( \"Setup CC\" ) if (( scheme % transition == 'lctm2015' ) . and . scheme % turbulence /= 'none' ) then call alloc ( CCnormalX , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"CCnormalX\" )) call alloc ( CCnormalY , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"CCnormalY\" )) call alloc ( CCnormalZ , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"CCnormalZ\" )) call alloc ( CCVn , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"CCVn\" )) call alloc ( DCCVnX , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"DCCVnZ\" )) call alloc ( DCCVnY , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"DCCVnY\" )) call alloc ( DCCVnZ , - 2 , dims % imx + 2 , - 2 , dims % jmx + 2 , - 2 , dims % kmx + 2 , AErrMsg ( \"DCCVnZ\" )) call find_CCnormal ( cells , Ifaces , Jfaces , Kfaces , dims ) end if end subroutine setupCC","tags":"","loc":"proc/setupcc.html","title":"setupCC – FEST-3D"},{"text":"private subroutine find_CCnormal(cells, Ifaces, Jfaces, Kfaces, dims) Find the cell-center unit normal Arguments Type Intent Optional Attributes Name type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Calls proc~~find_ccnormal~~CallsGraph proc~find_ccnormal find_CCnormal proc~compute_gradient compute_gradient proc~find_ccnormal->proc~compute_gradient Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~find_ccnormal~~CalledByGraph proc~find_ccnormal find_CCnormal proc~setupcc setupCC proc~setupcc->proc~find_ccnormal proc~setup_solver setup_solver proc~setup_solver->proc~setupcc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_CCnormal Source Code subroutine find_CCnormal ( cells , Ifaces , Jfaces , Kfaces , dims ) !< Find the cell-center unit normal implicit none type ( extent ), intent ( in ) :: dims type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal call compute_gradient ( CCnormalX , dist , cells , Ifaces , Jfaces , Kfaces , 'x' , dims ) call compute_gradient ( CCnormalY , dist , cells , Ifaces , Jfaces , Kfaces , 'y' , dims ) call compute_gradient ( CCnormalZ , dist , cells , Ifaces , Jfaces , Kfaces , 'z' , dims ) !using already allocated memeory for storing magnitude CCVn = sqrt ( CCnormalX ** 2 + CCnormalY ** 2 + CCnormalZ ** 2 ) !CCVn hold the magnitude of CCnormal temporaraly and can be !overwritten after next three lines of code. CCnormalX = CCnormalX / ( CCVn + 1 e - 12 ) CCnormalY = CCnormalY / ( CCVn + 1 e - 12 ) CCnormalZ = CCnormalZ / ( CCVn + 1 e - 12 ) end subroutine find_CCnormal","tags":"","loc":"proc/find_ccnormal.html","title":"find_CCnormal – FEST-3D"},{"text":"private subroutine find_CCVn(qp, dims) Taking a dot product between Cell-center velocity and unit normal Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx,-2:dims%jmx,-2:dims%kmx,-2:dims%n_var) :: qp type( extent ), intent(in) :: dims Called by proc~~find_ccvn~~CalledByGraph proc~find_ccvn find_CCVn proc~find_dccvn find_DCCVn proc~find_dccvn->proc~find_ccvn proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_sst_source_lctm2015->proc~find_dccvn proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocfind_ccvnCalledByGraph = svgPanZoom('#procfind_ccvnCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_CCVn Source Code subroutine find_CCVn ( qp , dims ) !< Taking a dot product between Cell-center velocity and unit normal implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx , - 2 : dims % jmx , - 2 : dims % kmx , - 2 : dims % n_var ), intent ( in ) :: qp CCVn = CCnormalX * qp (:,:,:, 2 ) + CCnormalY * qp (:,:,:, 3 ) + CCnormalZ * qp (:,:,:, 4 ) ! (nx,ny,nz).(u,v,w) end subroutine find_CCVn","tags":"","loc":"proc/find_ccvn.html","title":"find_CCVn – FEST-3D"},{"text":"public subroutine find_DCCVn(qp, cells, Ifaces, Jfaces, Kfaces, dims) Find gradient of the dot product between cell velocity and unit normal Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx,-2:dims%jmx,-2:dims%kmx,-2:dims%n_var) :: qp type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Calls proc~~find_dccvn~~CallsGraph proc~find_dccvn find_DCCVn proc~compute_gradient compute_gradient proc~find_dccvn->proc~compute_gradient proc~find_ccvn find_CCVn proc~find_dccvn->proc~find_ccvn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~find_dccvn~~CalledByGraph proc~find_dccvn find_DCCVn proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_sst_source_lctm2015->proc~find_dccvn proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocfind_dccvnCalledByGraph = svgPanZoom('#procfind_dccvnCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_DCCVn Source Code subroutine find_DCCVn ( qp , cells , Ifaces , Jfaces , Kfaces , dims ) !< Find gradient of the dot product between cell velocity and unit normal implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx , - 2 : dims % jmx , - 2 : dims % kmx , - 2 : dims % n_var ), intent ( in ) :: qp type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal call find_CCVn ( qp , dims ) call compute_gradient ( DCCVnX , dist , cells , Ifaces , Jfaces , Kfaces , 'x' , dims ) call compute_gradient ( DCCVnY , dist , cells , Ifaces , Jfaces , Kfaces , 'y' , dims ) call compute_gradient ( DCCVnZ , dist , cells , Ifaces , Jfaces , Kfaces , 'z' , dims ) end subroutine find_DCCVn","tags":"","loc":"proc/find_dccvn.html","title":"find_DCCVn – FEST-3D"},{"text":"private subroutine compute_gradient(grad, var, cells, Ifaces, Jfaces, Kfaces, dir, dims) Generalized subroutine to calculate gradients Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: grad real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: var type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal character(len=*), intent(in) :: dir type( extent ), intent(in) :: dims Called by proc~~compute_gradient~~CalledByGraph proc~compute_gradient compute_gradient proc~find_ccnormal find_CCnormal proc~find_ccnormal->proc~compute_gradient proc~find_dccvn find_DCCVn proc~find_dccvn->proc~compute_gradient proc~setupcc setupCC proc~setupcc->proc~find_ccnormal proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_sst_source_lctm2015->proc~find_dccvn proc~setup_solver setup_solver proc~setup_solver->proc~setupcc proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run proc~iterate_one_more_time_step iterate_one_more_time_step program~main->proc~iterate_one_more_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step->proc~get_next_solution var panproccompute_gradientCalledByGraph = svgPanZoom('#proccompute_gradientCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_gradient Source Code subroutine compute_gradient ( grad , var , cells , Ifaces , Jfaces , Kfaces , dir , dims ) !< Generalized subroutine to calculate gradients implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( out ) :: grad real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: var character ( len =* ) , intent ( in ) :: dir type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i integer :: j integer :: k ! initialize grad = 0.0 select case ( dir ) case ( 'x' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Ifaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Ifaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Ifaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Ifaces ( i + 1 , j , k )% nx * Ifaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Ifaces ( i , j + 1 , k )% ny * Ifaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Ifaces ( i , j , k + 1 )% nz * Ifaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case ( 'y' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Jfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Jfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Jfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Jfaces ( i + 1 , j , k )% nx * Jfaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Jfaces ( i , j + 1 , k )% ny * Jfaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Jfaces ( i , j , k + 1 )% nz * Jfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case ( 'z' ) do k = 0 , dims % kmx do j = 0 , dims % jmx do i = 0 , dims % imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * Kfaces ( i , j , k )% nx * Kfaces ( i , j , k )% A & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * Kfaces ( i , j , k )% ny * Kfaces ( i , j , k )% A & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * Kfaces ( i , j , k )% nz * Kfaces ( i , j , k )% A & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * Kfaces ( i + 1 , j , k )% nx * Kfaces ( i + 1 , j , k )% A & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * Kfaces ( i , j + 1 , k )% ny * Kfaces ( i , j + 1 , k )% A & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * Kfaces ( i , j , k + 1 )% nz * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) end do end do end do case DEFAULT print * , \"ERROR: gradient direction error\" Fatal_error end select if ( any ( isnan ( grad ))) then Fatal_error end if end subroutine compute_gradient","tags":"","loc":"proc/compute_gradient.html","title":"compute_gradient – FEST-3D"},{"text":"public subroutine compute_viscous_fluxes(F, G, H, qp, cells, Ifaces, Jfaces, Kfaces, scheme, flow, dims) Call to all viscous flux subroutine based on \n the drection and turbulence/transition model being\n used Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F real(kind=wp), intent(inout), dimension(:, :, :, :) :: G real(kind=wp), intent(inout), dimension(:, :, :, :) :: H real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_viscous_fluxes~~CallsGraph proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes_kkl compute_viscous_fluxes_kkl proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_kkl proc~compute_viscous_fluxes_lctm2015 compute_viscous_fluxes_lctm2015 proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_lctm2015 proc~compute_viscous_fluxes_laminar compute_viscous_fluxes_laminar proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_laminar proc~compute_viscous_fluxes_sst compute_viscous_fluxes_sst proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_sst proc~compute_viscous_fluxes_sa compute_viscous_fluxes_sa proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_sa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_viscous_fluxes~~CalledByGraph proc~compute_viscous_fluxes compute_viscous_fluxes proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxesCalledByGraph = svgPanZoom('#proccompute_viscous_fluxesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes Source Code subroutine compute_viscous_fluxes ( F , G , H , qp , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) !< Call to all viscous flux subroutine based on !< the drection and turbulence/transition model being !< used implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F , G , H type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces integer , dimension ( 3 ) :: flagsi = ( / 1 , 0 , 0 / ) integer , dimension ( 3 ) :: flagsj = ( / 0 , 1 , 0 / ) integer , dimension ( 3 ) :: flagsk = ( / 0 , 0 , 1 / ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx call compute_viscous_fluxes_laminar ( F , qp , cells , Ifaces , flagsi , scheme , flow , dims ) call compute_viscous_fluxes_laminar ( G , qp , cells , Jfaces , flagsj , scheme , flow , dims ) call compute_viscous_fluxes_laminar ( H , qp , cells , Kfaces , flagsk , scheme , flow , dims ) select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call compute_viscous_fluxes_sa ( F , qp , cells , Ifaces , flagsi , dims ) call compute_viscous_fluxes_sa ( G , qp , cells , Jfaces , flagsj , dims ) call compute_viscous_fluxes_sa ( H , qp , cells , Kfaces , flagsk , dims ) case ( 'sst' , 'sst2003' ) call compute_viscous_fluxes_sst ( F , qp , cells , Ifaces , flagsi , dims ) call compute_viscous_fluxes_sst ( G , qp , cells , Jfaces , flagsj , dims ) if ( kmx == 2 ) then continue else call compute_viscous_fluxes_sst ( H , qp , cells , Kfaces , flagsk , dims ) end if case ( 'kkl' ) call compute_viscous_fluxes_kkl ( F , qp , cells , Ifaces , flagsi , dims ) call compute_viscous_fluxes_kkl ( G , qp , cells , Jfaces , flagsj , dims ) call compute_viscous_fluxes_kkl ( H , qp , cells , Kfaces , flagsk , dims ) case DEFAULT Fatal_error end select select case ( trim ( scheme % transition )) case ( 'lctm2015' ) call compute_viscous_fluxes_lctm2015 ( F , qp , cells , Ifaces , flagsi , dims ) call compute_viscous_fluxes_lctm2015 ( G , qp , cells , Jfaces , flagsj , dims ) if ( kmx == 2 ) then continue else call compute_viscous_fluxes_lctm2015 ( H , qp , cells , Kfaces , flagsk , dims ) end if case ( 'none' , 'bc' ) !do nothing continue case DEFAULT Fatal_error end select if ( any ( isnan ( G ))) then Fatal_error end if if ( any ( isnan ( F ))) then Fatal_error end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_viscous_fluxes","tags":"","loc":"proc/compute_viscous_fluxes.html","title":"compute_viscous_fluxes – FEST-3D"},{"text":"private subroutine compute_viscous_fluxes_laminar(F, qp, cells, faces, flags, scheme, flow, dims) Compute viscous fluxes for first five Navier-Stokes equation Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Flux array real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Called by proc~~compute_viscous_fluxes_laminar~~CalledByGraph proc~compute_viscous_fluxes_laminar compute_viscous_fluxes_laminar proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_laminar proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxes_laminarCalledByGraph = svgPanZoom('#proccompute_viscous_fluxes_laminarCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes_laminar Source Code subroutine compute_viscous_fluxes_laminar ( F , qp , cells , faces , flags , scheme , flow , dims ) !< Compute viscous fluxes for first five Navier-Stokes equation implicit none real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Flux array type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal ! local variables real ( wp ) :: dudx , dudy , dudz real ( wp ) :: dvdx , dvdy , dvdz real ( wp ) :: dwdx , dwdy , dwdz real ( wp ) :: dTdx , dTdy , dTdz real ( wp ) :: normal_comp real ( wp ) :: d_LR real ( wp ) :: T_RE real ( wp ) :: T_LE real ( wp ) :: K_heat , Qx , Qy , Qz real ( wp ) :: mu_f real ( wp ) :: mut_f real ( wp ) :: total_mu real ( wp ) :: delx real ( wp ) :: dely real ( wp ) :: delz real ( wp ) :: delu real ( wp ) :: delv real ( wp ) :: delw real ( wp ) :: delT real ( wp ) :: Tau_xx real ( wp ) :: Tau_xy real ( wp ) :: Tau_xz real ( wp ) :: Tau_yx real ( wp ) :: Tau_yy real ( wp ) :: Tau_yz real ( wp ) :: Tau_zx real ( wp ) :: Tau_zy real ( wp ) :: Tau_zz real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: area real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface integer :: i , j , k integer :: ii , jj , kk ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) !--------------------------------------------------------------------- ! Calculating the fluxes at the faces !-------------------------------------------------------------------- do k = 1 , dims % kmx - 1 + kk do j = 1 , dims % jmx - 1 + jj do i = 1 , dims % imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dudx = 0.5 * ( gradu_x ( i - ii , j - jj , k - kk ) + gradu_x ( i , j , k )) dudy = 0.5 * ( gradu_y ( i - ii , j - jj , k - kk ) + gradu_y ( i , j , k )) dudz = 0.5 * ( gradu_z ( i - ii , j - jj , k - kk ) + gradu_z ( i , j , k )) dvdx = 0.5 * ( gradv_x ( i - ii , j - jj , k - kk ) + gradv_x ( i , j , k )) dvdy = 0.5 * ( gradv_y ( i - ii , j - jj , k - kk ) + gradv_y ( i , j , k )) dvdz = 0.5 * ( gradv_z ( i - ii , j - jj , k - kk ) + gradv_z ( i , j , k )) dwdx = 0.5 * ( gradw_x ( i - ii , j - jj , k - kk ) + gradw_x ( i , j , k )) dwdy = 0.5 * ( gradw_y ( i - ii , j - jj , k - kk ) + gradw_y ( i , j , k )) dwdz = 0.5 * ( gradw_z ( i - ii , j - jj , k - kk ) + gradw_z ( i , j , k )) dTdx = 0.5 * ( gradT_x ( i - ii , j - jj , k - kk ) + gradT_x ( i , j , k )) dTdy = 0.5 * ( gradT_y ( i - ii , j - jj , k - kk ) + gradT_y ( i , j , k )) dTdz = 0.5 * ( gradT_z ( i - ii , j - jj , k - kk ) + gradT_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = cells ( i , j , k )% centerx - cells ( i - ii , j - jj , k - kk )% centerx dely = cells ( i , j , k )% centery - cells ( i - ii , j - jj , k - kk )% centery delz = cells ( i , j , k )% centerz - cells ( i - ii , j - jj , k - kk )% centerz d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! Finding the temperature of left and right element to the face i,j,k T_LE = qp ( i - ii , j - jj , k - kk , 5 ) / ( qp ( i - ii , j - jj , k - kk , 1 ) * flow % R_gas ) T_RE = qp ( i , j , k , 5 ) / ( qp ( i , j , k , 1 ) * flow % R_gas ) ! difference in state across face delu = qp ( i , j , k , 2 ) - qp ( i - ii , j - jj , k - kk , 2 ) !x_speed delv = qp ( i , j , k , 3 ) - qp ( i - ii , j - jj , k - kk , 3 ) !y_speed delw = qp ( i , j , k , 4 ) - qp ( i - ii , j - jj , k - kk , 4 ) !z_speed delT = T_RE - T_LE !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( delu - ( dudx * delx + dudy * dely + dudz * delz )) / d_LR dudx = dudx + ( normal_comp * delx / d_LR ) dudy = dudy + ( normal_comp * dely / d_LR ) dudz = dudz + ( normal_comp * delz / d_LR ) normal_comp = ( delv - ( dvdx * delx + dvdy * dely + dvdz * delz )) / d_LR dvdx = dvdx + ( normal_comp * delx / d_LR ) dvdy = dvdy + ( normal_comp * dely / d_LR ) dvdz = dvdz + ( normal_comp * delz / d_LR ) normal_comp = ( delw - ( dwdx * delx + dwdy * dely + dwdz * delz )) / d_LR dwdx = dwdx + ( normal_comp * delx / d_LR ) dwdy = dwdy + ( normal_comp * dely / d_LR ) dwdz = dwdz + ( normal_comp * delz / d_LR ) normal_comp = ( delT - ( dTdx * delx + dTdy * dely + dTdz * delz )) / d_LR dTdx = dTdx + ( normal_comp * delx / d_LR ) dTdy = dTdy + ( normal_comp * dely / d_LR ) dTdz = dTdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) if ( trim ( scheme % turbulence ) /= 'none' ) then mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) else mut_f = 0.0 end if ! effective viscosity total_mu = mu_f + mut_f ! Using lambda = -2 * mu / 3 ! diagonal terms of stress tensor Tau_xx = 2. * total_mu * ( dudx - (( dudx + dvdy + dwdz ) / 3. )) Tau_yy = 2. * total_mu * ( dvdy - (( dudx + dvdy + dwdz ) / 3. )) Tau_zz = 2. * total_mu * ( dwdz - (( dudx + dvdy + dwdz ) / 3. )) ! off diagonal symmetrical part of stress tensor Tau_xy = total_mu * ( dvdx + dudy ) Tau_xz = total_mu * ( dwdx + dudz ) Tau_yz = total_mu * ( dwdy + dvdz ) Tau_yx = Tau_xy Tau_zx = Tau_xz Tau_zy = Tau_yz ! Pr: Prandtl Number and tPr: Turbulent Prandtl number ! Qx, Qy, Qz: Conduction fluxes K_heat = ( mu_f / flow % Pr + mut_f / flow % tPr ) * flow % gm * flow % R_gas / ( flow % gm - 1 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz ! calling some element from memory and keep them handy for calculation nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz area = faces ( i , j , k )% A uface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 2 ) + qp ( i , j , k , 2 )) vface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 3 ) + qp ( i , j , k , 3 )) wface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 4 ) + qp ( i , j , k , 4 )) ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - (( Tau_xx * nx + Tau_xy * ny + Tau_xz * nz ) * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - (( Tau_yx * nx + Tau_yy * ny + Tau_yz * nz ) * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - (( Tau_zx * nx + Tau_zy * ny + Tau_zz * nz ) * area ) ! Energy flux ! (TijVj + Qi)ni F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * ( & (( Tau_xx * uface + Tau_xy * vface + Tau_xz * wface + Qx ) * nx ) + & (( Tau_yx * uface + Tau_yy * vface + Tau_yz * wface + Qy ) * ny ) + & (( Tau_zx * uface + Tau_zy * vface + Tau_zz * wface + Qz ) * nz ) ) ) end do end do end do end subroutine compute_viscous_fluxes_laminar","tags":"","loc":"proc/compute_viscous_fluxes_laminar.html","title":"compute_viscous_fluxes_laminar – FEST-3D"},{"text":"private subroutine compute_viscous_fluxes_sst(F, qp, cells, faces, flags, dims) Compute viscous fluxes for additianal equations due to SST turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F flux array real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces quantities on the face integer, intent(in), dimension(3) :: flags flags for direction swithc type( extent ), intent(in) :: dims Extent of the domain: imx,jmx,kmx Called by proc~~compute_viscous_fluxes_sst~~CalledByGraph proc~compute_viscous_fluxes_sst compute_viscous_fluxes_sst proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_sst proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxes_sstCalledByGraph = svgPanZoom('#proccompute_viscous_fluxes_sstCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes_sst Source Code subroutine compute_viscous_fluxes_sst ( F , qp , cells , faces , flags , dims ) !< Compute viscous fluxes for additianal equations due to SST turbulence model implicit none real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< flux array type ( extent ), intent ( in ) :: dims !< Extent of the domain: imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction swithc real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< quantities on the face ! local variables real ( wp ) :: tkface real ( wp ) :: rhoface real ( wp ) :: normal_comp real ( wp ) :: d_LR real ( wp ) :: mu_f real ( wp ) :: mut_f real ( wp ) :: total_mu real ( wp ) :: delx real ( wp ) :: dely real ( wp ) :: delz real ( wp ) :: deltk real ( wp ) :: deltw real ( wp ) :: Tau_xx real ( wp ) :: Tau_yy real ( wp ) :: Tau_zz real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: area integer :: i , j , k integer :: ii , jj , kk !--- sst variable requirement ---! real ( wp ) :: dtkdx , dtkdy , dtkdz , dtwdx , dtwdy , dtwdz real ( wp ) :: F1 real ( wp ) :: sigma_kf real ( wp ) :: sigma_wf ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , dims % kmx - 1 + kk do j = 1 , dims % jmx - 1 + jj do i = 1 , dims % imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtkdx = 0.5 * ( gradtk_x ( i - ii , j - jj , k - kk ) + gradtk_x ( i , j , k )) dtkdy = 0.5 * ( gradtk_y ( i - ii , j - jj , k - kk ) + gradtk_y ( i , j , k )) dtkdz = 0.5 * ( gradtk_z ( i - ii , j - jj , k - kk ) + gradtk_z ( i , j , k )) dtwdx = 0.5 * ( gradtw_x ( i - ii , j - jj , k - kk ) + gradtw_x ( i , j , k )) dtwdy = 0.5 * ( gradtw_y ( i - ii , j - jj , k - kk ) + gradtw_y ( i , j , k )) dtwdz = 0.5 * ( gradtw_z ( i - ii , j - jj , k - kk ) + gradtw_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = cells ( i , j , k )% centerx - cells ( i - ii , j - jj , k - kk )% centerx dely = cells ( i , j , k )% centery - cells ( i - ii , j - jj , k - kk )% centery delz = cells ( i , j , k )% centerz - cells ( i - ii , j - jj , k - kk )% centerz d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltk = qp ( i , j , k , 6 ) - qp ( i - ii , j - jj , k - kk , 6 ) !TKE deltw = qp ( i , j , k , 7 ) - qp ( i - ii , j - jj , k - kk , 7 ) !Omega !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltk - ( dtkdx * delx + dtkdy * dely + dtkdz * delz )) / d_LR dtkdx = dtkdx + ( normal_comp * delx / d_LR ) dtkdy = dtkdy + ( normal_comp * dely / d_LR ) dtkdz = dtkdz + ( normal_comp * delz / d_LR ) normal_comp = ( deltw - ( dtwdx * delx + dtwdy * dely + dtwdz * delz )) / d_LR dtwdx = dtwdx + ( normal_comp * delx / d_LR ) dtwdy = dtwdy + ( normal_comp * dely / d_LR ) dtwdz = dtwdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) F1 = 0.5 * ( sst_F1 ( i - ii , j - jj , k - kk ) + sst_F1 ( i , j , k )) sigma_kf = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_wf = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) total_mu = mu_f + mut_f rhoface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 1 ) + qp ( i , j , k , 1 )) !Density tkface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 6 ) + qp ( i , j , k , 6 )) !TKE ! k in reynolds stress Tau_xx = - 2.0 * rhoface * tkface / 3.0 Tau_yy = Tau_xx Tau_zz = Tau_xx ! calling some element from memory and keep them handy for calculation nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz area = faces ( i , j , k )% A ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - ( Tau_xx * nx * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - ( Tau_yy * ny * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - ( Tau_zz * nz * area ) F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * (( mu_f + sigma_kf * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + sigma_kf * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 7 ) = F ( i , j , k , 7 ) - ( area * (( mu_f + sigma_wf * mut_f ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_sst","tags":"","loc":"proc/compute_viscous_fluxes_sst.html","title":"compute_viscous_fluxes_sst – FEST-3D"},{"text":"private subroutine compute_viscous_fluxes_kkl(F, qp, cells, faces, flags, dims) Compute viscous fluxes for additianal equations due to k-kL turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Flux array real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for directions switch type( extent ), intent(in) :: dims Extent of the domain: imx,jmx,kmx Called by proc~~compute_viscous_fluxes_kkl~~CalledByGraph proc~compute_viscous_fluxes_kkl compute_viscous_fluxes_kkl proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_kkl proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxes_kklCalledByGraph = svgPanZoom('#proccompute_viscous_fluxes_kklCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes_kkl Source Code subroutine compute_viscous_fluxes_kkl ( F , qp , cells , faces , flags , dims ) !< Compute viscous fluxes for additianal equations due to k-kL turbulence model implicit none real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Flux array type ( extent ), intent ( in ) :: dims !< Extent of the domain: imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for directions switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal ! local variables real ( wp ) :: tkface real ( wp ) :: rhoface real ( wp ) :: normal_comp real ( wp ) :: d_LR real ( wp ) :: mu_f real ( wp ) :: mut_f real ( wp ) :: total_mu real ( wp ) :: delx real ( wp ) :: dely real ( wp ) :: delz real ( wp ) :: deltk real ( wp ) :: deltkl real ( wp ) :: Tau_xx real ( wp ) :: Tau_yy real ( wp ) :: Tau_zz real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: area integer :: i , j , k integer :: ii , jj , kk !--- kkl variable requirement  ---! real ( wp ) :: dtkdx , dtkdy , dtkdz real ( wp ) :: dtkldx , dtkldy , dtkldz ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , dims % kmx - 1 + kk do j = 1 , dims % jmx - 1 + jj do i = 1 , dims % imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtkdx = 0.5 * ( gradtk_x ( i - ii , j - jj , k - kk ) + gradtk_x ( i , j , k )) dtkdy = 0.5 * ( gradtk_y ( i - ii , j - jj , k - kk ) + gradtk_y ( i , j , k )) dtkdz = 0.5 * ( gradtk_z ( i - ii , j - jj , k - kk ) + gradtk_z ( i , j , k )) dtkldx = 0.5 * ( gradtkl_x ( i - ii , j - jj , k - kk ) + gradtkl_x ( i , j , k )) dtkldy = 0.5 * ( gradtkl_y ( i - ii , j - jj , k - kk ) + gradtkl_y ( i , j , k )) dtkldz = 0.5 * ( gradtkl_z ( i - ii , j - jj , k - kk ) + gradtkl_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = cells ( i , j , k )% centerx - cells ( i - ii , j - jj , k - kk )% centerx dely = cells ( i , j , k )% centery - cells ( i - ii , j - jj , k - kk )% centery delz = cells ( i , j , k )% centerz - cells ( i - ii , j - jj , k - kk )% centerz d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltk = qp ( i , j , k , 6 ) - qp ( i - ii , j - jj , k - kk , 6 ) !TKE deltkl = qp ( i , j , k , 7 ) - qp ( i - ii , j - jj , k - kk , 7 ) !Kl !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltk - ( dtkdx * delx + dtkdy * dely + dtkdz * delz )) / d_LR dtkdx = dtkdx + ( normal_comp * delx / d_LR ) dtkdy = dtkdy + ( normal_comp * dely / d_LR ) dtkdz = dtkdz + ( normal_comp * delz / d_LR ) normal_comp = ( deltkl - ( dtkldx * delx + dtkldy * dely + dtkldz * delz )) / d_LR dtkldx = dtkldx + ( normal_comp * delx / d_LR ) dtkldy = dtkldy + ( normal_comp * dely / d_LR ) dtkldz = dtkldz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) total_mu = mu_f + mut_f rhoface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 1 ) + qp ( i , j , k , 1 )) tkface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 6 ) + qp ( i , j , k , 6 )) ! k in reynolds stress Tau_xx = - 2.0 * rhoface * tkface / 3.0 Tau_yy = Tau_xx Tau_zz = Tau_xx ! calling some element from memory and keep them handy for calculation nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz area = faces ( i , j , k )% A ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - ( Tau_xx * nx * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - ( Tau_yy * ny * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - ( Tau_zz * nz * area ) F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * (( mu_f + sigma_k * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + sigma_k * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 7 ) = F ( i , j , k , 7 ) - ( area * (( mu_f + sigma_phi * mut_f ) * ( dtkldx * nx + dtkldy * ny + dtkldz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_kkl","tags":"","loc":"proc/compute_viscous_fluxes_kkl.html","title":"compute_viscous_fluxes_kkl – FEST-3D"},{"text":"private subroutine compute_viscous_fluxes_sa(F, qp, cells, faces, flags, dims) Compute viscous fluxes for additianal equations due to SA turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Flux array real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( extent ), intent(in) :: dims Extent of the domain: imx,jmx,kmx Called by proc~~compute_viscous_fluxes_sa~~CalledByGraph proc~compute_viscous_fluxes_sa compute_viscous_fluxes_sa proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_sa proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxes_saCalledByGraph = svgPanZoom('#proccompute_viscous_fluxes_saCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes_sa Source Code subroutine compute_viscous_fluxes_sa ( F , qp , cells , faces , flags , dims ) !< Compute viscous fluxes for additianal equations due to SA turbulence model implicit none real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Flux array type ( extent ), intent ( in ) :: dims !< Extent of the domain: imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal ! local variables real ( wp ) :: rhoface real ( wp ) :: normal_comp real ( wp ) :: d_LR real ( wp ) :: mu_f real ( wp ) :: mut_f real ( wp ) :: delx real ( wp ) :: dely real ( wp ) :: delz real ( wp ) :: deltv real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: area integer :: i , j , k integer :: ii , jj , kk !--- sa variable requirement ---! real ( wp ) :: dtvdx , dtvdy , dtvdz ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , dims % kmx - 1 + kk do j = 1 , dims % jmx - 1 + jj do i = 1 , dims % imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtvdx = 0.5 * ( gradtv_x ( i - ii , j - jj , k - kk ) + gradtv_x ( i , j , k )) dtvdy = 0.5 * ( gradtv_y ( i - ii , j - jj , k - kk ) + gradtv_y ( i , j , k )) dtvdz = 0.5 * ( gradtv_z ( i - ii , j - jj , k - kk ) + gradtv_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = cells ( i , j , k )% centerx - cells ( i - ii , j - jj , k - kk )% centerx dely = cells ( i , j , k )% centery - cells ( i - ii , j - jj , k - kk )% centery delz = cells ( i , j , k )% centerz - cells ( i - ii , j - jj , k - kk )% centerz d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltv = qp ( i , j , k , 6 ) - qp ( i - ii , j - jj , k - kk , 6 ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltv - ( dtvdx * delx + dtvdy * dely + dtvdz * delz )) / d_LR dtvdx = dtvdx + ( normal_comp * delx / d_LR ) dtvdy = dtvdy + ( normal_comp * dely / d_LR ) dtvdz = dtvdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! rhoface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 1 ) + qp ( i , j , k , 1 )) mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( qp ( i - ii , j - jj , k - kk , 6 ) + qp ( i , j , k , 6 )) * rhoface ! calling some element from memory and keep them handy for calculation nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz area = faces ( i , j , k )% A ! adding viscous fluxes to stored convective flux F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + mut_f ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ))) / sigma_sa end do end do end do end subroutine compute_viscous_fluxes_sa","tags":"","loc":"proc/compute_viscous_fluxes_sa.html","title":"compute_viscous_fluxes_sa – FEST-3D"},{"text":"private subroutine compute_viscous_fluxes_lctm2015(F, qp, cells, faces, flags, dims) Compute viscous fluxes for additianal equations due to LCTM2015 transition model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Flux array real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( extent ), intent(in) :: dims Extent of the doamin:imx,jmx,kmx Called by proc~~compute_viscous_fluxes_lctm2015~~CalledByGraph proc~compute_viscous_fluxes_lctm2015 compute_viscous_fluxes_lctm2015 proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_lctm2015 proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxes_lctm2015CalledByGraph = svgPanZoom('#proccompute_viscous_fluxes_lctm2015CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes_lctm2015 Source Code subroutine compute_viscous_fluxes_lctm2015 ( F , qp , cells , faces , flags , dims ) !< Compute viscous fluxes for additianal equations due to LCTM2015 transition model implicit none real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Flux array type ( extent ), intent ( in ) :: dims !< Extent of the doamin:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !<flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal ! local variables real ( wp ) :: rhoface real ( wp ) :: normal_comp real ( wp ) :: d_LR real ( wp ) :: mu_f real ( wp ) :: mut_f real ( wp ) :: delx real ( wp ) :: dely real ( wp ) :: delz real ( wp ) :: deltgm real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: area integer :: i , j , k integer :: ii , jj , kk !--- sa variable requirement ---! real ( wp ) :: dtgmdx , dtgmdy , dtgmdz ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , dims % kmx - 1 + kk do j = 1 , dims % jmx - 1 + jj do i = 1 , dims % imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtgmdx = 0.5 * ( gradtgm_x ( i - ii , j - jj , k - kk ) + gradtgm_x ( i , j , k )) dtgmdy = 0.5 * ( gradtgm_y ( i - ii , j - jj , k - kk ) + gradtgm_y ( i , j , k )) dtgmdz = 0.5 * ( gradtgm_z ( i - ii , j - jj , k - kk ) + gradtgm_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = cells ( i , j , k )% centerx - cells ( i - ii , j - jj , k - kk )% centerx dely = cells ( i , j , k )% centery - cells ( i - ii , j - jj , k - kk )% centery delz = cells ( i , j , k )% centerz - cells ( i - ii , j - jj , k - kk )% centerz d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltgm = qp ( i , j , k , 8 ) - qp ( i - ii , j - jj , k - kk , 8 ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltgm - ( dtgmdx * delx + dtgmdy * dely + dtgmdz * delz )) / d_LR dtgmdx = dtgmdx + ( normal_comp * delx / d_LR ) dtgmdy = dtgmdy + ( normal_comp * dely / d_LR ) dtgmdz = dtgmdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! rhoface = 0.5 * ( qp ( i - ii , j - jj , k - kk , 1 ) + qp ( i , j , k , 1 )) mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) ! calling some element from memory and keep them handy for calculation nx = faces ( i , j , k )% nx ny = faces ( i , j , k )% ny nz = faces ( i , j , k )% nz area = faces ( i , j , k )% A ! adding viscous fluxes to stored convective flux F ( i , j , k , dims % n_var ) = F ( i , j , k , dims % n_var ) - ( area * (( mu_f + mut_f ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_lctm2015","tags":"","loc":"proc/compute_viscous_fluxes_lctm2015.html","title":"compute_viscous_fluxes_lctm2015 – FEST-3D"},{"text":"public subroutine add_source_term_residue(qp, residue, cells, Ifaces, Jfaces, Kfaces, scheme, flow, dims) Call to add different source terms to the residual of different equations. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~add_source_term_residue~~CallsGraph proc~add_source_term_residue add_source_term_residue proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~add_kkl_source add_kkl_source proc~add_source_term_residue->proc~add_kkl_source proc~add_sst_bc_source add_sst_bc_source proc~add_source_term_residue->proc~add_sst_bc_source proc~add_sabc_source add_saBC_source proc~add_source_term_residue->proc~add_sabc_source proc~add_sst_source add_sst_source proc~add_source_term_residue->proc~add_sst_source debugcall debugcall proc~add_source_term_residue->debugcall proc~add_sa_source add_sa_source proc~add_source_term_residue->proc~add_sa_source proc~find_dccvn find_DCCVn proc~add_sst_source_lctm2015->proc~find_dccvn proc~compute_gradient compute_gradient proc~find_dccvn->proc~compute_gradient proc~find_ccvn find_CCVn proc~find_dccvn->proc~find_ccvn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~add_source_term_residue~~CalledByGraph proc~add_source_term_residue add_source_term_residue proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_source_term_residueCalledByGraph = svgPanZoom('#procadd_source_term_residueCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_source_term_residue Source Code subroutine add_source_term_residue ( qp , residue , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) !< Call to add different source terms to the residual of different equations. implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal DebugCall ( 'add_source_term_residue' ) select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' ) select case ( trim ( scheme % transition )) case ( 'none' ) call add_sa_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'bc' ) call add_saBC_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , flow , dims ) case DEFAULT Fatal_error end select case ( 'sst' , 'sst2003' ) select case ( trim ( scheme % transition )) case ( 'none' ) call add_sst_source ( qp , residue , cells , scheme , dims ) case ( 'lctm2015' ) call add_sst_source_lctm2015 ( qp , residue , cells , Ifaces , Jfaces , Kfaces , scheme , dims ) case ( 'bc' ) call add_sst_bc_source ( qp , residue , cells , flow , dims ) case DEFAULT Fatal_error end select case ( 'kkl' ) call add_kkl_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , dims ) case DEFAULT Fatal_error end select end subroutine add_source_term_residue","tags":"","loc":"proc/add_source_term_residue.html","title":"add_source_term_residue – FEST-3D"},{"text":"private subroutine add_sst_source(qp, residue, cells, scheme, dims) Add residual due to source terms of the SST turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume\n Store residue at each cell-center type( schemetype ), intent(in) :: scheme finite-volume Schemes type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Called by proc~~add_sst_source~~CalledByGraph proc~add_sst_source add_sst_source proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_source proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_sst_sourceCalledByGraph = svgPanZoom('#procadd_sst_sourceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_sst_source Source Code subroutine add_sst_source ( qp , residue , cells , scheme , dims ) !< Add residual due to source terms of the SST turbulence model implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume !< Store residue at each cell-center integer :: i , j , k real ( wp ) :: CD !< cross diffusion term real ( wp ) :: F1 !< single cell belding fuction real ( wp ) :: vort !< vorticity magnitude real ( wp ) :: S_k !< Total source term of TKE equation real ( wp ) :: S_w !< Total source term of omega equation real ( wp ) :: D_k !< destruction term of TKE equation real ( wp ) :: D_w !< destruction term of omega equation real ( wp ) :: P_k !< production term of TKE equation real ( wp ) :: P_w !< production term of Omega equation real ( wp ) :: lamda !< additional source term in Omega equation integer :: limiter !< production term limiter real ( wp ) :: divergence !< del.V real ( wp ) :: density !< single cell density real ( wp ) :: tk !< single cell TKE real ( wp ) :: tw !< single cell Omega if ( trim ( scheme % turbulence ) == 'sst2003' ) then limiter = 10 gama1 = 5.0 / 9.0 gama2 = 0.44 else limiter = 20 end if do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tw = qp ( i , j , k , 7 ) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) CD = 2 * density * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw CD = max ( CD , 1 0.0 ** ( - limiter )) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density * tw * tk D_w = beta * density * tw ** 2 ! ____ PRODUCTION term____ divergence = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) P_k = mu_t ( i , j , k ) * ( vort ** 2 ) - (( 2.0 / 3.0 ) * density * tk * divergence ) P_k = min ( P_k , limiter * D_k ) P_w = ( density * gama / mu_t ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD S_k = P_k - D_k !Source term TKE S_w = P_w - D_w + lamda !source term omega S_k = S_k * cells ( i , j , k )% volume S_w = S_w * cells ( i , j , k )% volume residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_k residue ( i , j , k , 7 ) = residue ( i , j , k , 7 ) - S_w end do end do end do end subroutine add_sst_source","tags":"","loc":"proc/add_sst_source.html","title":"add_sst_source – FEST-3D"},{"text":"private subroutine add_sst_source_lctm2015(qp, residue, cells, Ifaces, Jfaces, Kfaces, scheme, dims) Add residual due to source terms of the LCTM2015 transition model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( schemetype ), intent(in) :: scheme finite-volume Schemes type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~add_sst_source_lctm2015~~CallsGraph proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~find_dccvn find_DCCVn proc~add_sst_source_lctm2015->proc~find_dccvn proc~compute_gradient compute_gradient proc~find_dccvn->proc~compute_gradient proc~find_ccvn find_CCVn proc~find_dccvn->proc~find_ccvn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~add_sst_source_lctm2015~~CalledByGraph proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_sst_source_lctm2015CalledByGraph = svgPanZoom('#procadd_sst_source_lctm2015CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_sst_source_lctm2015 Source Code subroutine add_sst_source_lctm2015 ( qp , residue , cells , Ifaces , Jfaces , Kfaces , scheme , dims ) !< Add residual due to source terms of the LCTM2015 transition model implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ) :: CD !< Cross-diffustion term real ( wp ) :: F1 !< single cell blending function real ( wp ) :: vort !< vorticity magnitude real ( wp ) :: S_K !< Total source term in TKE equation real ( wp ) :: S_w !< Total source term in Omega equation real ( wp ) :: S_gm !< Total source term in Gamma equation real ( wp ) :: D_k !< Destruction term in TKE equation real ( wp ) :: D_w !< Destruction term in Omega equation real ( wp ) :: D_gm !< Destruction term in Gamma equation real ( wp ) :: P_k !< production term in TKE equation real ( wp ) :: P_w !< production term in Omega equation real ( wp ) :: P_gm !< production term in Gamma equation real ( wp ) :: lamda !< additional source term in Omega equation real ( wp ) :: Fonset1 , Fonset2 , Fonset3 , Fonset !< Transition onset term real ( wp ) :: Rev !< Reynodlds number based on vorticity real ( wp ) :: RT !< Turbulent reynolds number real ( wp ) :: Fturb real ( wp ) :: Re_theta !< Cutt-off reynolds number based on momentum thickness real ( wp ) :: TuL !< local turbulence intensity real ( wp ) :: strain !< Strain rate magnitude real ( wp ) :: intermittency !< intermittency real ( wp ) :: Pk_lim !< production lim term real ( wp ) :: Fon_lim real ( wp ) :: lamd !< pressure gradient real ( wp ) :: Fpg !< pressure gradient functin real ( wp ) :: divergence !< del.V real ( wp ) :: dvdy !< pressure gradient sensor integer :: limiter !< production limiter real ( wp ) :: density !< single cell Density real ( wp ) :: tk !< single cell TKE real ( wp ) :: tw !< single cell Omega if ( trim ( scheme % turbulence ) == 'sst2003' ) then limiter = 10 gama1 = 5.0 / 9.0 gama2 = 0.44 else limiter = 20 end if !for pressure gradient calculation call find_DCCVn ( qp , cells , Ifaces , Jfaces , Kfaces , dims ) do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tw = qp ( i , j , k , 7 ) intermittency = qp ( i , j , k , 8 ) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( ((( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 ) & + (( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 ) & + (( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 ) & + 2 * ( gradu_x ( i , j , k ) ** 2 ) & + 2 * ( gradv_y ( i , j , k ) ** 2 ) & + 2 * ( gradw_z ( i , j , k ) ** 2 ) & )& ) CD = 2 * density * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw CD = max ( CD , 1 0.0 ** ( - limiter )) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density * tw * tk D_w = beta * density * tw ** 2 ! ____ PRODUCTION term____ divergence = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) P_k = mu_t ( i , j , k ) * ( vort * strain ) - (( 2.0 / 3.0 ) * density * tk * divergence ) P_k = min ( P_k , limiter * D_k ) P_w = ( density * gama / mu_t ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD ! ____Transition modeling  ____ ! --pressure gradient dvdy = DCCVnX ( i , j , k ) * CCnormalX ( i , j , k ) & + DCCVnY ( i , j , k ) * CCnormalY ( i , j , k ) & + DCCVnZ ( i , j , k ) * CCnormalZ ( i , j , k ) lamd = ( - 7.57e-3 ) * ( dvdy * dist ( i , j , k ) * dist ( i , j , k ) * density / mu ( i , j , k )) + 0.0128 lamd = min ( max ( lamd , - 1.0 ), 1.0 ) if ( lamd >= 0.0 ) then Fpg = min ( 1.0 + 1 4.68 * lamd , 1.5 ) else Fpg = min ( 1.0 - 7.34 * lamd , 3.0 ) end if Fpg = max ( Fpg , 0.0 ) ! --gradient TuL = min ( 10 0.0 * sqrt ( 2.0 * tk / 3.0 ) / ( tw * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) !Re_theta = 100.0 + 1000.0*exp(-TuL) Rev = density * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density * tk / ( mu ( i , j , k ) * tw ) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) P_gm = 100 * density * strain * intermittency * ( 1.0 - intermittency ) * Fonset D_gm = 0.06 * density * vort * intermittency * Fturb * (( 5 0.0 * intermittency ) - 1.0 ) Fon_lim = min ( max (( Rev / ( 2.2 * 110 0.0 )) - 1.0 , 0.0 ), 3.0 ) Pk_lim = 5 * max ( intermittency - 0.2 , 0.0 ) * ( 1.0 - intermittency ) * Fon_lim * max ( 3 * mu ( i , j , k ) - mu_t ( i , j , k ), 0.0 ) * strain * vort S_k = intermittency * P_k - max ( intermittency , 0.1 ) * D_k + Pk_lim !Source term gm S_W = P_w - D_w + lamda !Source term gm S_gm = P_gm - D_gm !Source term gm S_k = S_k * cells ( i , j , k )% volume S_w = S_w * cells ( i , j , k )% volume S_gm = S_gm * cells ( i , j , k )% Volume residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_k residue ( i , j , k , 7 ) = residue ( i , j , k , 7 ) - S_w residue ( i , j , k , 8 ) = residue ( i , j , k , 8 ) - S_gm end do end do end do end subroutine add_sst_source_lctm2015","tags":"","loc":"proc/add_sst_source_lctm2015.html","title":"add_sst_source_lctm2015 – FEST-3D"},{"text":"private subroutine add_sst_bc_source(qp, residue, cells, flow, dims) Add residual due to source terms of the SST-BC transition model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Called by proc~~add_sst_bc_source~~CalledByGraph proc~add_sst_bc_source add_sst_bc_source proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_bc_source proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_sst_bc_sourceCalledByGraph = svgPanZoom('#procadd_sst_bc_sourceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_sst_bc_source Source Code subroutine add_sst_bc_source ( qp , residue , cells , flow , dims ) !< Add residual due to source terms of the SST-BC transition model implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume integer :: i , j , k real ( wp ) :: CD !< cross-diffusion term real ( wp ) :: F1 !< single cell blending function real ( wp ) :: vort !< vorticity magnitude real ( wp ) :: S_k !< Total source term in TKE equation real ( wp ) :: S_w !< Total source term in Omega equation real ( wp ) :: D_k !< Destruction term in TKE equation real ( wp ) :: D_w !< Destruction term in Omega equation real ( wp ) :: P_k !< Production term in TKE equation real ( wp ) :: P_w !< production term in Omega equation real ( wp ) :: lamda !< addtion source term in Omega equation real ( wp ) :: TuL !< local turbulence intensity !--------BC model ----- real ( wp ) :: chi_1 = 0.002 real ( wp ) :: chi_2 = 5.0 real ( wp ) :: nu_BC real ( wp ) :: nu_cr real ( wp ) :: nu_t real ( wp ) :: re_v real ( wp ) :: re_theta real ( wp ) :: re_theta_t real ( wp ) :: term1 real ( wp ) :: term2 real ( wp ) :: term_exponential real ( wp ) :: gamma_BC !< intermittency function real ( wp ) :: vmag !< velocity magnitude real ( wp ) :: density !< single cell Density real ( wp ) :: tk !< single cell TKE real ( wp ) :: tw !< single cell omega do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tw = qp ( i , j , k , 7 ) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) CD = 2 * density * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw !CD = max(CD, 1e-20) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density * tw * tk D_w = beta * density * tw ** 2 ! ____ PRODUCTION term____ P_k = mu_t ( i , j , k ) * ( vort ** 2 ) P_k = min ( P_k , 2 0.0 * D_k ) P_w = ( density * gama / mu_t ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD ! ____Transition modeling  ____ !------ BC model --- vmag = sqrt ( SUM ( qp ( i , j , k , 2 : 4 ) ** 2 )) chi_1 = 0.002 chi_2 = 5.0 nu_t = mu_t ( i , j , k ) / density nu_cr = chi_2 / flow % Reynolds_number nu_bc = nu_t / ( vmag * dist ( i , j , k )) TuL = flow % tu_inf !local turbulence intensity might not work for BC model re_v = density * dist ( i , j , k ) * dist ( i , j , k ) * vort / mu ( i , j , k ) re_theta = re_v / 2.193 re_theta_t = ( 80 3.73 * (( TuL + 0.6067 ) ** ( - 1.027 ))) term1 = sqrt ( max ( re_theta - re_theta_t , 0. ) / ( chi_1 * re_theta_t )) term2 = sqrt ( max ( nu_BC - nu_cr , 0.0 ) / nu_cr ) term_exponential = ( term1 + term2 ) gamma_BC = 1.0 - exp ( - term_exponential ) P_k = gamma_BC * P_k S_k = P_k - D_k !Source term TKE S_w = P_w - D_w + lamda !source term omega S_k = S_k * cells ( i , j , k )% volume S_w = S_w * cells ( i , j , k )% volume residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_k residue ( i , j , k , 7 ) = residue ( i , j , k , 7 ) - S_w end do end do end do end subroutine add_sst_bc_source","tags":"","loc":"proc/add_sst_bc_source.html","title":"add_sst_bc_source – FEST-3D"},{"text":"private subroutine add_kkl_source(qp, residue, cells, Ifaces, Jfaces, Kfaces, dims) Add residual due to source terms of the k-kL turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Called by proc~~add_kkl_source~~CalledByGraph proc~add_kkl_source add_kkl_source proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_kkl_source proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_kkl_sourceCalledByGraph = svgPanZoom('#procadd_kkl_sourceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_kkl_source Source Code subroutine add_kkl_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , dims ) !< Add residual due to source terms of the k-kL turbulence model implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ) :: Tau11 real ( wp ) :: Tau12 real ( wp ) :: Tau13 real ( wp ) :: Tau21 real ( wp ) :: Tau22 real ( wp ) :: Tau23 real ( wp ) :: Tau31 real ( wp ) :: Tau32 real ( wp ) :: Tau33 real ( wp ) :: S11 real ( wp ) :: S12 real ( wp ) :: S13 real ( wp ) :: S21 real ( wp ) :: S22 real ( wp ) :: S23 real ( wp ) :: S31 real ( wp ) :: S32 real ( wp ) :: S33 real ( wp ) :: delv real ( wp ) :: d2udx2 real ( wp ) :: d2udy2 real ( wp ) :: d2udz2 real ( wp ) :: d2vdx2 real ( wp ) :: d2vdy2 real ( wp ) :: d2vdz2 real ( wp ) :: d2wdx2 real ( wp ) :: d2wdy2 real ( wp ) :: d2wdz2 real ( wp ) :: Lvk real ( wp ) :: fp real ( wp ) :: ud real ( wp ) :: udd real ( wp ) :: S_k real ( wp ) :: S_kl real ( wp ) :: D_k real ( wp ) :: D_kl real ( wp ) :: P_k real ( wp ) :: P_kl real ( wp ) :: density real ( wp ) :: tk real ( wp ) :: tkl do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tkl = qp ( i , j , k , 7 ) S11 = 0.5 * ( gradu_x ( i , j , k ) + gradu_x ( i , j , k )) S12 = 0.5 * ( gradu_y ( i , j , k ) + gradv_x ( i , j , k )) S13 = 0.5 * ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) S21 = 0.5 * ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) S22 = 0.5 * ( gradv_y ( i , j , k ) + gradv_y ( i , j , k )) S23 = 0.5 * ( gradv_z ( i , j , k ) + gradw_y ( i , j , k )) S31 = 0.5 * ( gradw_x ( i , j , k ) + gradu_z ( i , j , k )) S32 = 0.5 * ( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) S33 = 0.5 * ( gradw_z ( i , j , k ) + gradw_z ( i , j , k )) delv = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) Tau11 = mu_t ( i , j , k ) * ( 2 * S11 - ( 2.0 / 3.0 ) * delv ) - ( 2.0 / 3.0 ) * density * tk Tau12 = mu_t ( i , j , k ) * ( 2 * S12 ) Tau13 = mu_t ( i , j , k ) * ( 2 * S13 ) Tau21 = mu_t ( i , j , k ) * ( 2 * S21 ) Tau22 = mu_t ( i , j , k ) * ( 2 * S22 - ( 2.0 / 3.0 ) * delv ) - ( 2.0 / 3.0 ) * density * tk Tau23 = mu_t ( i , j , k ) * ( 2 * S23 ) Tau31 = mu_t ( i , j , k ) * ( 2 * S31 ) Tau32 = mu_t ( i , j , k ) * ( 2 * S32 ) Tau33 = mu_t ( i , j , k ) * ( 2 * S33 - ( 2.0 / 3.0 ) * delv ) - ( 2.0 / 3.0 ) * density * tk P_k = 0. P_k = P_k + Tau11 * gradu_x ( i , j , k ) + Tau12 * gradu_y ( i , j , k ) + Tau13 * gradu_z ( i , j , k ) P_k = P_k + Tau21 * gradv_x ( i , j , k ) + Tau22 * gradv_y ( i , j , k ) + Tau23 * gradv_z ( i , j , k ) P_k = P_k + Tau31 * gradw_x ( i , j , k ) + Tau32 * gradw_y ( i , j , k ) + Tau33 * gradw_z ( i , j , k ) D_k = ( cmu ** 0.75 ) * density * ( tk ** 2.5 ) / max ( tkl , 1.e-20 ) P_k = min ( P_k , 20 * D_k ) ! calculation of Lvk ! first get second order gradients d2udx2 = ( - ( gradu_x ( i - 1 , j , k ) + gradu_x ( i , j , k )) * Ifaces ( i , j , k )% nx * Ifaces ( i , j , k )% A & - ( gradu_x ( i , j - 1 , k ) + gradu_x ( i , j , k )) * Jfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( gradu_x ( i , j , k - 1 ) + gradu_x ( i , j , k )) * Kfaces ( i , j , k )% nx * Kfaces ( i , j , k )% A & + ( gradu_x ( i + 1 , j , k ) + gradu_x ( i , j , k )) * Ifaces ( i + 1 , j , k )% nx * Ifaces ( i + 1 , j , k )% A & + ( gradu_x ( i , j + 1 , k ) + gradu_x ( i , j , k )) * Jfaces ( i , j + 1 , k )% nx * Jfaces ( i , j + 1 , k )% A & + ( gradu_x ( i , j , k + 1 ) + gradu_x ( i , j , k )) * Kfaces ( i , j , k + 1 )% nx * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2udy2 = ( - ( gradu_y ( i - 1 , j , k ) + gradu_y ( i , j , k )) * Ifaces ( i , j , k )% ny * Ifaces ( i , j , k )% A & - ( gradu_y ( i , j - 1 , k ) + gradu_y ( i , j , k )) * Jfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( gradu_y ( i , j , k - 1 ) + gradu_y ( i , j , k )) * Kfaces ( i , j , k )% ny * Kfaces ( i , j , k )% A & + ( gradu_y ( i + 1 , j , k ) + gradu_y ( i , j , k )) * Ifaces ( i + 1 , j , k )% ny * Ifaces ( i + 1 , j , k )% A & + ( gradu_y ( i , j + 1 , k ) + gradu_y ( i , j , k )) * Jfaces ( i , j + 1 , k )% ny * Jfaces ( i , j + 1 , k )% A & + ( gradu_y ( i , j , k + 1 ) + gradu_y ( i , j , k )) * Kfaces ( i , j , k + 1 )% ny * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2udz2 = ( - ( gradu_z ( i - 1 , j , k ) + gradu_z ( i , j , k )) * Ifaces ( i , j , k )% nz * Ifaces ( i , j , k )% A & - ( gradu_z ( i , j - 1 , k ) + gradu_z ( i , j , k )) * Jfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & - ( gradu_z ( i , j , k - 1 ) + gradu_z ( i , j , k )) * Kfaces ( i , j , k )% nz * Kfaces ( i , j , k )% A & + ( gradu_z ( i + 1 , j , k ) + gradu_z ( i , j , k )) * Ifaces ( i + 1 , j , k )% nz * Ifaces ( i + 1 , j , k )% A & + ( gradu_z ( i , j + 1 , k ) + gradu_z ( i , j , k )) * Jfaces ( i , j + 1 , k )% nz * Jfaces ( i , j + 1 , k )% A & + ( gradu_z ( i , j , k + 1 ) + gradu_z ( i , j , k )) * Kfaces ( i , j , k + 1 )% nz * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) ! gradient of v component d2vdx2 = ( - ( gradv_x ( i - 1 , j , k ) + gradv_x ( i , j , k )) * Ifaces ( i , j , k )% nx * Ifaces ( i , j , k )% A & - ( gradv_x ( i , j - 1 , k ) + gradv_x ( i , j , k )) * Jfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( gradv_x ( i , j , k - 1 ) + gradv_x ( i , j , k )) * Kfaces ( i , j , k )% nx * Kfaces ( i , j , k )% A & + ( gradv_x ( i + 1 , j , k ) + gradv_x ( i , j , k )) * Ifaces ( i + 1 , j , k )% nx * Ifaces ( i + 1 , j , k )% A & + ( gradv_x ( i , j + 1 , k ) + gradv_x ( i , j , k )) * Jfaces ( i , j + 1 , k )% nx * Jfaces ( i , j + 1 , k )% A & + ( gradv_x ( i , j , k + 1 ) + gradv_x ( i , j , k )) * Kfaces ( i , j , k + 1 )% nx * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2vdy2 = ( - ( gradv_y ( i - 1 , j , k ) + gradv_y ( i , j , k )) * Ifaces ( i , j , k )% ny * Ifaces ( i , j , k )% A & - ( gradv_y ( i , j - 1 , k ) + gradv_y ( i , j , k )) * Jfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( gradv_y ( i , j , k - 1 ) + gradv_y ( i , j , k )) * Kfaces ( i , j , k )% ny * Kfaces ( i , j , k )% A & + ( gradv_y ( i + 1 , j , k ) + gradv_y ( i , j , k )) * Ifaces ( i + 1 , j , k )% ny * Ifaces ( i + 1 , j , k )% A & + ( gradv_y ( i , j + 1 , k ) + gradv_y ( i , j , k )) * Jfaces ( i , j + 1 , k )% ny * Jfaces ( i , j + 1 , k )% A & + ( gradv_y ( i , j , k + 1 ) + gradv_y ( i , j , k )) * Kfaces ( i , j , k + 1 )% ny * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2vdz2 = ( - ( gradv_z ( i - 1 , j , k ) + gradv_z ( i , j , k )) * Ifaces ( i , j , k )% nz * Ifaces ( i , j , k )% A & - ( gradv_z ( i , j - 1 , k ) + gradv_z ( i , j , k )) * Jfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & - ( gradv_z ( i , j , k - 1 ) + gradv_z ( i , j , k )) * Kfaces ( i , j , k )% nz * Kfaces ( i , j , k )% A & + ( gradv_z ( i + 1 , j , k ) + gradv_z ( i , j , k )) * Ifaces ( i + 1 , j , k )% nz * Ifaces ( i + 1 , j , k )% A & + ( gradv_z ( i , j + 1 , k ) + gradv_z ( i , j , k )) * Jfaces ( i , j + 1 , k )% nz * Jfaces ( i , j + 1 , k )% A & + ( gradv_z ( i , j , k + 1 ) + gradv_z ( i , j , k )) * Kfaces ( i , j , k + 1 )% nz * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) !gradients of w components d2wdx2 = ( - ( gradw_x ( i - 1 , j , k ) + gradw_x ( i , j , k )) * Ifaces ( i , j , k )% nx * Ifaces ( i , j , k )% A & - ( gradw_x ( i , j - 1 , k ) + gradw_x ( i , j , k )) * Jfaces ( i , j , k )% nx * Jfaces ( i , j , k )% A & - ( gradw_x ( i , j , k - 1 ) + gradw_x ( i , j , k )) * Kfaces ( i , j , k )% nx * Kfaces ( i , j , k )% A & + ( gradw_x ( i + 1 , j , k ) + gradw_x ( i , j , k )) * Ifaces ( i + 1 , j , k )% nx * Ifaces ( i + 1 , j , k )% A & + ( gradw_x ( i , j + 1 , k ) + gradw_x ( i , j , k )) * Jfaces ( i , j + 1 , k )% nx * Jfaces ( i , j + 1 , k )% A & + ( gradw_x ( i , j , k + 1 ) + gradw_x ( i , j , k )) * Kfaces ( i , j , k + 1 )% nx * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2wdy2 = ( - ( gradw_y ( i - 1 , j , k ) + gradw_y ( i , j , k )) * Ifaces ( i , j , k )% ny * Ifaces ( i , j , k )% A & - ( gradw_y ( i , j - 1 , k ) + gradw_y ( i , j , k )) * Jfaces ( i , j , k )% ny * Jfaces ( i , j , k )% A & - ( gradw_y ( i , j , k - 1 ) + gradw_y ( i , j , k )) * Kfaces ( i , j , k )% ny * Kfaces ( i , j , k )% A & + ( gradw_y ( i + 1 , j , k ) + gradw_y ( i , j , k )) * Ifaces ( i + 1 , j , k )% ny * Ifaces ( i + 1 , j , k )% A & + ( gradw_y ( i , j + 1 , k ) + gradw_y ( i , j , k )) * Jfaces ( i , j + 1 , k )% ny * Jfaces ( i , j + 1 , k )% A & + ( gradw_y ( i , j , k + 1 ) + gradw_y ( i , j , k )) * Kfaces ( i , j , k + 1 )% ny * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) d2wdz2 = ( - ( gradw_z ( i - 1 , j , k ) + gradw_z ( i , j , k )) * Ifaces ( i , j , k )% nz * Ifaces ( i , j , k )% A & - ( gradw_z ( i , j - 1 , k ) + gradw_z ( i , j , k )) * Jfaces ( i , j , k )% nz * Jfaces ( i , j , k )% A & - ( gradw_z ( i , j , k - 1 ) + gradw_z ( i , j , k )) * Kfaces ( i , j , k )% nz * Kfaces ( i , j , k )% A & + ( gradw_z ( i + 1 , j , k ) + gradw_z ( i , j , k )) * Ifaces ( i + 1 , j , k )% nz * Ifaces ( i + 1 , j , k )% A & + ( gradw_z ( i , j + 1 , k ) + gradw_z ( i , j , k )) * Jfaces ( i , j + 1 , k )% nz * Jfaces ( i , j + 1 , k )% A & + ( gradw_z ( i , j , k + 1 ) + gradw_z ( i , j , k )) * Kfaces ( i , j , k + 1 )% nz * Kfaces ( i , j , k + 1 )% A & ) / ( 2 * cells ( i , j , k )% volume ) udd = sqrt ( ( d2udx2 + d2udy2 + d2udz2 ) ** 2 & + ( d2vdx2 + d2vdy2 + d2vdz2 ) ** 2 & + ( d2wdx2 + d2wdy2 + d2wdz2 ) ** 2 ) ud = sqrt ( 2 * ( s11 ** 2 + s12 ** 2 + s13 ** 2 & + s21 ** 2 + s22 ** 2 + s23 ** 2 & + s31 ** 2 + s32 ** 2 + s33 ** 2 )) Lvk = kappa * abs ( ud / max ( udd , 1.e-20 )) fp = min ( max ( P_k / D_k , 0.5 ), 1.0 ) ! Lvk limiter Lvk = max ( Lvk , tkl / max (( tk * c11 ), 1.e-20 )) Lvk = min ( Lvk , c12 * kappa * dist ( i , j , k ) * fp ) eta = density * dist ( i , j , k ) * sqrt ( 0.3 * tk ) / ( 20 * mu ( i , j , k )) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) cphi2 = zeta3 cphi1 = ( zeta1 - zeta2 * (( tkl / max ( tk * Lvk , 1.e-20 )) ** 2 )) P_kl = cphi1 * tkl * P_k / max ( tk , 1.e-20 ) D_kl = cphi2 * density * ( tk ** 1.5 ) S_k = P_k - D_k - 2 * mu ( i , j , k ) * tk / ( dist ( i , j , k ) ** 2 ) !Source term TKE S_kl = P_kl - D_kl - 6 * mu ( i , j , k ) * tkl * fphi / ( dist ( i , j , k ) ** 2 ) !source term KL S_k = S_k * cells ( i , j , k )% volume S_kl = S_kl * cells ( i , j , k )% volume residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_k residue ( i , j , k , 7 ) = residue ( i , j , k , 7 ) - S_kl end do end do end do end subroutine add_kkl_source","tags":"","loc":"proc/add_kkl_source.html","title":"add_kkl_source – FEST-3D"},{"text":"private subroutine add_sa_source(qp, residue, cells, Ifaces, Jfaces, Kfaces, dims) Add residual due to source terms of SA turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Called by proc~~add_sa_source~~CalledByGraph proc~add_sa_source add_sa_source proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sa_source proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_sa_sourceCalledByGraph = svgPanZoom('#procadd_sa_sourceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_sa_source Source Code subroutine add_sa_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , dims ) !< Add residual due to source terms of SA turbulence model implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ) :: CD1 real ( wp ) :: CD2 real ( wp ) :: fv1 real ( wp ) :: fv2 real ( wp ) :: fw real ( wp ) :: g real ( wp ) :: Scap real ( wp ) :: r real ( wp ) :: vort real ( wp ) :: S_v real ( wp ) :: D_v real ( wp ) :: P_v real ( wp ) :: lamda real ( wp ) :: kd2 real ( wp ) :: xi real ( wp ) :: nu real ( wp ) :: gradrho_x real ( wp ) :: gradrho_y real ( wp ) :: gradrho_z real ( wp ), dimension ( 6 ) :: RhoFace real ( wp ), dimension ( 6 ) :: Area real ( wp ), dimension ( 6 , 3 ) :: Normal real ( wp ) :: density real ( wp ) :: tv do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) tv = qp ( i , j , k , 6 ) RhoFace ( 1 ) = qp ( i - 1 , j , k , 1 ) + density RhoFace ( 2 ) = qp ( i , j - 1 , k , 1 ) + density RhoFace ( 3 ) = qp ( i , j , k - 1 , 1 ) + density RhoFace ( 4 ) = qp ( i + 1 , j , k , 1 ) + density RhoFace ( 5 ) = qp ( i , j + 1 , k , 1 ) + density RhoFace ( 6 ) = qp ( i , j , k + 1 , 1 ) + density Area ( 1 ) = Ifaces ( i , j , k )% A Area ( 2 ) = Jfaces ( i , j , k )% A Area ( 3 ) = Kfaces ( i , j , k )% A Area ( 4 ) = Ifaces ( i + 1 , j , k )% A Area ( 5 ) = Jfaces ( i , j + 1 , k )% A Area ( 6 ) = Kfaces ( i , j , k + 1 )% A Normal ( 1 , 1 : 3 ) = ( / Ifaces ( i , j , k )% nx , Ifaces ( i , j , k )% ny , Ifaces ( i , j , k )% nz / ) Normal ( 2 , 1 : 3 ) = ( / Jfaces ( i , j , k )% nx , Jfaces ( i , j , k )% ny , Jfaces ( i , j , k )% nz / ) Normal ( 3 , 1 : 3 ) = ( / Kfaces ( i , j , k )% nx , Kfaces ( i , j , k )% nx , Kfaces ( i , j , k )% nx / ) Normal ( 4 , 1 : 3 ) = ( / Ifaces ( i + 1 , j , k )% nx , Ifaces ( i + 1 , j , k )% ny , Ifaces ( i + 1 , j , k )% nz / ) Normal ( 5 , 1 : 3 ) = ( / Jfaces ( i , j + 1 , k )% nx , Jfaces ( i , j + 1 , k )% ny , Jfaces ( i , j + 1 , k )% nz / ) Normal ( 6 , 1 : 3 ) = ( / Kfaces ( i , j , k + 1 )% nx , Kfaces ( i , j , k + 1 )% ny , Kfaces ( i , j , k + 1 )% nz / ) gradrho_x = ( - ( RhoFace ( 1 )) * Normal ( 1 , 1 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 1 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 1 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 1 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 1 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 1 ) * Area ( 6 ) & ) / ( 2.0 * cells ( i , j , k )% volume ) gradrho_y = ( - ( RhoFace ( 1 )) * Normal ( 1 , 2 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 2 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 2 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 2 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 2 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 2 ) * Area ( 6 ) & ) / ( 2.0 * cells ( i , j , k )% volume ) gradrho_z = ( - ( RhoFace ( 1 )) * Normal ( 1 , 3 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 3 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 3 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 3 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 3 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 3 ) * Area ( 6 ) & ) / ( 2.0 * cells ( i , j , k )% volume ) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) ! ___ cross diffusion ___ CD1 = cb2 * (( gradtv_x ( i , j , k ) * gradtv_x ( i , j , k ))& + ( gradtv_y ( i , j , k ) * gradtv_y ( i , j , k ))& + ( gradtv_z ( i , j , k ) * gradtv_z ( i , j , k ))& ) ! ___ addition cross diffusion result conservative form of tv ___ CD2 = (( gradrho_x * gradtv_x ( i , j , k ))& + ( gradrho_y * gradtv_y ( i , j , k ))& + ( gradrho_z * gradtv_z ( i , j , k ))& ) kd2 = ( kappa_sa * dist ( i , j , k )) ** 2 nu = mu ( i , j , k ) / density xi = tv / nu ! ___ functions ___ fv1 = ( xi ** 3 ) / (( xi ** 3 ) + ( cv1 ** 3 )) fv2 = 1.0 - xi / ( 1.0 + ( xi * fv1 )) ! ___ Shear stress for production ___ scap = max ( vort + ( tv * fv2 / ( kd2 )), 0.3 * vort ) ! ___ wall function ___ r = min ( tv / ( Scap * kd2 ), 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) fw = g * ( ( 1.0 + ( cw3 ** 6 )) / (( g ** 6 ) + ( cw3 ** 6 )) ) ** ( 1.0 / 6.0 ) ! ____ Dissipation term ___ D_v = density * cw1 * fw * (( tv / dist ( i , j , k )) ** 2 ) ! ____ PRODUCTION term____ P_v = density * cb1 * Scap * tv ! ____ cross diffusion term ___ lamda = density * CD1 / sigma_sa - CD2 * ( nu + tv ) / sigma_sa S_v = ( P_v - D_v + lamda ) * cells ( i , j , k )% volume residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_v end do end do end do end subroutine add_sa_source","tags":"","loc":"proc/add_sa_source.html","title":"add_sa_source – FEST-3D"},{"text":"private subroutine add_saBC_source(qp, residue, cells, Ifaces, Jfaces, Kfaces, flow, dims) Add residual due to source terms of SABC transition model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Called by proc~~add_sabc_source~~CalledByGraph proc~add_sabc_source add_saBC_source proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sabc_source proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_sabc_sourceCalledByGraph = svgPanZoom('#procadd_sabc_sourceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_saBC_source Source Code subroutine add_saBC_source ( qp , residue , cells , Ifaces , Jfaces , Kfaces , flow , dims ) !< Add residual due to source terms of SABC transition model implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ) :: CD1 real ( wp ) :: CD2 real ( wp ) :: fv1 real ( wp ) :: fv2 real ( wp ) :: fw real ( wp ) :: g real ( wp ) :: r real ( wp ) :: S_v real ( wp ) :: lamda real ( wp ) :: dist_i real ( wp ) :: dist_i_2 real ( wp ) :: Ji real ( wp ) :: Ji_2 real ( wp ) :: Ji_3 real ( wp ) :: S real ( wp ) :: Omega real ( wp ) :: k2 real ( wp ) :: inv_k2_d2 real ( wp ) :: Shat real ( wp ) :: inv_Shat real ( wp ) :: nu real ( wp ) :: gradrho_x real ( wp ) :: gradrho_y real ( wp ) :: gradrho_z real ( wp ), dimension ( 6 ) :: RhoFace real ( wp ), dimension ( 6 ) :: Area real ( wp ), dimension ( 6 , 3 ) :: Normal ! transition modeling variables real ( wp ) :: chi_1 = 0.002 real ( wp ) :: chi_2 = 5.0 real ( wp ) :: nu_BC real ( wp ) :: nu_cr real ( wp ) :: nu_t real ( wp ) :: u , v , w real ( wp ) :: glim real ( wp ) :: g_6 real ( wp ) :: vmag real ( wp ) :: Production real ( wp ) :: Destruction real ( wp ) :: re_v real ( wp ) :: re_theta real ( wp ) :: re_theta_t real ( wp ) :: term1 real ( wp ) :: term2 real ( wp ) :: term_exponential real ( wp ) :: gamma_BC real ( wp ) :: tu real ( wp ) :: tv real ( wp ) :: density tu = flow % tu_inf do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 !Local_vel_mag density = qp ( i , j , k , 1 ) u = qp ( i , j , k , 2 ) v = qp ( i , j , k , 3 ) w = qp ( i , j , k , 4 ) tv = qp ( i , j , k , 6 ) vmag = sqrt ( u * u + v * v + w * w ) RhoFace ( 1 ) = qp ( i - 1 , j , k , 1 ) + density RhoFace ( 2 ) = qp ( i , j - 1 , k , 1 ) + density RhoFace ( 3 ) = qp ( i , j , k - 1 , 1 ) + density RhoFace ( 4 ) = qp ( i + 1 , j , k , 1 ) + density RhoFace ( 5 ) = qp ( i , j + 1 , k , 1 ) + density RhoFace ( 6 ) = qp ( i , j , k + 1 , 1 ) + density Area ( 1 ) = Ifaces ( i , j , k )% A Area ( 2 ) = Jfaces ( i , j , k )% A Area ( 3 ) = Kfaces ( i , j , k )% A Area ( 4 ) = Ifaces ( i + 1 , j , k )% A Area ( 5 ) = Jfaces ( i , j + 1 , k )% A Area ( 6 ) = Kfaces ( i , j , k + 1 )% A Normal ( 1 , 1 : 3 ) = ( / Ifaces ( i , j , k )% nx , Ifaces ( i , j , k )% ny , Ifaces ( i , j , k )% nz / ) Normal ( 2 , 1 : 3 ) = ( / Jfaces ( i , j , k )% nx , Jfaces ( i , j , k )% ny , Jfaces ( i , j , k )% nz / ) Normal ( 3 , 1 : 3 ) = ( / Kfaces ( i , j , k )% nx , Kfaces ( i , j , k )% nx , Kfaces ( i , j , k )% nx / ) Normal ( 4 , 1 : 3 ) = ( / Ifaces ( i + 1 , j , k )% nx , Ifaces ( i + 1 , j , k )% ny , Ifaces ( i + 1 , j , k )% nz / ) Normal ( 5 , 1 : 3 ) = ( / Jfaces ( i , j + 1 , k )% nx , Jfaces ( i , j + 1 , k )% ny , Jfaces ( i , j + 1 , k )% nz / ) Normal ( 6 , 1 : 3 ) = ( / Kfaces ( i , j , k + 1 )% nx , Kfaces ( i , j , k + 1 )% ny , Kfaces ( i , j , k + 1 )% nz / ) gradrho_x = ( - ( RhoFace ( 1 )) * Normal ( 1 , 1 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 1 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 1 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 1 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 1 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 1 ) * Area ( 6 ) & ) / ( 2 * cells ( i , j , k )% volume ) gradrho_y = ( - ( RhoFace ( 1 )) * Normal ( 1 , 2 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 2 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 2 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 2 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 2 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 2 ) * Area ( 6 ) & ) / ( 2 * cells ( i , j , k )% volume ) gradrho_z = ( - ( RhoFace ( 1 )) * Normal ( 1 , 3 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 3 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 3 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 3 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 3 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 3 ) * Area ( 6 ) & ) / ( 2 * cells ( i , j , k )% volume ) ! __ vorticity __ Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) ! ___ cross diffusion ___ CD1 = cb2 * (( gradtv_x ( i , j , k ) * gradtv_x ( i , j , k ))& + ( gradtv_y ( i , j , k ) * gradtv_y ( i , j , k ))& + ( gradtv_z ( i , j , k ) * gradtv_z ( i , j , k ))& ) ! ___ addition cross diffusion result conservative form of tv ___ CD2 = (( gradrho_x * gradtv_x ( i , j , k ))& + ( gradrho_y * gradtv_y ( i , j , k ))& + ( gradrho_z * gradtv_z ( i , j , k ))& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density Ji = tv / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + tv * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat ! ____ PRODUCTION term____ chi_1 = 0.002 chi_2 = 5.0 nu_t = tv * fv1 nu_cr = chi_2 / flow % Reynolds_number nu_bc = nu_t / ( vmag * dist_i ) re_v = dist_i_2 * Omega / nu re_theta = re_v / 2.193 re_theta_t = ( 80 3.73 * (( tu + 0.6067 ) ** ( - 1.027 ))) !re_theta_t = 163.0 + exp(6.91-0.18) term1 = sqrt ( max ( re_theta - re_theta_t , 0. ) / ( chi_1 * re_theta_t )) term2 = sqrt ( max ( nu_BC - nu_cr , 0.0 ) / nu_cr ) term_exponential = ( term1 + term2 ) gamma_BC = 1.0 - exp ( - term_exponential ) Production = gamma_BC * cb1 * Shat * tv * cells ( i , j , k )% volume ! ___ Destruction term___ ! r = min ( tv * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim Destruction = ( cw1 * fw * tv * tv / dist_i_2 ) * ( cells ( i , j , k )% volume ) ! ____ cross diffusion term ___ lamda = ( density * CD1 / sigma_sa - CD2 * ( nu + tv ) / sigma_sa ) * cells ( i , j , k )% volume S_v = ( Production - Destruction + lamda ) residue ( i , j , k , 6 ) = residue ( i , j , k , 6 ) - S_v end do end do end do end subroutine add_saBC_source","tags":"","loc":"proc/add_sabc_source.html","title":"add_saBC_source – FEST-3D"},{"text":"public function converged(control) result(c) Check if the solution seems to have converged\n The solution is said to have converged if the change in \n the residue norm is \"negligible\". Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control control parameters Return Value logical convergence result:True or false Called by proc~~converged~~CalledByGraph proc~converged converged program~main main program~main->proc~converged Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code converged Source Code function converged ( control ) result ( c ) !< Check if the solution seems to have converged !< The solution is said to have converged if the change in !< the residue norm is \"negligible\". !----------------------------------------------------------- implicit none type ( controltype ), intent ( in ) :: control !< control parameters logical :: c !< convergence result:True or false real ( wp ) :: check = 1 0. select case ( trim ( control % tolerance_type )) case ( 'Mass_abs' ) check = Res_abs ( 0 ) case ( 'Resnorm_abs' ) check = sqrt ( sum ( Res_abs ( 1 :) ** 2 )) case ( 'Viscous_abs' ) check = sqrt ( sum ( Res_abs ( 1 : 5 ) ** 2 )) case ( 'Turbulent_abs' ) check = sqrt ( sum ( Res_abs ( 6 :) ** 2 )) case ( 'Continuity_abs' ) check = Res_abs ( 1 ) case ( 'X-mom_abs' ) check = Res_abs ( 2 ) case ( 'Z-mom_abs' ) check = Res_abs ( 3 ) case ( 'Y-mom_abs' ) check = Res_abs ( 4 ) case ( 'Energy_abs' ) check = Res_abs ( 5 ) case ( 'Mass_rel' ) check = Res_rel ( 0 ) case ( 'Resnorm_rel' ) check = sqrt ( sum ( Res_rel ( 1 :) ** 2 )) case ( 'Viscous_rel' ) check = sqrt ( sum ( Res_rel ( 1 : 5 ) ** 2 )) case ( 'Turbulent_rel' ) check = sqrt ( sum ( Res_rel ( 6 :) ** 2 )) case ( 'Continuity_rel' ) check = Res_rel ( 1 ) case ( 'X-mom_rel' ) check = Res_rel ( 2 ) case ( 'Z-mom_rel' ) check = Res_rel ( 3 ) case ( 'Y-mom_rel' ) check = Res_rel ( 4 ) case ( 'Energy_rel' ) check = Res_rel ( 5 ) case ( 'TKE_abs' ) check = Res_abs ( 6 ) case ( 'tv_abs' ) check = Res_abs ( 6 ) case ( 'Dissipation_abs' ) check = Res_abs ( 7 ) case ( 'Omega_abs' ) check = Res_abs ( 7 ) case ( 'Kl_abs' ) check = Res_abs ( 7 ) case ( 'TKE_rel' ) check = Res_rel ( 6 ) case ( 'tv_rel' ) check = Res_rel ( 6 ) case ( 'Dissipation_rel' ) check = Res_rel ( 7 ) case ( 'Omega_rel' ) check = Res_rel ( 7 ) case ( 'Kl_rel' ) check = Res_rel ( 7 ) case DEFAULT ! making absolute resnorm default check = sqrt ( sum ( Res_abs ( 1 :) ** 2 )) Issue_warning end select if ( check < control % tolerance . and . control % current_iter > 10 ) then c = . TRUE . else c = . FALSE . end if end function converged","tags":"","loc":"proc/converged.html","title":"converged – FEST-3D"},{"text":"public subroutine setup_grid(files, nodes, control, bc, dims) Read the grid file and initialize the grid Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Files' name and handler type( nodetype ), intent(out), dimension(:,:,:), allocatable :: nodes Grid points type( controltype ), intent(in) :: control Control parameters type( boundarytype ), intent(inout) :: bc boundary conditions and fixed values type( extent ), intent(out) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~setup_grid~~CallsGraph proc~setup_grid setup_grid proc~ghost_grid ghost_grid proc~setup_grid->proc~ghost_grid proc~extract_grid_size extract_grid_size proc~setup_grid->proc~extract_grid_size debugcall debugcall proc~setup_grid->debugcall proc~read_interface_map read_interface_map proc~setup_grid->proc~read_interface_map proc~populate_grid_points populate_grid_points proc~setup_grid->proc~populate_grid_points proc~ghost_grid->debugcall proc~extract_grid_size->debugcall proc~change_map_to_particular_range change_map_to_particular_range proc~read_interface_map->proc~change_map_to_particular_range proc~read_periodic_bc_file read_periodic_bc_file proc~read_interface_map->proc~read_periodic_bc_file proc~populate_grid_points->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_grid~~CalledByGraph proc~setup_grid setup_grid proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_grid Source Code subroutine setup_grid ( files , nodes , control , bc , dims ) !< Read the grid file and initialize the grid !----------------------------------------------------------- implicit none type ( filetype ), intent ( in ) :: files !< Files' name and handler type ( controltype ), intent ( in ) :: control !< Control parameters type ( boundarytype ), intent ( inout ) :: bc !< boundary conditions and fixed values type ( nodetype ), dimension (:,:,:), allocatable , intent ( out ) :: nodes !< Grid points type ( extent ), intent ( out ) :: dims !< Extent of the domain:imx,jmx,kmx DebugCall ( 'setup_grid' ) open ( files % GRID_FILE_UNIT , file = files % gridfile ) call extract_grid_size ( files % GRID_FILE_UNIT , dims ) ! allocate memory for storing grid points allocate ( nodes ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 )) !read interface mapping call read_interface_map ( files , control , bc , dims ) ! ghost grid exchange call populate_grid_points ( files % GRID_FILE_UNIT , nodes , dims ) close ( files % GRID_FILE_UNIT ) ! populate ghost grid points call ghost_grid ( nodes , dims ) end subroutine setup_grid","tags":"","loc":"proc/setup_grid.html","title":"setup_grid – FEST-3D"},{"text":"private subroutine extract_grid_size(file_handler, dims) Extract the grid size from the grid file header Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler (input)file handling unit type( extent ), intent(out) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~extract_grid_size~~CallsGraph proc~extract_grid_size extract_grid_size debugcall debugcall proc~extract_grid_size->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~extract_grid_size~~CalledByGraph proc~extract_grid_size extract_grid_size proc~setup_grid setup_grid proc~setup_grid->proc~extract_grid_size proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code extract_grid_size Source Code subroutine extract_grid_size ( file_handler , dims ) !< Extract the grid size from the grid file header ! ! We assume that the grid could be in 1 or 2 dimensions. If ! the grid is in 1 dimension, jmx will be set to 1. ! We assume that at least one number is specified in the ! header, i.e., the grid has atleast one dimension. !----------------------------------------------------------- implicit none integer , intent ( in ) :: file_handler !< (input)file handling unit character ( len = STRING_BUFFER_LENGTH ) :: header !< store header type ( extent ), intent ( out ) :: dims !< Extent of the domain:imx,jmx,kmx integer :: ios ! io operation status DebugCall ( 'extract_grid_size' ) read ( file_handler , '(A)' , iostat = ios ) header if ( ios /= 0 ) then print * , 'Error while reading grid file header.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH !stop end if ! Try to read constants corresponding to two dimensions. read ( header , * , iostat = ios ) dims % imx , dims % jmx , dims % kmx if ( ios /= 0 ) then print * , \"Not able to read dimension from the grid file\" print * , \"Make sure you provdie 3D grid\" Fatal_error end if end subroutine extract_grid_size","tags":"","loc":"proc/extract_grid_size.html","title":"extract_grid_size – FEST-3D"},{"text":"private subroutine populate_grid_points(file_handler, nodes, dims) Use the grid file to populate the grid points. Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler (input)file handling unit type( nodetype ), intent(out), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes Grid points type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~populate_grid_points~~CallsGraph proc~populate_grid_points populate_grid_points debugcall debugcall proc~populate_grid_points->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~populate_grid_points~~CalledByGraph proc~populate_grid_points populate_grid_points proc~setup_grid setup_grid proc~setup_grid->proc~populate_grid_points proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code populate_grid_points Source Code subroutine populate_grid_points ( file_handler , nodes , dims ) !< Use the grid file to populate the grid points. !----------------------------------------------------------- implicit none integer , intent ( in ) :: file_handler !< (input)file handling unit type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( out ) :: nodes !< Grid points character ( len = STRING_BUFFER_LENGTH ) :: line !< store read line integer :: i , j , k integer :: ios !< input/output  status DebugCall ( 'populate_grid_point' ) !  print *, imx, jmx, kmx ! Read grid points from the grid file do k = 1 , dims % kmx do j = 1 , dims % jmx do i = 1 , dims % imx read ( file_handler , '(A)' , iostat = ios ) line if ( ios /= 0 ) then print * , 'Error while reading grid line.' print * , 'Current grid point: ' , i , j , k print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH print * , 'Exiting program.' !stop end if !call extract_grid_point(line, i, j, k) read ( line , * ) nodes ( i , j , k )% x , nodes ( i , j , k )% y , nodes ( i , j , k )% z end do end do end do end subroutine populate_grid_points","tags":"","loc":"proc/populate_grid_points.html","title":"populate_grid_points – FEST-3D"},{"text":"private subroutine ghost_grid(nodes, dims) generate ghost grid for the various operations later. Arguments Type Intent Optional Attributes Name type( nodetype ), intent(inout), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes grid points type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~ghost_grid~~CallsGraph proc~ghost_grid ghost_grid debugcall debugcall proc~ghost_grid->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ghost_grid~~CalledByGraph proc~ghost_grid ghost_grid proc~setup_grid setup_grid proc~setup_grid->proc~ghost_grid proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ghost_grid Source Code subroutine ghost_grid ( nodes , dims ) !< generate ghost grid for the various operations later. implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( inout ) :: nodes !< grid points DebugCall ( 'ghost_grid' ) !------------------------------------------------------------------- !getting ghost cell for all faces even if it is a interface cell ! <algorithm> ! Point_ghost = 2*Point_first_inner_cell - Point_second_inner_cell ! </algorithm> !------------------------------------------------------------------- !--- I faces ---! !imin face -> 0 grid point !imin face -> -1 grid point !imin face -> -2 grid point nodes ( 0 ,:,:)% x = 2 * nodes ( 1 ,:,:)% x - nodes ( 2 ,:,:)% x nodes ( 0 ,:,:)% y = 2 * nodes ( 1 ,:,:)% y - nodes ( 2 ,:,:)% y nodes ( 0 ,:,:)% z = 2 * nodes ( 1 ,:,:)% z - nodes ( 2 ,:,:)% z nodes ( - 1 ,:,:)% x = 2 * nodes ( 0 ,:,:)% x - nodes ( 1 ,:,:)% x nodes ( - 1 ,:,:)% y = 2 * nodes ( 0 ,:,:)% y - nodes ( 1 ,:,:)% y nodes ( - 1 ,:,:)% z = 2 * nodes ( 0 ,:,:)% z - nodes ( 1 ,:,:)% z nodes ( - 2 ,:,:)% x = 2 * nodes ( - 1 ,:,:)% x - nodes ( 0 ,:,:)% x nodes ( - 2 ,:,:)% y = 2 * nodes ( - 1 ,:,:)% y - nodes ( 0 ,:,:)% y nodes ( - 2 ,:,:)% z = 2 * nodes ( - 1 ,:,:)% z - nodes ( 0 ,:,:)% z !imax face -> imx+1 grid point !imax face -> imx+2 grid point !imax face -> imx+3 grid point nodes ( dims % imx + 1 ,:,:)% x = 2 * nodes ( dims % imx + 0 ,:,:)% x - nodes ( dims % imx - 1 ,:,:)% x nodes ( dims % imx + 1 ,:,:)% y = 2 * nodes ( dims % imx + 0 ,:,:)% y - nodes ( dims % imx - 1 ,:,:)% y nodes ( dims % imx + 1 ,:,:)% z = 2 * nodes ( dims % imx + 0 ,:,:)% z - nodes ( dims % imx - 1 ,:,:)% z nodes ( dims % imx + 2 ,:,:)% x = 2 * nodes ( dims % imx + 1 ,:,:)% x - nodes ( dims % imx - 0 ,:,:)% x nodes ( dims % imx + 2 ,:,:)% y = 2 * nodes ( dims % imx + 1 ,:,:)% y - nodes ( dims % imx - 0 ,:,:)% y nodes ( dims % imx + 2 ,:,:)% z = 2 * nodes ( dims % imx + 1 ,:,:)% z - nodes ( dims % imx - 0 ,:,:)% z nodes ( dims % imx + 3 ,:,:)% x = 2 * nodes ( dims % imx + 2 ,:,:)% x - nodes ( dims % imx + 1 ,:,:)% x nodes ( dims % imx + 3 ,:,:)% y = 2 * nodes ( dims % imx + 2 ,:,:)% y - nodes ( dims % imx + 1 ,:,:)% y nodes ( dims % imx + 3 ,:,:)% z = 2 * nodes ( dims % imx + 2 ,:,:)% z - nodes ( dims % imx + 1 ,:,:)% z !--- Jmin faces ---! !jmin faces -> 0 grid point !jmin face -> -1 grid point !jmin face -> -2 grid point nodes (:, 0 ,:)% x = 2 * nodes (:, 1 ,:)% x - nodes (:, 2 ,:)% x nodes (:, 0 ,:)% y = 2 * nodes (:, 1 ,:)% y - nodes (:, 2 ,:)% y nodes (:, 0 ,:)% z = 2 * nodes (:, 1 ,:)% z - nodes (:, 2 ,:)% z nodes (:, - 1 ,:)% x = 2 * nodes (:, 0 ,:)% x - nodes (:, 1 ,:)% x nodes (:, - 1 ,:)% y = 2 * nodes (:, 0 ,:)% y - nodes (:, 1 ,:)% y nodes (:, - 1 ,:)% z = 2 * nodes (:, 0 ,:)% z - nodes (:, 1 ,:)% z nodes (:, - 2 ,:)% x = 2 * nodes (:, - 1 ,:)% x - nodes (:, 0 ,:)% x nodes (:, - 2 ,:)% y = 2 * nodes (:, - 1 ,:)% y - nodes (:, 0 ,:)% y nodes (:, - 2 ,:)% z = 2 * nodes (:, - 1 ,:)% z - nodes (:, 0 ,:)% z !jmax face -> jmx+1 grid point !jmax face -> jmx+3 grid point !jmax face -> jmx+2 grid point nodes (:, dims % jmx + 1 ,:)% x = 2 * nodes (:, dims % jmx + 0 ,:)% x - nodes (:, dims % jmx - 1 ,:)% x nodes (:, dims % jmx + 1 ,:)% y = 2 * nodes (:, dims % jmx + 0 ,:)% y - nodes (:, dims % jmx - 1 ,:)% y nodes (:, dims % jmx + 1 ,:)% z = 2 * nodes (:, dims % jmx + 0 ,:)% z - nodes (:, dims % jmx - 1 ,:)% z nodes (:, dims % jmx + 2 ,:)% x = 2 * nodes (:, dims % jmx + 1 ,:)% x - nodes (:, dims % jmx - 0 ,:)% x nodes (:, dims % jmx + 2 ,:)% y = 2 * nodes (:, dims % jmx + 1 ,:)% y - nodes (:, dims % jmx - 0 ,:)% y nodes (:, dims % jmx + 2 ,:)% z = 2 * nodes (:, dims % jmx + 1 ,:)% z - nodes (:, dims % jmx - 0 ,:)% z nodes (:, dims % jmx + 3 ,:)% x = 2 * nodes (:, dims % jmx + 2 ,:)% x - nodes (:, dims % jmx + 1 ,:)% x nodes (:, dims % jmx + 3 ,:)% y = 2 * nodes (:, dims % jmx + 2 ,:)% y - nodes (:, dims % jmx + 1 ,:)% y nodes (:, dims % jmx + 3 ,:)% z = 2 * nodes (:, dims % jmx + 2 ,:)% z - nodes (:, dims % jmx + 1 ,:)% z !--- Kmax faces ---! !kmin faces -> 0 grid point !kmin face -> -1 grid point !kmin face -> -2 grid point nodes (:,:, 0 )% x = 2 * nodes (:,:, 1 )% x - nodes (:,:, 2 )% x nodes (:,:, 0 )% y = 2 * nodes (:,:, 1 )% y - nodes (:,:, 2 )% y nodes (:,:, 0 )% z = 2 * nodes (:,:, 1 )% z - nodes (:,:, 2 )% z nodes (:,:, - 1 )% x = 2 * nodes (:,:, 0 )% x - nodes (:,:, 1 )% x nodes (:,:, - 1 )% y = 2 * nodes (:,:, 0 )% y - nodes (:,:, 1 )% y nodes (:,:, - 1 )% z = 2 * nodes (:,:, 0 )% z - nodes (:,:, 1 )% z nodes (:,:, - 2 )% x = 2 * nodes (:,:, - 1 )% x - nodes (:,:, 0 )% x nodes (:,:, - 2 )% y = 2 * nodes (:,:, - 1 )% y - nodes (:,:, 0 )% y nodes (:,:, - 2 )% z = 2 * nodes (:,:, - 1 )% z - nodes (:,:, 0 )% z !kmax face -> kmx+1 grid point !kmax face -> kmx+2 grid point !kmax face -> kmx+3 grid point nodes (:,:, dims % kmx + 1 )% x = 2 * nodes (:,:, dims % kmx + 0 )% x - nodes (:,:, dims % kmx - 1 )% x nodes (:,:, dims % kmx + 1 )% y = 2 * nodes (:,:, dims % kmx + 0 )% y - nodes (:,:, dims % kmx - 1 )% y nodes (:,:, dims % kmx + 1 )% z = 2 * nodes (:,:, dims % kmx + 0 )% z - nodes (:,:, dims % kmx - 1 )% z nodes (:,:, dims % kmx + 2 )% x = 2 * nodes (:,:, dims % kmx + 1 )% x - nodes (:,:, dims % kmx - 0 )% x nodes (:,:, dims % kmx + 2 )% y = 2 * nodes (:,:, dims % kmx + 1 )% y - nodes (:,:, dims % kmx - 0 )% y nodes (:,:, dims % kmx + 2 )% z = 2 * nodes (:,:, dims % kmx + 1 )% z - nodes (:,:, dims % kmx - 0 )% z nodes (:,:, dims % kmx + 3 )% x = 2 * nodes (:,:, dims % kmx + 2 )% x - nodes (:,:, dims % kmx + 1 )% x nodes (:,:, dims % kmx + 3 )% y = 2 * nodes (:,:, dims % kmx + 2 )% y - nodes (:,:, dims % kmx + 1 )% y nodes (:,:, dims % kmx + 3 )% z = 2 * nodes (:,:, dims % kmx + 2 )% z - nodes (:,:, dims % kmx + 1 )% z end subroutine ghost_grid","tags":"","loc":"proc/ghost_grid.html","title":"ghost_grid – FEST-3D"},{"text":"public function Flux(ql, qr, du, inputs) calculate the total flux through face for laminar flow. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:7) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Contents Source Code Flux Source Code function Flux ( ql , qr , du , inputs ) !< calculate the total flux through face for laminar flow. !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 1 : 5 ) = U ( 1 : 5 ) + du ( 1 : 5 ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux = Flux * Area end function Flux","tags":"","loc":"proc/flux~2.html","title":"Flux – FEST-3D"},{"text":"public function SpectralRadius(ql, qr, inputs, c1, c2) Calculate the spectral radius Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:7) :: inputs real(kind=wp), intent(in), dimension(1:3) :: c1 real(kind=wp), intent(in), dimension(1:3) :: c2 Return Value real(kind=wp) Called by proc~~spectralradius~2~~CalledByGraph proc~spectralradius~2 SpectralRadius proc~update_sa_variables~2 update_SA_variables proc~update_sa_variables~2->proc~spectralradius~2 proc~update_kkl_variables update_KKL_variables proc~update_kkl_variables->proc~spectralradius~2 proc~update_sst_variables~2 update_SST_variables proc~update_sst_variables~2->proc~spectralradius~2 proc~update_lctm2015~2 update_lctm2015 proc~update_lctm2015~2->proc~spectralradius~2 proc~update_laminar_variables~2 update_laminar_variables proc~update_laminar_variables~2->proc~spectralradius~2 proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_sa_variables~2 proc~update_with_lusgs->proc~update_kkl_variables proc~update_with_lusgs->proc~update_sst_variables~2 proc~update_with_lusgs->proc~update_lctm2015~2 proc~update_with_lusgs->proc~update_laminar_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocspectralradius2CalledByGraph = svgPanZoom('#procspectralradius2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SpectralRadius Source Code function SpectralRadius ( ql , qr , inputs , c1 , c2 ) !< Calculate the spectral radius implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : 3 ) , intent ( in ) :: c1 real ( wp ), dimension ( 1 : 3 ) , intent ( in ) :: c2 ! local variables real ( wp ) :: SpectralRadius real ( wp ) :: NormalSpeed real ( wp ) :: SpeedOfSound real ( wp ) :: vis real ( wp ) :: mu real ( wp ) :: rho real ( wp ) :: distance !extract inputs real ( wp ) :: Area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mm real ( wp ) :: tm Area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mm = inputs ( 6 ) tm = inputs ( 7 ) ! in state vector q (2-4) are the cell center velocity NormalSpeed = 0.5 * ( ( ( ql ( 2 ) + qr ( 2 ) ) * nx ) & + ( ( ql ( 3 ) + qr ( 3 ) ) * ny ) & + ( ( ql ( 4 ) + qr ( 4 ) ) * nz ) & ) NormalSpeed = abs ( NormalSpeed ) SpeedOfSound = 0.5 * ( sqrt ( gm * ql ( 5 ) / ql ( 1 )) + sqrt ( gm * qr ( 5 ) / qr ( 1 )) ) ! visocus part mu = mm / Pr + tm / tPr rho = 0.5 * ( ql ( 1 ) + qr ( 1 ) ) distance = sqrt (( c1 ( 1 ) - c2 ( 1 )) ** 2 + ( c1 ( 2 ) - c2 ( 2 )) ** 2 + ( c1 ( 3 ) - c2 ( 3 )) ** 2 ) vis = gm * ( mm / pr + tm / tpr ) / ( rho * distance ) SpectralRadius = ( NormalSpeed + SpeedOfSound + vis ) * Area end function SpectralRadius","tags":"","loc":"proc/spectralradius~2.html","title":"SpectralRadius – FEST-3D"},{"text":"public function SSTFlux(ql, qr, du, inputs) calculate the total flux through face for turbulent flow (SST) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:8) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Called by proc~~sstflux~2~~CalledByGraph proc~sstflux~2 SSTFlux proc~update_sst_variables~2 update_SST_variables proc~update_sst_variables~2->proc~sstflux~2 proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_sst_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsstflux2CalledByGraph = svgPanZoom('#procsstflux2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SSTFlux Source Code function SSTFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (SST) implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 8 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: SSTFlux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtkdx real ( wp ) :: dtkdy real ( wp ) :: dtkdz real ( wp ) :: dtwdx real ( wp ) :: dtwdy real ( wp ) :: dtwdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: sigma_k real ( wp ) :: sigma_w real ( wp ) :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux = Flux * Area SSTFlux = Flux end function SSTFlux","tags":"","loc":"proc/sstflux~2.html","title":"SSTFlux – FEST-3D"},{"text":"public function KKLFlux(ql, qr, du, inputs) calculate the total flux through face for turbulent flow (k-kL) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:7) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Called by proc~~kklflux~~CalledByGraph proc~kklflux KKLFlux proc~update_kkl_variables update_KKL_variables proc~update_kkl_variables->proc~kklflux proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_kkl_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprockklfluxCalledByGraph = svgPanZoom('#prockklfluxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code KKLFlux Source Code function KKLFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (k-kL) implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: KKLFlux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtkdx real ( wp ) :: dtkdy real ( wp ) :: dtkdz real ( wp ) :: dtkldx real ( wp ) :: dtkldy real ( wp ) :: dtkldz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) W ( 7 ) = max ( W ( 7 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtkldx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtkldy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtkldz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_phi * tmu ) * ( dtkldx * nx + dtkldy * ny + dtkldz * nz ) Flux = Flux * Area KKLFlux = Flux end function KKLFlux","tags":"","loc":"proc/kklflux.html","title":"KKLFlux – FEST-3D"},{"text":"public function SAFlux(ql, qr, du, inputs) calculate the total flux through face for turbulent flow (SA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:7) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Called by proc~~saflux~2~~CalledByGraph proc~saflux~2 SAFlux proc~update_sa_variables~2 update_SA_variables proc~update_sa_variables~2->proc~saflux~2 proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_sa_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsaflux2CalledByGraph = svgPanZoom('#procsaflux2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SAFlux Source Code function SAFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (SA) !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 7 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: SAFlux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtvdx real ( wp ) :: dtvdy real ( wp ) :: dtvdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: muCap area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) ! viscous terms muCap = 0.25 * ( P ( 1 ) + W ( 1 )) * ( P ( 6 ) + W ( 6 )) mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtvdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtvdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtvdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz tmu = 0.5 * ( W ( 6 ) + P ( 6 )) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + muCap ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ) / sigma_sa Flux = Flux * Area SAFlux = Flux end function SAFlux","tags":"","loc":"proc/saflux~2.html","title":"SAFlux – FEST-3D"},{"text":"public function lctm2015flux(ql, qr, du, inputs) calculate the total flux through face for turbulent/transition flow (LCTM2015) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:8) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Called by proc~~lctm2015flux~2~~CalledByGraph proc~lctm2015flux~2 lctm2015flux proc~update_lctm2015~2 update_lctm2015 proc~update_lctm2015~2->proc~lctm2015flux~2 proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_lctm2015~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproclctm2015flux2CalledByGraph = svgPanZoom('#proclctm2015flux2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code lctm2015flux Source Code function lctm2015flux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent/transition flow (LCTM2015) !--------------------------------------- implicit none real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: ql !left state real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real ( wp ), dimension ( 1 : n_var ), intent ( in ) :: du real ( wp ), dimension ( 1 : 8 ) , intent ( in ) :: inputs real ( wp ), dimension ( 1 : n_var ) :: Flux real ( wp ), dimension ( 1 : n_var ) :: lctm2015flux real ( wp ), dimension ( 1 : n_var ) :: U ! conservative variables real ( wp ), dimension ( 1 : n_var ) :: W ! new primitive variables real ( wp ), dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real ( wp ) :: area real ( wp ) :: nx real ( wp ) :: ny real ( wp ) :: nz real ( wp ) :: volume real ( wp ) :: mmu real ( wp ) :: tmu real ( wp ) :: dudx real ( wp ) :: dudy real ( wp ) :: dudz real ( wp ) :: dvdx real ( wp ) :: dvdy real ( wp ) :: dvdz real ( wp ) :: dwdx real ( wp ) :: dwdy real ( wp ) :: dwdz real ( wp ) :: dTdx real ( wp ) :: dTdy real ( wp ) :: dTdz real ( wp ) :: dtkdx real ( wp ) :: dtkdy real ( wp ) :: dtkdz real ( wp ) :: dtwdx real ( wp ) :: dtwdy real ( wp ) :: dtwdz real ( wp ) :: dtgmdx real ( wp ) :: dtgmdy real ( wp ) :: dtgmdz real ( wp ) :: T1 , T2 real ( wp ) :: uface real ( wp ) :: vface real ( wp ) :: wface real ( wp ) :: trace real ( wp ) :: Tauxx real ( wp ) :: Tauyy real ( wp ) :: Tauzz real ( wp ) :: Tauxy real ( wp ) :: Tauxz real ( wp ) :: Tauyz real ( wp ) :: Qx real ( wp ) :: Qy real ( wp ) :: Qz real ( wp ) :: HalfRhoUsquare real ( wp ) :: RhoHt real ( wp ) :: K_heat real ( wp ) :: FaceNormalVelocity real ( wp ) :: mu real ( wp ) :: sigma_k real ( wp ) :: sigma_w real ( wp ) :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 8 ) = ql ( 1 ) * ql ( 8 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 8 ) = U ( 8 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) W ( 8 ) = max ( W ( 8 ), 0.0 ) !W(8) = min(W(8), 1.0) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) Flux ( 8 ) = ( W ( 8 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume dtgmdx = ( P ( 8 ) - W ( 8 ) ) * nx * Area / Volume dtgmdy = ( P ( 8 ) - W ( 8 ) ) * ny * Area / Volume dtgmdz = ( P ( 8 ) - W ( 8 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux ( 8 ) = Flux ( 8 ) + ( mmu + tmu ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ) Flux = Flux * Area lctm2015flux = Flux end function lctm2015flux","tags":"","loc":"proc/lctm2015flux~2.html","title":"lctm2015flux – FEST-3D"},{"text":"public subroutine setup_lusgs(control, scheme, flow, dims) allocate array memory for data communication Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~setup_lusgs~~CallsGraph proc~setup_lusgs setup_lusgs interface~alloc alloc proc~setup_lusgs->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_lusgs~~CalledByGraph proc~setup_lusgs setup_lusgs proc~setup_update setup_update proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_update proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_lusgs Source Code subroutine setup_lusgs ( control , scheme , flow , dims ) !< allocate array memory for data communication implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx character ( len =* ), parameter :: errmsg = \"module: LUSGS, subrouinte setup\" !< Error message imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var gm = flow % gm mu_ref = flow % mu_ref Reynolds_number = flow % Reynolds_number free_stream_tu = flow % tu_inf tk_inf = flow % tk_inf tkl_inf = flow % tkl_inf tpr = flow % tpr pr = flow % pr R_gas = flow % R_gas call alloc ( delQ , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) call alloc ( delQstar , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) if ( mu_ref == 0.0 . or . scheme % turbulence == 'none' ) then call alloc ( dummy , 0 , imx , 0 , jmx , 0 , kmx ) dummy = 0.0 end if if ( mu_ref == 0.0 ) then mmu => dummy else mmu => mu end if if ( trim ( scheme % turbulence ) == 'none' ) then tmu => dummy else tmu => mu_t end if end subroutine setup_lusgs","tags":"","loc":"proc/setup_lusgs.html","title":"setup_lusgs – FEST-3D"},{"text":"public subroutine update_with_lusgs(qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, scheme, dims) Time-integrate with LU_SGS method Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( schemetype ), intent(in) :: scheme finite-volume Schemes type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_with_lusgs~~CallsGraph proc~update_with_lusgs update_with_lusgs proc~update_laminar_variables~2 update_laminar_variables proc~update_with_lusgs->proc~update_laminar_variables~2 proc~update_sa_variables~2 update_SA_variables proc~update_with_lusgs->proc~update_sa_variables~2 proc~update_lctm2015~2 update_lctm2015 proc~update_with_lusgs->proc~update_lctm2015~2 proc~update_kkl_variables update_KKL_variables proc~update_with_lusgs->proc~update_kkl_variables proc~update_sst_variables~2 update_SST_variables proc~update_with_lusgs->proc~update_sst_variables~2 debugcall debugcall proc~update_with_lusgs->debugcall proc~update_laminar_variables~2->debugcall proc~spectralradius~2 SpectralRadius proc~update_laminar_variables~2->proc~spectralradius~2 proc~update_sa_variables~2->proc~spectralradius~2 proc~saflux~2 SAFlux proc~update_sa_variables~2->proc~saflux~2 proc~update_lctm2015~2->proc~spectralradius~2 proc~lctm2015flux~2 lctm2015flux proc~update_lctm2015~2->proc~lctm2015flux~2 proc~update_kkl_variables->proc~spectralradius~2 proc~kklflux KKLFlux proc~update_kkl_variables->proc~kklflux proc~update_sst_variables~2->proc~spectralradius~2 proc~sstflux~2 SSTFlux proc~update_sst_variables~2->proc~sstflux~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_with_lusgs~~CalledByGraph proc~update_with_lusgs update_with_lusgs proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_with_lusgs Source Code subroutine update_with_lusgs ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , scheme , dims ) !< Time-integrate with LU_SGS method implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal DebugCall ( \"Update_with_lusgs\" ) select case ( trim ( scheme % turbulence )) case ( 'none' ) call update_laminar_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'sst' , 'sst2003' ) select case ( trim ( scheme % transition )) case ( 'none' , 'bc' ) call update_SST_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'lctm2015' ) call update_lctm2015 ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case DEFAULT Fatal_error end select case ( 'kkl' ) call update_KKL_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case ( 'sa' , 'saBC' ) call update_SA_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) case Default Fatal_error end select end subroutine update_with_lusgs","tags":"","loc":"proc/update_with_lusgs.html","title":"update_with_lusgs – FEST-3D"},{"text":"public subroutine update_laminar_variables(qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update laminar flow with LU-SGS scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_laminar_variables~2~~CallsGraph proc~update_laminar_variables~2 update_laminar_variables proc~spectralradius~2 SpectralRadius proc~update_laminar_variables~2->proc~spectralradius~2 debugcall debugcall proc~update_laminar_variables~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_laminar_variables~2~~CalledByGraph proc~update_laminar_variables~2 update_laminar_variables proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_laminar_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_laminar_variables2CalledByGraph = svgPanZoom('#procupdate_laminar_variables2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_laminar_variables Source Code subroutine update_laminar_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update laminar flow with LU-SGS scheme implicit none integer :: i , j , k type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal real ( wp ), dimension ( 1 : 5 ) :: deltaU real ( wp ) :: D real ( wp ), dimension ( 1 : 5 ) :: conservativeQ real ( wp ), dimension ( 1 : 5 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 5 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 5 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 5 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 5 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 5 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 5 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 5 ) :: Q2 real ( wp ), dimension ( 1 : 5 ) :: Q3 real ( wp ), dimension ( 1 : 5 ) :: Q4 real ( wp ), dimension ( 1 : 5 ) :: Q5 real ( wp ), dimension ( 1 : 5 ) :: Q6 real ( wp ), dimension ( 1 : 5 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 5 ) :: DQ1 real ( wp ), dimension ( 1 : 5 ) :: DQ2 real ( wp ), dimension ( 1 : 5 ) :: DQ3 real ( wp ), dimension ( 1 : 5 ) :: DQ4 real ( wp ), dimension ( 1 : 5 ) :: DQ5 real ( wp ), dimension ( 1 : 5 ) :: DQ6 real ( wp ), dimension ( 1 : 7 ) :: Flist1 real ( wp ), dimension ( 1 : 7 ) :: Flist2 real ( wp ), dimension ( 1 : 7 ) :: Flist3 real ( wp ), dimension ( 1 : 7 ) :: Flist4 real ( wp ), dimension ( 1 : 7 ) :: Flist5 real ( wp ), dimension ( 1 : 7 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 DebugCall ( \"Update_with_lusgs\" ) !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 5 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 5 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 5 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = Flux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 5 ) = - residue ( i , j , k , 1 : 5 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 5 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 5 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 5 )) ) delQstar ( i , j , k , 1 : 5 ) = deltaU ( 1 : 5 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 5 ) DQ5 = delQ ( i , j + 1 , k , 1 : 5 ) DQ6 = delQ ( i , j , k + 1 , 1 : 5 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = Flux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) delQ ( i , j , k , 1 : 5 ) = delQstar ( i , j , k , 1 : 5 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 5 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 5 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 5 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) ! add new change into conservative solution conservativeQ ( 1 : 5 ) = conservativeQ ( 1 : 5 ) + delQ ( i , j , k , 1 : 5 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) end do end do end do end subroutine update_laminar_variables","tags":"","loc":"proc/update_laminar_variables~2.html","title":"update_laminar_variables – FEST-3D"},{"text":"public subroutine update_SST_variables(qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (SST) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_sst_variables~2~~CallsGraph proc~update_sst_variables~2 update_SST_variables proc~spectralradius~2 SpectralRadius proc~update_sst_variables~2->proc~spectralradius~2 proc~sstflux~2 SSTFlux proc~update_sst_variables~2->proc~sstflux~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_sst_variables~2~~CalledByGraph proc~update_sst_variables~2 update_SST_variables proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_sst_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_sst_variables2CalledByGraph = svgPanZoom('#procupdate_sst_variables2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_SST_variables Source Code subroutine update_SST_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (SST) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 7 ) :: deltaU real ( wp ), dimension ( 1 : 7 ) :: D real ( wp ), dimension ( 1 : 7 ) :: conservativeQ real ( wp ), dimension ( 1 : 7 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 7 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 7 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 7 ) :: Q2 real ( wp ), dimension ( 1 : 7 ) :: Q3 real ( wp ), dimension ( 1 : 7 ) :: Q4 real ( wp ), dimension ( 1 : 7 ) :: Q5 real ( wp ), dimension ( 1 : 7 ) :: Q6 real ( wp ), dimension ( 1 : 7 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 7 ) :: DQ1 real ( wp ), dimension ( 1 : 7 ) :: DQ2 real ( wp ), dimension ( 1 : 7 ) :: DQ3 real ( wp ), dimension ( 1 : 7 ) :: DQ4 real ( wp ), dimension ( 1 : 7 ) :: DQ5 real ( wp ), dimension ( 1 : 7 ) :: DQ6 real ( wp ), dimension ( 1 : 8 ) :: Flist1 real ( wp ), dimension ( 1 : 8 ) :: Flist2 real ( wp ), dimension ( 1 : 8 ) :: Flist3 real ( wp ), dimension ( 1 : 8 ) :: Flist4 real ( wp ), dimension ( 1 : 8 ) :: Flist5 real ( wp ), dimension ( 1 : 8 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: beta ! intermittency real ( wp ) :: De , Dp De = 0.0 Dp = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SSTFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SSTFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SSTFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SSTFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SSTFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - ( residue ( i , j , k , 1 : 7 )) & - 0.5 * ((( DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + (( DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + (( DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SSTFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SSTFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SSTFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SSTFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SSTFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * ((( DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + (( DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + (( DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if end do end do end do end subroutine update_SST_variables","tags":"","loc":"proc/update_sst_variables~2.html","title":"update_SST_variables – FEST-3D"},{"text":"public subroutine update_KKL_variables(qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (k-kL) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_kkl_variables~~CallsGraph proc~update_kkl_variables update_KKL_variables proc~spectralradius~2 SpectralRadius proc~update_kkl_variables->proc~spectralradius~2 proc~kklflux KKLFlux proc~update_kkl_variables->proc~kklflux Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_kkl_variables~~CalledByGraph proc~update_kkl_variables update_KKL_variables proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_kkl_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_kkl_variablesCalledByGraph = svgPanZoom('#procupdate_kkl_variablesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_KKL_variables Source Code subroutine update_KKL_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (k-kL) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 7 ) :: deltaU real ( wp ), dimension ( 1 : 7 ) :: D real ( wp ), dimension ( 1 : 7 ) :: conservativeQ real ( wp ), dimension ( 1 : 7 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 7 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 7 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 7 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 7 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 7 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 7 ) :: Q2 real ( wp ), dimension ( 1 : 7 ) :: Q3 real ( wp ), dimension ( 1 : 7 ) :: Q4 real ( wp ), dimension ( 1 : 7 ) :: Q5 real ( wp ), dimension ( 1 : 7 ) :: Q6 real ( wp ), dimension ( 1 : 7 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 7 ) :: DQ1 real ( wp ), dimension ( 1 : 7 ) :: DQ2 real ( wp ), dimension ( 1 : 7 ) :: DQ3 real ( wp ), dimension ( 1 : 7 ) :: DQ4 real ( wp ), dimension ( 1 : 7 ) :: DQ5 real ( wp ), dimension ( 1 : 7 ) :: DQ6 real ( wp ), dimension ( 1 : 7 ) :: Flist1 real ( wp ), dimension ( 1 : 7 ) :: Flist2 real ( wp ), dimension ( 1 : 7 ) :: Flist3 real ( wp ), dimension ( 1 : 7 ) :: Flist4 real ( wp ), dimension ( 1 : 7 ) :: Flist5 real ( wp ), dimension ( 1 : 7 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = KKLFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = KKLFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = KKLFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = KKLFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = KKLFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = KKLFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) D ( 6 ) = D ( 6 ) + ( 2.5 * ( cmu ** ( 0.75 )) * Q0 ( 1 ) * ( Q0 ( 6 ) ** ( 1.5 )) * cells ( i , j , k )% volume / Q0 ( 7 )) D ( 6 ) = D ( 6 ) + ( 2 * mmu ( i , j , k ) * cells ( i , j , k )% volume / ( dist ( i , j , k ) ** 2 )) D ( 7 ) = D ( 7 ) + ( 6 * mmu ( i , j , k ) * cells ( i , j , k )% volume / ( dist ( i , j , k ) ** 2 )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - residue ( i , j , k , 1 : 7 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = KKLFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = KKLFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = KKLFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = KKLFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = KKLFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = KKLFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) D ( 6 ) = D ( 6 ) + ( 2.5 * ( cmu ** ( 0.75 )) * Q0 ( 1 ) * ( Q0 ( 6 ) ** ( 1.5 )) * cells ( i , j , k )% volume / Q0 ( 7 )) D ( 6 ) = D ( 6 ) + ( 2 * mmu ( i , j , k ) * cells ( i , j , k )% volume / ( dist ( i , j , k ) ** 2 )) D ( 7 ) = D ( 7 ) + ( 6 * mmu ( i , j , k ) * cells ( i , j , k )% volume / ( dist ( i , j , k ) ** 2 )) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) qp ( i , j , k , 7 ) = max ( qp ( i , j , k , 7 ), 1.e-8 ) end do end do end do end subroutine update_KKL_variables","tags":"","loc":"proc/update_kkl_variables.html","title":"update_KKL_variables – FEST-3D"},{"text":"public subroutine update_SA_variables(qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (SA) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_sa_variables~2~~CallsGraph proc~update_sa_variables~2 update_SA_variables proc~spectralradius~2 SpectralRadius proc~update_sa_variables~2->proc~spectralradius~2 proc~saflux~2 SAFlux proc~update_sa_variables~2->proc~saflux~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_sa_variables~2~~CalledByGraph proc~update_sa_variables~2 update_SA_variables proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_sa_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_sa_variables2CalledByGraph = svgPanZoom('#procupdate_sa_variables2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_SA_variables Source Code subroutine update_SA_variables ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (SA) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 6 ) :: deltaU real ( wp ), dimension ( 1 : 6 ) :: D real ( wp ), dimension ( 1 : 6 ) :: conservativeQ real ( wp ), dimension ( 1 : 6 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 6 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 6 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 6 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 6 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 6 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 6 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 6 ) :: Q2 real ( wp ), dimension ( 1 : 6 ) :: Q3 real ( wp ), dimension ( 1 : 6 ) :: Q4 real ( wp ), dimension ( 1 : 6 ) :: Q5 real ( wp ), dimension ( 1 : 6 ) :: Q6 real ( wp ), dimension ( 1 : 6 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 6 ) :: DQ1 real ( wp ), dimension ( 1 : 6 ) :: DQ2 real ( wp ), dimension ( 1 : 6 ) :: DQ3 real ( wp ), dimension ( 1 : 6 ) :: DQ4 real ( wp ), dimension ( 1 : 6 ) :: DQ5 real ( wp ), dimension ( 1 : 6 ) :: DQ6 real ( wp ), dimension ( 1 : 7 ) :: Flist1 real ( wp ), dimension ( 1 : 7 ) :: Flist2 real ( wp ), dimension ( 1 : 7 ) :: Flist3 real ( wp ), dimension ( 1 : 7 ) :: Flist4 real ( wp ), dimension ( 1 : 7 ) :: Flist5 real ( wp ), dimension ( 1 : 7 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: fv1 real ( wp ) :: fv2 real ( wp ) :: fw real ( wp ) :: g real ( wp ) :: r real ( wp ) :: dist_i real ( wp ) :: dist_i_2 real ( wp ) :: Ji real ( wp ) :: Ji_2 real ( wp ) :: Ji_3 real ( wp ) :: S real ( wp ) :: Omega real ( wp ) :: k2 real ( wp ) :: inv_k2_d2 real ( wp ) :: Shat real ( wp ) :: inv_Shat real ( wp ) :: nu real ( wp ) :: glim real ( wp ) :: g_6 real ( wp ) :: dfv1 real ( wp ) :: dfv2 real ( wp ) :: dfw real ( wp ) :: dShat real ( wp ) :: dr real ( wp ) :: dg real ( wp ) :: density !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 6 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 6 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 6 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SAFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SAFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SAFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SAFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SAFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * cells ( i , j , k )% volume ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * cells ( i , j , k )% volume ! --  end of source term -- ! deltaU ( 1 : 6 ) = - residue ( i , j , k , 1 : 6 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 6 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 6 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 6 )) ) delQstar ( i , j , k , 1 : 6 ) = deltaU ( 1 : 6 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 6 ) DQ5 = delQ ( i , j + 1 , k , 1 : 6 ) DQ6 = delQ ( i , j , k + 1 , 1 : 6 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SAFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SAFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SAFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SAFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SAFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * cells ( i , j , k )% volume ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * cells ( i , j , k )% volume ! --  end of source term -- ! delQ ( i , j , k , 1 : 6 ) = delQstar ( i , j , k , 1 : 6 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 6 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 6 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 6 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) ! add new change into conservative solution conservativeQ ( 1 : 6 ) = conservativeQ ( 1 : 6 ) + delQ ( i , j , k , 1 : 6 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) end do end do end do end subroutine update_SA_variables","tags":"","loc":"proc/update_sa_variables~2.html","title":"update_SA_variables – FEST-3D"},{"text":"public subroutine update_lctm2015(qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (LCTM2015 transition model with SST2003) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~update_lctm2015~2~~CallsGraph proc~update_lctm2015~2 update_lctm2015 proc~spectralradius~2 SpectralRadius proc~update_lctm2015~2->proc~spectralradius~2 proc~lctm2015flux~2 lctm2015flux proc~update_lctm2015~2->proc~lctm2015flux~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_lctm2015~2~~CalledByGraph proc~update_lctm2015~2 update_lctm2015 proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_lctm2015~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_lctm20152CalledByGraph = svgPanZoom('#procupdate_lctm20152CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_lctm2015 Source Code subroutine update_lctm2015 ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , dims ) !< Update the RANS (LCTM2015 transition model with SST2003) equation with LU-SGS implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ) , dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal integer :: i , j , k real ( wp ), dimension ( 1 : 8 ) :: deltaU real ( wp ), dimension ( 1 : 8 ) :: D real ( wp ), dimension ( 1 : 8 ) :: conservativeQ real ( wp ), dimension ( 1 : 8 ) :: OldIminusFlux real ( wp ), dimension ( 1 : 8 ) :: OldJminusFlux real ( wp ), dimension ( 1 : 8 ) :: OldKminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewIminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewJminusFlux real ( wp ), dimension ( 1 : 8 ) :: NewKminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelIminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelJminusFlux real ( wp ), dimension ( 1 : 8 ) :: DelKminusFlux real ( wp ), dimension ( 1 : 6 ) :: LambdaTimesArea real ( wp ), dimension ( 1 : 8 ) :: Q0 ! state at cell real ( wp ), dimension ( 1 : 8 ) :: Q1 ! state at neighbours real ( wp ), dimension ( 1 : 8 ) :: Q2 real ( wp ), dimension ( 1 : 8 ) :: Q3 real ( wp ), dimension ( 1 : 8 ) :: Q4 real ( wp ), dimension ( 1 : 8 ) :: Q5 real ( wp ), dimension ( 1 : 8 ) :: Q6 real ( wp ), dimension ( 1 : 8 ) :: DQ0 ! change in state real ( wp ), dimension ( 1 : 8 ) :: DQ1 real ( wp ), dimension ( 1 : 8 ) :: DQ2 real ( wp ), dimension ( 1 : 8 ) :: DQ3 real ( wp ), dimension ( 1 : 8 ) :: DQ4 real ( wp ), dimension ( 1 : 8 ) :: DQ5 real ( wp ), dimension ( 1 : 8 ) :: DQ6 real ( wp ), dimension ( 1 : 8 ) :: Flist1 real ( wp ), dimension ( 1 : 8 ) :: Flist2 real ( wp ), dimension ( 1 : 8 ) :: Flist3 real ( wp ), dimension ( 1 : 8 ) :: Flist4 real ( wp ), dimension ( 1 : 8 ) :: Flist5 real ( wp ), dimension ( 1 : 8 ) :: Flist6 real ( wp ), dimension ( 1 : 3 ) :: C0 real ( wp ), dimension ( 1 : 3 ) :: C1 real ( wp ), dimension ( 1 : 3 ) :: C2 real ( wp ), dimension ( 1 : 3 ) :: C3 real ( wp ), dimension ( 1 : 3 ) :: C4 real ( wp ), dimension ( 1 : 3 ) :: C5 real ( wp ), dimension ( 1 : 3 ) :: C6 real ( wp ) :: beta ! intermittency real ( wp ) :: Fonset1 real ( wp ) :: Fonset2 real ( wp ) :: Fonset3 real ( wp ) :: Fonset real ( wp ) :: Rev real ( wp ) :: RT real ( wp ) :: Fturb real ( wp ) :: Re_theta real ( wp ) :: TuL real ( wp ) :: strain real ( wp ) :: vort real ( wp ) :: Dp , De real ( wp ) :: density Dp = 0.0 De = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 8 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 8 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 8 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*cells(i,j,k)%volume) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) TuL = min ( 10 0.0 * sqrt ( 2.0 * qp ( i , j , k , 6 ) / 3.0 ) / ( qp ( i , j , k , 7 ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL ) Rev = density * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density * qp ( i , j , k , 6 ) / ( mu ( i , j , k ) * qp ( i , j , k , 7 )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * cells ( i , j , k )% volume ) !storing D in Iflux array for backward sweep deltaU ( 1 : 8 ) = - residue ( i , j , k , 1 : 8 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 8 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 8 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 8 )) ) delQstar ( i , j , k , 1 : 8 ) = deltaU ( 1 : 8 ) / D end do end do end do delQ = 0.0 !backward sweep do i = dims % imx - 1 , 1 , - 1 do j = dims % jmx - 1 , 1 , - 1 do k = dims % kmx - 1 , 1 , - 1 density = qp ( i , j , k , 1 ) C0 = ( / Cells ( i , j , k )% Centerx , Cells ( i , j , k )% Centery , Cells ( i , j , k )% Centerz / ) C1 = ( / Cells ( i - 1 , j , k )% Centerx , Cells ( i - 1 , j , k )% Centery , Cells ( i - 1 , j , k )% Centerz / ) C2 = ( / Cells ( i , j - 1 , k )% Centerx , Cells ( i , j - 1 , k )% Centery , Cells ( i , j - 1 , k )% Centerz / ) C3 = ( / Cells ( i , j , k - 1 )% Centerx , Cells ( i , j , k - 1 )% Centery , Cells ( i , j , k - 1 )% Centerz / ) C4 = ( / Cells ( i + 1 , j , k )% Centerx , Cells ( i + 1 , j , k )% Centery , Cells ( i + 1 , j , k )% Centerz / ) C5 = ( / Cells ( i , j + 1 , k )% Centerx , Cells ( i , j + 1 , k )% Centery , Cells ( i , j + 1 , k )% Centerz / ) C6 = ( / Cells ( i , j , k + 1 )% Centerx , Cells ( i , j , k + 1 )% Centery , Cells ( i , j , k + 1 )% Centerz / ) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 8 ) DQ5 = delQ ( i , j + 1 , k , 1 : 8 ) DQ6 = delQ ( i , j , k + 1 , 1 : 8 ) Flist1 ( 1 ) = Ifaces ( i , j , k )% A Flist1 ( 2 ) = - Ifaces ( i , j , k )% nx Flist1 ( 3 ) = - Ifaces ( i , j , k )% ny Flist1 ( 4 ) = - Ifaces ( i , j , k )% nz Flist1 ( 5 ) = 0.5 * ( cells ( i - 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = Jfaces ( i , j , k )% A Flist2 ( 2 ) = - Jfaces ( i , j , k )% nx Flist2 ( 3 ) = - Jfaces ( i , j , k )% ny Flist2 ( 4 ) = - Jfaces ( i , j , k )% nz Flist2 ( 5 ) = 0.5 * ( cells ( i , j - 1 , k )% volume + cells ( i , j , k )% volume ) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = Kfaces ( i , j , k )% A Flist3 ( 2 ) = - Kfaces ( i , j , k )% nx Flist3 ( 3 ) = - Kfaces ( i , j , k )% ny Flist3 ( 4 ) = - Kfaces ( i , j , k )% nz Flist3 ( 5 ) = 0.5 * ( cells ( i , j , k - 1 )% volume + cells ( i , j , k )% volume ) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = Ifaces ( i + 1 , j , k )% A Flist4 ( 2 ) = + Ifaces ( i + 1 , j , k )% nx Flist4 ( 3 ) = + Ifaces ( i + 1 , j , k )% ny Flist4 ( 4 ) = + Ifaces ( i + 1 , j , k )% nz Flist4 ( 5 ) = 0.5 * ( cells ( i + 1 , j , k )% volume + cells ( i , j , k )% volume ) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = Jfaces ( i , j + 1 , k )% A Flist5 ( 2 ) = + Jfaces ( i , j + 1 , k )% nx Flist5 ( 3 ) = + Jfaces ( i , j + 1 , k )% ny Flist5 ( 4 ) = + Jfaces ( i , j + 1 , k )% nz Flist5 ( 5 ) = 0.5 * ( cells ( i , j + 1 , k )% volume + cells ( i , j , k )% volume ) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = Kfaces ( i , j , k + 1 )% A Flist6 ( 2 ) = + Kfaces ( i , j , k + 1 )% nx Flist6 ( 3 ) = + Kfaces ( i , j , k + 1 )% ny Flist6 ( 4 ) = + Kfaces ( i , j , k + 1 )% nz Flist6 ( 5 ) = 0.5 * ( cells ( i , j , k + 1 )% volume + cells ( i , j , k )% volume ) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( cells ( i , j , k )% volume / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*cells(i,j,k)%volume) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * cells ( i , j , k )% volume ) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * cells ( i , j , k )% volume ) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) TuL = min ( 10 0.0 * sqrt ( 2.0 * qp ( i , j , k , 6 ) / 3.0 ) / ( qp ( i , j , k , 7 ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL ) Rev = density * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density * qp ( i , j , k , 6 ) / ( mu ( i , j , k ) * qp ( i , j , k , 7 )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * cells ( i , j , k )% volume ) delQ ( i , j , k , 1 : 8 ) = delQstar ( i , j , k , 1 : 8 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 8 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 8 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 8 )) ) / D end do end do end do do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) conservativeQ ( 8 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 8 ) ! add new change into conservative solution conservativeQ ( 1 : n_var ) = conservativeQ ( 1 : n_var ) + delQ ( i , j , k , 1 : n_var ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) !              qp(i,j,k,6) = conservativeQ(6) / conservativeQ(1) !              qp(i,j,k,7) = conservativeQ(7) / conservativeQ(1) if ( conservativeQ ( 6 ) > 0.0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0.0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if qp ( i , j , k , 8 ) = conservativeQ ( 8 ) / conservativeQ ( 1 ) qp ( i , j , k , 8 ) = max ( qp ( i , j , k , 8 ), 0.0 ) !qp(i,j,k,8) = min(qp(i,j,k,8), 1.0) end do end do end do end subroutine update_lctm2015","tags":"","loc":"proc/update_lctm2015~2.html","title":"update_lctm2015 – FEST-3D"},{"text":"public subroutine setup_resnorm(files, control, scheme, flow) Allocate memory, setup scale and file to write Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Files' name and handler type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-{u,v,rho,p}, etc. Calls proc~~setup_resnorm~~CallsGraph proc~setup_resnorm setup_resnorm proc~allocate_memory allocate_memory proc~setup_resnorm->proc~allocate_memory proc~setup_file setup_file proc~setup_resnorm->proc~setup_file proc~setup_scale setup_scale proc~setup_resnorm->proc~setup_scale interface~alloc alloc proc~allocate_memory->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_resnorm~~CalledByGraph proc~setup_resnorm setup_resnorm proc~setup_solver setup_solver proc~setup_solver->proc~setup_resnorm proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_resnorm Source Code subroutine setup_resnorm ( files , control , scheme , flow ) !< Allocate memory, setup scale and file to write implicit none type ( filetype ), intent ( in ) :: files !< Files' name and handler type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-{u,v,rho,p}, etc. call allocate_memory ( control ) call setup_scale ( scheme , flow ) call setup_file ( files , control ) end subroutine setup_resnorm","tags":"","loc":"proc/setup_resnorm.html","title":"setup_resnorm – FEST-3D"},{"text":"public subroutine find_resnorm(file_handler, residue, F, G, H, control, scheme, dims) Find the normalized residual for each processor Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler residual file handler real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(in), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(in), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( controltype ), intent(inout) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~find_resnorm~~CallsGraph proc~find_resnorm find_resnorm proc~write_resnorm write_resnorm proc~find_resnorm->proc~write_resnorm proc~collect_resnorm_from_all_blocks collect_resnorm_from_all_blocks proc~find_resnorm->proc~collect_resnorm_from_all_blocks proc~get_absolute_resnorm get_absolute_resnorm proc~find_resnorm->proc~get_absolute_resnorm proc~get_relative_resnorm get_relative_resnorm proc~find_resnorm->proc~get_relative_resnorm proc~assemble_resnom_at_each_process assemble_resnom_at_each_process proc~find_resnorm->proc~assemble_resnom_at_each_process mpi_allgather mpi_allgather proc~collect_resnorm_from_all_blocks->mpi_allgather Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~find_resnorm~~CalledByGraph proc~find_resnorm find_resnorm proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_resnorm Source Code subroutine find_resnorm ( file_handler , residue , F , G , H , control , scheme , dims ) !< Find the normalized residual for each processor implicit none integer , intent ( in ) :: file_handler !< residual file handler type ( controltype ), intent ( inout ) :: control !< Control parameters type ( schemetype ) , intent ( in ) :: scheme !< finite-volume Schemes type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), intent ( in ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: H !< Store fluxes throught the K faces call get_absolute_resnorm ( residue , F , G , H , control , dims ) call collect_resnorm_from_all_blocks ( control ) call assemble_resnom_at_each_process ( control ) call get_relative_resnorm ( control ) if (( mod ( control % current_iter , control % res_write_interval ) == 0 . or . & control % current_iter == Res_itr . or . & control % current_iter == 1 ) . and . & process_id == 0 ) then call write_resnorm ( file_handler , control , scheme ) end if end subroutine find_resnorm","tags":"","loc":"proc/find_resnorm.html","title":"find_resnorm – FEST-3D"},{"text":"private subroutine setup_file(files, control) Open the residual file to write Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Files' name and handler type( controltype ), intent(in) :: control Control parameters Called by proc~~setup_file~~CalledByGraph proc~setup_file setup_file proc~setup_resnorm setup_resnorm proc~setup_resnorm->proc~setup_file proc~setup_solver setup_solver proc~setup_solver->proc~setup_resnorm proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_file Source Code subroutine setup_file ( files , control ) !< Open the residual file to write implicit none type ( filetype ), intent ( in ) :: files !< Files' name and handler type ( controltype ), intent ( in ) :: control !< Control parameters integer :: i if ( process_id == 0 ) then if ( control % start_from == 0 ) then open ( files % RESNORM_FILE_UNIT , file = files % resnorm_file ) else open ( files % RESNORM_FILE_UNIT , file = files % resnorm_file , status = 'old' , position = 'append' , action = 'write' ) end if write ( files % RESNORM_FILE_UNIT , '(A,2x)' , advance = 'no' ) \"Iteration\" do i = 1 , control % Res_count write ( files % RESNORM_FILE_UNIT , '(A,2x)' , advance = 'no' ) trim ( control % Res_list ( i )) end do write ( files % RESNORM_FILE_UNIT , * ) end if end subroutine setup_file","tags":"","loc":"proc/setup_file.html","title":"setup_file – FEST-3D"},{"text":"private subroutine allocate_memory(control) Allocate memory to MPI Communication Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Calls proc~~allocate_memory~~CallsGraph proc~allocate_memory allocate_memory interface~alloc alloc proc~allocate_memory->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory~~CalledByGraph proc~allocate_memory allocate_memory proc~setup_resnorm setup_resnorm proc~setup_resnorm->proc~allocate_memory proc~setup_solver setup_solver proc~setup_solver->proc~setup_resnorm proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory Source Code subroutine allocate_memory ( control ) !< Allocate memory to MPI Communication implicit none type ( controltype ), intent ( in ) :: control call alloc ( Res_abs , 0 , control % n_var ) call alloc ( Res_rel , 0 , control % n_var ) call alloc ( Res_scale , 0 , control % n_var ) call alloc ( Res_save , 0 , control % n_var ) call alloc ( buffer , 1 ,( control % n_var + 1 ) * control % total_process ) end subroutine allocate_memory","tags":"","loc":"proc/allocate_memory.html","title":"allocate_memory – FEST-3D"},{"text":"private subroutine setup_scale(scheme, flow) Setup scale required for relative and absolute\n residual for writing in the file. Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. Called by proc~~setup_scale~~CalledByGraph proc~setup_scale setup_scale proc~setup_resnorm setup_resnorm proc~setup_resnorm->proc~setup_scale proc~setup_solver setup_solver proc~setup_solver->proc~setup_resnorm proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scale Source Code subroutine setup_scale ( scheme , flow ) !< Setup scale required for relative and absolute !< residual for writing in the file. implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. Res_scale ( 0 ) = 1. Res_scale ( 1 ) = flow % density_inf * flow % vel_mag Res_scale ( 2 ) = flow % density_inf * flow % vel_mag * flow % vel_mag Res_scale ( 3 ) = flow % density_inf * flow % vel_mag * flow % vel_mag Res_scale ( 4 ) = flow % density_inf * flow % vel_mag * flow % vel_mag Res_scale ( 5 ) = ( 0.5 * flow % density_inf * flow % vel_mag ** 3 + & (( flow % gm / ( flow % gm - 1. )) * flow % pressure_inf )) select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tk_inf Res_scale ( 7 ) = flow % density_inf * flow % vel_mag * flow % tw_inf case ( 'kkl' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tk_inf Res_scale ( 7 ) = flow % density_inf * flow % vel_mag * flow % tkl_inf case ( 'des' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tk_inf Res_scale ( 7 ) = flow % density_inf * flow % vel_mag * flow % tw_inf case ( 'sa' , 'saBC' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tv_inf case ( 'kw' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tk_inf Res_scale ( 7 ) = flow % density_inf * flow % vel_mag * flow % tw_inf case ( 'ke' ) Res_scale ( 6 ) = flow % density_inf * flow % vel_mag * flow % tk_inf Res_scale ( 7 ) = flow % density_inf * flow % vel_mag * flow % te_inf case DEFAULT Fatal_error end select end subroutine setup_scale","tags":"","loc":"proc/setup_scale.html","title":"setup_scale – FEST-3D"},{"text":"private subroutine get_absolute_resnorm(residue, F, G, H, control, dims) Get absolute residual for current process Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(in), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(in), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( controltype ), intent(in) :: control Control parameters: number of variables type( extent ), intent(in) :: dims extent of the 3D domain Called by proc~~get_absolute_resnorm~~CalledByGraph proc~get_absolute_resnorm get_absolute_resnorm proc~find_resnorm find_resnorm proc~find_resnorm->proc~get_absolute_resnorm proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_absolute_resnorm Source Code subroutine get_absolute_resnorm ( residue , F , G , H , control , dims ) !< Get absolute residual for current process implicit none type ( controltype ), intent ( in ) :: control !< Control parameters: number of variables type ( extent ), intent ( in ) :: dims !< extent of the 3D domain real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), intent ( in ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: H !< Store fluxes throught the K faces integer :: i do i = 1 , control % n_var Res_abs ( i ) = ( sum ( Residue (:,:,:, i ) ** 2 ) / Res_scale ( i ) ** 2 ) end do merror = ( & sum ( F ( 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 )) & - sum ( F ( dims % imx , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 )) & + sum ( G ( 1 : dims % imx - 1 , 1 , 1 : dims % kmx - 1 , 1 )) & - sum ( G ( 1 : dims % imx - 1 , dims % jmx , 1 : dims % kmx - 1 , 1 )) & + sum ( H ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 , 1 )) & - sum ( H ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , dims % kmx , 1 )) & ) Res_abs ( 0 ) = ( merror / Res_scale ( 0 )) end subroutine get_absolute_resnorm","tags":"","loc":"proc/get_absolute_resnorm.html","title":"get_absolute_resnorm – FEST-3D"},{"text":"private subroutine collect_resnorm_from_all_blocks(control) MPI Communication to gather residual from all processes Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters: number of variables Calls proc~~collect_resnorm_from_all_blocks~~CallsGraph proc~collect_resnorm_from_all_blocks collect_resnorm_from_all_blocks mpi_allgather mpi_allgather proc~collect_resnorm_from_all_blocks->mpi_allgather Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~collect_resnorm_from_all_blocks~~CalledByGraph proc~collect_resnorm_from_all_blocks collect_resnorm_from_all_blocks proc~find_resnorm find_resnorm proc~find_resnorm->proc~collect_resnorm_from_all_blocks proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code collect_resnorm_from_all_blocks Source Code subroutine collect_resnorm_from_all_blocks ( control ) !< MPI Communication to gather residual from all processes implicit none type ( controltype ), intent ( in ) :: control !< Control parameters: number of variables integer :: ierr call MPI_ALLGATHER ( Res_abs , control % n_var + 1 , MPI_DOUBLE_PRECISION , & buffer , control % n_var + 1 , MPI_DOUBLE_PRECISION , MPI_COMM_WORLD , ierr ) end subroutine collect_resnorm_from_all_blocks","tags":"","loc":"proc/collect_resnorm_from_all_blocks.html","title":"collect_resnorm_from_all_blocks – FEST-3D"},{"text":"private subroutine assemble_resnom_at_each_process(control) Sum residual obtained from all the processes after MPI_Communication Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters: number of variables and total mpi processes Called by proc~~assemble_resnom_at_each_process~~CalledByGraph proc~assemble_resnom_at_each_process assemble_resnom_at_each_process proc~find_resnorm find_resnorm proc~find_resnorm->proc~assemble_resnom_at_each_process proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code assemble_resnom_at_each_process Source Code subroutine assemble_resnom_at_each_process ( control ) !< Sum residual obtained from all the processes after MPI_Communication implicit none type ( controltype ), intent ( in ) :: control !< Control parameters: number of variables and total mpi processes integer :: i , j Res_abs = 0. do i = 0 , control % total_process - 1 do j = 0 , control % n_var Res_abs ( j ) = Res_abs ( j ) + buffer (( j + 1 ) + ( control % n_var + 1 ) * i ) end do end do Res_abs ( 1 :) = sqrt ( Res_abs ( 1 :)) Res_abs ( 0 ) = abs ( Res_abs ( 0 )) end subroutine assemble_resnom_at_each_process","tags":"","loc":"proc/assemble_resnom_at_each_process.html","title":"assemble_resnom_at_each_process – FEST-3D"},{"text":"private subroutine get_relative_resnorm(control) Get relative residual with respect to first iteration residual Arguments Type Intent Optional Attributes Name type( controltype ), intent(inout) :: control Control parameters: iterations Called by proc~~get_relative_resnorm~~CalledByGraph proc~get_relative_resnorm get_relative_resnorm proc~find_resnorm find_resnorm proc~find_resnorm->proc~get_relative_resnorm proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_relative_resnorm Source Code subroutine get_relative_resnorm ( control ) !< Get relative residual with respect to first iteration residual implicit none type ( controltype ), intent ( inout ) :: control !< Control parameters: iterations if ( control % current_iter <= Res_itr ) Res_save = Res_abs if ( control % start_from /= 0 ) then Res_save = control % previous_Res else control % previous_Res = Res_save end if Res_rel = Res_abs / Res_save end subroutine get_relative_resnorm","tags":"","loc":"proc/get_relative_resnorm.html","title":"get_relative_resnorm – FEST-3D"},{"text":"private subroutine write_resnorm(RESNORM_FILE_UNIT, control, scheme) Writing the residual in the file to save. Arguments Type Intent Optional Attributes Name integer, intent(in) :: RESNORM_FILE_UNIT Resnorm file handler unit type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme turbulenca and transition schemes Called by proc~~write_resnorm~~CalledByGraph proc~write_resnorm write_resnorm proc~find_resnorm find_resnorm proc~find_resnorm->proc~write_resnorm proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_resnorm Source Code subroutine write_resnorm ( RESNORM_FILE_UNIT , control , scheme ) !< Writing the residual in the file to save. implicit none integer , intent ( in ) :: RESNORM_FILE_UNIT !<Resnorm file handler unit type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ) , intent ( in ) :: scheme !< turbulenca and transition schemes integer :: i integer :: n = 6 character ( len = 20 ) :: frm n = control % write_percision write ( frm , '(A,I0,A,I0,A)' ) \"(e\" , n + 8 , \".\" , n , \"E2, 4x)\" write ( RESNORM_FILE_UNIT , '(I0,4x)' , advance = 'no' ) control % current_iter + control % last_iter do i = 1 , control % Res_count select case ( trim ( control % Res_list ( i ))) !include \"resnorm_write_cases.inc\" case ( 'Mass_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 0 ) case ( 'Resnorm_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 :) ** 2 )) case ( 'Viscous_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 : 5 ) ** 2 )) case ( 'Turbulent_abs' ) if ( trim ( scheme % turbulence ) /= 'none' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 6 :) ** 2 )) end if case ( 'Continuity_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 1 ) case ( 'X_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 2 ) case ( 'Y_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 3 ) case ( 'Z_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 4 ) case ( 'Energy_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 5 ) case ( 'Mass_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 0 ) case ( 'Resnorm_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 1 :) ** 2 )) case ( 'Viscous_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 1 : 5 ) ** 2 )) case ( 'Turbulent_rel' ) if ( trim ( scheme % turbulence ) /= 'none' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 6 :) ** 2 )) end if case ( 'Continuity_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 1 ) case ( 'X-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 2 ) case ( 'Y-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 3 ) case ( 'Z-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 4 ) case ( 'Energy_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 5 ) case ( 'TKE_abs' ) if ( trim ( scheme % turbulence ) == 'sst' . or . trim ( scheme % turbulence ) == 'kkl' . or . trim ( scheme % turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 6 ) end if case ( 'Tv_abs' ) if ( trim ( scheme % turbulence ) == 'sa' . or . trim ( scheme % turbulence ) == 'saBC' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 6 ) end if case ( 'Dissipation_abs' ) if ( trim ( scheme % turbulence ) == 'ke' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'Omega_abs' ) if ( trim ( scheme % turbulence ) == 'sst' . or . trim ( scheme % turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'Kl_abs' ) if ( trim ( scheme % turbulence ) == 'kkl' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'TKE_rel' ) if ( trim ( scheme % turbulence ) == 'sst' . or . trim ( scheme % turbulence ) == 'kkl' . or . trim ( scheme % turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 6 ) end if case ( 'Tv_rel' ) if ( trim ( scheme % turbulence ) == 'sa' . or . trim ( scheme % turbulence ) == 'saBC' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 6 ) end if case ( 'Dissipation_rel' ) if ( trim ( scheme % turbulence ) == 'ke' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case ( 'Omega_rel' ) if ( trim ( scheme % turbulence ) == 'sst' . or . trim ( scheme % turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case ( 'Kl_rel' ) if ( trim ( scheme % turbulence ) == 'kkl' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case DEFAULT ! making absolute resnorm default write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 :) ** 2 )) Issue_warning end select end do write ( RESNORM_FILE_UNIT , * ) end subroutine write_resnorm","tags":"","loc":"proc/write_resnorm.html","title":"write_resnorm – FEST-3D"},{"text":"public subroutine abort_run() Aborting the solver Arguments None Calls proc~~abort_run~~CallsGraph proc~abort_run abort_run proc~finish_run finish_run proc~abort_run->proc~finish_run proc~destroy_solver destroy_solver proc~finish_run->proc~destroy_solver mpi_finalize mpi_finalize proc~finish_run->mpi_finalize proc~destroy_time destroy_time proc~destroy_solver->proc~destroy_time debugcall debugcall proc~destroy_solver->debugcall proc~destroy_time->debugcall mpi_gather mpi_gather proc~destroy_time->mpi_gather proc~write_time write_time proc~destroy_time->proc~write_time interface~alloc alloc proc~destroy_time->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code abort_run Source Code subroutine abort_run () !< Aborting the solver implicit none call finish_run () stop end subroutine abort_run","tags":"","loc":"proc/abort_run.html","title":"abort_run – FEST-3D"},{"text":"public subroutine finish_run() Finishing the solution computation Arguments None Calls proc~~finish_run~~CallsGraph proc~finish_run finish_run proc~destroy_solver destroy_solver proc~finish_run->proc~destroy_solver mpi_finalize mpi_finalize proc~finish_run->mpi_finalize proc~destroy_time destroy_time proc~destroy_solver->proc~destroy_time debugcall debugcall proc~destroy_solver->debugcall proc~destroy_time->debugcall mpi_gather mpi_gather proc~destroy_time->mpi_gather proc~write_time write_time proc~destroy_time->proc~write_time interface~alloc alloc proc~destroy_time->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~finish_run~~CalledByGraph proc~finish_run finish_run program~main main program~main->proc~finish_run proc~abort_run abort_run proc~abort_run->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code finish_run Source Code subroutine finish_run () !< Finishing the solution computation implicit none integer :: ierr call destroy_solver () call MPI_FINALIZE ( ierr ) end subroutine finish_run","tags":"","loc":"proc/finish_run.html","title":"finish_run – FEST-3D"},{"text":"public subroutine start_run() Starting the solver setup Arguments None Calls proc~~start_run~~CallsGraph proc~start_run start_run proc~setup_solver setup_solver proc~start_run->proc~setup_solver mpi_init mpi_init proc~start_run->mpi_init proc~initmisc initmisc proc~setup_solver->proc~initmisc mpi_barrier mpi_barrier proc~setup_solver->mpi_barrier proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~setup_time setup_time proc~setup_solver->proc~setup_time proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~checkpoint checkpoint proc~setup_solver->proc~checkpoint proc~setupcc setupCC proc~setup_solver->proc~setupcc proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_scheme setup_scheme proc~setup_solver->proc~setup_scheme proc~find_wall_dist find_wall_dist proc~setup_solver->proc~find_wall_dist proc~setup_wall_dist setup_wall_dist proc~setup_solver->proc~setup_wall_dist debugcall debugcall proc~setup_solver->debugcall proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~read_input_and_controls read_input_and_controls proc~setup_solver->proc~read_input_and_controls proc~setup_interface setup_interface proc~setup_solver->proc~setup_interface proc~setup_bc setup_bc proc~setup_solver->proc~setup_bc proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_viscosity setup_viscosity proc~setup_solver->proc~setup_viscosity proc~get_process_data get_process_data proc~setup_solver->proc~get_process_data proc~setup_update setup_update proc~setup_solver->proc~setup_update proc~read_layout_file read_layout_file proc~setup_solver->proc~read_layout_file proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~start_run~~CalledByGraph proc~start_run start_run program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code start_run Source Code subroutine start_run () !< Starting the solver setup implicit none integer :: ierr call MPI_INIT ( ierr ) call setup_solver () end subroutine start_run","tags":"","loc":"proc/start_run.html","title":"start_run – FEST-3D"},{"text":"public subroutine setup_solver() Call to allocate memoery and initialize domain Arguments None Calls proc~~setup_solver~~CallsGraph proc~setup_solver setup_solver proc~initmisc initmisc proc~setup_solver->proc~initmisc mpi_barrier mpi_barrier proc~setup_solver->mpi_barrier proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~setup_time setup_time proc~setup_solver->proc~setup_time proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~checkpoint checkpoint proc~setup_solver->proc~checkpoint proc~setupcc setupCC proc~setup_solver->proc~setupcc proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_scheme setup_scheme proc~setup_solver->proc~setup_scheme proc~find_wall_dist find_wall_dist proc~setup_solver->proc~find_wall_dist proc~setup_wall_dist setup_wall_dist proc~setup_solver->proc~setup_wall_dist debugcall debugcall proc~setup_solver->debugcall proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~read_input_and_controls read_input_and_controls proc~setup_solver->proc~read_input_and_controls proc~setup_interface setup_interface proc~setup_solver->proc~setup_interface proc~setup_bc setup_bc proc~setup_solver->proc~setup_bc proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_viscosity setup_viscosity proc~setup_solver->proc~setup_viscosity proc~get_process_data get_process_data proc~setup_solver->proc~get_process_data proc~setup_update setup_update proc~setup_solver->proc~setup_update proc~read_layout_file read_layout_file proc~setup_solver->proc~read_layout_file proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_solver~~CalledByGraph proc~setup_solver setup_solver proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_solver Source Code subroutine setup_solver () !< Call to allocate memoery and initialize domain !-------------------------------------------------- implicit none integer :: ierr DebugCall ( 'setup_solver: Start' ) call get_process_data ( control ) ! parallel calls call read_layout_file ( files , control , boundary ) ! reads layout file calls call read_input_and_controls ( files , control , schemes , flow ) call setup_grid ( files , nodes , control , boundary , dims ) call setup_geometry ( cells , Ifaces , Jfaces , Kfaces , nodes , boundary , dims ) !call setup_viscosity(mu, mu_t, schemes, flow, dims) call setup_viscosity ( schemes , flow , dims ) call setup_state ( files , qp , control , schemes , flow , dims ) allocate ( Temp ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 )) call setup_gradients ( control , schemes , flow , dims ) !call setup_source call setup_bc ( files , schemes , flow , boundary , dims ) call setup_time ( delta_t , control , dims ) call setup_update ( control , schemes , flow , dims ) call setup_interface ( control , dims ) call setup_scheme ( residue , F , G , H , control , dims ) if ( schemes % turbulence /= 'none' ) then call write_surfnode ( files , nodes , control , boundary , dims ) call setup_wall_dist ( files , dims ) call mpi_barrier ( MPI_COMM_WORLD , ierr ) call find_wall_dist ( nodes , dims ) end if call setupCC ( schemes , cells , Ifaces , Jfaces , Kfaces , dims ) call setup_resnorm ( files , control , schemes , flow ) call initmisc () control % checkpoint_iter_count = 0 call checkpoint ( files , qp , nodes , control , schemes , dims ) ! Create an initial dump file control % current_iter = 1 DebugCall ( 'setup_solver: checkpoint' ) DebugCall ( 'Setup solver complete' ) end subroutine setup_solver","tags":"","loc":"proc/setup_solver.html","title":"setup_solver – FEST-3D"},{"text":"public subroutine destroy_solver() Call to different modules to deallocate memory Arguments None Calls proc~~destroy_solver~~CallsGraph proc~destroy_solver destroy_solver proc~destroy_time destroy_time proc~destroy_solver->proc~destroy_time debugcall debugcall proc~destroy_solver->debugcall proc~destroy_time->debugcall mpi_gather mpi_gather proc~destroy_time->mpi_gather proc~write_time write_time proc~destroy_time->proc~write_time interface~alloc alloc proc~destroy_time->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_solver~~CalledByGraph proc~destroy_solver destroy_solver proc~finish_run finish_run proc~finish_run->proc~destroy_solver program~main main program~main->proc~finish_run proc~abort_run abort_run proc~abort_run->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_solver Source Code subroutine destroy_solver () !< Call to different modules to deallocate memory !-------------------------------------------------- implicit none DebugCall ( 'destroy_solver' ) call destroy_time ( control ) end subroutine destroy_solver","tags":"","loc":"proc/destroy_solver.html","title":"destroy_solver – FEST-3D"},{"text":"private subroutine initmisc() Initilize miscellaneous variables Arguments None Calls proc~~initmisc~~CallsGraph proc~initmisc initmisc debugcall debugcall proc~initmisc->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initmisc~~CalledByGraph proc~initmisc initmisc proc~setup_solver setup_solver proc~setup_solver->proc~initmisc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initmisc Source Code subroutine initmisc () !< Initilize miscellaneous variables !---------------------------------- implicit none DebugCall ( 'initmisc' ) control % current_iter = 0 end subroutine initmisc","tags":"","loc":"proc/initmisc.html","title":"initmisc – FEST-3D"},{"text":"public subroutine iterate_one_more_time_step() Perform one time step iteration Arguments None Calls proc~~iterate_one_more_time_step~~CallsGraph proc~iterate_one_more_time_step iterate_one_more_time_step proc~find_resnorm find_resnorm proc~iterate_one_more_time_step->proc~find_resnorm proc~checkpoint checkpoint proc~iterate_one_more_time_step->proc~checkpoint debugcall debugcall proc~iterate_one_more_time_step->debugcall proc~get_next_solution get_next_solution proc~iterate_one_more_time_step->proc~get_next_solution mpi_bcast mpi_bcast proc~iterate_one_more_time_step->mpi_bcast proc~assemble_resnom_at_each_process assemble_resnom_at_each_process proc~find_resnorm->proc~assemble_resnom_at_each_process proc~write_resnorm write_resnorm proc~find_resnorm->proc~write_resnorm proc~get_relative_resnorm get_relative_resnorm proc~find_resnorm->proc~get_relative_resnorm proc~collect_resnorm_from_all_blocks collect_resnorm_from_all_blocks proc~find_resnorm->proc~collect_resnorm_from_all_blocks proc~get_absolute_resnorm get_absolute_resnorm proc~find_resnorm->proc~get_absolute_resnorm proc~checkpoint->debugcall proc~make_dump_dir make_dump_dir proc~checkpoint->proc~make_dump_dir proc~dump_data dump_data proc~checkpoint->proc~dump_data proc~purge_dump_dir purge_dump_dir proc~checkpoint->proc~purge_dump_dir proc~update_with update_with proc~get_next_solution->proc~update_with proc~compute_time_step compute_time_step proc~get_next_solution->proc~compute_time_step proc~update_with_plusgs update_with_plusgs proc~get_next_solution->proc~update_with_plusgs proc~update_with_lusgs update_with_lusgs proc~get_next_solution->proc~update_with_lusgs proc~get_total_conservative_residue get_total_conservative_Residue proc~get_next_solution->proc~get_total_conservative_residue proc~create_directory create_directory proc~make_dump_dir->proc~create_directory proc~compute_time_step->debugcall proc~compute_local_time_step compute_local_time_step proc~compute_time_step->proc~compute_local_time_step proc~compute_global_time_step compute_global_time_step proc~compute_time_step->proc~compute_global_time_step proc~update_simulation_clock update_simulation_clock proc~compute_time_step->proc~update_simulation_clock proc~update_lctm2015 update_lctm2015 proc~update_with_plusgs->proc~update_lctm2015 proc~update_laminar_variables update_laminar_variables proc~update_with_plusgs->proc~update_laminar_variables proc~update_sa_variables update_SA_variables proc~update_with_plusgs->proc~update_sa_variables proc~update_sst_variables update_SST_variables proc~update_with_plusgs->proc~update_sst_variables proc~dump_data->debugcall proc~write_file~4 write_file proc~dump_data->proc~write_file~4 proc~write_restart_log write_restart_log proc~dump_data->proc~write_restart_log mpi_allgather mpi_allgather proc~collect_resnorm_from_all_blocks->mpi_allgather proc~remove_directory remove_directory proc~purge_dump_dir->proc~remove_directory proc~update_with_lusgs->debugcall proc~update_kkl_variables update_KKL_variables proc~update_with_lusgs->proc~update_kkl_variables proc~update_sa_variables~2 update_SA_variables proc~update_with_lusgs->proc~update_sa_variables~2 proc~update_lctm2015~2 update_lctm2015 proc~update_with_lusgs->proc~update_lctm2015~2 proc~update_laminar_variables~2 update_laminar_variables proc~update_with_lusgs->proc~update_laminar_variables~2 proc~update_sst_variables~2 update_SST_variables proc~update_with_lusgs->proc~update_sst_variables~2 proc~apply_interface apply_interface proc~get_total_conservative_residue->proc~apply_interface proc~add_source_term_residue add_source_term_residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~compute_residue compute_residue proc~get_total_conservative_residue->proc~compute_residue proc~populate_ghost_primitive populate_ghost_primitive proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~evaluate_all_gradients evaluate_all_gradients proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~calculate_viscosity calculate_viscosity proc~get_total_conservative_residue->proc~calculate_viscosity proc~reconstruct_boundary_state reconstruct_boundary_state proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~compute_fluxes~7 compute_fluxes proc~get_total_conservative_residue->proc~compute_fluxes~7 proc~compute_face_interpolant compute_face_interpolant proc~get_total_conservative_residue->proc~compute_face_interpolant proc~compute_viscous_fluxes compute_viscous_fluxes proc~get_total_conservative_residue->proc~compute_viscous_fluxes var panprociterate_one_more_time_stepCallsGraph = svgPanZoom('#prociterate_one_more_time_stepCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~iterate_one_more_time_step~~CalledByGraph proc~iterate_one_more_time_step iterate_one_more_time_step program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code iterate_one_more_time_step Source Code subroutine iterate_one_more_time_step () !< Perform one time step iteration !  This subroutine performs one iteration by stepping through !  time once. !----------------------------------------------------------- implicit none integer :: ierr DebugCall ( 'iterate_one_more_time_step' ) if ( process_id == 0 ) then print * , control % current_iter end if call get_next_solution ( qp , Temp , residue , delta_t , cells , F , G , H , Ifaces , Jfaces , Kfaces , control , schemes , flow , boundary , dims ) call find_resnorm ( files % RESNORM_FILE_UNIT , residue , F , G , H , control , schemes , dims ) call checkpoint ( files , qp , nodes , control , schemes , dims ) control % current_iter = control % current_iter + 1 if ( process_id == 0 ) then open ( files % STOP_FILE_UNIT , file = files % stop_file ) read ( files % STOP_FILE_UNIT , * ) control % want_to_stop close ( files % STOP_FILE_UNIT ) end if call MPI_BCAST ( control % want_to_stop , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) if ( control % want_to_stop == 1 ) control % Halt = . TRUE . end subroutine iterate_one_more_time_step","tags":"","loc":"proc/iterate_one_more_time_step.html","title":"iterate_one_more_time_step – FEST-3D"},{"text":"public subroutine read_interface_map(files, control, bc, dims) Read mapping file in the system/mesh/layout/mapping.txt Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Files' name and handler type( controltype ), intent(in) :: control Control parameters type( boundarytype ), intent(inout) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~read_interface_map~~CallsGraph proc~read_interface_map read_interface_map proc~change_map_to_particular_range change_map_to_particular_range proc~read_interface_map->proc~change_map_to_particular_range proc~read_periodic_bc_file read_periodic_bc_file proc~read_interface_map->proc~read_periodic_bc_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_interface_map~~CalledByGraph proc~read_interface_map read_interface_map proc~setup_grid setup_grid proc~setup_grid->proc~read_interface_map proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_interface_map Source Code subroutine read_interface_map ( files , control , bc , dims ) !< Read mapping file in the system/mesh/layout/mapping.txt implicit none type ( filetype ), intent ( in ) :: files !< Files' name and handler type ( controltype ), intent ( in ) :: control !< Control parameters type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( boundarytype ), intent ( inout ) :: bc !< boundary conditions and fixed values integer :: ios integer :: max_call integer :: i integer :: b1 , b2 , f1 , f2 integer :: s11 , s12 , s21 , s22 integer :: e11 , e12 , e21 , e22 integer :: switch integer :: class !--- initialize indicies --! max_call = control % total_process * 6 ilo ( 1 ) = 1 ; ihi ( 1 ) = 1 ilo ( 2 ) = dims % imx ; ihi ( 2 ) = dims % imx ilo ( 3 ) = 1 ; ihi ( 3 ) = dims % imx ilo ( 4 ) = 1 ; ihi ( 4 ) = dims % imx ilo ( 5 ) = 1 ; ihi ( 5 ) = dims % imx ilo ( 6 ) = 1 ; ihi ( 6 ) = dims % imx jlo ( 1 ) = 1 ; jhi ( 1 ) = dims % jmx jlo ( 2 ) = 1 ; jhi ( 2 ) = dims % jmx jlo ( 3 ) = 1 ; jhi ( 3 ) = 1 jlo ( 4 ) = dims % jmx ; jhi ( 4 ) = dims % jmx jlo ( 5 ) = 1 ; jhi ( 5 ) = dims % jmx jlo ( 6 ) = 1 ; jhi ( 6 ) = dims % jmx klo ( 1 ) = 1 ; khi ( 1 ) = dims % kmx klo ( 2 ) = 1 ; khi ( 2 ) = dims % kmx klo ( 3 ) = 1 ; khi ( 3 ) = dims % kmx klo ( 4 ) = 1 ; khi ( 4 ) = dims % kmx klo ( 5 ) = 1 ; khi ( 5 ) = 1 klo ( 6 ) = dims % kmx ; khi ( 6 ) = dims % kmx bc % otherface ( 1 ) = 2 bc % otherface ( 2 ) = 1 bc % otherface ( 3 ) = 4 bc % otherface ( 4 ) = 3 bc % otherface ( 5 ) = 6 bc % otherface ( 6 ) = 5 bc % dir_switch = 0 !--- end of variable intializaiton --! !--- reading map file  ---! open ( files % MAP_FILE_UNIT , file = files % mapfile , status = 'old' , action = 'read' ) read ( files % MAP_FILE_UNIT , * ) ! ignore header do i = 1 , max_call read ( files % MAP_FILE_UNIT , * , iostat = ios ) b1 , f1 , s11 , e11 , s12 , e12 ,& b2 , f2 , s21 , e21 , s22 , e22 , switch , class if ( is_iostat_end ( ios )) EXIT if ( b1 == control % process_id ) then if ( f1 == 1 ) then bc % otherface ( 1 ) = f2 jlo ( 1 ) = s21 jhi ( 1 ) = e21 klo ( 1 ) = s22 khi ( 1 ) = e22 bc % dir_switch ( 1 ) = switch mpi_class ( 1 ) = class elseif ( f1 == 2 ) then bc % otherface ( 2 ) = f2 jlo ( 2 ) = s21 jhi ( 2 ) = e21 klo ( 2 ) = s22 khi ( 2 ) = e22 bc % dir_switch ( 2 ) = switch mpi_class ( 2 ) = class elseif ( f1 == 3 ) then bc % otherface ( 3 ) = f2 ilo ( 3 ) = s21 ihi ( 3 ) = e21 klo ( 3 ) = s22 khi ( 3 ) = e22 bc % dir_switch ( 3 ) = switch mpi_class ( 3 ) = class elseif ( f1 == 4 ) then bc % otherface ( 4 ) = f2 ilo ( 4 ) = s21 ihi ( 4 ) = e21 klo ( 4 ) = s22 khi ( 4 ) = e22 bc % dir_switch ( 4 ) = switch mpi_class ( 4 ) = class elseif ( f1 == 5 ) then bc % otherface ( 5 ) = f2 ilo ( 5 ) = s21 ihi ( 5 ) = e21 jlo ( 5 ) = s22 jhi ( 5 ) = e22 bc % dir_switch ( 5 ) = switch mpi_class ( 5 ) = class elseif ( f1 == 6 ) then bc % otherface ( 6 ) = f2 ilo ( 6 ) = s21 ihi ( 6 ) = e21 jlo ( 6 ) = s22 jhi ( 6 ) = e22 bc % dir_switch ( 6 ) = switch mpi_class ( 6 ) = class end if else continue end if end do close ( files % MAP_FILE_UNIT ) call change_map_to_particular_range () call read_periodic_bc_file ( files , control , bc ) end subroutine read_interface_map","tags":"","loc":"proc/read_interface_map.html","title":"read_interface_map – FEST-3D"},{"text":"private subroutine change_map_to_particular_range() Modified the indicies for MPI communication Arguments None Called by proc~~change_map_to_particular_range~~CalledByGraph proc~change_map_to_particular_range change_map_to_particular_range proc~read_interface_map read_interface_map proc~read_interface_map->proc~change_map_to_particular_range proc~setup_grid setup_grid proc~setup_grid->proc~read_interface_map proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocchange_map_to_particular_rangeCalledByGraph = svgPanZoom('#procchange_map_to_particular_rangeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code change_map_to_particular_range Source Code subroutine change_map_to_particular_range () !< Modified the indicies for MPI communication !------------------------------------- !eg: 1-kmx to 0 to kmx for data transfer !-------------------------------------- implicit none integer :: i Pilo = ilo Pjlo = jlo Pklo = klo Pihi = ihi Pjhi = jhi Pkhi = khi PiDir = 1 PjDir = 1 PkDir = 1 do i = 1 , 6 if ( ilo ( i ) == 1 . and . i > 2 ) then Pilo ( i ) = 1 Gilo ( i ) =- 2 end if if ( jlo ( i ) == 1 . and . ( i > 4 . or . i < 3 ) ) then Pjlo ( i ) = 1 Gjlo ( i ) =- 2 end if if ( klo ( i ) == 1 . and . i < 5 ) then Pklo ( i ) = 1 Gklo ( i ) =- 2 end if if ( ihi ( i ) == 1 . and . i > 2 ) then Pihi ( i ) = 1 Gihi ( i ) =- 2 PiDir ( i ) =- 1 end if if ( jhi ( i ) == 1 . and . ( i > 4 . or . i < 3 )) then Pjhi ( i ) = 1 Gjhi ( i ) =- 2 PjDir ( i ) =- 1 end if if ( khi ( i ) == 1 . and . i < 5 ) then Pkhi ( i ) = 1 Gkhi ( i ) =- 2 PkDir ( i ) =- 1 end if if ( ilo ( i ) > 1 . and . i > 2 ) then Gilo ( i ) = ilo ( i ) + 3 Pilo ( i ) = ilo ( i ) - 1 PiDir ( i ) =- 1 end if if ( jlo ( i ) > 1 . and . ( i > 4 . or . i < 5 )) then Gjlo ( i ) = jlo ( i ) + 3 Pjlo ( i ) = jlo ( i ) - 1 PjDir ( i ) =- 1 end if if ( klo ( i ) > 1 . and . i < 5 ) then Gklo ( i ) = klo ( i ) + 3 Pklo ( i ) = klo ( i ) - 1 PkDir ( i ) =- 1 end if if ( ihi ( i ) > 1 . and . i > 2 ) then Gihi ( i ) = ihi ( i ) + 3 Pihi ( i ) = ihi ( i ) - 1 end if if ( jhi ( i ) > 1 . and . ( i > 4 . or . i < 5 )) then Gjhi ( i ) = jhi ( i ) + 3 Pjhi ( i ) = jhi ( i ) - 1 end if if ( khi ( i ) > 1 . and . i < 5 ) then Gkhi ( i ) = khi ( i ) + 3 Pkhi ( i ) = khi ( i ) - 1 end if end do end subroutine change_map_to_particular_range","tags":"","loc":"proc/change_map_to_particular_range.html","title":"change_map_to_particular_range – FEST-3D"},{"text":"private subroutine read_periodic_bc_file(files, control, bc) Read periodic.md file in the system/mesh/layout/periodic.md Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Files' name and handler type( controltype ), intent(in) :: control Control parameters type( boundarytype ), intent(inout) :: bc boundary conditions and fixed values Called by proc~~read_periodic_bc_file~~CalledByGraph proc~read_periodic_bc_file read_periodic_bc_file proc~read_interface_map read_interface_map proc~read_interface_map->proc~read_periodic_bc_file proc~setup_grid setup_grid proc~setup_grid->proc~read_interface_map proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocread_periodic_bc_fileCalledByGraph = svgPanZoom('#procread_periodic_bc_fileCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_periodic_bc_file Source Code subroutine read_periodic_bc_file ( files , control , bc ) !< Read periodic.md file in the system/mesh/layout/periodic.md implicit none type ( filetype ), intent ( in ) :: files !< Files' name and handler type ( controltype ), intent ( in ) :: control !< Control parameters type ( boundarytype ), intent ( inout ) :: bc !< boundary conditions and fixed values integer :: ios integer :: max_call integer :: i integer :: b1 , b2 integer :: f1 , f2 integer :: class open ( files % PERIODIC_FILE_UNIT , file = files % periodicfile , status = 'old' , action = 'read' ) read ( files % PERIODIC_FILE_UNIT , * ) !ignore first line (header) max_call = control % total_process * 6 do i = 1 , max_call read ( files % PERIODIC_FILE_UNIT , * , iostat = ios ) b1 , b2 , f1 , f2 , class if ( is_iostat_end ( ios )) EXIT if ( b1 == control % process_id ) then bc % PbcId ( f1 ) = b2 end if end do close ( files % PERIODIC_FILE_UNIT ) end subroutine read_periodic_bc_file","tags":"","loc":"proc/read_periodic_bc_file.html","title":"read_periodic_bc_file – FEST-3D"},{"text":"public subroutine get_process_data(control) Get Processor Id and total number of processors Arguments Type Intent Optional Attributes Name type( controltype ), intent(inout) :: control Control parameters Calls proc~~get_process_data~~CallsGraph proc~get_process_data get_process_data mpi_comm_size mpi_comm_size proc~get_process_data->mpi_comm_size mpi_comm_rank mpi_comm_rank proc~get_process_data->mpi_comm_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_process_data~~CalledByGraph proc~get_process_data get_process_data proc~setup_solver setup_solver proc~setup_solver->proc~get_process_data proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_process_data Source Code subroutine get_process_data ( control ) !<Get Processor Id and total number of processors implicit none type ( controltype ), intent ( inout ) :: control !< Control parameters ! Finds and sets process data integer :: ierr call MPI_COMM_RANK ( MPI_COMM_WORLD , control % process_id , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , control % total_process , ierr ) process_id = control % process_id end subroutine get_process_data","tags":"","loc":"proc/get_process_data.html","title":"get_process_data – FEST-3D"},{"text":"public subroutine get_next_token_parallel(handler, buf) Extract the next token from the layout file Each token is on a separate line.\n There may be multiple comments (lines beginning with #) \n and blank lines in between.\n The purpose of this subroutine is to ignore all these \n lines and return the next \"useful\" line. Arguments Type Intent Optional Attributes Name integer, intent(in) :: handler character(len=STRING_BUFFER_LENGTH), intent(out) :: buf Called by proc~~get_next_token_parallel~~CalledByGraph proc~get_next_token_parallel get_next_token_parallel proc~read_layout_file read_layout_file proc~read_layout_file->proc~get_next_token_parallel proc~setup_solver setup_solver proc~setup_solver->proc~read_layout_file proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_next_token_parallel Source Code subroutine get_next_token_parallel ( handler , buf ) !< Extract the next token from the layout file !< !< Each token is on a separate line. !< There may be multiple comments (lines beginning with #) !< and blank lines in between. !< The purpose of this subroutine is to ignore all these !< lines and return the next \"useful\" line. !----------------------------------------------------------- implicit none integer , intent ( in ) :: handler character ( len = STRING_BUFFER_LENGTH ), intent ( out ) :: buf integer :: ios do !read(CONFIG_FILE_UNIT, '(A)', iostat=ios) buf read ( handler , '(A)' , iostat = ios ) buf if ( ios /= 0 ) then print * , 'Error while reading config file.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH stop end if if ( index ( buf , '#' ) == 1 ) then ! The current line begins with a hash ! Ignore it continue else if ( len_trim ( buf ) == 0 ) then ! The current line is empty ! Ignore it continue else ! A new token has been found ! Break out exit end if end do end subroutine get_next_token_parallel","tags":"","loc":"proc/get_next_token_parallel.html","title":"get_next_token_parallel – FEST-3D"},{"text":"public subroutine read_layout_file(files, control, bc) Read the layout file for particular processor Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files Files' name and handler type( controltype ), intent(in) :: control Processor id for current block type( boundarytype ), intent(inout) :: bc boundary conditions and fixed values Calls proc~~read_layout_file~~CallsGraph proc~read_layout_file read_layout_file debugcall debugcall proc~read_layout_file->debugcall proc~get_next_token_parallel get_next_token_parallel proc~read_layout_file->proc~get_next_token_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_layout_file~~CalledByGraph proc~read_layout_file read_layout_file proc~setup_solver setup_solver proc~setup_solver->proc~read_layout_file proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_layout_file Source Code subroutine read_layout_file ( files , control , bc ) !< Read the layout file for particular processor implicit none type ( filetype ), intent ( inout ) :: files !< Files' name and handler type ( boundarytype ), intent ( inout ) :: bc !< boundary conditions and fixed values character ( len = STRING_BUFFER_LENGTH ) :: buf !< read buffer character ( len = 128 ) :: grid_file_buf !< Name of the gridfile to load character ( len = 128 ) :: bc_file !< Name of the boundary condition file to load. type ( controltype ) , intent ( in ) :: control !< Processor id for current block integer :: total_entries !< Total enteries in layout.md for each processorS integer :: i , buf_id DebugCall ( 'read_layout_file' ) open ( files % CONFIG_FILE_UNIT , file = files % layout_file ) ! Read the parameters from the file call get_next_token_parallel ( files % CONFIG_FILE_UNIT , buf ) read ( buf , * ) !control%total_process call get_next_token_parallel ( files % CONFIG_FILE_UNIT , buf ) read ( buf , * ) total_entries i = 0 !print *, process_id call get_next_token_parallel ( files % CONFIG_FILE_UNIT , buf ) do while ( i < control % process_id ) call get_next_token_parallel ( files % CONFIG_FILE_UNIT , buf ) i = i + 1 end do read ( buf , * ) buf_id , grid_file_buf , bc_file , bc % imin_id , bc % imax_id , bc % jmin_id , bc % jmax_id , bc % kmin_id , bc % kmax_id write ( files % gridfile , '(A)' ) 'system/mesh/gridfiles/' // trim ( grid_file_buf ) write ( files % bcfile , '(A)' ) 'system/mesh/bc/' // trim ( bc_file ) end subroutine read_layout_file","tags":"","loc":"proc/read_layout_file.html","title":"read_layout_file – FEST-3D"},{"text":"public subroutine calculate_viscosity(qp, scheme, flow, bc, dims) Calculate molecular and turbulent viscosity Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Called by proc~~calculate_viscosity~~CalledByGraph proc~calculate_viscosity calculate_viscosity proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~calculate_viscosity proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccalculate_viscosityCalledByGraph = svgPanZoom('#proccalculate_viscosityCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_viscosity Source Code subroutine calculate_viscosity ( qp , scheme , flow , bc , dims ) !< Calculate molecular and turbulent viscosity implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center integer :: i , j , k real ( wp ) :: T ! molecular viscosity real ( wp ) :: c ! kkl eddy viscosity !- sst varibales -! real ( wp ) :: F real ( wp ) :: arg2 real ( wp ) :: vort real ( wp ) :: NUM real ( wp ) :: DENOM ! for arg2 real ( wp ) :: var1 real ( wp ) :: var2 !for vorticity real ( wp ) :: wijwij real ( wp ) :: wx real ( wp ) :: wy real ( wp ) :: wz !for strain calculation real ( wp ) :: SijSij real ( wp ) :: Sxx , Syy , Szz real ( wp ) :: Sxy , Szx , Syz real ( wp ) :: strain !for arg1 real ( wp ) :: arg1 real ( wp ) :: CD real ( wp ) :: right real ( wp ) :: left ! sa variables real ( wp ) :: fv1 real ( wp ) :: xi real ( wp ) :: pressure real ( wp ) :: density real ( wp ) :: tk real ( wp ) :: tkl real ( wp ) :: tw real ( wp ) :: tv integer :: imx , jmx , kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx !--- calculate_molecular_viscosity ---! if ( flow % mu_ref /= 0. ) then select case ( trim ( flow % mu_variation )) case ( 'sutherland_law' ) ! apply_sutherland_law do k = 0 , kmx do j = 0 , jmx do i = 0 , imx pressure = qp ( i , j , k , 5 ) density = qp ( i , j , k , 1 ) T = pressure / ( density * flow % R_gas ) mu ( i , j , k ) = flow % mu_ref * (( T / flow % T_ref ) ** ( 1.5 )) & * (( flow % T_ref + flow % Sutherland_temp )& / ( T + flow % Sutherland_temp )) end do end do end do case ( 'constant' ) !do nothing !mu will be equal to mu_ref continue case DEFAULT print * , \"mu_variation not recognized:\" print * , \"   found '\" , trim ( flow % mu_variation ), \"'\" print * , \"accepted values: 1) sutherland_law\" print * , \"                 2) constant\" Fatal_error end select end if !--- end molecular viscosity calculation---! !--- calculate_turbulent_viscosity  ---! if ( scheme % turbulence /= 'none' ) then select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) !call calculate_sa_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx tv = qp ( i , j , k , 6 ) density = qp ( i , j , k , 1 ) ! xsi xi = tv * density / mu ( i , j , k ) !calculation fo fv1 function fv1 = ( xi ** 3 ) / (( xi ** 3 ) + ( cv1 ** 3 )) mu_t ( i , j , k ) = density * tv * fv1 end do end do end do ! populating ghost cell do i = 1 , 6 select case ( bc % id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sa_mu, \"symm\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sa_mu, \"anti\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sa eddy viscosity  ---! case ( 'sst2003' ) !call calculate_sst_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tw = qp ( i , j , k , 7 ) ! calculate_arg2() var1 = sqrt ( tk ) / ( bstar * tw * dist ( i , j , k )) var2 = 500 * ( mu ( i , j , k ) / density ) / (( dist ( i , j , k ) ** 2 ) * tw ) arg2 = max ( 2 * var1 , var2 ) ! calculate_f2() F = tanh ( arg2 ** 2 ) ! calculate_vorticity( sxx = ( gradu_x ( i , j , k )) syy = ( gradv_y ( i , j , k )) szz = ( gradw_z ( i , j , k )) syz = ( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) szx = ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) sxy = ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) SijSij = ( 2.0 * ( sxx ** 2 )) + ( 2.0 * ( syy ** 2 )) + ( 2.0 * ( szz ** 2 )) + syz ** 2 + szx ** 2 + sxy ** 2 strain = sqrt ( SijSij ) NUM = density * a1 * tk DENOM = max ( max (( a1 * tw ), strain * F ), 1.0e-10 ) mu_t ( i , j , k ) = NUM / DENOM !-- end eddy visocisyt calculation --! !-- calculating blending function F1 --! CD = max ( 2 * density * sigma_w2 * ( & gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw , & 1.0e-10 ) right = 4 * ( density * sigma_w2 * tk ) / ( CD * ( dist ( i , j , k ) ** 2 )) left = max ( var1 , var2 ) arg1 = min ( left , right ) sst_F1 ( i , j , k ) = tanh ( arg1 ** 4 ) !-- end of blending function F1 calculation --! end do end do end do select case ( trim ( scheme % transition )) case ( 'lctm2015' ) do k = 0 , kmx do j = 0 , jmx do i = 0 , imx !modified blending function (Menter 2015) var1 = density * dist ( i , j , k ) * sqrt ( tk ) / mu ( i , j , k ) var2 = exp ( - ( var1 / 120 ) ** 8 ) sst_F1 ( i , j , k ) = max ( sst_F1 ( i , j , k ), var2 ) end do end do end do case DEFAULT !do nothing continue end select ! populating ghost cell do i = 1 , 6 select case ( bc % id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sst_mu, \"symm\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sst_mu, \"anti\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sst2003 eddy viscosity  and blending fucntion calculation ---! case ( 'sst' ) !call calculate_sst_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tw = qp ( i , j , k , 7 ) ! calculate_arg2() var1 = sqrt ( tk ) / ( bstar * tw * dist ( i , j , k )) var2 = 500 * ( mu ( i , j , k ) / density ) / (( dist ( i , j , k ) ** 2 ) * tw ) arg2 = max ( 2 * var1 , var2 ) ! calculate_f2() F = tanh ( arg2 ** 2 ) ! calculate_vorticity( wx = ( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) wy = ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) wz = ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) wijwij = wx ** 2 + wy ** 2 + wz ** 2 vort = sqrt ( wijwij ) NUM = density * a1 * tk DENOM = max ( max (( a1 * tw ), vort * F ), 1.e-20 ) mu_t ( i , j , k ) = NUM / DENOM !-- end eddy visocisyt calculation --! !-- calculating blending function F1 --! CD = max ( 2 * density * sigma_w2 * ( & gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw , & 1 e - 20 ) right = 4 * ( density * sigma_w2 * tk ) / ( CD * ( dist ( i , j , k ) ** 2 )) left = max ( var1 , var2 ) arg1 = min ( left , right ) sst_F1 ( i , j , k ) = tanh ( arg1 ** 4 ) !-- end of blending function F1 calculation --! end do end do end do select case ( trim ( scheme % transition )) case ( 'lctm2015' ) do k = 0 , kmx do j = 0 , jmx do i = 0 , imx !modified blending function (Menter 2015) var1 = density * dist ( i , j , k ) * sqrt ( tk ) / mu ( i , j , k ) var2 = exp ( - ( var1 / 120 ) ** 8 ) sst_F1 ( i , j , k ) = max ( sst_F1 ( i , j , k ), var2 ) end do end do end do case DEFAULT !do nothing continue end select ! populating ghost cell do i = 1 , 6 select case ( bc % id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sst_mu, \"symm\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sst_mu, \"anti\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sst eddy viscosity  and blending fucntion calculation ---! case ( 'kkl' ) !--- calculate_kkl_mu() c = cmu ** 0.25 do k = 0 , kmx do j = 0 , jmx do i = 0 , imx density = qp ( i , j , k , 1 ) tk = qp ( i , j , k , 6 ) tkl = qp ( i , j , k , 7 ) mu_t ( i , j , k ) = c * density * tkl / ( max ( sqrt ( tk ), 1.e-20 )) if ( tkl < 1.e-14 . or . tk < 1.e-14 ) & mu_t ( i , j , k ) = 0.0 end do end do end do ! populating ghost cell do i = 1 , 6 select case ( bc % id ( i )) case ( - 10 , 0 :) !interface continue case ( - 4 : - 1 , - 6 , - 8 , - 9 ) !call copy1(kkl_mu, \"symm\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(kkl_mu, \"anti\", face_names(i)) select case ( bc % face_names ( i )) case ( \"imin\" ) mu_t ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) mu_t ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - mu_t ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) mu_t ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) mu_t ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - mu_t ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - mu_t ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of kkl eddy viscosity calculation ---! case DEFAULT Fatal_error end select end if !--- end turbulent viscosity calculation---! !--- check on viscosity ---! if ( any ( isnan ( mu ))) then Fatal_error end if end subroutine calculate_viscosity","tags":"","loc":"proc/calculate_viscosity.html","title":"calculate_viscosity – FEST-3D"},{"text":"public subroutine setup_viscosity(scheme, flow, dims) Allocate and pointer for molecular and turbulent viscosity Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~setup_viscosity~~CallsGraph proc~setup_viscosity setup_viscosity interface~alloc alloc proc~setup_viscosity->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_viscosity~~CalledByGraph proc~setup_viscosity setup_viscosity proc~setup_solver setup_solver proc~setup_solver->proc~setup_viscosity proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_viscosity Source Code subroutine setup_viscosity ( scheme , flow , dims ) !< Allocate and pointer for molecular and turbulent viscosity implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. integer :: imx , jmx , kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx !setup_molecular_viscosity() if ( flow % mu_ref /= 0. ) then call alloc ( mu , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) mu = flow % mu_ref !intialize end if !--- setup_turbulent_viscosity ---! if ( scheme % turbulence /= 'none' ) then call alloc ( mu_t , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) select case ( trim ( scheme % turbulence )) case ( 'none' , 'sa' , 'saBC' , 'kkl' ) !do nothing continue case ( 'sst' , 'sst2003' ) !-- sst blending funciton F1 --! call alloc ( sst_F1 , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) sst_F1 = 0. !-- sst blnding function setup compete--! case DEFAULT Fatal_error end select end if ! --- end turbulent viscosity setup ---! end subroutine setup_viscosity","tags":"","loc":"proc/setup_viscosity.html","title":"setup_viscosity – FEST-3D"},{"text":"public subroutine setup_update(control, scheme, flow, dims) Allocate memory to variables required based \n on the time-integration scheme. Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~setup_update~~CallsGraph proc~setup_update setup_update interface~alloc alloc proc~setup_update->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~setup_lusgs->interface~alloc proc~setup_plusgs->interface~alloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_update~~CalledByGraph proc~setup_update setup_update proc~setup_solver setup_solver proc~setup_solver->proc~setup_update proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_update Source Code subroutine setup_update ( control , scheme , flow , dims ) !< Allocate memory to variables required based !< on the time-integration scheme. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var call alloc ( u1 , 1 , n_var ) call alloc ( u2 , 1 , n_var ) call alloc ( R , 1 , n_var ) call alloc ( aux , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) select case ( scheme % time_step_accuracy ) case ( \"none\" ) ! Do nothing continue case ( \"RK2\" , \"RK4\" ) call alloc ( U_store , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) call alloc ( R_store , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var ) case ( \"TVDRK2\" , \"TVDRK3\" ) call alloc ( U_store , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) case ( \"implicit\" ) call setup_lusgs ( control , scheme , flow , dims ) case ( \"plusgs\" ) call setup_plusgs ( control , scheme , flow , dims ) case default Fatal_error end select end subroutine setup_update","tags":"","loc":"proc/setup_update.html","title":"setup_update – FEST-3D"},{"text":"public subroutine get_next_solution(qp, Temp, residue, delta_t, cells, F, G, H, Ifaces, Jfaces, Kfaces, control, scheme, flow, bc, dims) Get solution at next time-step using scheme\n given in the input file. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2,1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: Temp Store Temperature variable at cell center real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center\n Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~get_next_solution~~CallsGraph proc~get_next_solution get_next_solution proc~get_total_conservative_residue get_total_conservative_Residue proc~get_next_solution->proc~get_total_conservative_residue proc~update_with update_with proc~get_next_solution->proc~update_with proc~compute_time_step compute_time_step proc~get_next_solution->proc~compute_time_step proc~update_with_plusgs update_with_plusgs proc~get_next_solution->proc~update_with_plusgs proc~update_with_lusgs update_with_lusgs proc~get_next_solution->proc~update_with_lusgs proc~apply_interface apply_interface proc~get_total_conservative_residue->proc~apply_interface proc~add_source_term_residue add_source_term_residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~compute_residue compute_residue proc~get_total_conservative_residue->proc~compute_residue proc~populate_ghost_primitive populate_ghost_primitive proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~evaluate_all_gradients evaluate_all_gradients proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~calculate_viscosity calculate_viscosity proc~get_total_conservative_residue->proc~calculate_viscosity proc~reconstruct_boundary_state reconstruct_boundary_state proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~compute_fluxes~7 compute_fluxes proc~get_total_conservative_residue->proc~compute_fluxes~7 proc~compute_face_interpolant compute_face_interpolant proc~get_total_conservative_residue->proc~compute_face_interpolant proc~compute_viscous_fluxes compute_viscous_fluxes proc~get_total_conservative_residue->proc~compute_viscous_fluxes debugcall debugcall proc~compute_time_step->debugcall proc~compute_local_time_step compute_local_time_step proc~compute_time_step->proc~compute_local_time_step proc~compute_global_time_step compute_global_time_step proc~compute_time_step->proc~compute_global_time_step proc~update_simulation_clock update_simulation_clock proc~compute_time_step->proc~update_simulation_clock proc~update_lctm2015 update_lctm2015 proc~update_with_plusgs->proc~update_lctm2015 proc~update_laminar_variables update_laminar_variables proc~update_with_plusgs->proc~update_laminar_variables proc~update_sa_variables update_SA_variables proc~update_with_plusgs->proc~update_sa_variables proc~update_sst_variables update_SST_variables proc~update_with_plusgs->proc~update_sst_variables proc~update_kkl_variables update_KKL_variables proc~update_with_lusgs->proc~update_kkl_variables proc~update_sa_variables~2 update_SA_variables proc~update_with_lusgs->proc~update_sa_variables~2 proc~update_lctm2015~2 update_lctm2015 proc~update_with_lusgs->proc~update_lctm2015~2 proc~update_with_lusgs->debugcall proc~update_laminar_variables~2 update_laminar_variables proc~update_with_lusgs->proc~update_laminar_variables~2 proc~update_sst_variables~2 update_SST_variables proc~update_with_lusgs->proc~update_sst_variables~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_next_solution~~CalledByGraph proc~get_next_solution get_next_solution proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_next_solution Source Code subroutine get_next_solution ( qp , Temp , residue , delta_t , cells , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) !< Get solution at next time-step using scheme !< given in the input file. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( inout ) :: Temp !< Store Temperature variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 ), intent ( inout ) :: delta_t !< Local time increment value at each cell center !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ) :: CFL CFL = control % CFL !finding the updated Temperature using ideal gas law !T=P/(R_gas*Rho) Temp = qp (:,:,:, 5 ) / ( flow % R_gas * qp (:,:,:, 1 ) ) select case ( trim ( scheme % time_step_accuracy )) case ( \"none\" ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1. , 1. , . FALSE .) case ( \"RK4\" ) R_store = 0. U_store = qp call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 0.5 , 1. , . FALSE ., R_store , U_store ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 0.5 , 2. , . FALSE ., R_store , U_store ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 2. , . FALSE ., R_store , U_store ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1. / 6. , 1. , . TRUE . , R_store , U_store ) case ( \"RK2\" ) R_store = 0. U_store = qp call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 0.5 , 1. , . FALSE ., R_store , U_store ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 0.5 , 1. , . TRUE ., R_store , U_store ) case ( \"TVDRK3\" ) U_store = qp call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 1. ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 1. ) qp = 0.75 * U_store + 0.25 * qp call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 1. ) qp = ( 1. / 3. ) * U_store + ( 2. / 3. ) * qp case ( \"TVDRK2\" ) U_store = qp call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 1. ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call update_with ( qp , residue , delta_t , cells , scheme , flow , \"conservative\" , 1.0 , 1. ) qp = 0.5 * U_store + 0.5 * qp case ( \"implicit\" ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with_lusgs ( qp , residue , delta_t , cells , Ifaces , Jfaces , Kfaces , scheme , dims ) case ( \"plusgs\" ) call get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_time_step ( qp , delta_t , CFL , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) ! has to be after get_..._Residue() call update_with_plusgs ( qp , delta_t , cells , Ifaces , Jfaces , Kfaces , residue , scheme , dims ) case default Fatal_error end select end subroutine get_next_solution","tags":"","loc":"proc/get_next_solution.html","title":"get_next_solution – FEST-3D"},{"text":"private subroutine update_with(qp, residue, delta_t, cells, scheme, flow, type, time_factor, store_factor, use, Rn, un) A generalized scheme to updat the solution explicitly using\n any RK method and even first order euler explicit. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:imx-1,1:jmx-1,1:kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: cells Cell center quantities: volume type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. character(len=*), intent(in) :: type real(kind=wp), intent(in), optional :: time_factor real(kind=wp), intent(in), optional :: store_factor logical, intent(in), optional :: use real(kind=wp), intent(inout), optional dimension(1:imx-1,1:jmx-1,1:kmx-1,1:n_var) :: Rn real(kind=wp), intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un Called by proc~~update_with~~CalledByGraph proc~update_with update_with proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_with Source Code subroutine update_with ( qp , residue , delta_t , cells , scheme , flow , type , time_factor , store_factor , use , Rn , un ) !< A generalized scheme to updat the solution explicitly using !< any RK method and even first order euler explicit. implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( inout ), target :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( in ) :: cells !< Cell center quantities: volume real ( wp ), dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ), intent ( in ) :: delta_t !< Local time increment value at each cell center real ( wp ), dimension (:, :, :, :), intent ( in ) :: residue !< Store residue at each cell-center type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. character ( len =* ), intent ( in ) :: type real ( wp ), intent ( in ), optional :: time_factor ! time factor real ( wp ), intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ), optional , target :: un real ( wp ), dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional :: Rn real ( wp ) :: TF = 1.0 !time factor real ( wp ) :: SF = 1.0 !store factor Logical :: TU = . FALSE . !to use or not real ( wp ), dimension (:,:,:,:), pointer :: Quse integer :: i , j , k real ( wp ) :: KE = 0. real ( wp ) :: beta !sa variables real ( wp ) :: vort real ( wp ) :: fv1 real ( wp ) :: fv2 real ( wp ) :: fw real ( wp ) :: g real ( wp ) :: scap real ( wp ) :: rsa real ( wp ) :: kd2 real ( wp ) :: xi real ( wp ) :: mass_residue real ( wp ) :: x_mom_residue , y_mom_residue , z_mom_residue real ( wp ) :: energy_residue real ( wp ) :: TKE_residue , Omega_residue , kl_residue if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if select case ( type ) case ( 'primitive' ) !update primitive variable do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 mass_residue = residue ( i , j , k , 1 ) x_mom_residue = residue ( i , j , k , 2 ) y_mom_residue = residue ( i , j , k , 3 ) z_mom_residue = residue ( i , j , k , 4 ) energy_residue = residue ( i , j , k , 5 ) u1 ( 1 : n_var ) = Quse ( i , j , k , 1 : n_var ) ! finding primitive residue R ( 1 ) = mass_residue R ( 2 ) = - 1 * ( u1 ( 2 ) / u1 ( 1 )) * mass_residue + x_mom_residue / u1 ( 1 ) R ( 3 ) = - 1 * ( u1 ( 3 ) / u1 ( 1 )) * mass_residue + y_mom_residue / u1 ( 1 ) R ( 4 ) = - 1 * ( u1 ( 4 ) / u1 ( 1 )) * mass_residue + z_mom_residue / u1 ( 1 ) R ( 5 ) = 0.5 * ( flow % gm - 1. ) * ( sum ( u1 ( 2 : 4 ) ** 2 ) * mass_residue ) & - ( flow % gm - 1. ) * u1 ( 2 ) * x_mom_residue & - ( flow % gm - 1. ) * u1 ( 3 ) * y_mom_residue & - ( flow % gm - 1. ) * u1 ( 4 ) * z_mom_residue & + ( flow % gm - 1. ) * energy_residue select case ( scheme % turbulence ) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) TKE_residue = residue ( i , j , k , 6 ) omega_residue = residue ( i , j , k , 7 ) beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 5 ) = R ( 5 ) - ( flow % gm - 1. ) * TKE_residue R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue & + ( 1. / ( 1. + bstar * u1 ( 6 ) * delta_t ( i , j , k ))) * TKE_residue / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue & + ( 1. / ( 1. + 2. * beta * u1 ( 6 ) * delta_t ( i , j , k ))) * omega_residue / u1 ( 1 ) case ( 'kkl' ) TKE_residue = residue ( i , j , k , 6 ) kl_residue = residue ( i , j , k , 7 ) eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 5 ) = R ( 5 ) - ( flow % gm - 1. ) * TKE_residue R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue & + ( 1. / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * u1 ( 1 ) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )))) * TKE_residue / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue & + ( 1. / ( 1. + ( 6 * mu ( i , j , k ) * fphi / dist ( i , j , k ) ** 2 ) * delta_t ( i , j , k ))) * kl_residue / u1 ( 1 ) case DEFAULT Fatal_error end select !check if user want to store residue if ( present ( Rn )) then Rn ( i , j , k , 1 : n_var ) = Rn ( i , j , k , 1 : n_var ) + SF * R ( 1 : n_var ) if ( TU ) R (:) = Rn ( i , j , k ,:) end if !update u2 (:) = u1 (:) - R (:) * ( TF * delta_t ( i , j , k ) / cells ( i , j , k )% volume ) !check solution for non pyhysical results if (( u2 ( 1 ) < 0. ) . or . ( u2 ( 5 )) < 0. ) then Fatal_error else !update qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kkl' ) if ( u2 ( 6 ) > 0. ) qp ( i , j , k , 6 ) = u2 ( 6 ) if ( u2 ( 7 ) > 0. ) qp ( i , j , k , 7 ) = u2 ( 7 ) case DEFAULT ! do nothing continue end select end if end do end do end do case ( 'conservative' ) !include \"update_conservative.inc\" !update conservative variable do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! getting conservative variable u1 ( 1 ) = Quse ( i , j , k , 1 ) u1 ( 2 :) = Quse ( i , j , k , 2 :) * u1 ( 1 ) select case ( scheme % turbulence ) case ( 'sst' , 'sst2003' , 'kkl' ) KE = 0.0 !u1(6) case ( 'sa' , 'saBC' ) KE = 0.0 case DEFAULT KE = 0. end select u1 ( 5 ) = ( u1 ( 5 ) / ( flow % gm - 1. ) + 0.5 * sum ( u1 ( 2 : 4 ) ** 2 )) / u1 ( 1 ) + KE ! get R R ( 1 : n_var ) = residue ( i , j , k , 1 : n_var ) ! point implicit destruction term select case ( trim ( scheme % turbulence )) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 6 ) = R ( 6 ) / ( 1 + ( beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1 + ( 2 * beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) case ( 'kkl' ) eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 6 ) = R ( 6 ) / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * sqrt ( u1 ( 1 )) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / ( dist ( i , j , k ) ** 2 ))) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1. + ( 6 * mu ( i , j , k ) * fphi / ( dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )) case ( 'sa' , 'saBC' ) vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) kd2 = ( kappa_sa * dist ( i , j , k )) ** 2 xi = U1 ( 6 ) * qp ( i , j , k , 1 ) / mu ( i , j , k ) fv1 = xi ** 3 / ( xi ** 3 + cv1 ** 3 ) fv2 = 1.0 - xi / ( 1 + xi * fv1 ) scap = vort + U1 ( 6 ) * fv2 / ( kd2 ) rsa = min ( U1 ( 6 ) / ( Scap * kd2 ), 1 0.0 ) g = rsa + cw2 * ( rsa ** 6 - rsa ) fw = g * ( ( 1.0 + cw3 ** 6 ) / ( g ** 6 + cw3 ** 6 ) ) ** ( 1.0 / 6.0 ) R ( 6 ) = R ( 6 ) / ( 1. + (( - 1.0 * u1 ( 1 ) * cb1 * scap ) + ( 2.0 * u1 ( 1 ) * cw1 * fw * u1 ( 6 ) / ( dist ( i , j , k ) ** 2 ))) * delta_t ( i , j , k )) case DEFAULT Fatal_error end select !check if user want to store residue if ( present ( Rn )) then Rn ( i , j , k , 1 : n_var ) = Rn ( i , j , k , 1 : n_var ) + SF * R ( 1 : n_var ) if ( TU ) R (:) = Rn ( i , j , k ,:) end if !update u2 ( 1 : n_var ) = u1 ( 1 : n_var ) - R ( 1 : n_var ) * ( TF * delta_t ( i , j , k ) / cells ( i , j , k )% volume ) ! getting primitve variable back variable u2 ( 1 ) = u2 ( 1 ) u2 ( 2 :) = u2 ( 2 :) / u2 ( 1 ) select case ( scheme % turbulence ) case ( 'sst' , 'sst2003' , 'kkl' ) KE = 0.0 !u2(6) case ( 'sa' , 'saBC' ) !u2(6) = u2(6)*u2(1) KE = 0.0 case DEFAULT KE = 0. end select u2 ( 5 ) = ( flow % gm - 1. ) * u2 ( 1 ) * ( u2 ( 5 ) - ( 0.5 * sum ( u2 ( 2 : 4 ) ** 2 )) - KE ) !check solution for non pyhysical results if (( u2 ( 1 ) < 0. ) . or . ( u2 ( 5 )) < 0. . or . any ( isnan ( u2 ))) then print * , u2 (:) print * , \"R: \" , R print * , \"old \" , U1 Fatal_error else !update qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kkl' ) if ( u2 ( 6 ) >= 0. ) then qp ( i , j , k , 6 ) = u2 ( 6 ) else !  qp(i,j,k,6) = tk_inf !  qp(i,j,k,6) = (max(qp(i-1,j,k,6),0.) + max(qp(i+1,j,k,6),0.) & !                +max(qp(i,j-1,k,6),0.) + max(qp(i,j+1,k,6),0.) & !                )/4 !  qp(i,j,k,6) = 1.e-3*maxval(qp(i-1:i+1,j-1:j+1,k-1:k+1,6)) end if if ( u2 ( 7 ) >= 0. ) then qp ( i , j , k , 7 ) = u2 ( 7 ) else !  qp(i,j,k,7) = tkl_inf !  qp(i,j,k,7) = (max(qp(i-1,j,k,7),0.) + max(qp(i+1,j,k,7),0.) & !                +max(qp(i,j-1,k,7),0.) + max(qp(i,j+1,k,7),0.) & !                )/4 end if case ( 'sa' , 'saBC' ) qp ( i , j , k , 6 ) = max ( u2 ( 6 ), 1.e-12 ) case DEFAULT ! do nothing continue end select end if !print*, i,j, R(1:n_var) end do end do end do case DEFAULT Fatal_error end select end subroutine update_with","tags":"","loc":"proc/update_with.html","title":"update_with – FEST-3D"},{"text":"private subroutine get_total_conservative_Residue(qp, Temp, cells, residue, F, G, H, Ifaces, Jfaces, Kfaces, control, scheme, flow, bc, dims) For each iteration it apply boundary conditions,\n use higher order method to reconstruct state at\n face, evalute fluxes at each face, calculate \n inviscid residual, and introuduce additional \n residual due to  viscosity, turbulence and source\n terms. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2,1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: Temp Store Temperature variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~get_total_conservative_residue~~CallsGraph proc~get_total_conservative_residue get_total_conservative_Residue proc~evaluate_all_gradients evaluate_all_gradients proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~compute_face_interpolant compute_face_interpolant proc~get_total_conservative_residue->proc~compute_face_interpolant proc~calculate_viscosity calculate_viscosity proc~get_total_conservative_residue->proc~calculate_viscosity proc~reconstruct_boundary_state reconstruct_boundary_state proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~compute_fluxes~7 compute_fluxes proc~get_total_conservative_residue->proc~compute_fluxes~7 proc~add_source_term_residue add_source_term_residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~compute_viscous_fluxes compute_viscous_fluxes proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~compute_residue compute_residue proc~get_total_conservative_residue->proc~compute_residue proc~apply_interface apply_interface proc~get_total_conservative_residue->proc~apply_interface proc~populate_ghost_primitive populate_ghost_primitive proc~get_total_conservative_residue->proc~populate_ghost_primitive Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_total_conservative_residue~~CalledByGraph proc~get_total_conservative_residue get_total_conservative_Residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_total_conservative_Residue Source Code subroutine get_total_conservative_Residue ( qp , Temp , cells , residue , F , G , H , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) !< For each iteration it apply boundary conditions, !< use higher order method to reconstruct state at !< face, evalute fluxes at each face, calculate !< inviscid residual, and introuduce additional !< residual due to  viscosity, turbulence and source !< terms. implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Temp !< Store Temperature variable at cell center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal call apply_interface ( qp , control , bc , dims ) call populate_ghost_primitive ( qp , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) call compute_face_interpolant ( qp , cells , scheme , flow , dims ) call reconstruct_boundary_state ( qp , control , scheme , bc , dims ) call compute_fluxes ( F , G , H , Ifaces , Jfaces , Kfaces , scheme , flow , bc , dims ) if ( flow % mu_ref /= 0.0 ) then call evaluate_all_gradients ( qp , Temp , cells , Ifaces , Jfaces , Kfaces , scheme , bc , dims ) call calculate_viscosity ( qp , scheme , flow , bc , dims ) call compute_viscous_fluxes ( F , G , H , qp , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) end if call compute_residue ( residue , F , G , H , dims ) call add_source_term_residue ( qp , residue , cells , Ifaces , Jfaces , Kfaces , scheme , flow , dims ) end subroutine get_total_conservative_Residue","tags":"","loc":"proc/get_total_conservative_residue.html","title":"get_total_conservative_Residue – FEST-3D"},{"text":"private function vol_tetrahedron(p1, p2, p3, p4) Compute the volume of a tetrahedron, given 4 points which\n are 1-D arrays\n Since we know that the determinant is to be evaluated of \n a 3x3 matrix, we write the expression itself Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: p1 real(kind=wp), intent(in), dimension(:) :: p2 real(kind=wp), intent(in), dimension(:) :: p3 real(kind=wp), intent(in), dimension(:) :: p4 Return Value real(kind=wp) Called by proc~~vol_tetrahedron~~CalledByGraph proc~vol_tetrahedron vol_tetrahedron proc~vol_hexahedron vol_hexahedron proc~vol_hexahedron->proc~vol_tetrahedron proc~compute_volumes compute_volumes proc~compute_volumes->proc~vol_hexahedron proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_volumes proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocvol_tetrahedronCalledByGraph = svgPanZoom('#procvol_tetrahedronCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code vol_tetrahedron Source Code function vol_tetrahedron ( p1 , p2 , p3 , p4 ) !< Compute the volume of a tetrahedron, given 4 points which !< are 1-D arrays !< Since we know that the determinant is to be evaluated of !< a 3x3 matrix, we write the expression itself !----------------------------------------------------------- implicit none real ( wp ), dimension (:), intent ( in ) :: p1 , p2 , p3 , p4 real ( wp ), dimension ( 1 : 3 , 1 : 3 ) :: A real ( wp ) :: vol_tetrahedron A (:, 1 ) = p1 - p4 A (:, 2 ) = p2 - p4 A (:, 3 ) = p3 - p4 !vol_tetrahedron = A(1,1) * (A(2,2)*A(3,3) - A(2,3)*A(3,2)) + & !                  A(1,2) * (A(2,3)*A(3,1) - A(2,1)*A(3,3)) + & !                  A(1,3) * (A(2,1)*A(3,2) - A(2,2)*A(3,1)) vol_tetrahedron = ( p4 ( 1 ) - p1 ( 1 )) * (( p2 ( 2 ) - p1 ( 2 )) * ( p3 ( 3 ) - p1 ( 3 )) - ( p2 ( 3 ) - p1 ( 3 )) * ( p3 ( 2 ) - p1 ( 2 ))) & + ( p4 ( 2 ) - p1 ( 2 )) * (( p2 ( 3 ) - p1 ( 3 )) * ( p3 ( 1 ) - p1 ( 1 )) - ( p2 ( 1 ) - p1 ( 1 )) * ( p3 ( 3 ) - p1 ( 3 ))) & + ( p4 ( 3 ) - p1 ( 3 )) * (( p2 ( 1 ) - p1 ( 1 )) * ( p3 ( 2 ) - p1 ( 2 )) - ( p2 ( 2 ) - p1 ( 2 )) * ( p3 ( 1 ) - p1 ( 1 ))) vol_tetrahedron = - vol_tetrahedron / 6. end function vol_tetrahedron","tags":"","loc":"proc/vol_tetrahedron.html","title":"vol_tetrahedron – FEST-3D"},{"text":"private function vol_hexahedron(p_list) Compute the volume of a hexahedron, given a list of points Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:3, 1:8) :: p_list Return Value real(kind=wp) Calls proc~~vol_hexahedron~~CallsGraph proc~vol_hexahedron vol_hexahedron proc~vol_tetrahedron vol_tetrahedron proc~vol_hexahedron->proc~vol_tetrahedron Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vol_hexahedron~~CalledByGraph proc~vol_hexahedron vol_hexahedron proc~compute_volumes compute_volumes proc~compute_volumes->proc~vol_hexahedron proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_volumes proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocvol_hexahedronCalledByGraph = svgPanZoom('#procvol_hexahedronCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code vol_hexahedron Source Code function vol_hexahedron ( p_list ) !< Compute the volume of a hexahedron, given a list of points ! The points are arranged in a specific order. For the ! element i,j,k, the order of nodes required are: ! i,j,k ! i+1, j, k ! i+1, j+1, k ! i, j+1, k ! i, j, k+1 ! i+1, j, k+1 ! i+1, j+1, k+1 ! i, j+1, k+1 ! ! The hexahedron is to be split into 5 tetrahedrons. ! Source: Split hex into 5 tetrahedron: ! No assumptions about planarity seem to be made. All cuts ! were made with a plane containing only 3 vertices at a time. ! https://ieeexplore.ieee.org/ieee_pilot/articles/06/ttg2009061587/assets/img/article_1/fig_6/large.gif ! ! The indices of the 5 split tetrahedra can be visualised from ! the above link. But since the volume of each tetrahedron ! depends on the determinant calculated, it is IMPERATIVE to ! ensure that a \"correct\" order is followed for the 4 points. ! ! The logic to get the \"correct\" order is explained as ! follows (Refer wiki article on parallelepiped): ! The determinant is taken of a matrix of pi - p4, i = 1, 2, 3. ! Graphically it denotes the sides with p4 as common vertex, ! with direction outward from p4, i.e., directed from ! p4 to pi, i = 1, 2, 3 ! Hence, if you ensure that  cross(p1-p4, p2-p4) is along ! p3-p4, then the determinant will be positive. ! ! From the above link, a set of 5 tetrahedra was obtained. ! Each tetrahedra has 4 points, and in the function calls ! below, care was taken to ensure that the order is observed ! while passing parameters into the vol_tetrahedron function !----------------------------------------------------------- implicit none real ( wp ), dimension ( 1 : 3 , 1 : 8 ), intent ( in ) :: p_list real ( wp ) :: vol_hexahedron real ( wp ) :: vol_hexahedron1 vol_hexahedron1 = 0. vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 1 ), p_list (:, 5 ), & p_list (:, 8 ), p_list (:, 6 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 7 ), p_list (:, 8 ), & p_list (:, 6 ), p_list (:, 3 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 8 ), p_list (:, 4 ), & p_list (:, 1 ), p_list (:, 3 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 6 ), p_list (:, 1 ), & p_list (:, 3 ), p_list (:, 8 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 1 ), p_list (:, 2 ), & p_list (:, 6 ), p_list (:, 3 )) vol_hexahedron = 0. vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 2 ), p_list (:, 6 ), & p_list (:, 5 ), p_list (:, 7 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 8 ), p_list (:, 5 ), & p_list (:, 7 ), p_list (:, 4 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 5 ), p_list (:, 1 ), & p_list (:, 2 ), p_list (:, 4 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 7 ), p_list (:, 2 ), & p_list (:, 4 ), p_list (:, 5 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 2 ), p_list (:, 3 ), & p_list (:, 7 ), p_list (:, 4 )) vol_hexahedron = max ( vol_hexahedron , vol_hexahedron1 ) end function vol_hexahedron","tags":"","loc":"proc/vol_hexahedron.html","title":"vol_hexahedron – FEST-3D"},{"text":"private subroutine allocate_memory(cells, Ifaces, Jfaces, Kfaces) Allocate memory for the required variables. Allocate memory for cells Allocate memory for the face variables. Arguments Type Intent Optional Attributes Name type( celltype ), intent(out), dimension(:,:,:), allocatable :: cells Store cell center quantities: volume, cell center coordinate type( facetype ), intent(out), dimension(:,:,:), allocatable :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(out), dimension(:,:,:), allocatable :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(out), dimension(:,:,:), allocatable :: Kfaces Store face quantites for K faces: normal and area Calls proc~~allocate_memory~2~~CallsGraph proc~allocate_memory~2 allocate_memory debugcall debugcall proc~allocate_memory~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory~2~~CalledByGraph proc~allocate_memory~2 allocate_memory proc~setup_geometry setup_geometry proc~setup_geometry->proc~allocate_memory~2 proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory Source Code subroutine allocate_memory ( cells , Ifaces , Jfaces , Kfaces ) !< Allocate memory for the required variables. !----------------------------------------------------------- implicit none type ( celltype ), dimension (:,:,:), allocatable , intent ( out ) :: cells !< Store cell center quantities: volume, cell center coordinate type ( facetype ), dimension (:,:,:), allocatable , intent ( out ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension (:,:,:), allocatable , intent ( out ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension (:,:,:), allocatable , intent ( out ) :: Kfaces !< Store face quantites for K faces: normal and area DebugCall ( 'allocate_memory' ) allocate ( cells ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 )) !< Allocate memory for cells !----------------------------------------------------------- allocate ( Ifaces ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 )) allocate ( Jfaces ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 )) allocate ( Kfaces ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 )) !< Allocate memory for the face variables. !----------------------------------------------------------- end subroutine allocate_memory","tags":"","loc":"proc/allocate_memory~2.html","title":"allocate_memory – FEST-3D"},{"text":"private subroutine normalize_face_normals(Ifaces, Jfaces, Kfaces, bc) Normalize the face normal vectors computed to get unit\n vectors Arguments Type Intent Optional Attributes Name type( facetype ), intent(inout), dimension(-2:imx+3,-2:jmx+2,-2:kmx+2) :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+3,-2:kmx+2) :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+2,-2:kmx+3) :: Kfaces Store face quantites for K faces: normal and area type( boundarytype ), intent(in) :: bc Called by proc~~normalize_face_normals~~CalledByGraph proc~normalize_face_normals normalize_face_normals proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_face_areas_and_normals->proc~normalize_face_normals proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_face_areas_and_normals proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocnormalize_face_normalsCalledByGraph = svgPanZoom('#procnormalize_face_normalsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code normalize_face_normals Source Code subroutine normalize_face_normals ( Ifaces , Jfaces , Kfaces , bc ) !< Normalize the face normal vectors computed to get unit !< vectors !----------------------------------------------------------- implicit none type ( facetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ), intent ( inout ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ), intent ( inout ) :: Kfaces !< Store face quantites for K faces: normal and area type ( boundarytype ), intent ( in ) :: bc integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 3 if ( Ifaces ( i , j , k )% A /= 0. ) then Ifaces ( i , j , k )% nx = Ifaces ( i , j , k )% nx / Ifaces ( i , j , k )% A Ifaces ( i , j , k )% ny = Ifaces ( i , j , k )% ny / Ifaces ( i , j , k )% A Ifaces ( i , j , k )% nz = Ifaces ( i , j , k )% nz / Ifaces ( i , j , k )% A end if end do end do end do do k = - 2 , kmx + 2 do j = - 2 , jmx + 3 do i = - 2 , imx + 2 if ( Jfaces ( i , j , k )% A /= 0. ) then Jfaces ( i , j , k )% nx = Jfaces ( i , j , k )% nx / Jfaces ( i , j , k )% A Jfaces ( i , j , k )% ny = Jfaces ( i , j , k )% ny / Jfaces ( i , j , k )% A Jfaces ( i , j , k )% nz = Jfaces ( i , j , k )% nz / Jfaces ( i , j , k )% A end if end do end do end do do k = - 2 , kmx + 3 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 if ( Kfaces ( i , j , k )% A /= 0. ) then Kfaces ( i , j , k )% nx = Kfaces ( i , j , k )% nx / Kfaces ( i , j , k )% A Kfaces ( i , j , k )% ny = Kfaces ( i , j , k )% ny / Kfaces ( i , j , k )% A Kfaces ( i , j , k )% nz = Kfaces ( i , j , k )% nz / Kfaces ( i , j , k )% A end if end do end do end do ! pole boundary condition if ( bc % imin_id ==- 7 ) then Ifaces ( 1 ,:,:)% nx = Ifaces ( 2 ,:,:)% nx Ifaces ( 0 ,:,:)% nx = Ifaces ( 2 ,:,:)% nx Ifaces ( - 1 ,:,:)% nx = Ifaces ( 2 ,:,:)% nx Ifaces ( - 2 ,:,:)% nx = Ifaces ( 2 ,:,:)% nx Ifaces ( 1 ,:,:)% ny = Ifaces ( 2 ,:,:)% ny Ifaces ( 0 ,:,:)% ny = Ifaces ( 2 ,:,:)% ny Ifaces ( - 1 ,:,:)% ny = Ifaces ( 2 ,:,:)% ny Ifaces ( - 2 ,:,:)% ny = Ifaces ( 2 ,:,:)% ny Ifaces ( 1 ,:,:)% nz = Ifaces ( 2 ,:,:)% nz Ifaces ( 0 ,:,:)% nz = Ifaces ( 2 ,:,:)% nz Ifaces ( - 1 ,:,:)% nz = Ifaces ( 2 ,:,:)% nz Ifaces ( - 2 ,:,:)% nz = Ifaces ( 2 ,:,:)% nz end if if ( bc % imax_id ==- 7 ) then Ifaces ( imx + 0 ,:,:)% nx = Ifaces ( imx - 1 ,:,:)% nx Ifaces ( imx + 1 ,:,:)% nx = Ifaces ( imx - 1 ,:,:)% nx Ifaces ( imx + 2 ,:,:)% nx = Ifaces ( imx - 1 ,:,:)% nx Ifaces ( imx + 3 ,:,:)% nx = Ifaces ( imx - 1 ,:,:)% nx Ifaces ( imx + 0 ,:,:)% ny = Ifaces ( imx - 1 ,:,:)% ny Ifaces ( imx + 1 ,:,:)% ny = Ifaces ( imx - 1 ,:,:)% ny Ifaces ( imx + 2 ,:,:)% ny = Ifaces ( imx - 1 ,:,:)% ny Ifaces ( imx + 3 ,:,:)% ny = Ifaces ( imx - 1 ,:,:)% ny Ifaces ( imx + 0 ,:,:)% nz = Ifaces ( imx - 1 ,:,:)% nz Ifaces ( imx + 1 ,:,:)% nz = Ifaces ( imx - 1 ,:,:)% nz Ifaces ( imx + 2 ,:,:)% nz = Ifaces ( imx - 1 ,:,:)% nz Ifaces ( imx + 3 ,:,:)% nz = Ifaces ( imx - 1 ,:,:)% nz end if if ( bc % jmin_id ==- 7 ) then Jfaces (:, 1 ,:)% nx = Jfaces (:, 2 ,:)% nx Jfaces (:, 0 ,:)% nx = Jfaces (:, 2 ,:)% nx Jfaces (:, - 1 ,:)% nx = Jfaces (:, 2 ,:)% nx Jfaces (:, - 2 ,:)% nx = Jfaces (:, 2 ,:)% nx Jfaces (:, 1 ,:)% ny = Jfaces (:, 2 ,:)% ny Jfaces (:, 0 ,:)% ny = Jfaces (:, 2 ,:)% ny Jfaces (:, - 1 ,:)% ny = Jfaces (:, 2 ,:)% ny Jfaces (:, - 2 ,:)% ny = Jfaces (:, 2 ,:)% ny Jfaces (:, 1 ,:)% nz = Jfaces (:, 2 ,:)% nz Jfaces (:, 0 ,:)% nz = Jfaces (:, 2 ,:)% nz Jfaces (:, - 1 ,:)% nz = Jfaces (:, 2 ,:)% nz Jfaces (:, - 2 ,:)% nz = Jfaces (:, 2 ,:)% nz end if if ( bc % jmax_id ==- 7 ) then Jfaces (:, jmx + 0 ,:)% nx = Jfaces (:, jmx - 1 ,:)% nx Jfaces (:, jmx + 1 ,:)% nx = Jfaces (:, jmx - 1 ,:)% nx Jfaces (:, jmx + 2 ,:)% nx = Jfaces (:, jmx - 1 ,:)% nx Jfaces (:, jmx + 3 ,:)% nx = Jfaces (:, jmx - 1 ,:)% nx Jfaces (:, jmx + 0 ,:)% ny = Jfaces (:, jmx - 1 ,:)% ny Jfaces (:, jmx + 1 ,:)% ny = Jfaces (:, jmx - 1 ,:)% ny Jfaces (:, jmx + 2 ,:)% ny = Jfaces (:, jmx - 1 ,:)% ny Jfaces (:, jmx + 3 ,:)% ny = Jfaces (:, jmx - 1 ,:)% ny Jfaces (:, jmx + 0 ,:)% nz = Jfaces (:, jmx - 1 ,:)% nz Jfaces (:, jmx + 1 ,:)% nz = Jfaces (:, jmx - 1 ,:)% nz Jfaces (:, jmx + 2 ,:)% nz = Jfaces (:, jmx - 1 ,:)% nz Jfaces (:, jmx + 3 ,:)% nz = Jfaces (:, jmx - 1 ,:)% nz end if if ( bc % kmin_id ==- 7 ) then Kfaces (:,:, 1 )% nx = Kfaces (:,:, 2 )% nx Kfaces (:,:, 0 )% nx = Kfaces (:,:, 2 )% nx Kfaces (:,:, - 1 )% nx = Kfaces (:,:, 2 )% nx Kfaces (:,:, - 2 )% nx = Kfaces (:,:, 2 )% nx Kfaces (:,:, 1 )% ny = Kfaces (:,:, 2 )% ny Kfaces (:,:, 0 )% ny = Kfaces (:,:, 2 )% ny Kfaces (:,:, - 1 )% ny = Kfaces (:,:, 2 )% ny Kfaces (:,:, - 2 )% ny = Kfaces (:,:, 2 )% ny Kfaces (:,:, 1 )% nz = Kfaces (:,:, 2 )% nz Kfaces (:,:, 0 )% nz = Kfaces (:,:, 2 )% nz Kfaces (:,:, - 1 )% nz = Kfaces (:,:, 2 )% nz Kfaces (:,:, - 2 )% nz = Kfaces (:,:, 2 )% nz end if if ( bc % kmax_id ==- 7 ) then Kfaces (:,:, kmx + 0 )% nx = Kfaces (:,:, kmx - 1 )% nx Kfaces (:,:, kmx + 1 )% nx = Kfaces (:,:, kmx - 1 )% nx Kfaces (:,:, kmx + 2 )% nx = Kfaces (:,:, kmx - 1 )% nx Kfaces (:,:, kmx + 3 )% nx = Kfaces (:,:, kmx - 1 )% nx Kfaces (:,:, kmx + 0 )% ny = Kfaces (:,:, kmx - 1 )% ny Kfaces (:,:, kmx + 1 )% ny = Kfaces (:,:, kmx - 1 )% ny Kfaces (:,:, kmx + 2 )% ny = Kfaces (:,:, kmx - 1 )% ny Kfaces (:,:, kmx + 3 )% ny = Kfaces (:,:, kmx - 1 )% ny Kfaces (:,:, kmx + 0 )% nz = Kfaces (:,:, kmx - 1 )% nz Kfaces (:,:, kmx + 1 )% nz = Kfaces (:,:, kmx - 1 )% nz Kfaces (:,:, kmx + 2 )% nz = Kfaces (:,:, kmx - 1 )% nz Kfaces (:,:, kmx + 3 )% nz = Kfaces (:,:, kmx - 1 )% nz end if end subroutine normalize_face_normals","tags":"","loc":"proc/normalize_face_normals.html","title":"normalize_face_normals – FEST-3D"},{"text":"private subroutine compute_face_areas(Ifaces, Jfaces, Kfaces, bc) Compute face areas based on area vectors The face areas are computed using the face area vectors. \n Prior to using this subroutine, the face area vectors must\n computed and placed in the face normal variables. Since the area is given by abs(d1 x d2), the areas are\n calculated using the normal vectors calculated in \n compute_face_area_vectors, but before normalising them Arguments Type Intent Optional Attributes Name type( facetype ), intent(inout), dimension(-2:imx+3,-2:jmx+2,-2:kmx+2) :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+3,-2:kmx+2) :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+2,-2:kmx+3) :: Kfaces Store face quantites for K faces: normal and area type( boundarytype ), intent(in) :: bc Called by proc~~compute_face_areas~~CalledByGraph proc~compute_face_areas compute_face_areas proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_face_areas_and_normals->proc~compute_face_areas proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_face_areas_and_normals proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panproccompute_face_areasCalledByGraph = svgPanZoom('#proccompute_face_areasCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_areas Source Code subroutine compute_face_areas ( Ifaces , Jfaces , Kfaces , bc ) !< Compute face areas based on area vectors !< !< The face areas are computed using the face area vectors. !< Prior to using this subroutine, the face area vectors must !< computed and placed in the face normal variables. !< !< Since the area is given by abs(d1 x d2), the areas are !< calculated using the normal vectors calculated in !< compute_face_area_vectors, but before normalising them !----------------------------------------------------------- implicit none type ( facetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ), intent ( inout ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ), intent ( inout ) :: Kfaces !< Store face quantites for K faces: normal and area type ( boundarytype ), intent ( in ) :: bc Ifaces (:,:,:)% A = sqrt (( Ifaces (:,:,:)% nx ) ** 2 + ( Ifaces (:,:,:)% ny ) ** 2 + & ( Ifaces (:,:,:)% nz ) ** 2 ) Jfaces (:,:,:)% A = sqrt (( Jfaces (:,:,:)% nx ) ** 2 + ( Jfaces (:,:,:)% ny ) ** 2 + & ( Jfaces (:,:,:)% nz ) ** 2 ) Kfaces (:,:,:)% A = sqrt (( Kfaces (:,:,:)% nx ) ** 2 + ( Kfaces (:,:,:)% ny ) ** 2 + & ( Kfaces (:,:,:)% nz ) ** 2 ) ! Pole boundary conditions ! making sure face area is exactly equal zero if ( bc % imin_id ==- 7 ) Ifaces ( - 2 : 1 , :, :)% A = 0. if ( bc % imax_id ==- 7 ) Ifaces ( imx : imx + 3 , :, :)% A = 0. if ( bc % jmin_id ==- 7 ) Jfaces ( :, - 2 : 1 , :)% A = 0. if ( bc % jmax_id ==- 7 ) Jfaces ( :, jmx : jmx + 3 , :)% A = 0. if ( bc % kmin_id ==- 7 ) Kfaces ( :, :, - 2 : 1 )% A = 0. if ( bc % kmax_id ==- 7 ) Kfaces ( :, :, kmx : kmx + 3 )% A = 0. end subroutine compute_face_areas","tags":"","loc":"proc/compute_face_areas.html","title":"compute_face_areas – FEST-3D"},{"text":"private subroutine compute_face_area_vectors(Ifaces, Jfaces, Kfaces, nodes) Compute face area vectors The face area vectors denote the face area both in \n magnitude and direction. They are placed in the face \n normal variables for further calculation. The face normal is given by d1 x d2, where d1 and d2 are\n the diagonals of a face Arguments Type Intent Optional Attributes Name type( facetype ), intent(inout), dimension(-2:imx+3,-2:jmx+2,-2:kmx+2) :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+3,-2:kmx+2) :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+2,-2:kmx+3) :: Kfaces Store face quantites for K faces: normal and area type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Grid points Called by proc~~compute_face_area_vectors~~CalledByGraph proc~compute_face_area_vectors compute_face_area_vectors proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_face_areas_and_normals->proc~compute_face_area_vectors proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_face_areas_and_normals proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panproccompute_face_area_vectorsCalledByGraph = svgPanZoom('#proccompute_face_area_vectorsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_area_vectors Source Code subroutine compute_face_area_vectors ( Ifaces , Jfaces , Kfaces , nodes ) !< Compute face area vectors !< !< The face area vectors denote the face area both in !< magnitude and direction. They are placed in the face !< normal variables for further calculation. !< !< The face normal is given by d1 x d2, where d1 and d2 are !< the diagonals of a face !----------------------------------------------------------- implicit none type ( facetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ), intent ( inout ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ), intent ( inout ) :: Kfaces !< Store face quantites for K faces: normal and area type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes !< Grid points real ( wp ) :: d1x , d2x , d1y , d2y , d1z , d2z integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 3 d1x = nodes ( i , j + 1 , k + 1 )% x - nodes ( i , j , k )% x d1y = nodes ( i , j + 1 , k + 1 )% y - nodes ( i , j , k )% y d1z = nodes ( i , j + 1 , k + 1 )% z - nodes ( i , j , k )% z d2x = nodes ( i , j , k + 1 )% x - nodes ( i , j + 1 , k )% x d2y = nodes ( i , j , k + 1 )% y - nodes ( i , j + 1 , k )% y d2z = nodes ( i , j , k + 1 )% z - nodes ( i , j + 1 , k )% z Ifaces ( i , j , k )% nx = 0.5 * ( d1y * d2z - d1z * d2y ) Ifaces ( i , j , k )% ny = 0.5 * ( d1z * d2x - d1x * d2z ) Ifaces ( i , j , k )% nz = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do do k = - 2 , kmx + 2 do j = - 2 , jmx + 3 do i = - 2 , imx + 2 d1x = nodes ( i + 1 , j , k + 1 )% x - nodes ( i , j , k )% x d1y = nodes ( i + 1 , j , k + 1 )% y - nodes ( i , j , k )% y d1z = nodes ( i + 1 , j , k + 1 )% z - nodes ( i , j , k )% z d2x = nodes ( i + 1 , j , k )% x - nodes ( i , j , k + 1 )% x d2y = nodes ( i + 1 , j , k )% y - nodes ( i , j , k + 1 )% y d2z = nodes ( i + 1 , j , k )% z - nodes ( i , j , k + 1 )% z Jfaces ( i , j , k )% nx = 0.5 * ( d1y * d2z - d1z * d2y ) Jfaces ( i , j , k )% ny = 0.5 * ( d1z * d2x - d1x * d2z ) Jfaces ( i , j , k )% nz = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do do k = - 2 , kmx + 3 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 d1x = nodes ( i + 1 , j + 1 , k )% x - nodes ( i , j , k )% x d1y = nodes ( i + 1 , j + 1 , k )% y - nodes ( i , j , k )% y d1z = nodes ( i + 1 , j + 1 , k )% z - nodes ( i , j , k )% z d2x = nodes ( i , j + 1 , k )% x - nodes ( i + 1 , j , k )% x d2y = nodes ( i , j + 1 , k )% y - nodes ( i + 1 , j , k )% y d2z = nodes ( i , j + 1 , k )% z - nodes ( i + 1 , j , k )% z Kfaces ( i , j , k )% nx = 0.5 * ( d1y * d2z - d1z * d2y ) Kfaces ( i , j , k )% ny = 0.5 * ( d1z * d2x - d1x * d2z ) Kfaces ( i , j , k )% nz = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do end subroutine compute_face_area_vectors","tags":"","loc":"proc/compute_face_area_vectors.html","title":"compute_face_area_vectors – FEST-3D"},{"text":"private subroutine compute_face_areas_and_normals(Ifaces, Jfaces, Kfaces, nodes, bc) Compute the face areas and normals This is the 2-dimensional version. In this case, the face \n areas default to edge lengths. Arguments Type Intent Optional Attributes Name type( facetype ), intent(inout), dimension(-2:imx+3,-2:jmx+2,-2:kmx+2) :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+3,-2:kmx+2) :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+2,-2:kmx+3) :: Kfaces Store face quantites for K faces: normal and area type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Grid points type( boundarytype ), intent(in) :: bc boundary condition and fixed values Calls proc~~compute_face_areas_and_normals~~CallsGraph proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_face_area_vectors compute_face_area_vectors proc~compute_face_areas_and_normals->proc~compute_face_area_vectors proc~compute_face_areas compute_face_areas proc~compute_face_areas_and_normals->proc~compute_face_areas proc~normalize_face_normals normalize_face_normals proc~compute_face_areas_and_normals->proc~normalize_face_normals Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_face_areas_and_normals~~CalledByGraph proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_face_areas_and_normals proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_areas_and_normals Source Code subroutine compute_face_areas_and_normals ( Ifaces , Jfaces , Kfaces , nodes , bc ) !< Compute the face areas and normals !< !< This is the 2-dimensional version. In this case, the face !< areas default to edge lengths. !----------------------------------------------------------- implicit none type ( facetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ), intent ( inout ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ), intent ( inout ) :: Kfaces !< Store face quantites for K faces: normal and area type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes !< Grid points type ( boundarytype ), intent ( in ) :: bc !< boundary condition and fixed values call compute_face_area_vectors ( Ifaces , Jfaces , Kfaces , nodes ) call compute_face_areas ( Ifaces , Jfaces , Kfaces , bc ) call normalize_face_normals ( Ifaces , Jfaces , Kfaces , bc ) end subroutine compute_face_areas_and_normals","tags":"","loc":"proc/compute_face_areas_and_normals.html","title":"compute_face_areas_and_normals – FEST-3D"},{"text":"private subroutine compute_volumes(cells, nodes) Compute the grid cell volumes\n Each grid is a hexahedron, whose volume is calculated by\n splitting it into 5 tetrahedrons, whose volume is known Arguments Type Intent Optional Attributes Name type( celltype ), intent(out), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: cells Cell center quanties: volume and coordiantes of cell center type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Grid points Calls proc~~compute_volumes~~CallsGraph proc~compute_volumes compute_volumes proc~vol_hexahedron vol_hexahedron proc~compute_volumes->proc~vol_hexahedron proc~vol_tetrahedron vol_tetrahedron proc~vol_hexahedron->proc~vol_tetrahedron Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_volumes~~CalledByGraph proc~compute_volumes compute_volumes proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_volumes proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_volumes Source Code subroutine compute_volumes ( cells , nodes ) !< Compute the grid cell volumes !< Each grid is a hexahedron, whose volume is calculated by !< splitting it into 5 tetrahedrons, whose volume is known !----------------------------------------------------------- implicit none type ( celltype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( out ) :: cells !< Cell center quanties: volume and coordiantes of cell center type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes !< Grid points integer :: i , j , k real ( wp ), dimension ( 1 : 3 , 1 : 8 ) :: p_list cells (:,:,:)% volume = 1. do k = 0 , kmx + 0 do j = 0 , jmx + 0 do i = 0 , imx + 0 p_list (:, :) = 0. p_list (:, 1 ) = ( / nodes ( i , j , k )% x , nodes ( i , j , k )% y , nodes ( i , j , k )% z / ) p_list (:, 2 ) = ( / nodes ( i + 1 , j , k )% x , nodes ( i + 1 , j , k )% y , nodes ( i + 1 , j , k )% z / ) p_list (:, 3 ) = ( / nodes ( i + 1 , j + 1 , k )% x , nodes ( i + 1 , j + 1 , k )% y , nodes ( i + 1 , j + 1 , k )% z / ) p_list (:, 4 ) = ( / nodes ( i , j + 1 , k )% x , nodes ( i , j + 1 , k )% y , nodes ( i , j + 1 , k )% z / ) p_list (:, 5 ) = ( / nodes ( i , j , k + 1 )% x , nodes ( i , j , k + 1 )% y , nodes ( i , j , k + 1 )% z / ) p_list (:, 6 ) = ( / nodes ( i + 1 , j , k + 1 )% x , nodes ( i + 1 , j , k + 1 )% y , nodes ( i + 1 , j , k + 1 )% z / ) p_list (:, 7 ) = ( / nodes ( i + 1 , j + 1 , k + 1 )% x , nodes ( i + 1 , j + 1 , k + 1 )% y , nodes ( i + 1 , j + 1 , k + 1 )% z / ) p_list (:, 8 ) = ( / nodes ( i , j + 1 , k + 1 )% x , nodes ( i , j + 1 , k + 1 )% y , nodes ( i , j + 1 , k + 1 )% z / ) cells ( i , j , k )% volume = ( vol_hexahedron ( p_list )) if ( cells ( i , j , k )% volume <= 0.0 ) then if ( i == 0 . or . i == imx . or . j == 0 . or . j == jmx . or . k == 0 . or . k == kmx ) then !print*, \"Ghost Cell volume negative\" cells ( i , j , k )% volume = ( vol_hexahedron ( p_list )) else print * , process_id , i , j , k print * , \"negative volume :\" , ( vol_hexahedron ( p_list )) STOP end if end if end do end do end do if ( any ( cells (:,:,:)% volume == 0.0 )) then Fatal_error end if if ( any (( cells (:,:,:)% volume ) < 0.0 )) then Fatal_error end if end subroutine compute_volumes","tags":"","loc":"proc/compute_volumes.html","title":"compute_volumes – FEST-3D"},{"text":"private subroutine compute_ghost_cell_centroid(cells, nodes) Compute cell center of all cell including ghost cells Arguments Type Intent Optional Attributes Name type( celltype ), intent(out), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: cells Cell center quanties: volume and coordiantes of cell center type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Grid points Called by proc~~compute_ghost_cell_centroid~~CalledByGraph proc~compute_ghost_cell_centroid compute_ghost_cell_centroid proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_ghost_cell_centroid proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_ghost_cell_centroid Source Code subroutine compute_ghost_cell_centroid ( cells , nodes ) !< Compute cell center of all cell including ghost cells implicit none type ( celltype ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( out ) :: cells !< Cell center quanties: volume and coordiantes of cell center type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes !< Grid points integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 cells ( i , j , k )% centerx = 0.125 * ( nodes ( i , j , k )% x & + nodes ( i + 1 , j , k )% x & + nodes ( i + 1 , j + 1 , k )% x & + nodes ( i + 1 , j + 1 , k + 1 )% x & + nodes ( i + 1 , j , k + 1 )% x & + nodes ( i , j + 1 , k )% x & + nodes ( i , j + 1 , k + 1 )% x & + nodes ( i , j , k + 1 )% x & ) cells ( i , j , k )% centery = 0.125 * ( nodes ( i , j , k )% y & + nodes ( i + 1 , j , k )% y & + nodes ( i + 1 , j + 1 , k )% y & + nodes ( i + 1 , j + 1 , k + 1 )% y & + nodes ( i + 1 , j , k + 1 )% y & + nodes ( i , j + 1 , k )% y & + nodes ( i , j + 1 , k + 1 )% y & + nodes ( i , j , k + 1 )% y & ) cells ( i , j , k )% centerz = 0.125 * ( nodes ( i , j , k )% z & + nodes ( i + 1 , j , k )% z & + nodes ( i + 1 , j + 1 , k )% z & + nodes ( i + 1 , j + 1 , k + 1 )% z & + nodes ( i + 1 , j , k + 1 )% z & + nodes ( i , j + 1 , k )% z & + nodes ( i , j + 1 , k + 1 )% z & + nodes ( i , j , k + 1 )% z & ) end do end do end do end subroutine compute_ghost_cell_centroid","tags":"","loc":"proc/compute_ghost_cell_centroid.html","title":"compute_ghost_cell_centroid – FEST-3D"},{"text":"public subroutine setup_geometry(cells, Ifaces, Jfaces, Kfaces, nodes, bc, dims) Make the geometry module useful Allocates memory to the variables and initializes them. Arguments Type Intent Optional Attributes Name type( celltype ), intent(inout), dimension(:,:,:), allocatable :: cells Cell center quanties: volume and coordiantes of cell center type( facetype ), intent(inout), dimension(:,:,:), allocatable :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(inout), dimension(:,:,:), allocatable :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(inout), dimension(:,:,:), allocatable :: Kfaces Store face quantites for K faces: normal and area type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Grid points type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Calls proc~~setup_geometry~~CallsGraph proc~setup_geometry setup_geometry proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~setup_geometry->proc~compute_face_areas_and_normals proc~compute_ghost_cell_centroid compute_ghost_cell_centroid proc~setup_geometry->proc~compute_ghost_cell_centroid debugcall debugcall proc~setup_geometry->debugcall proc~allocate_memory~2 allocate_memory proc~setup_geometry->proc~allocate_memory~2 proc~compute_volumes compute_volumes proc~setup_geometry->proc~compute_volumes proc~compute_face_area_vectors compute_face_area_vectors proc~compute_face_areas_and_normals->proc~compute_face_area_vectors proc~compute_face_areas compute_face_areas proc~compute_face_areas_and_normals->proc~compute_face_areas proc~normalize_face_normals normalize_face_normals proc~compute_face_areas_and_normals->proc~normalize_face_normals proc~allocate_memory~2->debugcall proc~vol_hexahedron vol_hexahedron proc~compute_volumes->proc~vol_hexahedron proc~vol_tetrahedron vol_tetrahedron proc~vol_hexahedron->proc~vol_tetrahedron Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_geometry~~CalledByGraph proc~setup_geometry setup_geometry proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_geometry Source Code subroutine setup_geometry ( cells , Ifaces , Jfaces , Kfaces , nodes , bc , dims ) !< Make the geometry module useful !< !< Allocates memory to the variables and initializes them. !----------------------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims type ( celltype ), dimension (:,:,:), allocatable , intent ( inout ) :: cells !< Cell center quanties: volume and coordiantes of cell center type ( facetype ), dimension (:,:,:), allocatable , intent ( inout ) :: Ifaces !< Store face quantites for I faces: normal and area type ( facetype ), dimension (:,:,:), allocatable , intent ( inout ) :: Jfaces !< Store face quantites for J faces: normal and area type ( facetype ), dimension (:,:,:), allocatable , intent ( inout ) :: Kfaces !< Store face quantites for K faces: normal and area type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes !< Grid points type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values DebugCall ( 'setup_geometry' ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx call allocate_memory ( cells , Ifaces , Jfaces , Kfaces ) call compute_face_areas_and_normals ( Ifaces , Jfaces , Kfaces , nodes , bc ) call compute_volumes ( cells , nodes ) call compute_ghost_cell_centroid ( cells , nodes ) end subroutine setup_geometry","tags":"","loc":"proc/setup_geometry.html","title":"setup_geometry – FEST-3D"},{"text":"private subroutine compute_flux(Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input-argument direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variable at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variable at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_flux~~CallsGraph proc~compute_flux compute_flux debugcall debugcall proc~compute_flux->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~~CalledByGraph proc~compute_flux compute_flux proc~compute_fluxes compute_fluxes proc~compute_fluxes->proc~compute_flux Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input-argument direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at face integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus , F_minus real ( wp ) :: M_perp_left , M_perp_right real ( wp ) :: alpha_plus , alpha_minus real ( wp ) :: beta_left , beta_right real ( wp ) :: M_plus , M_minus real ( wp ) :: D_plus , D_minus real ( wp ) :: c_plus , c_minus real ( wp ) :: scrD_plus , scrD_minus real ( wp ) :: sound_speed_avg , face_normal_speeds DebugCall ( 'compute_flux' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( flow % gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( flow % gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_left ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_left ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_right ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_right ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! First construct the F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! First construct the F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * faces ( i , j , k )% A F_minus (:) = F_minus (:) * faces ( i , j , k )% A ! Get the total flux for a face Flux ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes(F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_fluxes~~CallsGraph proc~compute_fluxes compute_fluxes debugcall debugcall proc~compute_fluxes->debugcall proc~compute_flux compute_flux proc~compute_fluxes->proc~compute_flux proc~compute_flux->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes.html","title":"compute_fluxes – FEST-3D"},{"text":"private subroutine compute_flux(Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variable at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variable at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_flux~2~~CallsGraph proc~compute_flux~2 compute_flux debugcall debugcall proc~compute_flux~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~2~~CalledByGraph proc~compute_flux~2 compute_flux proc~compute_fluxes~2 compute_fluxes proc~compute_fluxes~2->proc~compute_flux~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at face integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus !< Right flux through the face real ( wp ), dimension ( 1 : dims % n_var ) :: F_minus !< Left flux through  the face real ( wp ) :: xi real ( wp ) :: vnabs real ( wp ) :: delp real ( wp ) :: delrho real ( wp ) :: fnG real ( wp ) :: pbar real ( wp ) :: Mcap real ( wp ) :: vtface real ( wp ) :: mass real ( wp ) :: HL , HR !< Enthalpy real ( wp ) :: uL , uR !< X-component of velocity real ( wp ) :: vL , vR !< Y-component of velocity real ( wp ) :: wL , wR !< Z-component of velocity real ( wp ) :: pL , pR !< Pressure real ( wp ) :: rL , rR !< Density real ( wp ) :: cL , cR !< Speed sound left/right real ( wp ) :: C !< Speed of sound at face real ( wp ) :: ML , MR !< Mach number left/right real ( wp ) :: VnL , VnR !< Face normal velocity left/right real ( wp ) :: betaL , betaR real ( wp ) :: alphaL , alphaR real ( wp ) :: VnabsL , VnabsR DebugCall ( 'compute_flux ' // trim ( f_dir )) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( flow % gm / ( flow % gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( flow % gm / ( flow % gm - 1. )) * pR / rR ) ! ---- speed of sound ---- cL = sqrt ( flow % gm * pL / rL ) cR = sqrt ( flow % gm * pR / rR ) C = 0.5 * ( cL + cR ) ! ---- delta quantities ---- delp = pR - pL !pL - pR delrho = rR - rL !rL - rR ! ---- face normal velocity ---- VnL = uL * faces ( i , j , k )% nx + vL * faces ( i , j , k )% ny + wL * faces ( i , j , k )% nz VnR = uR * faces ( i , j , k )% nx + vR * faces ( i , j , k )% ny + wR * faces ( i , j , k )% nz ! ---- Mach at face ---- ML = VnL / C MR = VnR / C ! ---- switch for supersonic flow ---- alphaL = max ( 0.0 , 1.0 - floor ( abs ( ML ))) alphaR = max ( 0.0 , 1.0 - floor ( abs ( MR ))) !Above two line of code is eqvivalent to following code !if(abs(ML)>=1.0) then !  alphaL = 0.0 !else !  alphaL=1.0 !end if !if(abs(MR)>=1.0) then !  alphaR=0.0 !else !  alphaR=1.0 !end if ! -- pressure factor -- betaL = ( 1.0 - alphaL ) * 0.5 * ( 1.0 + sign ( 1.0 , ML )) + ( alphaL ) * 0.25 * ( 2.0 - ML ) * (( ML + 1.0 ) ** 2 ) betaR = ( 1.0 - alphaR ) * 0.5 * ( 1.0 - sign ( 1.0 , MR )) + ( alphaR ) * 0.25 * ( 2.0 + MR ) * (( MR - 1.0 ) ** 2 ) ! -- xi calculation -- vtface = sqrt ( 0.5 * (( uL * uL ) + ( vL * vL ) + ( wL * wL ) + ( uR * uR ) + ( vR * vR ) + ( wR * wR ))) Mcap = min ( 1.0 , vtface / C ) Xi = ( 1.0 - Mcap ) ** 2 ! -- |Vn| -- Vnabs = ( rL * abs ( VnL ) + rR * abs ( VnR )) / ( rL + rR ) ! -- function G -- fnG = - 1.0 * max ( min ( ML , 0.0 ), - 1.0 ) * min ( max ( MR , 0.0 ), 1.0 ) ! -- Pressure -- pbar = 0.5 * (( pL + pR ) + ( betaL - betaR ) * ( pL - pR ) + ( 1.0 - xi ) * ( betaL + betaR - 1.0 ) * ( pL + pR )) ! -- mass -- !mass = 0.5*((rL*VnL + rR*VnR - Vnabs*delrho)*(1.0-fnG) - (Xi*delp/C)) VnabsL = ( 1.0 - fnG ) * Vnabs + fnG * abs ( VnL ) VnabsR = ( 1.0 - fnG ) * Vnabs + fnG * abs ( VnR ) mass = 0.5 * (( rL * ( VnL + VnabsL ) + rR * ( VnR - VnabsR )) - ( Xi * delp / C )) mass = mass * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) ! -- Turbulence variables mass flux -- if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Get the total flux for a face Flux ( i , j , k , :) = F_plus (:) + F_minus (:) ! -- Pressure flux addition -- Flux ( i , j , K , 2 ) = Flux ( i , j , k , 2 ) + ( pbar * faces ( i , j , k )% nx ) Flux ( i , j , K , 3 ) = Flux ( i , j , k , 3 ) + ( pbar * faces ( i , j , k )% ny ) Flux ( i , j , K , 4 ) = Flux ( i , j , k , 4 ) + ( pbar * faces ( i , j , k )% nz ) Flux ( i , j , k , :) = Flux ( i , j , k , :) * faces ( i , j , k )% A end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux~2.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes(F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_fluxes~2~~CallsGraph proc~compute_fluxes~2 compute_fluxes proc~compute_flux~2 compute_flux proc~compute_fluxes~2->proc~compute_flux~2 debugcall debugcall proc~compute_fluxes~2->debugcall proc~compute_flux~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~2.html","title":"compute_fluxes – FEST-3D"},{"text":"public subroutine setup_scheme(residue, F, G, H, control, dims) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:, :, :, :), allocatable, target :: residue Store residue at each cell-center real(kind=wp), intent(out), dimension(:, :, :, :), allocatable :: F Store fluxes throught the I faces real(kind=wp), intent(out), dimension(:, :, :, :), allocatable :: G Store fluxes throught the J faces real(kind=wp), intent(out), dimension(:, :, :, :), allocatable :: H Store fluxes throught the K faces type( controltype ), intent(in) :: control Control parameters type( extent ), intent(in) :: dims extent of the 3D domain Calls proc~~setup_scheme~~CallsGraph proc~setup_scheme setup_scheme interface~alloc alloc proc~setup_scheme->interface~alloc proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~setup_interpolant_scheme->interface~alloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_scheme~~CalledByGraph proc~setup_scheme setup_scheme proc~setup_solver setup_solver proc~setup_solver->proc~setup_scheme proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme ( residue , F , G , H , control , dims ) implicit none type ( controltype ), intent ( in ) :: control !< Control parameters type ( extent ), intent ( in ) :: dims !< extent of the 3D domain real ( wp ), dimension (:, :, :, :), allocatable , intent ( out ), target :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), allocatable , intent ( out ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), allocatable , intent ( out ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), allocatable , intent ( out ) :: H !< Store fluxes throught the K faces imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var call setup_interpolant_scheme ( dims ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - Scheme' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - Scheme' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - Scheme' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - Scheme' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine compute_fluxes(F, G, H, Ifaces, Jfaces, Kfaces, scheme, flow, bc, dims) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims extent of the 3D domain Calls proc~~compute_fluxes~7~~CallsGraph proc~compute_fluxes~7 compute_fluxes compute_fluxes_van_leer compute_fluxes_van_leer proc~compute_fluxes~7->compute_fluxes_van_leer compute_fluxes_ldfss0 compute_fluxes_ldfss0 proc~compute_fluxes~7->compute_fluxes_ldfss0 compute_fluxes_ausm compute_fluxes_ausm proc~compute_fluxes~7->compute_fluxes_ausm compute_fluxes_ausmp compute_fluxes_ausmp proc~compute_fluxes~7->compute_fluxes_ausmp compute_fluxes_slau compute_fluxes_slau proc~compute_fluxes~7->compute_fluxes_slau compute_fluxes_ausmup compute_fluxes_ausmup proc~compute_fluxes~7->compute_fluxes_ausmup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_fluxes~7~~CalledByGraph proc~compute_fluxes~7 compute_fluxes proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_fluxes~7 proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_fluxes7CalledByGraph = svgPanZoom('#proccompute_fluxes7CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes ( F , G , H , Ifaces , Jfaces , Kfaces , scheme , flow , bc , dims ) implicit none type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( extent ), intent ( in ) :: dims !< extent of the 3D domain real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values select case ( scheme % scheme_name ) case ( \"van_leer\" ) call compute_fluxes_van_leer ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case ( \"ausm\" ) call compute_fluxes_ausm ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case ( \"ausmP\" ) call compute_fluxes_ausmP ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case ( \"ausmUP\" ) call compute_fluxes_ausmUP ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case ( \"slau\" ) call compute_fluxes_slau ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case ( \"ldfss0\" ) call compute_fluxes_ldfss0 ( F , G , H , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , Ifaces , Jfaces , Kfaces , flow , bc , dims ) case default Fatal_error end select end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~7.html","title":"compute_fluxes – FEST-3D"},{"text":"public subroutine compute_residue(residue, F, G, H, dims) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(in), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(in), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( extent ), intent(in) :: dims extent of the 3D domain Calls proc~~compute_residue~~CallsGraph proc~compute_residue compute_residue debugcall debugcall proc~compute_residue->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_residue~~CalledByGraph proc~compute_residue compute_residue proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_residueCalledByGraph = svgPanZoom('#proccompute_residueCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_residue Source Code subroutine compute_residue ( residue , F , G , H , dims ) implicit none type ( extent ), intent ( in ) :: dims !< extent of the 3D domain real ( wp ), dimension (:, :, :, :), intent ( out ) :: residue !< Store residue at each cell-center real ( wp ), dimension (:, :, :, :), intent ( in ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( in ) :: H !< Store fluxes throught the K faces integer :: i , j , k , l DebugCall ( 'compute_residue' ) do l = 1 , dims % n_var do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 residue ( i , j , k , l ) = ( F ( i + 1 , j , k , l ) - F ( i , j , k , l )) & + ( G ( i , j + 1 , k , l ) - G ( i , j , k , l )) & + ( H ( i , j , k + 1 , l ) - H ( i , j , k , l )) end do end do end do end do end subroutine compute_residue","tags":"","loc":"proc/compute_residue.html","title":"compute_residue – FEST-3D"},{"text":"private subroutine compute_flux(Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variable at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variable at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_flux~3~~CallsGraph proc~compute_flux~3 compute_flux debugcall debugcall proc~compute_flux~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~3~~CalledByGraph proc~compute_flux~3 compute_flux proc~compute_fluxes~3 compute_fluxes proc~compute_fluxes~3->proc~compute_flux~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at face integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus !< Right flux through the face real ( wp ), dimension ( 1 : dims % n_var ) :: F_minus !< Left flux through  the face real ( wp ) :: pbar real ( wp ) :: mass real ( wp ) :: HL , HR !< Enthalpy real ( wp ) :: uL , uR !< X-component of velocity real ( wp ) :: vL , vR !< Y-component of velocity real ( wp ) :: wL , wR !< Z-component of velocity real ( wp ) :: pL , pR !< Pressure real ( wp ) :: rL , rR !< Density real ( wp ) :: cL , cR !< Speed sound left/right real ( wp ) :: C !< Speed of sound at face real ( wp ) :: ML , MR !< Mach number left/right real ( wp ) :: VnL , VnR !< Face normal velocity left/right real ( wp ) :: betaL , betaR real ( wp ) :: alphaL , alphaR real ( wp ) :: FmL , FmR real ( wp ) :: Mface real ( wp ) :: Cs real ( wp ) :: Mb real ( wp ) :: Mo real ( wp ) :: fna real ( wp ) :: Pu real ( wp ) :: Mp real ( wp ) :: alfa real ( wp ), parameter :: Kp = 0.25 real ( wp ), parameter :: Ku = 0.75 real ( wp ), parameter :: sigma = 1.0 DebugCall ( 'compute_flux ' // trim ( f_dir )) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( flow % gm / ( flow % gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( flow % gm / ( flow % gm - 1. )) * pR / rR ) ! ---- face normal velocity ---- VnL = uL * faces ( i , j , k )% nx + vL * faces ( i , j , k )% ny + wL * faces ( i , j , k )% nz VnR = uR * faces ( i , j , k )% nx + vR * faces ( i , j , k )% ny + wR * faces ( i , j , k )% nz ! ---- speed of sound ---- cs = sqrt ( 2.0 * ( flow % gm - 1.0 ) * ( 0.5 * ( HL + HR )) / ( flow % gm + 1.0 )) cL = cs * cs / ( max ( cs , VnL )) cR = cs * cs / ( max ( cs , - VnR )) C = min ( cL , CR ) ! ---- Mach at face ---- ML = VnL / C MR = VnR / C Mb = sqrt ( 0.5 * (( VnL * VnL ) + ( VnR * VnR )) / ( C * C )) ! ---- function at face ---- Mo = sqrt ( min ( 1.0 , max ( Mb * Mb , flow % MInf * flow % MInf ))) fna = Mo * ( 2.0 - Mo ) alfa = 3.0 * ( - 4.0 + ( 5.0 * fna * fna )) / 1 6.0 ! ---- switch for supersonic flow ---- alphaL = max ( 0 , 1 - floor ( abs ( ML ))) alphaR = max ( 0 , 1 - floor ( abs ( MR ))) ! Compute '+' direction quantities FmL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL ) * ML ) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) betaL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL )) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) * ( 2.0 - ML ) ! Compute '-' direction quantities FmR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR ) * MR ) - alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) betaR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR )) + alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) * ( 2.0 + MR ) !AUSM+modification ! Compute '+' direction quantities FmL = FmL + alphaL * 0.125 * (( ML ** 2 - 1.0 ) ** 2 ) betaL = betaL + alphaL * alfa * (( ML ** 2 - 1.0 ) ** 2 ) * ML ! Compute '-' direction quantities FmR = FmR - alphaR * 0.125 * (( MR ** 2 - 1.0 ) ** 2 ) betaR = betaR - alphaR * alfa * (( MR ** 2 - 1.0 ) ** 2 ) * MR !AUSM+- modification Pu = - Ku * betaL * betaR * ( rL + rR ) * fna * C * ( VnR - VnL ) Mp = - 2.0 * Kp * max ( 1.0 - ( sigma * Mb * Mb ), 0.0 ) * ( pR - pL ) / ( fna * ( rL + rR ) * C * C ) if ( isnan ( Pu )) then print * , \"Nan:\" , f_qp_left ( i , j , k ,:), f_qp_right ( i , j , k ,:) end if ! mass coefficient Mface = FmL + FmR + Mp ! -- Pressure coeffient-- pbar = betaL * pL + betaR * pR + Pu ! -- mass -- if ( Mface > 0.0 ) then mass = Mface * C * rL else mass = Mface * c * rR end if mass = mass * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) !! -- Turbulence variables mass flux -- if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! total flux Flux ( i , j , k , :) = F_plus (:) + F_minus (:) ! Get the total flux for a face ! -- Pressure flux addition -- Flux ( i , j , K , 2 ) = Flux ( i , j , k , 2 ) + ( pbar * faces ( i , j , k )% nx ) Flux ( i , j , K , 3 ) = Flux ( i , j , k , 3 ) + ( pbar * faces ( i , j , k )% ny ) Flux ( i , j , K , 4 ) = Flux ( i , j , k , 4 ) + ( pbar * faces ( i , j , k )% nz ) Flux ( i , j , k , :) = Flux ( i , j , k , :) * faces ( i , j , k )% A end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux~3.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes(F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_fluxes~3~~CallsGraph proc~compute_fluxes~3 compute_fluxes proc~compute_flux~3 compute_flux proc~compute_fluxes~3->proc~compute_flux~3 debugcall debugcall proc~compute_fluxes~3->debugcall proc~compute_flux~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~3.html","title":"compute_fluxes – FEST-3D"},{"text":"private subroutine compute_flux(Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variable at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variable at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_flux~4~~CallsGraph proc~compute_flux~4 compute_flux debugcall debugcall proc~compute_flux~4->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~4~~CalledByGraph proc~compute_flux~4 compute_flux proc~compute_fluxes~4 compute_fluxes proc~compute_fluxes~4->proc~compute_flux~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at face integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus !< Right flux through the face real ( wp ), dimension ( 1 : dims % n_var ) :: F_minus !< Left flux through  the face real ( wp ) :: pbar real ( wp ) :: mass real ( wp ) :: HL , HR !< Enthalpy real ( wp ) :: uL , uR !< X-component of velocity real ( wp ) :: vL , vR !< Y-component of velocity real ( wp ) :: wL , wR !< Z-component of velocity real ( wp ) :: pL , pR !< Pressure real ( wp ) :: rL , rR !< Density real ( wp ) :: cL , cR !< Speed sound left/right real ( wp ) :: C !< Speed of sound at face real ( wp ) :: ML , MR !< Mach number left/right real ( wp ) :: VnL , VnR !< Face normal velocity left/right real ( wp ) :: betaL , betaR real ( wp ) :: alphaL , alphaR real ( wp ) :: FmL , FmR real ( wp ) :: Mface real ( wp ) :: Cs DebugCall ( 'compute_flux ' // trim ( f_dir )) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( flow % gm / ( flow % gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( flow % gm / ( flow % gm - 1. )) * pR / rR ) ! ---- face normal velocity ---- VnL = uL * faces ( i , j , k )% nx + vL * faces ( i , j , k )% ny + wL * faces ( i , j , k )% nz VnR = uR * faces ( i , j , k )% nx + vR * faces ( i , j , k )% ny + wR * faces ( i , j , k )% nz ! ---- speed of sound ---- cs = sqrt ( 2.0 * ( flow % gm - 1.0 ) * ( 0.5 * ( HL + HR )) / ( flow % gm + 1.0 )) cL = cs * cs / ( max ( cs , abs ( VnL ))) cR = cs * cs / ( max ( cs , abs ( VnR ))) C = min ( cL , CR ) ! ---- Mach at face ---- ML = VnL / C MR = VnR / C ! ---- switch for supersonic flow ---- alphaL = max ( 0 , 1 - floor ( abs ( ML ))) alphaR = max ( 0 , 1 - floor ( abs ( MR ))) ! Compute '+' direction quantities FmL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL ) * ML ) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) betaL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL )) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) * ( 2.0 - ML ) ! Compute '-' direction quantities FmR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR ) * MR ) - alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) betaR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR )) + alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) * ( 2.0 + MR ) !AUSM+modification ! Compute '+' direction quantities FmL = FmL + alphaL * 0.1250 * (( ML ** 2 - 1.0 ) ** 2 ) betaL = betaL + alphaL * 0.1875 * (( ML ** 2 - 1.0 ) ** 2 ) * ML ! Compute '-' direction quantities FmR = FmR - alphaR * 0.1250 * (( MR ** 2 - 1.0 ) ** 2 ) betaR = betaR - alphaR * 0.1875 * (( MR ** 2 - 1.0 ) ** 2 ) * MR ! mass coefficient Mface = FmL + FmR ! -- Pressure coeffient-- pbar = betaL * pL + betaR * pR ! -- mass -- if ( Mface > 0.0 ) then mass = Mface * C * rL else mass = Mface * c * rR end if mass = mass * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) !! -- Turbulence variables mass flux -- if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! total flux Flux ( i , j , k , :) = F_plus (:) + F_minus (:) ! Get the total flux for a face ! -- Pressure flux addition -- Flux ( i , j , K , 2 ) = Flux ( i , j , k , 2 ) + ( pbar * faces ( i , j , k )% nx ) Flux ( i , j , K , 3 ) = Flux ( i , j , k , 3 ) + ( pbar * faces ( i , j , k )% ny ) Flux ( i , j , K , 4 ) = Flux ( i , j , k , 4 ) + ( pbar * faces ( i , j , k )% nz ) Flux ( i , j , k , :) = Flux ( i , j , k , :) * faces ( i , j , k )% A end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux~4.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes(F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_fluxes~4~~CallsGraph proc~compute_fluxes~4 compute_fluxes debugcall debugcall proc~compute_fluxes~4->debugcall proc~compute_flux~4 compute_flux proc~compute_fluxes~4->proc~compute_flux~4 proc~compute_flux~4->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~4.html","title":"compute_fluxes – FEST-3D"},{"text":"private subroutine compute_flux(Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input-argument direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variables at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variables at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_flux~5~~CallsGraph proc~compute_flux~5 compute_flux debugcall debugcall proc~compute_flux~5->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~5~~CalledByGraph proc~compute_flux~5 compute_flux proc~compute_fluxes~5 compute_fluxes proc~compute_fluxes~5->proc~compute_flux~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input-argument direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variables at face integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus , F_minus real ( wp ) :: M_perp_left , M_perp_right real ( wp ) :: alpha_plus , alpha_minus real ( wp ) :: beta_left , beta_right real ( wp ) :: M_plus , M_minus real ( wp ) :: D_plus , D_minus real ( wp ) :: c_plus , c_minus real ( wp ) :: scrD_plus , scrD_minus real ( wp ) :: sound_speed_avg , face_normal_speeds real ( wp ) :: temp_c DebugCall ( 'compute_flux' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( flow % gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( flow % gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_left ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_left ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_right ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_right ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! AUSM modification temp_c = c_plus + c_minus c_plus = max ( 0. , temp_c ) c_minus = min ( 0. , temp_c ) ! F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * faces ( i , j , k )% A F_minus (:) = F_minus (:) * faces ( i , j , k )% A ! Get the total flux for a face Flux ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux~5.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes(F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_fluxes~5~~CallsGraph proc~compute_fluxes~5 compute_fluxes debugcall debugcall proc~compute_fluxes~5->debugcall proc~compute_flux~5 compute_flux proc~compute_fluxes~5->proc~compute_flux~5 proc~compute_flux~5->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~5.html","title":"compute_fluxes – FEST-3D"},{"text":"private subroutine compute_flux(Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input-argument direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variable at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variable at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_flux~6~~CallsGraph proc~compute_flux~6 compute_flux debugcall debugcall proc~compute_flux~6->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~6~~CalledByGraph proc~compute_flux~6 compute_flux proc~compute_fluxes~6 compute_fluxes proc~compute_fluxes~6->proc~compute_flux~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( Flux , f_qp_left , f_qp_right , faces , flags , flow , bc , dims ) !< A generalized subroutine to calculate !< flux through the input-argument direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values real ( wp ), dimension (:, :, :, :), intent ( inout ) :: Flux !< Store fluxes throught the any(I,J,K) faces type ( facetype ), dimension ( - 2 : dims % imx + 2 + flags ( 1 ), - 2 : dims % jmx + 2 + flags ( 2 ), - 2 : dims % kmx + 2 + flags ( 3 )), intent ( in ) :: faces !< Face quantities: area and unit normal real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at face integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ), dimension ( 1 : dims % n_var ) :: F_plus , F_minus real ( wp ) :: M_perp_left , M_perp_right real ( wp ) :: alpha_plus , alpha_minus real ( wp ) :: beta_left , beta_right real ( wp ) :: M_plus , M_minus real ( wp ) :: D_plus , D_minus real ( wp ) :: c_plus , c_minus real ( wp ) :: scrD_plus , scrD_minus real ( wp ) :: sound_speed_avg , face_normal_speeds real ( wp ) :: M_ldfss , M_plus_ldfss , M_minus_ldfss DebugCall ( 'compute_flux' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do k = 1 , dims % kmx - 1 + k_f do j = 1 , dims % jmx - 1 + j_f do i = 1 , dims % imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( flow % gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( flow % gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_left ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_left ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * faces ( i , j , k )% nx + & f_qp_right ( i , j , k , 3 ) * faces ( i , j , k )% ny + & f_qp_right ( i , j , k , 4 ) * faces ( i , j , k )% nz M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! LDFSS0 modification M_ldfss = 0.25 * beta_left * beta_right * & ( sqrt (( M_perp_left ** 2 + M_perp_right ** 2 ) * 0.5 ) & - 1 ) ** 2 M_plus_ldfss = M_ldfss * & ( 1 - ( f_qp_left ( i , j , k , 5 ) - f_qp_right ( i , j , k , 5 )) / & ( 2 * f_qp_left ( i , j , k , 1 ) * ( sound_speed_avg ** 2 ))) M_minus_ldfss = M_ldfss * & ( 1 - ( f_qp_left ( i , j , k , 5 ) - f_qp_right ( i , j , k , 5 )) / & ( 2 * f_qp_right ( i , j , k , 1 ) * ( sound_speed_avg ** 2 ))) c_plus = c_plus - M_plus_ldfss c_minus = c_minus + M_minus_ldfss ! F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * bc % make_F_flux_zero ( i ) & + j_f * bc % make_G_flux_zero ( j ) & + k_f * bc % make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nx ) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% ny ) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * faces ( i , j , k )% nz ) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( flow % gm / ( flow % gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( dims % n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * faces ( i , j , k )% A F_minus (:) = F_minus (:) * faces ( i , j , k )% A ! Get the total flux for a face Flux ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux~6.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes(F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_fluxes~6~~CallsGraph proc~compute_fluxes~6 compute_fluxes debugcall debugcall proc~compute_fluxes~6->debugcall proc~compute_flux~6 compute_flux proc~compute_fluxes~6->proc~compute_flux~6 proc~compute_flux~6->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes ( F , G , H , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , Ifaces , Jfaces , Kfaces , flow , bc , dims ) !subroutine compute_fluxes(F,G,H, flow, dims) !< Call to compute fluxes throught faces in each direction implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. real ( wp ), dimension (:, :, :, :), intent ( inout ) :: F !< Store fluxes throught the I faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: G !< Store fluxes throught the J faces real ( wp ), dimension (:, :, :, :), intent ( inout ) :: H !< Store fluxes throught the K faces type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Store face quantites for I faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Store face quantites for J faces type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Store face quantites for K faces real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( boundarytype ), intent ( in ) :: bc !< boundary conditions and fixed values integer , dimension ( 3 ) :: flags DebugCall ( 'compute_fluxes' ) flags = ( / 1 , 0 , 0 / ) call compute_flux ( F , x_qp_l , x_qp_r , Ifaces , flags , flow , bc , dims ) if ( any ( isnan ( F ))) then Fatal_error end if flags = ( / 0 , 1 , 0 / ) call compute_flux ( G , y_qp_l , y_qp_r , Jfaces , flags , flow , bc , dims ) if ( any ( isnan ( G ))) then Fatal_error end if if ( dims % kmx == 2 ) then H = 0. else flags = ( / 0 , 0 , 1 / ) call compute_flux ( H , z_qp_l , z_qp_r , Kfaces , flags , flow , bc , dims ) end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~6.html","title":"compute_fluxes – FEST-3D"},{"text":"private subroutine pressure_based_switching(qp, f_qp_left, f_qp_right, pdif, flags, flow, dims) Pressure based switching. \n User x,y, or z for I,J,or K face respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitive variable at cell faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitive variable at cell faces real(kind=wp), intent(inout), dimension(0:dims%imx,0:dims%jmx,0:dims%kmx) :: pdif pressure difference integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~pressure_based_switching~~CallsGraph proc~pressure_based_switching pressure_based_switching debugcall debugcall proc~pressure_based_switching->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pressure_based_switching~~CalledByGraph proc~pressure_based_switching pressure_based_switching proc~compute_muscl_states compute_muscl_states proc~compute_muscl_states->proc~pressure_based_switching proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_muscl_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocpressure_based_switchingCalledByGraph = svgPanZoom('#procpressure_based_switchingCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code pressure_based_switching Source Code subroutine pressure_based_switching ( qp , f_qp_left , f_qp_right , pdif , flags , flow , dims ) !< Pressure based switching. !< User x,y, or z for I,J,or K face respectively !---------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive variable at cell faces real ( wp ), dimension ( 0 : dims % imx , 0 : dims % jmx , 0 : dims % kmx ), intent ( inout ) :: pdif !< pressure difference integer :: i , j , k , i_end , j_end , k_end integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ) :: pd2 DebugCall ( 'pressure_based_switching' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) i_end = dims % imx - 1 + i_f j_end = dims % jmx - 1 + j_f k_end = dims % kmx - 1 + k_f ! i_end and j_end denote number of faces ! Total number of cells including ghost_cells is ! (i_end+1) * j_end for xi faces and i_end*(j_end+1) for ! eta faces. ! Loop over cells (physical) do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 pd2 = abs ( qp ( i + i_f * 1 , j + j_f * 1 , k + k_f * 1 , 5 ) - & !pressure qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , 5 )) pdif ( i , j , k ) = 1 - ( pd2 / ( pd2 + flow % pressure_inf )) end do end do end do ! Update at ghost cells pdif (( 1 - i_f ):( 1 - i_f ) * ( dims % imx - 1 ), ( 1 - j_f ):( 1 - j_f ) * ( dims % jmx - 1 ), & ( 1 - k_f ):( 1 - k_f ) * ( dims % kmx - 1 )) = & pdif ( 1 : dims % imx - 1 - i_f * ( dims % imx - 2 ), 1 : dims % jmx - 1 - j_f * ( dims % jmx - 2 ), & 1 : dims % kmx - 1 - k_f * ( dims % kmx - 2 )) pdif (( 1 - i_f * ( - dims % imx + 1 )):( i_f ) + ( dims % imx - 1 ), ( 1 - j_f * ( - dims % jmx + 1 )):( j_f ) + ( dims % jmx - 1 ), & ( 1 - k_f * ( - dims % kmx + 1 )):( k_f ) + ( dims % kmx - 1 )) = & pdif ( 1 + i_f * ( dims % imx - 2 ): dims % imx - 1 , 1 + j_f * ( dims % jmx - 2 ): dims % jmx - 1 , & 1 + k_f * ( dims % kmx - 2 ): dims % kmx - 1 ) ! Loop over faces do k = 1 , dims % kmx - ( 1 - k_f ) do j = 1 , dims % jmx - ( 1 - j_f ) do i = 1 , dims % imx - ( 1 - i_f ) f_qp_left ( i , j , k , :) = qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :) + (& pdif ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 ) * ( & f_qp_left ( i , j , k , :) - qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :))) f_qp_right ( i , j , k , :) = qp ( i , j , k , :) - (& pdif ( i , j , k ) * ( & qp ( i , j , k , :) - f_qp_right ( i , j , k , :))) end do end do end do end subroutine pressure_based_switching","tags":"","loc":"proc/pressure_based_switching.html","title":"pressure_based_switching – FEST-3D"},{"text":"private subroutine compute_face_state(qp, f_qp_left, f_qp_right, flags, lam_switch, turb_switch, dims) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitive variable at cell faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitive variable at cell faces integer, intent(in), dimension(3) :: flags Flags for direction switch integer, intent(in) :: lam_switch Limiter switch for laminar variables integer, intent(in) :: turb_switch Limiter switch for turbulent variables type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_face_state~~CallsGraph proc~compute_face_state compute_face_state debugcall debugcall proc~compute_face_state->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_face_state~~CalledByGraph proc~compute_face_state compute_face_state proc~compute_muscl_states compute_muscl_states proc~compute_muscl_states->proc~compute_face_state proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_muscl_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_face_stateCalledByGraph = svgPanZoom('#proccompute_face_stateCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_state Source Code subroutine compute_face_state ( qp , f_qp_left , f_qp_right , flags , lam_switch , turb_switch , dims ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< Flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive variable at cell faces integer , intent ( in ) :: lam_switch !< Limiter switch for laminar variables integer , intent ( in ) :: turb_switch !< Limiter switch for turbulent variables integer :: i , j , k , l !< integer used for DO loop integer :: ii , jj , kk !< Variable for ALFA family limiter real ( wp ) :: alpha !< Flags to determine face direction real ( wp ) :: psi1 , psi2 !< limiters real ( wp ) :: fd !< forward difference real ( wp ) :: bd !< backward difference real ( wp ) :: r !< ratio of differences DebugCall ( 'compute_face_state' ) alpha = 2. / 3. !Koren limiter phi = 1.0 kappa = 1. / 3. switch_L = lam_switch ii = flags ( 1 ) jj = flags ( 2 ) kk = flags ( 3 ) do l = 1 , dims % n_var if ( l >= 6 ) then switch_L = turb_switch end if do k = 1 - kk , dims % kmx - 1 + kk do j = 1 - jj , dims % jmx - 1 + jj do i = 1 - ii , dims % imx - 1 + ii ! Cell based ! Koren limiter for now ! From paper: delta: forward difference 'fd' !             nabla: backward difference 'bd' fd = qp ( i + ii , j + jj , k + kk , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - ii , j - jj , k - kk , l ) r = fd / max ( bd , 1 e - 10 ) psi1 = max ( 0. , min ( 2 * r , alpha * ( r - 1.0 ) + 1.0 , 2. )) !alpha limiter !                psi1 = max(0., min(2*r,1.), min(r,2.))    ! superbee !                psi1 = ((r*r) + r)/((r*r) + 1.0)          ! Van-Albda !                psi1 = (abs(r) + r)/(abs(r) + 1.0)          ! Van-Leer r = bd / max ( fd , 1 e - 10 ) psi2 = max ( 0. , min ( 2 * r , alpha * ( r - 1.0 ) + 1.0 , 2. )) !                psi2 = max(0., min(2*r,1.), min(r,2.)) !                psi2 = ((r*r) + r)/((r*r) + 1.0)          ! Van-Albda !                psi2 = (abs(r) + r)/(abs(r) + 1.0)          ! Van-Leer psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) f_qp_left ( i + ii , j + jj , k + kk , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) f_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end subroutine compute_face_state","tags":"","loc":"proc/compute_face_state.html","title":"compute_face_state – FEST-3D"},{"text":"public subroutine compute_muscl_states(qp, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, pdif, scheme, flow, dims) Implement MUSCL scheme to get left and right states at\n each face. The computation is done through all cells\n and first level ghost cells Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face real(kind=wp), intent(inout), dimension(0:dims%imx,0:dims%jmx,0:dims%kmx) :: pdif pressure difference type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_muscl_states~~CallsGraph proc~compute_muscl_states compute_muscl_states proc~compute_face_state compute_face_state proc~compute_muscl_states->proc~compute_face_state proc~pressure_based_switching pressure_based_switching proc~compute_muscl_states->proc~pressure_based_switching debugcall debugcall proc~compute_face_state->debugcall proc~pressure_based_switching->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_muscl_states~~CalledByGraph proc~compute_muscl_states compute_muscl_states proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_muscl_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_muscl_statesCalledByGraph = svgPanZoom('#proccompute_muscl_statesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_muscl_states Source Code subroutine compute_muscl_states ( qp , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , pdif , scheme , flow , dims ) !< Implement MUSCL scheme to get left and right states at !< each face. The computation is done through all cells !< and first level ghost cells !--------------------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face real ( wp ), dimension ( 0 : dims % imx , 0 : dims % jmx , 0 : dims % kmx ), intent ( inout ) :: pdif !< pressure difference type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. integer , dimension ( 3 ) :: flags !< Flags for direction flags = ( / 1 , 0 , 0 / ) call compute_face_state ( qp , x_qp_l , x_qp_r , flags , scheme % ilimiter_switch , scheme % itlimiter_switch , dims ) if ( scheme % iPB_switch == 1 ) then call pressure_based_switching ( qp , x_qp_l , x_qp_r , pdif , flags , flow , dims ) end if flags = ( / 0 , 1 , 0 / ) call compute_face_state ( qp , y_qp_l , y_qp_r , flags , scheme % jlimiter_switch , scheme % jtlimiter_switch , dims ) if ( scheme % jPB_switch == 1 ) then call pressure_based_switching ( qp , y_qp_l , y_qp_r , pdif , flags , flow , dims ) end if flags = ( / 0 , 0 , 1 / ) call compute_face_state ( qp , z_qp_l , z_qp_r , flags , scheme % klimiter_switch , scheme % ktlimiter_switch , dims ) if ( scheme % kPB_switch == 1 ) then call pressure_based_switching ( qp , z_qp_l , z_qp_r , pdif , flags , flow , dims ) end if end subroutine compute_muscl_states","tags":"","loc":"proc/compute_muscl_states.html","title":"compute_muscl_states – FEST-3D"},{"text":"private subroutine compute_face_states(qp, f_qp_left, f_qp_right, flags, dims) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitive state variable at faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitive state variable at faces integer, intent(in), dimension(3) :: flags flags for direction switch type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Called by proc~~compute_face_states~~CalledByGraph proc~compute_face_states compute_face_states proc~compute_weno_states compute_weno_states proc~compute_weno_states->proc~compute_face_states proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_weno_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_face_statesCalledByGraph = svgPanZoom('#proccompute_face_statesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_states Source Code subroutine compute_face_states ( qp , f_qp_left , f_qp_right , flags , dims ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive state variable at faces integer :: i , j , k , l integer :: i_f = 0 , j_f = 0 , k_f = 0 real ( wp ), dimension ( 3 ) :: P !< polynomial approximation real ( wp ), dimension ( 3 ) :: B !< smoothness factor real ( wp ), dimension ( 3 ) :: w !< wieght real ( wp ), dimension ( 3 ) :: g !< linear wieght real ( wp ), dimension ( - 2 : 2 ) :: u !< state_variable real ( wp ) :: eps = 1 e - 6 g ( 1 ) = 1.0 / 1 0.0 g ( 2 ) = 6.0 / 1 0.0 g ( 3 ) = 3.0 / 1 0.0 i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do l = 1 , dims % n_var do k = 1 - k_f , dims % kmx - 1 + k_f do j = 1 - j_f , dims % jmx - 1 + j_f do i = 1 - i_f , dims % imx - 1 + i_f U ( - 2 ) = qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , l ) !u_{i-2} U ( - 1 ) = qp ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f , l ) !u_{i-1} u ( 0 ) = qp ( i , j , k , l ) !u_{i} U ( 1 ) = qp ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f , l ) !u_{i+1} U ( 2 ) = qp ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f , l ) !u_{i+2} P ( 1 ) = ( 2.0 * U ( - 2 ) - 7.0 * U ( - 1 ) + 1 1.0 * U ( 0 )) / 6.0 P ( 2 ) = ( - 1.0 * U ( - 1 ) + 5.0 * U ( 0 ) + 2.0 * U ( 1 )) / 6.0 P ( 3 ) = ( 2.0 * U ( 0 ) + 5.0 * U ( 1 ) - 1.0 * U ( 2 )) / 6.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( U ( - 2 ) - 2.0 * U ( - 1 ) + U ( 0 )) ** 2 + ( 1.0 / 4.0 ) * ( U ( - 2 ) - 4.0 * U ( - 1 ) + 3.0 * U ( 0 )) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( U ( - 1 ) - 2.0 * U ( 0 ) + U ( 1 )) ** 2 + ( 1.0 / 4.0 ) * ( U ( - 1 ) - U ( 1 )) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( U ( 0 ) - 2.0 * U ( 1 ) + U ( 2 )) ** 2 + ( 1.0 / 4.0 ) * ( 3.0 * U ( 0 ) - 4.0 * U ( 1 ) + U ( 2 )) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = SUM ( w * P ) / SUM ( w ) P ( 1 ) = ( 2.0 * U ( 2 ) - 7.0 * U ( 1 ) + 1 1.0 * U ( 0 )) / 6.0 P ( 2 ) = ( - 1.0 * U ( 1 ) + 5.0 * U ( 0 ) + 2.0 * U ( - 1 )) / 6.0 P ( 3 ) = ( 2.0 * U ( 0 ) + 5.0 * U ( - 1 ) - 1.0 * U ( - 2 )) / 6.0 !B(1) = (13.0/12.0)*(U( 2)-2.0*U( 1)+U( 0))**2 + (1.0/4.0)*(    U(2)-4.0*U( 1)+3.0*U( 0))**2 !B(2) = (13.0/12.0)*(U( 1)-2.0*U( 0)+U(-1))**2 + (1.0/4.0)*(    U(1)-              U(-1))**2 !B(3) = (13.0/12.0)*(U( 0)-2.0*U(-1)+U(-2))**2 + (1.0/4.0)*(3.0*U(0)-4.0*U(-1)+    U(-2))**2 w ( 1 ) = g ( 1 ) / ( eps + B ( 3 )) ** 2 w ( 2 ) = g ( 2 ) / ( eps + B ( 2 )) ** 2 w ( 3 ) = g ( 3 ) / ( eps + B ( 1 )) ** 2 f_qp_right ( i , j , k , l ) = SUM ( w * P ) / SUM ( w ) end do end do end do end do end subroutine compute_face_states","tags":"","loc":"proc/compute_face_states.html","title":"compute_face_states – FEST-3D"},{"text":"public subroutine compute_weno_states(qp, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, dims) Call Weno scheme for all the three direction I,J, and K Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_weno_states~~CallsGraph proc~compute_weno_states compute_weno_states proc~compute_face_states compute_face_states proc~compute_weno_states->proc~compute_face_states Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_weno_states~~CalledByGraph proc~compute_weno_states compute_weno_states proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_weno_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_weno_statesCalledByGraph = svgPanZoom('#proccompute_weno_statesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_weno_states Source Code subroutine compute_weno_states ( qp , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , dims ) !< Call Weno scheme for all the three direction I,J, and K implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face integer , dimension ( 3 ) :: flags !< flags for different direction flags = ( / 1 , 0 , 0 / ) call compute_face_states ( qp , x_qp_l , x_qp_r , flags , dims ) flags = ( / 0 , 1 , 0 / ) call compute_face_states ( qp , y_qp_l , y_qp_r , flags , dims ) flags = ( / 0 , 0 , 1 / ) call compute_face_states ( qp , z_qp_l , z_qp_r , flags , dims ) end subroutine compute_weno_states","tags":"","loc":"proc/compute_weno_states.html","title":"compute_weno_states – FEST-3D"},{"text":"private subroutine compute_face_states(qp, f_qp_left, f_qp_right, flags, cells, dims) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitive state at faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitive state at faces integer, intent(in), dimension(3) :: flags flags for direction switch type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Called by proc~~compute_face_states~2~~CalledByGraph proc~compute_face_states~2 compute_face_states proc~compute_weno_nm_states compute_weno_NM_states proc~compute_weno_nm_states->proc~compute_face_states~2 proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_weno_nm_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_face_states2CalledByGraph = svgPanZoom('#proccompute_face_states2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_states Source Code subroutine compute_face_states ( qp , f_qp_left , f_qp_right , flags , cells , dims ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ), 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive state at faces type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Input cell quantities: volume integer :: i , j , k , l integer :: i_f = 0 , j_f = 0 , k_f = 0 real ( wp ), dimension ( 3 ) :: P !< polynomial approximation real ( wp ), dimension ( 3 ) :: B !< smoothness factor real ( wp ), dimension ( 3 ) :: w !< wieght real ( wp ), dimension ( 3 ) :: g !< linear wieght real ( wp ), dimension ( - 2 : 2 ) :: u !<state_variable real ( wp ) :: eps = 1 e - 6 real ( wp ), dimension ( - 2 : 2 ) :: vol real ( wp ) :: U11 real ( wp ) :: U00 real ( wp ) :: U21 real ( wp ) :: U10 real ( wp ) :: U01 real ( wp ) :: U12 real ( wp ) :: alpha12 real ( wp ) :: alpha01 real ( wp ) :: alpha10 real ( wp ) :: alpha21 g ( 1 ) = 1.0 / 1 0.0 g ( 2 ) = 6.0 / 1 0.0 g ( 3 ) = 3.0 / 1 0.0 i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) do l = 1 , dims % n_var do k = 1 - k_f , dims % kmx - 1 + k_f do j = 1 - j_f , dims % jmx - 1 + j_f do i = 1 - i_f , dims % imx - 1 + i_f U ( - 2 ) = qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , l ) !u_{i-2} U ( - 1 ) = qp ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f , l ) !u_{i-1} u ( 0 ) = qp ( i , j , k , l ) !u_{i} U ( 1 ) = qp ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f , l ) !u_{i+1} U ( 2 ) = qp ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f , l ) !u_{i+2} Vol ( - 2 ) = cells ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f )% volume !volume_{i-2} Vol ( - 1 ) = cells ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f )% volume !volume_{i-1} Vol ( 0 ) = cells ( i , j , k )% volume !volume_{i} Vol ( 1 ) = cells ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f )% volume !volume_{i+1} Vol ( 2 ) = cells ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f )% volume !volume_{i+2} alpha12 = Vol ( 2 ) / ( Vol ( 1 ) + Vol ( 2 )) alpha01 = Vol ( 1 ) / ( Vol ( 0 ) + Vol ( 1 )) alpha10 = Vol ( 0 ) / ( Vol ( - 1 ) + Vol ( 0 )) alpha21 = vol ( - 1 ) / ( Vol ( - 2 ) + Vol ( - 1 )) U01 = ( 1.0 - alpha01 ) * U ( 0 ) + alpha01 * U ( 1 ) U12 = ( 1.0 - alpha12 ) * U ( 1 ) + alpha12 * U ( 2 ) U10 = ( 1.0 - alpha10 ) * U ( - 1 ) + alpha10 * U ( 0 ) U21 = ( 1.0 - alpha21 ) * U ( - 2 ) + alpha21 * U ( - 1 ) U00 = U ( - 1 ) + ( 1.0 - alpha21 ) * ( U ( - 1 ) - U ( - 2 )) U11 = U ( 1 ) + alpha12 * ( U ( 1 ) - U ( 2 )) P ( 1 ) = ( 6.0 * U ( 0 ) - 1.0 * U10 - 2.0 * U00 ) / 3.0 P ( 2 ) = ( - 1.0 * U10 + 2.0 * U ( 0 ) + 2.0 * U01 ) / 3.0 P ( 3 ) = ( 2.0 * U01 + 2.0 * U ( 1 ) - 1.0 * U12 ) / 3.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 2.0 * U00 ) ** 2 + ( 1.0 / 4.0 ) * ( 4 * U ( 0 ) - 2.0 * U10 - 2.0 * U00 ) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 4.0 * U ( 0 ) + 2 * U01 ) ** 2 + ( 1.0 / 4.0 ) * ( - 2 * u10 + 2.0 * U01 ) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 4.0 * U ( 1 ) + 2 * U12 ) ** 2 + ( 1.0 / 4.0 ) * ( - 6 * U01 + 8.0 * U ( 1 ) - 2.0 * U12 ) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = SUM ( w * P ) / SUM ( w ) P ( 1 ) = ( 6.0 * U ( 0 ) - 1.0 * U01 - 2.0 * U11 ) / 3.0 P ( 2 ) = ( - 1.0 * U01 + 2.0 * U ( 0 ) + 2.0 * U10 ) / 3.0 P ( 3 ) = ( 2.0 * U10 + 2.0 * U ( - 1 ) - 1.0 * U21 ) / 3.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 2.0 * U11 ) ** 2 + ( 1.0 / 4.0 ) * ( 4 * U ( 0 ) - 2.0 * U01 - 2.0 * U11 ) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 4.0 * U ( 0 ) + 2 * U10 ) ** 2 + ( 1.0 / 4.0 ) * ( - 2 * u01 + 2.0 * U10 ) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 4.0 * U ( - 1 ) + 2 * U21 ) ** 2 + ( 1.0 / 4.0 ) * ( - 6 * U10 + 8.0 * U ( - 1 ) - 2.0 * U21 ) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_right ( i , j , k , l ) = SUM ( w * P ) / SUM ( w ) end do end do end do end do end subroutine compute_face_states","tags":"","loc":"proc/compute_face_states~2.html","title":"compute_face_states – FEST-3D"},{"text":"public subroutine compute_weno_NM_states(qp, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, cells, dims) Call Weno scheme for all the three direction I,J, and K Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_weno_nm_states~~CallsGraph proc~compute_weno_nm_states compute_weno_NM_states proc~compute_face_states~2 compute_face_states proc~compute_weno_nm_states->proc~compute_face_states~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_weno_nm_states~~CalledByGraph proc~compute_weno_nm_states compute_weno_NM_states proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_weno_nm_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_weno_nm_statesCalledByGraph = svgPanZoom('#proccompute_weno_nm_statesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_weno_NM_states Source Code subroutine compute_weno_NM_states ( qp , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , cells , dims ) !< Call Weno scheme for all the three direction I,J, and K implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells integer , dimension ( 3 ) :: flags !< flags for different directions flags = ( / 1 , 0 , 0 / ) call compute_face_states ( qp , x_qp_l , x_qp_r , flags , cells , dims ) flags = ( / 0 , 1 , 0 / ) call compute_face_states ( qp , y_qp_l , y_qp_r , flags , cells , dims ) flags = ( / 0 , 0 , 1 / ) call compute_face_states ( qp , z_qp_l , z_qp_r , flags , cells , dims ) end subroutine compute_weno_NM_states","tags":"","loc":"proc/compute_weno_nm_states.html","title":"compute_weno_NM_states – FEST-3D"},{"text":"public subroutine setup_interpolant_scheme(dims) Arguments Type Intent Optional Attributes Name type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~setup_interpolant_scheme~~CallsGraph proc~setup_interpolant_scheme setup_interpolant_scheme interface~alloc alloc proc~setup_interpolant_scheme->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_interpolant_scheme~~CalledByGraph proc~setup_interpolant_scheme setup_interpolant_scheme proc~setup_scheme setup_scheme proc~setup_scheme->proc~setup_interpolant_scheme proc~setup_solver setup_solver proc~setup_solver->proc~setup_scheme proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_interpolant_scheme Source Code subroutine setup_interpolant_scheme ( dims ) implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx call alloc ( x_qp_left , 0 , dims % imx + 1 , 1 , dims % jmx - 1 , 1 , dims % kmx - 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for x_qp_left.' ) call alloc ( x_qp_right , 0 , dims % imx + 1 , 1 , dims % jmx - 1 , 1 , dims % kmx - 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for x_qp_right.' ) call alloc ( y_qp_left , 1 , dims % imx - 1 , 0 , dims % jmx + 1 , 1 , dims % kmx - 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for y_qp_left.' ) call alloc ( y_qp_right , 1 , dims % imx - 1 , 0 , dims % jmx + 1 , 1 , dims % kmx - 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for y_qp_right.' ) call alloc ( z_qp_left , 1 , dims % imx - 1 , 1 , dims % jmx - 1 , 0 , dims % kmx + 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for z_qp_left.' ) call alloc ( z_qp_right , 1 , dims % imx - 1 , 1 , dims % jmx - 1 , 0 , dims % kmx + 1 , 1 , dims % n_var , & errmsg = 'Error: Unable to allocate memory for z_qp_right.' ) call alloc ( pdif , 0 , dims % imx , 0 , dims % jmx , 0 , dims % kmx , & errmsg = 'Error: Unable to allocate memory for pdif' ) end subroutine setup_interpolant_scheme","tags":"","loc":"proc/setup_interpolant_scheme.html","title":"setup_interpolant_scheme – FEST-3D"},{"text":"private subroutine extrapolate_cell_averages_to_faces(qp, dims) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~extrapolate_cell_averages_to_faces~~CallsGraph proc~extrapolate_cell_averages_to_faces extrapolate_cell_averages_to_faces debugcall debugcall proc~extrapolate_cell_averages_to_faces->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~extrapolate_cell_averages_to_faces~~CalledByGraph proc~extrapolate_cell_averages_to_faces extrapolate_cell_averages_to_faces proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~extrapolate_cell_averages_to_faces proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocextrapolate_cell_averages_to_facesCalledByGraph = svgPanZoom('#procextrapolate_cell_averages_to_facesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code extrapolate_cell_averages_to_faces Source Code subroutine extrapolate_cell_averages_to_faces ( qp , dims ) implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center DebugCall ( 'extrapolate_cell_averages_to_faces' ) x_qp_left (:, :, :, :) = qp ( - 1 : dims % imx , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ) x_qp_right (:, :, :, :) = qp ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ) y_qp_left (:, :, :, :) = qp ( 1 : dims % imx - 1 , - 1 : dims % jmx , 1 : dims % kmx - 1 , 1 : dims % n_var ) y_qp_right (:, :, :, :) = qp ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ) z_qp_left (:, :, :, :) = qp ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , - 1 : dims % kmx , 1 : dims % n_var ) z_qp_right (:, :, :, :) = qp ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ) end subroutine extrapolate_cell_averages_to_faces","tags":"","loc":"proc/extrapolate_cell_averages_to_faces.html","title":"extrapolate_cell_averages_to_faces – FEST-3D"},{"text":"public subroutine compute_face_interpolant(qp, cells, scheme, flow, dims) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Cell center quantities: volume, cellCenter type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_face_interpolant~~CallsGraph proc~compute_face_interpolant compute_face_interpolant proc~compute_ppm_states compute_ppm_states proc~compute_face_interpolant->proc~compute_ppm_states proc~extrapolate_cell_averages_to_faces extrapolate_cell_averages_to_faces proc~compute_face_interpolant->proc~extrapolate_cell_averages_to_faces proc~compute_muscl_states compute_muscl_states proc~compute_face_interpolant->proc~compute_muscl_states proc~compute_weno_nm_states compute_weno_NM_states proc~compute_face_interpolant->proc~compute_weno_nm_states proc~compute_weno_states compute_weno_states proc~compute_face_interpolant->proc~compute_weno_states proc~pressure_based_switching~2 pressure_based_switching proc~compute_ppm_states->proc~pressure_based_switching~2 proc~remove_extrema remove_extrema proc~compute_ppm_states->proc~remove_extrema proc~compute_face_estimates compute_face_estimates proc~compute_ppm_states->proc~compute_face_estimates debugcall debugcall proc~extrapolate_cell_averages_to_faces->debugcall proc~compute_face_state compute_face_state proc~compute_muscl_states->proc~compute_face_state proc~pressure_based_switching pressure_based_switching proc~compute_muscl_states->proc~pressure_based_switching proc~compute_face_states~2 compute_face_states proc~compute_weno_nm_states->proc~compute_face_states~2 proc~compute_face_states compute_face_states proc~compute_weno_states->proc~compute_face_states proc~pressure_based_switching~2->debugcall proc~remove_extrema->debugcall proc~compute_face_estimates->debugcall proc~compute_face_state->debugcall proc~pressure_based_switching->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_face_interpolant~~CalledByGraph proc~compute_face_interpolant compute_face_interpolant proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_face_interpolantCalledByGraph = svgPanZoom('#proccompute_face_interpolantCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_interpolant Source Code subroutine compute_face_interpolant ( qp , cells , scheme , flow , dims ) implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center type ( celltype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: cells !< Cell center quantities: volume, cellCenter type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. select case ( scheme % interpolant ) case ( \"none\" ) call extrapolate_cell_averages_to_faces ( qp , dims ) case ( \"ppm\" ) call compute_ppm_states ( qp , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , pdif , scheme , flow , dims ) case ( \"muscl\" ) call compute_muscl_states ( qp , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , pdif , scheme , flow , dims ) case ( \"weno\" ) call compute_weno_states ( qp , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , dims ) case ( \"weno_NM\" ) call compute_weno_NM_states ( qp , x_qp_left , x_qp_right , y_qp_left , y_qp_right , z_qp_left , z_qp_right , cells , dims ) case default Fatal_error end select end subroutine compute_face_interpolant","tags":"","loc":"proc/compute_face_interpolant.html","title":"compute_face_interpolant – FEST-3D"},{"text":"private subroutine compute_face_estimates(qp, f_qp_left, f_qp_right, flags, dims) Subroutine to calculate state at the face, generalized for Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_left primitive state at faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_right primitive state at faces integer, intent(in), dimension(3) :: flags Flags for direction switch type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_face_estimates~~CallsGraph proc~compute_face_estimates compute_face_estimates debugcall debugcall proc~compute_face_estimates->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_face_estimates~~CalledByGraph proc~compute_face_estimates compute_face_estimates proc~compute_ppm_states compute_ppm_states proc~compute_ppm_states->proc~compute_face_estimates proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_ppm_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_face_estimatesCalledByGraph = svgPanZoom('#proccompute_face_estimatesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_estimates Source Code subroutine compute_face_estimates ( qp , f_qp_left , f_qp_right , flags , dims ) !< Subroutine to calculate state at the face, generalized for implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< Flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ),& 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive state at faces integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction DebugCall ( 'compute_face_estimates' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) ! Interior faces do k = ( 1 - k_f ), dims % kmx - 1 + 2 * k_f do j = ( 1 - j_f ), dims % jmx - 1 + 2 * j_f do i = ( 1 - i_f ), dims % imx - 1 + 2 * i_f f_qp_left ( i , j , k , :) = ( 7. * ( qp ( i , j , k , :) + & qp ( i - i_f , j - j_f , k - k_f , :)) - ( qp ( i + i_f , j + j_f , k + k_f , :) + & qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , :))) / 1 2. end do end do end do f_qp_right = f_qp_left end subroutine compute_face_estimates","tags":"","loc":"proc/compute_face_estimates.html","title":"compute_face_estimates – FEST-3D"},{"text":"private subroutine remove_extrema(qp, f_qp_left, f_qp_right, flags, dims) Remove extrema from the state estimated. \n Limiting the value in case of PPM Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_left primitve state variable at faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_right primitve state variable at faces integer, intent(in), dimension(3) :: flags flags for direction switch type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~remove_extrema~~CallsGraph proc~remove_extrema remove_extrema debugcall debugcall proc~remove_extrema->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~remove_extrema~~CalledByGraph proc~remove_extrema remove_extrema proc~compute_ppm_states compute_ppm_states proc~compute_ppm_states->proc~remove_extrema proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_ppm_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocremove_extremaCalledByGraph = svgPanZoom('#procremove_extremaCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code remove_extrema Source Code subroutine remove_extrema ( qp , f_qp_left , f_qp_right , flags , dims ) !< Remove extrema from the state estimated. !< Limiting the value in case of PPM implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ),& 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitve state variable at faces integer :: i , j , k , l integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ) :: dqrl , dq6 DebugCall ( 'remove_extrema' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) ! Loop over cells (including ghost cells) do l = 1 , dims % n_var do k = 1 - k_f , dims % kmx - 1 + k_f do j = 1 - j_f , dims % jmx - 1 + j_f do i = 1 - i_f , dims % imx - 1 + i_f if (( f_qp_left ( i + i_f , j + j_f , k + k_f , l ) - qp ( i , j , k , l )) * & ( qp ( i , j , k , l ) - f_qp_right ( i , j , k , l )) <= 0 ) then f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = qp ( i , j , k , l ) f_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) else dqrl = f_qp_left ( i + i_f , j + j_f , k + k_f , l ) - f_qp_right ( i , j , k , l ) dq6 = 6. * ( qp ( i , j , k , l ) - 0.5 * ( f_qp_left ( i + i_f , j + j_f , k + k_f , l ) + & f_qp_right ( i , j , k , l ))) if ( dqrl * dq6 > dqrl * dqrl ) then f_qp_right ( i , j , k , l ) = 3. * qp ( i , j , k , l ) - & 2. * f_qp_left ( i + i_f , j + j_f , k + k_f , l ) else if ( - dqrl * dqrl > dqrl * dq6 ) then f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = 3. * qp ( i , j , k , l ) - & 2. * f_qp_right ( i , j , k , l ) end if end if end do end do end do end do end subroutine remove_extrema","tags":"","loc":"proc/remove_extrema.html","title":"remove_extrema – FEST-3D"},{"text":"private subroutine pressure_based_switching(qp, f_qp_left, f_qp_right, pdif, flags, flow, dims) Pressure based switching. \n User x,y, or z for I,J,or K face respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_left primitive state at faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_right primitive state at faces real(kind=wp), intent(inout), dimension(0:dims%imx,0:dims%jmx,0:dims%kmx) :: pdif pressure difference integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~pressure_based_switching~2~~CallsGraph proc~pressure_based_switching~2 pressure_based_switching debugcall debugcall proc~pressure_based_switching~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pressure_based_switching~2~~CalledByGraph proc~pressure_based_switching~2 pressure_based_switching proc~compute_ppm_states compute_ppm_states proc~compute_ppm_states->proc~pressure_based_switching~2 proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_ppm_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocpressure_based_switching2CalledByGraph = svgPanZoom('#procpressure_based_switching2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code pressure_based_switching Source Code subroutine pressure_based_switching ( qp , f_qp_left , f_qp_right , pdif , flags , flow , dims ) !< Pressure based switching. !< User x,y, or z for I,J,or K face respectively !---------------------------------------------- implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx integer , dimension ( 3 ), intent ( in ) :: flags !< flags for direction switch real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 1 - flags ( 1 ): dims % imx - 1 + 2 * flags ( 1 ), 1 - flags ( 2 ): dims % jmx - 1 + 2 * flags ( 2 ),& 1 - flags ( 3 ): dims % kmx - 1 + 2 * flags ( 3 ), 1 : dims % n_var ), intent ( inout ) :: f_qp_left , f_qp_right !< primitive state at faces real ( wp ), dimension ( 0 : dims % imx , 0 : dims % jmx , 0 : dims % kmx ), intent ( inout ) :: pdif !< pressure difference type ( flowtype ), intent ( in ) :: flow ! Character can be x or y or z integer :: i , j , k , i_end , j_end , k_end integer :: i_f , j_f , k_f ! Flags to determine face direction real ( wp ) :: pd2 DebugCall ( 'pressure_based_switching' ) i_f = flags ( 1 ) j_f = flags ( 2 ) k_f = flags ( 3 ) i_end = dims % imx - 1 + i_f j_end = dims % jmx - 1 + j_f k_end = dims % kmx - 1 + k_f ! i_end and j_end denote number of faces ! Total number of cells including ghost_cells is ! (i_end+1) * j_end for xi faces and i_end*(j_end+1) for ! eta faces. ! Loop over cells (physical) do k = 1 , dims % kmx - 1 do j = 1 , dims % jmx - 1 do i = 1 , dims % imx - 1 pd2 = abs ( qp ( i + i_f * 1 , j + j_f * 1 , k + k_f * 1 , 5 ) - & qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , 5 )) pdif ( i , j , k ) = 1 - ( pd2 / ( pd2 + flow % pressure_inf )) end do end do end do ! Update at ghost cells pdif (( 1 - i_f ):( 1 - i_f ) * ( dims % imx - 1 ), ( 1 - j_f ):( 1 - j_f ) * ( dims % jmx - 1 ), & ( 1 - k_f ):( 1 - k_f ) * ( dims % kmx - 1 )) = & pdif ( 1 : dims % imx - 1 - i_f * ( dims % imx - 2 ), 1 : dims % jmx - 1 - j_f * ( dims % jmx - 2 ), & 1 : dims % kmx - 1 - k_f * ( dims % kmx - 2 )) pdif ((( dims % imx - 1 ) * i_f ) + 1 : dims % imx - 1 + i_f , & (( dims % jmx - 1 ) * j_f ) + 1 : dims % jmx - 1 + j_f , & (( dims % kmx - 1 ) * k_f ) + 1 : dims % kmx - 1 + k_f ) & = & pdif ( i_f * ( dims % imx - 2 ) + 1 : dims % imx - 1 , & j_f * ( dims % jmx - 2 ) + 1 : dims % jmx - 1 , & k_f * ( dims % kmx - 2 ) + 1 : dims % kmx - 1 ) ! Loop over faces do k = 1 , dims % kmx - ( 1 - k_f ) do j = 1 , dims % jmx - ( 1 - j_f ) do i = 1 , dims % imx - ( 1 - i_f ) f_qp_left ( i , j , k , :) = qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :) + (& pdif ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 ) * ( & f_qp_left ( i , j , k , :) - qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :))) f_qp_right ( i , j , k , :) = qp ( i , j , k , :) - (& pdif ( i , j , k ) * ( & qp ( i , j , k , :) - f_qp_right ( i , j , k , :))) end do end do end do end subroutine pressure_based_switching","tags":"","loc":"proc/pressure_based_switching~2.html","title":"pressure_based_switching – FEST-3D"},{"text":"public subroutine compute_ppm_states(qp, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, pdif, scheme, flow, dims) Call PPM face-state reconstruction for each face\n with optional call for remove extrema based on\n input limter switch and call pressure based switching\n based on input pressure based switch Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face real(kind=wp), intent(inout), dimension(0:dims%imx,0:dims%jmx,0:dims%kmx) :: pdif pressure difference type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx Calls proc~~compute_ppm_states~~CallsGraph proc~compute_ppm_states compute_ppm_states proc~remove_extrema remove_extrema proc~compute_ppm_states->proc~remove_extrema proc~pressure_based_switching~2 pressure_based_switching proc~compute_ppm_states->proc~pressure_based_switching~2 proc~compute_face_estimates compute_face_estimates proc~compute_ppm_states->proc~compute_face_estimates debugcall debugcall proc~remove_extrema->debugcall proc~pressure_based_switching~2->debugcall proc~compute_face_estimates->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_ppm_states~~CalledByGraph proc~compute_ppm_states compute_ppm_states proc~compute_face_interpolant compute_face_interpolant proc~compute_face_interpolant->proc~compute_ppm_states proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_face_interpolant proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_ppm_statesCalledByGraph = svgPanZoom('#proccompute_ppm_statesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_ppm_states Source Code subroutine compute_ppm_states ( qp , x_qp_l , x_qp_r , y_qp_l , y_qp_r , z_qp_l , z_qp_r , pdif , scheme , flow , dims ) !< Call PPM face-state reconstruction for each face !< with optional call for remove extrema based on !< input limter switch and call pressure based switching !< based on input pressure based switch implicit none type ( extent ), intent ( in ) :: dims !< Extent of the domain:imx,jmx,kmx real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp !< Store primitive variable at cell center real ( wp ), dimension ( 0 : dims % imx + 1 , 1 : dims % jmx - 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: x_qp_l , x_qp_r !< Store primitive state at the I-face real ( wp ), dimension ( 1 : dims % imx - 1 , 0 : dims % jmx + 1 , 1 : dims % kmx - 1 , 1 : dims % n_var ), intent ( inout ) :: y_qp_l , y_qp_r !< Store primitive state at the J-face real ( wp ), dimension ( 1 : dims % imx - 1 , 1 : dims % jmx - 1 , 0 : dims % kmx + 1 , 1 : dims % n_var ), intent ( inout ) :: z_qp_l , z_qp_r !< Store primitive state at the K-face real ( wp ), dimension ( 0 : dims % imx , 0 : dims % jmx , 0 : dims % kmx ), intent ( inout ) :: pdif !< pressure difference type ( schemetype ), intent ( in ) :: scheme !< finite-volume Schemes type ( flowtype ), intent ( in ) :: flow !< Information about fluid flow: freestream-speed, ref-viscosity,etc. integer , dimension ( 3 ) :: flags !< flags for different directions flags = ( / 1 , 0 , 0 / ) call compute_face_estimates ( qp , x_qp_l , x_qp_r , flags , dims ) if ( scheme % ilimiter_switch == 1 ) then call remove_extrema ( qp , x_qp_l , x_qp_r , flags , dims ) end if if ( scheme % iPB_switch == 1 ) then call pressure_based_switching ( qp , x_qp_l , x_qp_r , pdif , flags , flow , dims ) end if flags = ( / 0 , 1 , 0 / ) call compute_face_estimates ( qp , y_qp_l , y_qp_r , flags , dims ) if ( scheme % jlimiter_switch == 1 ) then call remove_extrema ( qp , y_qp_l , y_qp_r , flags , dims ) end if if ( scheme % jPB_switch == 1 ) then call pressure_based_switching ( qp , y_qp_l , y_qp_r , pdif , flags , flow , dims ) end if flags = ( / 0 , 0 , 1 / ) call compute_face_estimates ( qp , z_qp_l , z_qp_r , flags , dims ) if ( scheme % klimiter_switch == 1 ) then call remove_extrema ( qp , z_qp_l , z_qp_r , flags , dims ) end if if ( scheme % kPB_switch == 1 ) then call pressure_based_switching ( qp , z_qp_l , z_qp_r , pdif , flags , flow , dims ) end if end subroutine compute_ppm_states","tags":"","loc":"proc/compute_ppm_states.html","title":"compute_ppm_states – FEST-3D"},{"text":"public subroutine setup_bc(files, scheme, flow, bc, dims) Initialization and allocate memory of boundary condition variables Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow type( boundarytype ), intent(inout) :: bc type( extent ), intent(in) :: dims Calls proc~~setup_bc~~CallsGraph proc~setup_bc setup_bc proc~read_fixed_values read_fixed_values proc~setup_bc->proc~read_fixed_values interface~alloc alloc proc~setup_bc->interface~alloc proc~get_fixed_values get_fixed_values proc~read_fixed_values->proc~get_fixed_values proc~fill_fixed_values fill_fixed_values proc~read_fixed_values->proc~fill_fixed_values proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~set_value set_value proc~get_fixed_values->proc~set_value proc~fill_fixed_values->proc~set_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_bc~~CalledByGraph proc~setup_bc setup_bc proc~setup_solver setup_solver proc~setup_solver->proc~setup_bc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_bc Source Code subroutine setup_bc ( files , scheme , flow , bc , dims ) !< Initialization and allocate memory of boundary condition variables implicit none type ( filetype ), intent ( in ) :: files type ( schemetype ), intent ( in ) :: scheme type ( flowtype ), intent ( in ) :: flow type ( boundarytype ), intent ( inout ) :: bc type ( extent ), intent ( in ) :: dims !check for periodic bc if ( bc % PbcId ( 1 ) >= 0 ) bc % imin_id =- 10 if ( bc % PbcId ( 2 ) >= 0 ) bc % imax_id =- 10 if ( bc % PbcId ( 3 ) >= 0 ) bc % jmin_id =- 10 if ( bc % PbcId ( 4 ) >= 0 ) bc % jmax_id =- 10 if ( bc % PbcId ( 5 ) >= 0 ) bc % kmin_id =- 10 if ( bc % PbcId ( 6 ) >= 0 ) bc % kmax_id =- 10 ! assign name to each face bc % face_names ( 1 ) = \"imin\" bc % face_names ( 2 ) = \"imax\" bc % face_names ( 3 ) = \"jmin\" bc % face_names ( 4 ) = \"jmax\" bc % face_names ( 5 ) = \"kmin\" bc % face_names ( 6 ) = \"kmax\" bc % id ( 1 ) = bc % imin_id bc % id ( 2 ) = bc % imax_id bc % id ( 3 ) = bc % jmin_id bc % id ( 4 ) = bc % jmax_id bc % id ( 5 ) = bc % kmin_id bc % id ( 6 ) = bc % kmax_id bc % c2 = 1 + scheme % accur bc % c3 = 0.5 * scheme % accur bc % c1 = bc % c2 - bc % c3 call read_fixed_values ( files , scheme , flow , bc ) call alloc ( bc % make_F_flux_zero , 1 , dims % imx ) call alloc ( bc % make_G_flux_zero , 1 , dims % jmx ) call alloc ( bc % make_H_flux_zero , 1 , dims % kmx ) bc % make_F_flux_zero = 1 bc % make_G_flux_zero = 1 bc % make_H_flux_zero = 1 if ( bc % imin_id ==- 5 . or . bc % imin_id ==- 6 . or . bc % imin_id ==- 7 ) bc % make_F_flux_zero ( 1 ) = 0 if ( bc % jmin_id ==- 5 . or . bc % jmin_id ==- 6 . or . bc % jmin_id ==- 7 ) bc % make_G_flux_zero ( 1 ) = 0 if ( bc % kmin_id ==- 5 . or . bc % kmin_id ==- 6 . or . bc % kmin_id ==- 7 ) bc % make_H_flux_zero ( 1 ) = 0 if ( bc % imax_id ==- 5 . or . bc % imax_id ==- 6 . or . bc % imax_id ==- 7 ) bc % make_F_flux_zero ( dims % imx ) = 0 if ( bc % jmax_id ==- 5 . or . bc % jmax_id ==- 6 . or . bc % jmax_id ==- 7 ) bc % make_G_flux_zero ( dims % jmx ) = 0 if ( bc % kmax_id ==- 5 . or . bc % kmax_id ==- 6 . or . bc % kmax_id ==- 7 ) bc % make_H_flux_zero ( dims % kmx ) = 0 end subroutine setup_bc","tags":"","loc":"proc/setup_bc.html","title":"setup_bc – FEST-3D"},{"text":"public subroutine copy1(var, type, face, dims) Copy 1 layer of interior cell to first ghost cell layer Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2) :: var Varible over which these operation has to be performed character(len=*), intent(in) :: type Type of copy: flat, symmetry, anti-symmetry character(len=*), intent(in) :: face Face over which boundary condition is being called type( extent ), intent(in) :: dims Contents Source Code copy1 Source Code subroutine copy1 ( var , type , face , dims ) !< Copy 1 layer of interior cell to first ghost cell layer implicit none type ( extent ), intent ( in ) :: dims character ( len =* ), intent ( in ) :: face !< Face over which boundary condition is being called character ( len =* ), intent ( in ) :: type !< Type of copy: flat, symmetry, anti-symmetry real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( inout ) :: var !< Varible over which these operation has to be performed real ( wp ) :: a2 = 1 integer :: imx , jmx , kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx select case ( type ) case ( \"anti\" ) a2 = - 1 case ( \"symm\" ) a2 = 1 case DEFAULT print * , \"ERROR: Wrong boundary condition type\" end select select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = a2 * var ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = a2 * var ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = a2 * var ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = a2 * var ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" end select end subroutine copy1","tags":"","loc":"proc/copy1.html","title":"copy1 – FEST-3D"},{"text":"public subroutine copy3(var, type, face, bc, dims) Copy 3 layer of interior cell to three ghost cell layer Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2) :: var Varible over which these operation has to be performed character(len=*), intent(in) :: type Type of copy: flat, symmetry, anti-symmetry character(len=*), intent(in) :: face Face over which boundary condition is being called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Called by proc~~copy3~~CalledByGraph proc~copy3 copy3 proc~subsonic_inlet subsonic_inlet proc~subsonic_inlet->proc~copy3 proc~wall wall proc~wall->proc~copy3 proc~temp_based_density temp_based_density proc~wall->proc~temp_based_density proc~no_slip no_slip proc~wall->proc~no_slip proc~total_pressure total_pressure proc~total_pressure->proc~copy3 proc~subsonic_outlet subsonic_outlet proc~subsonic_outlet->proc~copy3 proc~temp_based_density->proc~copy3 proc~supersonic_outlet supersonic_outlet proc~supersonic_outlet->proc~copy3 proc~no_slip->proc~copy3 proc~pole pole proc~pole->proc~copy3 proc~far_field far_field proc~far_field->proc~copy3 proc~slip_wall slip_wall proc~slip_wall->proc~copy3 proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~subsonic_inlet proc~populate_ghost_primitive->proc~wall proc~populate_ghost_primitive->proc~total_pressure proc~populate_ghost_primitive->proc~subsonic_outlet proc~populate_ghost_primitive->proc~supersonic_outlet proc~populate_ghost_primitive->proc~pole proc~populate_ghost_primitive->proc~far_field proc~populate_ghost_primitive->proc~slip_wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccopy3CalledByGraph = svgPanZoom('#proccopy3CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code copy3 Source Code subroutine copy3 ( var , type , face , bc , dims ) !< Copy 3 layer of interior cell to three ghost cell layer implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Face over which boundary condition is being called character ( len =* ), intent ( in ) :: type !< Type of copy: flat, symmetry, anti-symmetry real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( inout ) :: var !< Varible over which these operation has to be performed real ( wp ) :: a1 = 1 real ( wp ) :: a2 = 1 real ( wp ) :: a3 = 0 integer :: i1 = 1 integer :: i2 = 2 integer :: i3 = 3 integer :: imx , jmx , kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx select case ( type ) case ( \"anti\" ) a1 = 1. ; i1 = 1 a2 = - 1. ; i2 = 2 a3 = 0. ; i3 = 3 case ( \"flat\" ) a1 = 1. ; i1 = 1 a2 = 1. ; i2 = 1 a3 = 0. ; i3 = 1 case ( \"symm\" ) a1 = bc % c1 ; i1 = 1 a2 = bc % c2 ; i2 = 2 a3 = bc % c3 ; i3 = 3 ! do nothing ! use default value continue case DEFAULT print * , \"ERROR: Wrong boundary condition type\" end select select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i1 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i1 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i2 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i2 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( - 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i3 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i3 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i1 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i1 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i2 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i2 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( imx + 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i3 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i3 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i1 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i1 + 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , - 1 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i2 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i2 + 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , - 2 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i3 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i3 + 1 , 1 : kmx - 1 )) / a1 case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i1 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i1 - 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , jmx + 1 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i2 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i2 - 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , jmx + 2 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i3 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i3 - 1 , 1 : kmx - 1 )) / a1 case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i1 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i1 + 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , - 1 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i2 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i2 + 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , - 2 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i3 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i3 + 1 )) / a1 case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i1 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i1 - 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 1 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i2 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i2 - 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 2 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i3 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i3 - 1 )) / a1 case DEFAULT print * , \"ERROR: wrong face for boundary condition\" end select end subroutine copy3","tags":"","loc":"proc/copy3.html","title":"copy3 – FEST-3D"},{"text":"public subroutine populate_ghost_primitive(state, Ifaces, Jfaces, Kfaces, control, scheme, flow, bc, dims) Populate the state variables in the ghost cell\n with particular value based on the boundary conditio \n being applied at that face Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state state variables type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~populate_ghost_primitive~~CallsGraph proc~populate_ghost_primitive populate_ghost_primitive proc~subsonic_inlet subsonic_inlet proc~populate_ghost_primitive->proc~subsonic_inlet proc~wall wall proc~populate_ghost_primitive->proc~wall proc~total_pressure total_pressure proc~populate_ghost_primitive->proc~total_pressure proc~slip_wall slip_wall proc~populate_ghost_primitive->proc~slip_wall proc~supersonic_inlet supersonic_inlet proc~populate_ghost_primitive->proc~supersonic_inlet proc~supersonic_outlet supersonic_outlet proc~populate_ghost_primitive->proc~supersonic_outlet proc~subsonic_outlet subsonic_outlet proc~populate_ghost_primitive->proc~subsonic_outlet proc~pole pole proc~populate_ghost_primitive->proc~pole proc~far_field far_field proc~populate_ghost_primitive->proc~far_field proc~periodic_bc periodic_bc proc~populate_ghost_primitive->proc~periodic_bc proc~copy3 copy3 proc~subsonic_inlet->proc~copy3 proc~fix fix proc~subsonic_inlet->proc~fix proc~no_slip no_slip proc~wall->proc~no_slip proc~temp_based_density temp_based_density proc~wall->proc~temp_based_density proc~wall->proc~copy3 proc~total_pressure->proc~copy3 proc~total_pressure->proc~fix proc~flow_tangency flow_tangency proc~slip_wall->proc~flow_tangency proc~slip_wall->proc~copy3 proc~supersonic_inlet->proc~fix proc~supersonic_outlet->proc~copy3 proc~subsonic_outlet->proc~copy3 proc~subsonic_outlet->proc~fix proc~pole->proc~copy3 proc~far_field->proc~copy3 proc~far_field->proc~fix proc~no_slip->proc~copy3 proc~set_omega_at_wall set_omega_at_wall proc~no_slip->proc~set_omega_at_wall proc~temp_based_density->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~populate_ghost_primitive~~CalledByGraph proc~populate_ghost_primitive populate_ghost_primitive proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocpopulate_ghost_primitiveCalledByGraph = svgPanZoom('#procpopulate_ghost_primitiveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code populate_ghost_primitive Source Code subroutine populate_ghost_primitive ( state , Ifaces , Jfaces , Kfaces , control , scheme , flow , bc , dims ) !< Populate the state variables in the ghost cell !< with particular value based on the boundary conditio !< being applied at that face implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: state !< state variables type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( flowtype ), intent ( in ) :: flow type ( boundarytype ), intent ( in ) :: bc integer :: i character ( len = 4 ) :: face imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = dims % n_var current_iter = control % current_iter turbulence = trim ( scheme % turbulence ) transition = trim ( scheme % transition ) mu_ref = flow % mu_ref gm = flow % gm R_gas = flow % R_gas T_ref = flow % T_ref sutherland_temp = flow % sutherland_temp x_speed_inf = flow % x_speed_inf y_speed_inf = flow % y_speed_inf z_speed_inf = flow % z_speed_inf density_inf = flow % density_inf pressure_inf = flow % pressure_inf tk_inf = flow % tk_inf tw_inf = flow % tw_inf te_inf = flow % te_inf tv_inf = flow % tv_inf tgm_inf = flow % tgm_inf tkl_inf = flow % tkl_inf qp ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => state (:, :, :, :) density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, n_var ) !          tgm_inf => qp_inf(n_var) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select do i = 1 , 6 face_num = i face = bc % face_names ( face_num ) select case ( bc % id ( face_num )) case ( - 1 ) call supersonic_inlet ( face , bc ) case ( - 2 ) call supersonic_outlet ( face , bc , dims ) case ( - 3 ) call subsonic_inlet ( face , bc , dims ) case ( - 4 ) call subsonic_outlet ( face , bc , dims ) case ( - 5 ) call wall ( face , bc , dims ) case ( - 6 ) call slip_wall ( face , Ifaces , Jfaces , Kfaces , bc , dims ) case ( - 7 ) call pole ( face , bc , dims ) case ( - 8 ) call far_field ( face , Ifaces , Jfaces , Kfaces , bc , dims ) case ( - 9 ) call periodic_bc ( face ) case ( - 11 ) call total_pressure ( face , Ifaces , Jfaces , Kfaces , bc , dims ) case Default if ( bc % id ( i ) >= 0 . or . bc % id ( i ) ==- 10 ) then continue !interface boundary else print * , \" boundary condition not recognised -> id is :\" , bc % id ( i ) end if end select end do !        qp(0,0,:,:) = 0.5*(qp(0,1,:,:)+qp(1,0,:,:)) !        qp(0,jmx,:,:) = 0.5*(qp(0,jmx-1,:,:)+qp(1,jmx,:,:)) !        qp(imx,0,:,:) = 0.5*(qp(imx,1,:,:)+qp(imx-1,0,:,:)) !        qp(imx,jmx,:,:) = 0.5*(qp(imx,jmx-1,:,:)+qp(imx-1,jmx,:,:)) !        qp(0,:,0,:) = 0.5*(qp(0,:,1,:)+qp(1,:,0,:)) !        qp(0,:,kmx,:) = 0.5*(qp(0,:,kmx-1,:)+qp(1,:,kmx,:)) !        qp(imx,:,0,:) = 0.5*(qp(imx,:,1,:)+qp(imx-1,:,0,:)) !        qp(imx,:,kmx,:) = 0.5*(qp(imx,:,jmx-1,:)+qp(imx-1,:,jmx,:)) qp (:, 0 , 0 ,:) = 0.33 * ( qp (:, 1 , 1 ,:) + qp (:, 0 , 1 ,:) + qp (:, 1 , 0 ,:)) qp (:, 0 , kmx ,:) = 0.33 * ( qp (:, 1 , kmx - 1 ,:) + qp (:, 0 , kmx - 1 ,:) + qp (:, 1 , kmx ,:)) qp (:, jmx , 0 ,:) = 0.33 * ( qp (:, jmx - 1 , 1 ,:) + qp (:, jmx , 1 ,:) + qp (:, jmx - 1 , 0 ,:)) qp (:, jmx , kmx ,:) = 0.33 * ( qp (:, jmx - 1 , kmx - 1 ,:) + qp (:, jmx , kmx - 1 ,:) + qp (:, jmx - 1 , kmx ,:)) qp ( imx , 0 ,:,:) = 0.33 * ( qp ( imx - 1 , 1 ,:,:) + qp ( imx - 1 , 0 ,:,:) + qp ( imx , 1 ,:,:)) qp ( 0 , 0 ,:,:) = 0.33 * ( qp ( 1 , 1 ,:,:) + qp ( 1 , 0 ,:,:) + qp ( 0 , 1 ,:,:)) qp ( 0 , jmx ,:,:) = 0.33 * ( qp ( 1 , jmx - 1 ,:,:) + qp ( 1 , jmx ,:,:) + qp ( 0 , jmx - 1 ,:,:)) qp ( imx , jmx ,:,:) = 0.33 * ( qp ( imx - 1 , jmx - 1 ,:,:) + qp ( imx - 1 , jmx ,:,:) + qp ( imx , jmx - 1 ,:,:)) qp ( 0 , 0 , 0 ,:) = 0.33 * ( qp ( 1 , 0 , 0 ,:) + qp ( 0 , 1 , 0 ,:) + qp ( 0 , 0 , 1 ,:)) qp ( imx , 0 , 0 ,:) = 0.33 * ( qp ( imx - 1 , 0 , 0 ,:) + qp ( imx , 1 , 0 ,:) + qp ( imx , 0 , 1 ,:)) qp ( 0 , jmx , 0 ,:) = 0.33 * ( qp ( 1 , jmx , 0 ,:) + qp ( 0 , jmx - 1 , 0 ,:) + qp ( 0 , jmx , 1 ,:)) qp ( 0 , 0 , kmx ,:) = 0.33 * ( qp ( 1 , 0 , kmx ,:) + qp ( 0 , 1 , kmx ,:) + qp ( 0 , 0 , kmx - 1 ,:)) qp ( imx , jmx , 0 ,:) = 0.33 * ( qp ( imx - 1 , jmx , 0 ,:) + qp ( imx , jmx - 1 , 0 ,:) + qp ( imx , jmx , 1 ,:)) qp ( imx , 0 , kmx ,:) = 0.33 * ( qp ( imx - 1 , 0 , kmx ,:) + qp ( imx , 1 , kmx ,:) + qp ( imx , 0 , kmx - 1 ,:)) qp ( 0 , jmx , kmx ,:) = 0.33 * ( qp ( 1 , jmx , kmx ,:) + qp ( 0 , jmx - 1 , kmx ,:) + qp ( 0 , jmx , kmx - 1 ,:)) qp ( imx , jmx , kmx ,:) = 0.33 * ( qp ( imx - 1 , jmx , kmx ,:) + qp ( imx , jmx - 1 , kmx ,:) + qp ( imx , jmx , kmx - 1 ,:)) end subroutine populate_ghost_primitive","tags":"","loc":"proc/populate_ghost_primitive.html","title":"populate_ghost_primitive – FEST-3D"},{"text":"private subroutine supersonic_inlet(face, bc) Supersonic inlet boundary condition\n All the values of state variables are fixed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face type( boundarytype ), intent(in) :: bc Name of the face at which boundary condition is called Calls proc~~supersonic_inlet~~CallsGraph proc~supersonic_inlet supersonic_inlet proc~fix fix proc~supersonic_inlet->proc~fix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~supersonic_inlet~~CalledByGraph proc~supersonic_inlet supersonic_inlet proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~supersonic_inlet proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsupersonic_inletCalledByGraph = svgPanZoom('#procsupersonic_inletCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code supersonic_inlet Source Code subroutine supersonic_inlet ( face , bc ) !< Supersonic inlet boundary condition !< All the values of state variables are fixed implicit none character ( len =* ), intent ( in ) :: face type ( boundarytype ), intent ( in ) :: bc !< Name of the face at which boundary condition is called if ( current_iter <= 2 ) then call fix ( density , bc % fixed_density , face ) call fix ( x_speed , bc % fixed_x_speed , face ) call fix ( y_speed , bc % fixed_y_speed , face ) call fix ( z_speed , bc % fixed_z_speed , face ) call fix ( pressure , bc % fixed_pressure , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if end subroutine supersonic_inlet","tags":"","loc":"proc/supersonic_inlet.html","title":"supersonic_inlet – FEST-3D"},{"text":"private subroutine supersonic_outlet(face, bc, dims) Supersonic outlet boundary condition. \n All the values of state variables are copied \n from inside the domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~supersonic_outlet~~CallsGraph proc~supersonic_outlet supersonic_outlet proc~copy3 copy3 proc~supersonic_outlet->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~supersonic_outlet~~CalledByGraph proc~supersonic_outlet supersonic_outlet proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~supersonic_outlet proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsupersonic_outletCalledByGraph = svgPanZoom('#procsupersonic_outletCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code supersonic_outlet Source Code subroutine supersonic_outlet ( face , bc , dims ) !< Supersonic outlet boundary condition. !< All the values of state variables are copied !< from inside the domain implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face , bc , dims ) call copy3 ( x_speed , \"flat\" , face , bc , dims ) call copy3 ( y_speed , \"flat\" , face , bc , dims ) call copy3 ( z_speed , \"flat\" , face , bc , dims ) call copy3 ( pressure , \"flat\" , face , bc , dims ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select end subroutine supersonic_outlet","tags":"","loc":"proc/supersonic_outlet.html","title":"supersonic_outlet – FEST-3D"},{"text":"private subroutine subsonic_inlet(face, bc, dims) Subsonic inlet boundary condition. \n All the state variables's value expect pressure\n is fixed and pressure is copied from inside the \n domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~subsonic_inlet~~CallsGraph proc~subsonic_inlet subsonic_inlet proc~copy3 copy3 proc~subsonic_inlet->proc~copy3 proc~fix fix proc~subsonic_inlet->proc~fix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subsonic_inlet~~CalledByGraph proc~subsonic_inlet subsonic_inlet proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~subsonic_inlet proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsubsonic_inletCalledByGraph = svgPanZoom('#procsubsonic_inletCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code subsonic_inlet Source Code subroutine subsonic_inlet ( face , bc , dims ) !< Subsonic inlet boundary condition. !< All the state variables's value expect pressure !< is fixed and pressure is copied from inside the !< domain implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called if ( current_iter <= 2 ) then call fix ( density , bc % fixed_density , face ) call fix ( x_speed , bc % fixed_x_speed , face ) call fix ( y_speed , bc % fixed_y_speed , face ) call fix ( z_speed , bc % fixed_z_speed , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tw , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if call copy3 ( pressure , \"flat\" , face , bc , dims ) end subroutine subsonic_inlet","tags":"","loc":"proc/subsonic_inlet.html","title":"subsonic_inlet – FEST-3D"},{"text":"private subroutine subsonic_outlet(face, bc, dims) Subsonic outlet boundary condition. \n All the state variables's value expect pressure\n is copied from the inside of the domain and pressure \n is fixed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~subsonic_outlet~~CallsGraph proc~subsonic_outlet subsonic_outlet proc~copy3 copy3 proc~subsonic_outlet->proc~copy3 proc~fix fix proc~subsonic_outlet->proc~fix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subsonic_outlet~~CalledByGraph proc~subsonic_outlet subsonic_outlet proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~subsonic_outlet proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsubsonic_outletCalledByGraph = svgPanZoom('#procsubsonic_outletCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code subsonic_outlet Source Code subroutine subsonic_outlet ( face , bc , dims ) !< Subsonic outlet boundary condition. !< All the state variables's value expect pressure !< is copied from the inside of the domain and pressure !< is fixed implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face , bc , dims ) call copy3 ( x_speed , \"flat\" , face , bc , dims ) call copy3 ( y_speed , \"flat\" , face , bc , dims ) call copy3 ( z_speed , \"flat\" , face , bc , dims ) if ( current_iter <= 2 ) then call fix ( pressure , bc % fixed_pressure , face ) end if select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select end subroutine subsonic_outlet","tags":"","loc":"proc/subsonic_outlet.html","title":"subsonic_outlet – FEST-3D"},{"text":"private subroutine wall(face, bc, dims) Adiabatic/Isothermal wall boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face type( boundarytype ), intent(in) :: bc Name of the face at which boundary condition is called type( extent ), intent(in) :: dims Calls proc~~wall~~CallsGraph proc~wall wall proc~no_slip no_slip proc~wall->proc~no_slip proc~temp_based_density temp_based_density proc~wall->proc~temp_based_density proc~copy3 copy3 proc~wall->proc~copy3 proc~no_slip->proc~copy3 proc~set_omega_at_wall set_omega_at_wall proc~no_slip->proc~set_omega_at_wall proc~temp_based_density->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~wall~~CalledByGraph proc~wall wall proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocwallCalledByGraph = svgPanZoom('#procwallCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code wall Source Code subroutine wall ( face , bc , dims ) !< Adiabatic/Isothermal wall boundary condition implicit none type ( extent ), intent ( in ) :: dims character ( len =* ), intent ( in ) :: face type ( boundarytype ), intent ( in ) :: bc !< Name of the face at which boundary condition is called call copy3 ( pressure , \"symm\" , face , bc , dims ) call temp_based_density ( bc % fixed_wall_temperature , face , bc , dims ) call no_slip ( face , bc , dims ) end subroutine wall","tags":"","loc":"proc/wall.html","title":"wall – FEST-3D"},{"text":"private subroutine slip_wall(face, Ifaces, Jfaces, Kfaces, bc, dims) Slip wall boundary condition. \n Maintain flow tangency Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal\n Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~slip_wall~~CallsGraph proc~slip_wall slip_wall proc~copy3 copy3 proc~slip_wall->proc~copy3 proc~flow_tangency flow_tangency proc~slip_wall->proc~flow_tangency Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~slip_wall~~CalledByGraph proc~slip_wall slip_wall proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~slip_wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocslip_wallCalledByGraph = svgPanZoom('#procslip_wallCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code slip_wall Source Code subroutine slip_wall ( face , Ifaces , Jfaces , Kfaces , bc , dims ) !< Slip wall boundary condition. !< Maintain flow tangency implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal !< Name of the face at which boundary condition is called call copy3 ( density , \"symm\" , face , bc , dims ) call copy3 ( pressure , \"symm\" , face , bc , dims ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"symm\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"symm\" , face , bc , dims ) call copy3 ( tw , \"symm\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"symm\" , face , bc , dims ) call copy3 ( tkl , \"symm\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select call flow_tangency ( qp , face , Ifaces , Jfaces , Kfaces , dims ) end subroutine slip_wall","tags":"","loc":"proc/slip_wall.html","title":"slip_wall – FEST-3D"},{"text":"private subroutine pole(face, bc, dims) Boundary condition for the block face\n with zero area; turning into a pole Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~pole~~CallsGraph proc~pole pole proc~copy3 copy3 proc~pole->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pole~~CalledByGraph proc~pole pole proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~pole proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocpoleCalledByGraph = svgPanZoom('#procpoleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code pole Source Code subroutine pole ( face , bc , dims ) !< Boundary condition for the block face !< with zero area; turning into a pole implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face , bc , dims ) call copy3 ( x_speed , \"flat\" , face , bc , dims ) call copy3 ( y_speed , \"flat\" , face , bc , dims ) call copy3 ( z_speed , \"flat\" , face , bc , dims ) call copy3 ( pressure , \"flat\" , face , bc , dims ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select end subroutine pole","tags":"","loc":"proc/pole.html","title":"pole – FEST-3D"},{"text":"private subroutine fix(var, fix_val, face) Generalized subroutine to fix particular value\n at particular face Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2) :: var Variable of which values are being fixed in the ghost cell real(kind=wp), intent(in), dimension(1:6) :: fix_val Amount of value that need to be fixed. character(len=*), intent(in) :: face Name of the face at which boundary condition is called Called by proc~~fix~~CalledByGraph proc~fix fix proc~subsonic_outlet subsonic_outlet proc~subsonic_outlet->proc~fix proc~supersonic_inlet supersonic_inlet proc~supersonic_inlet->proc~fix proc~subsonic_inlet subsonic_inlet proc~subsonic_inlet->proc~fix proc~far_field far_field proc~far_field->proc~fix proc~total_pressure total_pressure proc~total_pressure->proc~fix proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~subsonic_outlet proc~populate_ghost_primitive->proc~supersonic_inlet proc~populate_ghost_primitive->proc~subsonic_inlet proc~populate_ghost_primitive->proc~far_field proc~populate_ghost_primitive->proc~total_pressure proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocfixCalledByGraph = svgPanZoom('#procfixCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fix Source Code subroutine fix ( var , fix_val , face ) !< Generalized subroutine to fix particular value !< at particular face implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) , intent ( out ) :: var !< Variable of which values are being fixed in the ghost cell real ( wp ), dimension ( 1 : 6 ) , intent ( in ) :: fix_val !< Amount of value that need to be fixed. character ( len =* ) , intent ( in ) :: face !< Name of the face at which boundary condition is called select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) var ( - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) var ( - 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) var ( imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) var ( imx + 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = fix_val ( 3 ) var ( 1 : imx - 1 , - 1 , 1 : kmx - 1 ) = fix_val ( 3 ) var ( 1 : imx - 1 , - 2 , 1 : kmx - 1 ) = fix_val ( 3 ) case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = fix_val ( 4 ) var ( 1 : imx - 1 , jmx + 1 , 1 : kmx - 1 ) = fix_val ( 4 ) var ( 1 : imx - 1 , jmx + 2 , 1 : kmx - 1 ) = fix_val ( 4 ) case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = fix_val ( 5 ) var ( 1 : imx - 1 , 1 : jmx - 1 , - 1 ) = fix_val ( 5 ) var ( 1 : imx - 1 , 1 : jmx - 1 , - 2 ) = fix_val ( 5 ) case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = fix_val ( 6 ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 1 ) = fix_val ( 6 ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 2 ) = fix_val ( 6 ) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine fix","tags":"","loc":"proc/fix.html","title":"fix – FEST-3D"},{"text":"private subroutine no_slip(face, bc, dims) No-slip wall boundary condition. All the \n component of velocity throught face is zero Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~no_slip~~CallsGraph proc~no_slip no_slip proc~set_omega_at_wall set_omega_at_wall proc~no_slip->proc~set_omega_at_wall proc~copy3 copy3 proc~no_slip->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~no_slip~~CalledByGraph proc~no_slip no_slip proc~wall wall proc~wall->proc~no_slip proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocno_slipCalledByGraph = svgPanZoom('#procno_slipCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code no_slip Source Code subroutine no_slip ( face , bc , dims ) !< No-slip wall boundary condition. All the !< component of velocity throught face is zero implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( x_speed , \"anti\" , face , bc , dims ) call copy3 ( y_speed , \"anti\" , face , bc , dims ) call copy3 ( z_speed , \"anti\" , face , bc , dims ) select case ( turbulence ) case ( \"none\" ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"anti\" , face , bc , dims ) case ( \"sst\" , 'sst2003' ) call copy3 ( tk , \"anti\" , face , bc , dims ) call set_omega_at_wall ( face ) case ( \"kkl\" ) call copy3 ( tk , \"anti\" , face , bc , dims ) call copy3 ( tkl , \"anti\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select end subroutine no_slip","tags":"","loc":"proc/no_slip.html","title":"no_slip – FEST-3D"},{"text":"private subroutine set_omega_at_wall(face) Set value of turbulence variable: omega (turbulenct dissipation rate). \n Value fixed is accourding to the SST turbulence model Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Called by proc~~set_omega_at_wall~~CalledByGraph proc~set_omega_at_wall set_omega_at_wall proc~no_slip no_slip proc~no_slip->proc~set_omega_at_wall proc~wall wall proc~wall->proc~no_slip proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocset_omega_at_wallCalledByGraph = svgPanZoom('#procset_omega_at_wallCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_omega_at_wall Source Code subroutine set_omega_at_wall ( face ) !< Set value of turbulence variable: omega (turbulenct dissipation rate). !< Value fixed is accourding to the SST turbulence model implicit none character ( len =* ), intent ( in ) :: face real ( wp ) :: T_face real ( wp ) :: mu real ( wp ) :: rho integer :: i , j , k , l select case ( face ) case ( \"imin\" ) do l = 1 , 3 do k = 1 , kmx - 1 do j = 1 , jmx - 1 T_face = 0.5 * (( pressure ( 0 , j , k ) / density ( 0 , j , k )) + ( pressure ( 1 , j , k ) / density ( 1 , j , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( 0 , j , k ) + density ( 1 , j , k )) tw ( 1 - l , j , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( 1 , j , k )) ** 2 ) - tw ( l , j , k ) end do end do end do case ( \"imax\" ) do l = 1 , 3 do k = 1 , kmx - 1 do j = 1 , jmx - 1 T_face = 0.5 * (( pressure ( imx - 1 , j , k ) / density ( imx - 1 , j , k )) + ( pressure ( imx , j , k ) / density ( imx , j , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( imx - 1 , j , k ) + density ( imx , j , k )) tw ( imx + l - 1 , j , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( imx - 1 , j , k )) ** 2 ) - tw ( imx - l , j , k ) end do end do end do case ( \"jmin\" ) do l = 1 , 3 do k = 1 , kmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , 0 , k ) / density ( i , 0 , k )) + ( pressure ( i , 1 , k ) / density ( i , 1 , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , 0 , k ) + density ( i , 1 , k )) tw ( i , 1 - l , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , 1 , k )) ** 2 ) - tw ( i , l , k ) end do end do end do case ( \"jmax\" ) do l = 1 , 3 do k = 1 , kmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , jmx - 1 , k ) / density ( i , jmx - 1 , k )) + ( pressure ( i , jmx , k ) / density ( i , jmx , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , jmx - 1 , k ) + density ( i , jmx , k )) tw ( i , jmx + l - 1 , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , jmx - 1 , k )) ** 2 ) - tw ( i , jmx - l , k ) end do end do end do case ( \"kmin\" ) do l = 1 , 3 do j = 1 , jmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , j , 0 ) / density ( i , j , 0 )) + ( pressure ( i , j , 1 ) / density ( i , j , 1 ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , j , 0 ) + density ( i , j , 1 )) tw ( i , j , 1 - l ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , j , 1 )) ** 2 ) - tw ( i , j , l ) end do end do end do case ( \"kmax\" ) do l = 1 , 3 do j = 1 , jmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , j , kmx - 1 ) / density ( i , j , kmx - 1 )) + ( pressure ( i , j , kmx ) / density ( i , j , kmx ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , j , kmx - 1 ) + density ( i , j , kmx )) tw ( i , j , kmx + l - 1 ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , j , kmx - 1 )) ** 2 ) - tw ( i , j , kmx - l ) end do end do end do end select end subroutine set_omega_at_wall","tags":"","loc":"proc/set_omega_at_wall.html","title":"set_omega_at_wall – FEST-3D"},{"text":"private subroutine far_field(face, Ifaces, Jfaces, Kfaces, bc, dims) Far-field Riemann boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~far_field~~CallsGraph proc~far_field far_field proc~copy3 copy3 proc~far_field->proc~copy3 proc~fix fix proc~far_field->proc~fix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~far_field~~CalledByGraph proc~far_field far_field proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~far_field proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocfar_fieldCalledByGraph = svgPanZoom('#procfar_fieldCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code far_field Source Code subroutine far_field ( face , Ifaces , Jfaces , Kfaces , bc , dims ) !< Far-field Riemann boundary condition implicit none type ( extent ), intent ( in ) :: dims character ( len =* ), intent ( in ) :: face type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal type ( boundarytype ), intent ( in ) :: bc real ( wp ) :: cinf , cexp ! speed of sound real ( wp ) :: Rinf , Rexp ! Riemann invarient real ( wp ) :: Uninf , Unexp ! face normal speed real ( wp ) :: Unb ! normal velocity boundary real ( wp ) :: Cb ! speed of sound boundary real ( wp ) :: vel_diff real ( wp ) :: u , v , w real ( wp ) :: uf , vf , wf integer :: i , j , k real ( wp ) :: s integer , dimension ( 6 ) :: face_already_has_fixed_values = 0 !0=.no. face_already_has_fixed_values = 0 select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i-1,j,k) vf = y_speed_inf !y_speed(i-1,j,k) wf = z_speed_inf !z_speed(i-1,j,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i-1,j,k)/density(i-1,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Ifaces ( i , j , k )% nx ) + v * ( - Ifaces ( i , j , k )% ny ) + w * ( - Ifaces ( i , j , k )% nz ) Uninf = uf * ( - Ifaces ( i , j , k )% nx ) + vf * ( - Ifaces ( i , j , k )% ny ) + wf * ( - Ifaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i - 1 , j , k ) = x_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% nx ) y_speed ( i - 1 , j , k ) = y_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% ny ) z_speed ( i - 1 , j , k ) = z_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% nz ) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i - 1 , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i - 1 , j , k ) = ( density ( i - 1 , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 1 ) = 0 else vel_diff = Unb - Uninf x_speed ( i - 1 , j , k ) = x_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% nx ) y_speed ( i - 1 , j , k ) = y_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% ny ) z_speed ( i - 1 , j , k ) = z_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i - 1 , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i - 1 , j , k ) = ( density ( i - 1 , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 1 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 1 ) = 1 end if end do end do end do qp ( - 1 ,:,:,:) = qp ( 0 ,:,:,:) qp ( - 2 ,:,:,:) = qp ( 0 ,:,:,:) case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx , imx ! interior cell u = x_speed ( i - 1 , j , k ) v = y_speed ( i - 1 , j , k ) w = z_speed ( i - 1 , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i - 1 , j , k ) / density ( i - 1 , j , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Ifaces ( i , j , k )% nx ) + v * ( Ifaces ( i , j , k )% ny ) + w * ( Ifaces ( i , j , k )% nz ) Uninf = uf * ( Ifaces ( i , j , k )% nx ) + vf * ( Ifaces ( i , j , k )% ny ) + wf * ( Ifaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% nz ) s = pressure ( i - 1 , j , k ) / ( density ( i - 1 , j , k ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 2 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Ifaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Ifaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Ifaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 2 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 2 ) = 1 end if end do end do end do qp ( imx + 1 ,:,:,:) = qp ( imx ,:,:,:) qp ( imx + 2 ,:,:,:) = qp ( imx ,:,:,:) case ( \"jmin\" ) do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j-1,k) vf = y_speed_inf !y_speed(i,j-1,k) wf = z_speed_inf !z_speed(i,j-1,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j-1,k)/density(i,j-1,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Jfaces ( i , j , k )% nx ) + v * ( - Jfaces ( i , j , k )% ny ) + w * ( - Jfaces ( i , j , k )% nz ) Uninf = uf * ( - Jfaces ( i , j , k )% nx ) + vf * ( - Jfaces ( i , j , k )% ny ) + wf * ( - Jfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j - 1 , k ) = x_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% nx ) y_speed ( i , j - 1 , k ) = y_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% ny ) z_speed ( i , j - 1 , k ) = z_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% nz ) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i , j - 1 , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j - 1 , k ) = ( density ( i , j - 1 , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 3 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j - 1 , k ) = x_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% nx ) y_speed ( i , j - 1 , k ) = y_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% ny ) z_speed ( i , j - 1 , k ) = z_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j - 1 , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j - 1 , k ) = ( density ( i , j - 1 , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 3 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 3 ) = 1 end if end do end do end do qp (:, - 1 ,:,:) = qp (:, 0 ,:,:) qp (:, - 2 ,:,:) = qp (:, 0 ,:,:) case ( \"jmax\" ) do k = 1 , kmx - 1 do j = jmx , jmx do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j - 1 , k ) v = y_speed ( i , j - 1 , k ) w = z_speed ( i , j - 1 , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j - 1 , k ) / density ( i , j - 1 , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Jfaces ( i , j , k )% nx ) + v * ( Jfaces ( i , j , k )% ny ) + w * ( Jfaces ( i , j , k )% nz ) Uninf = uf * ( Jfaces ( i , j , k )% nx ) + vf * ( Jfaces ( i , j , k )% ny ) + wf * ( Jfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% nz ) s = pressure ( i , j - 1 , k ) / ( density ( i , j - 1 , k ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 4 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Jfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Jfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Jfaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 4 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 4 ) = 1 end if end do end do end do qp (:, jmx + 1 ,:,:) = qp (:, jmx ,:,:) qp (:, jmx + 2 ,:,:) = qp (:, jmx ,:,:) case ( \"kmin\" ) do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k-1) vf = y_speed_inf !y_speed(i,j,k-1) wf = z_speed_inf !z_speed(i,j,k-1) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j,k-1)/density(i,j,k-1)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Kfaces ( i , j , k )% nx ) + v * ( - Kfaces ( i , j , k )% ny ) + w * ( - Kfaces ( i , j , k )% nz ) Uninf = uf * ( - Kfaces ( i , j , k )% nx ) + vf * ( - Kfaces ( i , j , k )% ny ) + wf * ( - Kfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k - 1 ) = x_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% nx ) y_speed ( i , j , k - 1 ) = y_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% ny ) z_speed ( i , j , k - 1 ) = z_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% nz ) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i , j , k - 1 ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k - 1 ) = ( density ( i , j , k - 1 ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 5 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k - 1 ) = x_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% nx ) y_speed ( i , j , k - 1 ) = y_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% ny ) z_speed ( i , j , k - 1 ) = z_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k - 1 ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k - 1 ) = ( density ( i , j , k - 1 ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 5 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 5 ) = 1 end if end do end do end do qp (:,:, - 1 ,:) = qp (:,:, 0 ,:) qp (:,:, - 2 ,:) = qp (:,:, 0 ,:) case ( \"kmax\" ) do k = kmx , kmx do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k - 1 ) v = y_speed ( i , j , k - 1 ) w = z_speed ( i , j , k - 1 ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j , k - 1 ) / density ( i , j , k - 1 )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Kfaces ( i , j , k )% nx ) + v * ( Kfaces ( i , j , k )% ny ) + w * ( Kfaces ( i , j , k )% nz ) Uninf = uf * ( Kfaces ( i , j , k )% nx ) + vf * ( Kfaces ( i , j , k )% ny ) + wf * ( Kfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% nz ) s = pressure ( i , j , k - 1 ) / ( density ( i , j , k - 1 ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select face_already_has_fixed_values ( 6 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Kfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Kfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Kfaces ( i , j , k )% nz ) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 6 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 6 ) = 1 end if end do end do end do qp (:,:, kmx + 1 ,:) = qp (:,:, kmx ,:) qp (:,:, kmx + 2 ,:) = qp (:,:, kmx ,:) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine far_field","tags":"","loc":"proc/far_field.html","title":"far_field – FEST-3D"},{"text":"private subroutine total_pressure(face, Ifaces, Jfaces, Kfaces, bc, dims) Total Pressure Riemann boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~total_pressure~~CallsGraph proc~total_pressure total_pressure proc~copy3 copy3 proc~total_pressure->proc~copy3 proc~fix fix proc~total_pressure->proc~fix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~total_pressure~~CalledByGraph proc~total_pressure total_pressure proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~total_pressure proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproctotal_pressureCalledByGraph = svgPanZoom('#proctotal_pressureCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code total_pressure Source Code subroutine total_pressure ( face , Ifaces , Jfaces , Kfaces , bc , dims ) !< Total Pressure Riemann boundary condition implicit none type ( extent ), intent ( in ) :: dims character ( len =* ), intent ( in ) :: face type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal type ( boundarytype ), intent ( in ) :: bc real ( wp ) :: cinf , cexp ! speed of sound real ( wp ) :: Rinf , Rexp ! Riemann invarient real ( wp ) :: Uninf , Unexp ! face normal speed real ( wp ) :: Unb ! normal velocity boundary real ( wp ) :: Cb ! speed of sound boundary real ( wp ) :: vel_diff real ( wp ) :: u , v , w real ( wp ) :: uf , vf , wf real ( wp ) :: Mb integer :: i , j , k select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i-1,j,k) vf = y_speed_inf !y_speed(i-1,j,k) wf = z_speed_inf !z_speed(i-1,j,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i-1,j,k)/density(i-1,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Ifaces ( i , j , k )% nx ) + v * ( - Ifaces ( i , j , k )% ny ) + w * ( - Ifaces ( i , j , k )% nz ) Uninf = uf * ( - Ifaces ( i , j , k )% nx ) + vf * ( - Ifaces ( i , j , k )% ny ) + wf * ( - Ifaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i - 1 , j , k ) = x_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% nx ) y_speed ( i - 1 , j , k ) = y_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% ny ) z_speed ( i - 1 , j , k ) = z_speed ( i , j , k ) + vel_diff * ( - Ifaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i - 1 , j , k ) = x_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% nx ) y_speed ( i - 1 , j , k ) = y_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% ny ) z_speed ( i - 1 , j , k ) = z_speed_inf + vel_diff * ( - Ifaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i - 1 , j , k ) ** 2 + y_speed ( i - 1 , j , k ) ** 2 + z_speed ( i - 1 , j , k ) ** 2 ) / Cb pressure ( i - 1 , j , k ) = bc % fixed_Tpressure ( 1 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i - 1 , j , k ) = gm * pressure ( i - 1 , j , k ) / ( Cb * Cb ) end do end do end do qp ( - 1 ,:,:,:) = qp ( 0 ,:,:,:) qp ( - 2 ,:,:,:) = qp ( 0 ,:,:,:) case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx , imx ! interior cell u = x_speed ( i - 1 , j , k ) v = y_speed ( i - 1 , j , k ) w = z_speed ( i - 1 , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i - 1 , j , k ) / density ( i - 1 , j , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Ifaces ( i , j , k )% nx ) + v * ( Ifaces ( i , j , k )% ny ) + w * ( Ifaces ( i , j , k )% nz ) Uninf = uf * ( Ifaces ( i , j , k )% nx ) + vf * ( Ifaces ( i , j , k )% ny ) + wf * ( Ifaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i - 1 , j , k ) + vel_diff * ( Ifaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Ifaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Ifaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Ifaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = bc % fixed_Tpressure ( 2 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp ( imx + 1 ,:,:,:) = qp ( imx ,:,:,:) qp ( imx + 2 ,:,:,:) = qp ( imx ,:,:,:) case ( \"jmin\" ) do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j-1,k) vf = y_speed_inf !y_speed(i,j-1,k) wf = z_speed_inf !z_speed(i,j-1,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j-1,k)/density(i,j-1,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Jfaces ( i , j , k )% nx ) + v * ( - Jfaces ( i , j , k )% ny ) + w * ( - Jfaces ( i , j , k )% nz ) Uninf = uf * ( - Jfaces ( i , j , k )% nx ) + vf * ( - Jfaces ( i , j , k )% ny ) + wf * ( - Jfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j - 1 , k ) = x_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% nx ) y_speed ( i , j - 1 , k ) = y_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% ny ) z_speed ( i , j - 1 , k ) = z_speed ( i , j , k ) + vel_diff * ( - Jfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j - 1 , k ) = x_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% nx ) y_speed ( i , j - 1 , k ) = y_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% ny ) z_speed ( i , j - 1 , k ) = z_speed_inf + vel_diff * ( - Jfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j - 1 , k ) ** 2 + y_speed ( i , j - 1 , k ) ** 2 + z_speed ( i , j - 1 , k ) ** 2 ) / Cb pressure ( i , j - 1 , k ) = bc % fixed_Tpressure ( 3 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j - 1 , k ) = gm * pressure ( i , j - 1 , k ) / ( Cb * Cb ) end do end do end do qp (:, - 1 ,:,:) = qp (:, 0 ,:,:) qp (:, - 2 ,:,:) = qp (:, 0 ,:,:) case ( \"jmax\" ) do k = 1 , kmx - 1 do j = jmx , jmx do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j - 1 , k ) v = y_speed ( i , j - 1 , k ) w = z_speed ( i , j - 1 , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j - 1 , k ) / density ( i , j - 1 , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Jfaces ( i , j , k )% nx ) + v * ( Jfaces ( i , j , k )% ny ) + w * ( Jfaces ( i , j , k )% nz ) Uninf = uf * ( Jfaces ( i , j , k )% nx ) + vf * ( Jfaces ( i , j , k )% ny ) + wf * ( Jfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i , j - 1 , k ) + vel_diff * ( Jfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Jfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Jfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Jfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = bc % fixed_Tpressure ( 4 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp (:, jmx + 1 ,:,:) = qp (:, jmx ,:,:) qp (:, jmx + 2 ,:,:) = qp (:, jmx ,:,:) case ( \"kmin\" ) do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k-1) vf = y_speed_inf !y_speed(i,j,k-1) wf = z_speed_inf !z_speed(i,j,k-1) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j,k-1)/density(i,j,k-1)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - Kfaces ( i , j , k )% nx ) + v * ( - Kfaces ( i , j , k )% ny ) + w * ( - Kfaces ( i , j , k )% nz ) Uninf = uf * ( - Kfaces ( i , j , k )% nx ) + vf * ( - Kfaces ( i , j , k )% ny ) + wf * ( - Kfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k - 1 ) = x_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% nx ) y_speed ( i , j , k - 1 ) = y_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% ny ) z_speed ( i , j , k - 1 ) = z_speed ( i , j , k ) + vel_diff * ( - Kfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k - 1 ) = x_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% nx ) y_speed ( i , j , k - 1 ) = y_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% ny ) z_speed ( i , j , k - 1 ) = z_speed_inf + vel_diff * ( - Kfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k - 1 ) = bc % fixed_Tpressure ( 5 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k - 1 ) = gm * pressure ( i , j , k - 1 ) / ( Cb * Cb ) end do end do end do qp (:,:, - 1 ,:) = qp (:,:, 0 ,:) qp (:,:, - 2 ,:) = qp (:,:, 0 ,:) case ( \"kmax\" ) do k = kmx , kmx do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k - 1 ) v = y_speed ( i , j , k - 1 ) w = z_speed ( i , j , k - 1 ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j , k - 1 ) / density ( i , j , k - 1 )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( Kfaces ( i , j , k )% nx ) + v * ( Kfaces ( i , j , k )% ny ) + w * ( Kfaces ( i , j , k )% nz ) Uninf = uf * ( Kfaces ( i , j , k )% nx ) + vf * ( Kfaces ( i , j , k )% ny ) + wf * ( Kfaces ( i , j , k )% nz ) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed ( i , j , k - 1 ) + vel_diff * ( Kfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face , bc , dims ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tw , \"flat\" , face , bc , dims ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face , bc , dims ) call copy3 ( tkl , \"flat\" , face , bc , dims ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face , bc , dims ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( Kfaces ( i , j , k )% nx ) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( Kfaces ( i , j , k )% ny ) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( Kfaces ( i , j , k )% nz ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , bc % fixed_tv , face ) case ( 'sst' , 'sst2003' ) !call check_if_value_fixed(bc, \"sst\") call fix ( tk , bc % fixed_tk , face ) call fix ( tw , bc % fixed_tw , face ) case ( 'kkl' ) !call check_if_value_fixed(bc, \"kkl\") call fix ( tk , bc % fixed_tk , face ) call fix ( tkl , bc % fixed_tkl , face ) case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) !call check_if_value_fixed(bc, \"lctm2015\") call fix ( tgm , bc % fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = bc % fixed_Tpressure ( 6 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp (:,:, kmx + 1 ,:) = qp (:,:, kmx ,:) qp (:,:, kmx + 2 ,:) = qp (:,:, kmx ,:) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine total_pressure","tags":"","loc":"proc/total_pressure.html","title":"total_pressure – FEST-3D"},{"text":"private subroutine temp_based_density(temperature, face, bc, dims) Specify the density in the ghost cell based on the\n temperature on the wall. Isothermal or adiabatic Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:6) :: temperature character(len=*), intent(in) :: face type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~temp_based_density~~CallsGraph proc~temp_based_density temp_based_density proc~copy3 copy3 proc~temp_based_density->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~temp_based_density~~CalledByGraph proc~temp_based_density temp_based_density proc~wall wall proc~wall->proc~temp_based_density proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproctemp_based_densityCalledByGraph = svgPanZoom('#proctemp_based_densityCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code temp_based_density Source Code subroutine temp_based_density ( temperature , face , bc , dims ) !< Specify the density in the ghost cell based on the !< temperature on the wall. Isothermal or adiabatic implicit none type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc real ( wp ), dimension ( 1 : 6 ) , intent ( in ) :: temperature character ( len =* ) , intent ( in ) :: face real ( wp ) :: stag_temp integer :: i , j , k select case ( face ) case ( \"imin\" ) if ( temperature ( 1 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i - 1 , j , k ) = pressure ( i - 1 , j , k ) / ( R_gas * stag_temp ) density ( i - 2 , j , k ) = pressure ( i - 2 , j , k ) / ( R_gas * stag_temp ) density ( i - 3 , j , k ) = pressure ( i - 3 , j , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 1 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 density ( i - 1 , j , k ) = pressure ( i - 1 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 0 , j , k ) / ( R_gas * density ( i + 0 , j , k ))))) density ( i - 2 , j , k ) = pressure ( i - 2 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 1 , j , k ) / ( R_gas * density ( i + 1 , j , k ))))) density ( i - 3 , j , k ) = pressure ( i - 3 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 2 , j , k ) / ( R_gas * density ( i + 2 , j , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case ( \"imax\" ) if ( temperature ( 2 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i + 1 , j , k ) = pressure ( i + 1 , j , k ) / ( R_gas * stag_temp ) density ( i + 2 , j , k ) = pressure ( i + 2 , j , k ) / ( R_gas * stag_temp ) density ( i + 3 , j , k ) = pressure ( i + 3 , j , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 2 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 density ( i + 1 , j , k ) = pressure ( i + 1 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 0 , j , k ) / ( R_gas * density ( i - 0 , j , k ))))) density ( i + 2 , j , k ) = pressure ( i + 2 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 1 , j , k ) / ( R_gas * density ( i - 1 , j , k ))))) density ( i + 3 , j , k ) = pressure ( i + 3 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 2 , j , k ) / ( R_gas * density ( i - 2 , j , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case ( \"jmin\" ) if ( temperature ( 3 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j - 1 , k ) = pressure ( i , j - 1 , k ) / ( R_gas * stag_temp ) density ( i , j - 2 , k ) = pressure ( i , j - 2 , k ) / ( R_gas * stag_temp ) density ( i , j - 3 , k ) = pressure ( i , j - 3 , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 3 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 density ( i , j - 1 , k ) = pressure ( i , j - 1 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 0 , k ) / ( R_gas * density ( i , j + 0 , k ))))) density ( i , j - 2 , k ) = pressure ( i , j - 2 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 1 , k ) / ( R_gas * density ( i , j + 1 , k ))))) density ( i , j - 3 , k ) = pressure ( i , j - 3 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 2 , k ) / ( R_gas * density ( i , j + 2 , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case ( \"jmax\" ) if ( temperature ( 4 ) < 0.0 ) then do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j + 1 , k ) = pressure ( i , j + 1 , k ) / ( R_gas * stag_temp ) density ( i , j + 2 , k ) = pressure ( i , j + 2 , k ) / ( R_gas * stag_temp ) density ( i , j + 3 , k ) = pressure ( i , j + 3 , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 4 ) > 1.0 ) then do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j + 1 , k ) = pressure ( i , j + 1 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 0 , k ) / ( R_gas * density ( i , j - 0 , k ))))) density ( i , j + 2 , k ) = pressure ( i , j + 2 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 1 , k ) / ( R_gas * density ( i , j - 1 , k ))))) density ( i , j + 3 , k ) = pressure ( i , j + 3 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 2 , k ) / ( R_gas * density ( i , j - 2 , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case ( \"kmin\" ) if ( temperature ( 5 ) < 0.0 ) then do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j , k - 1 ) = pressure ( i , j , k - 1 ) / ( R_gas * stag_temp ) density ( i , j , k - 2 ) = pressure ( i , j , k - 2 ) / ( R_gas * stag_temp ) density ( i , j , k - 3 ) = pressure ( i , j , k - 3 ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 5 ) > 1.0 ) then do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j , k - 1 ) = pressure ( i , j , k - 1 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 0 ) / ( R_gas * density ( i , j , k + 0 ))))) density ( i , j , k - 2 ) = pressure ( i , j , k - 2 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 1 ) / ( R_gas * density ( i , j , k + 1 ))))) density ( i , j , k - 3 ) = pressure ( i , j , k - 3 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 2 ) / ( R_gas * density ( i , j , k + 2 ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case ( \"kmax\" ) if ( temperature ( 6 ) < 0.0 ) then do k = kmx - 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j , k + 1 ) = pressure ( i , j , k + 1 ) / ( R_gas * stag_temp ) density ( i , j , k + 2 ) = pressure ( i , j , k + 2 ) / ( R_gas * stag_temp ) density ( i , j , k + 3 ) = pressure ( i , j , k + 3 ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 6 ) > 1.0 ) then do k = kmx - 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j , k + 1 ) = pressure ( i , j , k + 1 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 0 ) / ( R_gas * density ( i , j , k - 0 ))))) density ( i , j , k + 2 ) = pressure ( i , j , k + 2 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 1 ) / ( R_gas * density ( i , j , k - 1 ))))) density ( i , j , k + 3 ) = pressure ( i , j , k + 3 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 2 ) / ( R_gas * density ( i , j , k - 2 ))))) end do end do end do else call copy3 ( density , \"symm\" , face , bc , dims ) end if case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine temp_based_density","tags":"","loc":"proc/temp_based_density.html","title":"temp_based_density – FEST-3D"},{"text":"private subroutine periodic_bc(face) Single block periodic boundary condition.\n Not to be used for multiblock boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Called by proc~~periodic_bc~~CalledByGraph proc~periodic_bc periodic_bc proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~periodic_bc proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocperiodic_bcCalledByGraph = svgPanZoom('#procperiodic_bcCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code periodic_bc Source Code subroutine periodic_bc ( face ) !< Single block periodic boundary condition. !< Not to be used for multiblock boundary condition implicit none character ( len =* ), intent ( in ) :: face select case ( trim ( face )) case ( 'imin' ) qp ( - 2 : 0 ,:,:,:) = qp ( imx - 3 : imx - 1 ,:,:,:) case ( 'imax' ) qp ( imx : imx + 2 ,:,:,:) = qp ( 1 : 3 ,:,:,:) case ( 'jmin' ) qp (:, - 2 : 0 ,:,:) = qp (:, jmx - 3 : jmx - 1 ,:,:) case ( 'jmax' ) qp (:, jmx : jmx + 2 ,:,:) = qp (:, 1 : 3 ,:,:) case ( 'kmin' ) qp (:,:, - 2 : 0 ,:) = qp (:,:, kmx - 3 : kmx - 1 ,:) case ( 'kmax' ) qp (:,:, kmx : kmx + 2 ,:) = qp (:,:, 1 : 3 ,:) case Default Fatal_error end select end subroutine periodic_bc","tags":"","loc":"proc/periodic_bc.html","title":"periodic_bc – FEST-3D"},{"text":"public subroutine flow_tangency(qp, face, Ifaces, Jfaces, Kfaces, dims) Apply flow tangency boundary condition Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp character(len=*), intent(in) :: face Face over which flow tangency condition has to be applied type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Called by proc~~flow_tangency~~CalledByGraph proc~flow_tangency flow_tangency proc~slip_wall slip_wall proc~slip_wall->proc~flow_tangency proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~slip_wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocflow_tangencyCalledByGraph = svgPanZoom('#procflow_tangencyCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code flow_tangency Source Code subroutine flow_tangency ( qp , face , Ifaces , Jfaces , Kfaces , dims ) !< Apply flow tangency boundary condition implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ) :: qp character ( len =* ), intent ( in ) :: face !< Face over which flow tangency condition has to be applied type ( facetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 ), intent ( in ) :: Ifaces !< Input varaible which stores I faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 2 ), intent ( in ) :: Jfaces !< Input varaible which stores J faces' area and unit normal type ( facetype ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 3 ), intent ( in ) :: Kfaces !< Input varaible which stores K faces' area and unit normal real ( wp ) :: dot integer :: i integer :: j integer :: k integer :: l integer :: imx , jmx , kmx imx = dims % imx jmx = dims % jmx kmx = dims % kmx select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do l = 1 , 3 dot = qp ( l , j , k , 2 ) * Ifaces ( 1 , j , k )% nx + qp ( l , j , k , 3 ) * Ifaces ( 1 , j , k )% ny + qp ( l , j , k , 4 ) * Ifaces ( 1 , j , k )% nz qp ( - l + 1 , j , k , 2 ) = qp ( l , j , k , 2 ) - ( 2.0 * dot * Ifaces ( 1 , j , k )% nx ) qp ( - l + 1 , j , k , 3 ) = qp ( l , j , k , 3 ) - ( 2.0 * dot * Ifaces ( 1 , j , k )% ny ) qp ( - l + 1 , j , k , 4 ) = qp ( l , j , k , 4 ) - ( 2.0 * dot * Ifaces ( 1 , j , k )% nz ) end do end do end do case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do l = 1 , 3 dot = qp ( imx - l , j , k , 2 ) * Ifaces ( imx , j , k )% nx + qp ( imx - l , j , k , 3 ) * Ifaces ( imx , j , k )% ny + qp ( imx - l , j , k , 4 ) * Ifaces ( imx , j , k )% nz qp ( imx + l - 1 , j , k , 2 ) = qp ( imx - l , j , k , 2 ) - ( 2.0 * dot * Ifaces ( imx , j , k )% nx ) qp ( imx + l - 1 , j , k , 3 ) = qp ( imx - l , j , k , 3 ) - ( 2.0 * dot * Ifaces ( imx , j , k )% ny ) qp ( imx + l - 1 , j , k , 4 ) = qp ( imx - l , j , k , 4 ) - ( 2.0 * dot * Ifaces ( imx , j , k )% nz ) end do end do end do case ( \"jmin\" ) do k = 1 , kmx - 1 do i = 1 , imx - 1 do l = 1 , 3 dot = qp ( i , l , k , 2 ) * Jfaces ( i , 1 , k )% nx + qp ( i , l , k , 3 ) * Jfaces ( i , 1 , k )% ny + qp ( i , l , k , 4 ) * Jfaces ( i , 1 , k )% nz qp ( i , - l + 1 , k , 2 ) = qp ( i , l , k , 2 ) - ( 2.0 * dot * Ifaces ( i , 1 , k )% nx ) qp ( i , - l + 1 , k , 3 ) = qp ( i , l , k , 3 ) - ( 2.0 * dot * Ifaces ( i , 1 , k )% ny ) qp ( i , - l + 1 , k , 4 ) = qp ( i , l , k , 4 ) - ( 2.0 * dot * Ifaces ( i , 1 , k )% nz ) end do end do end do case ( \"jmax\" ) do k = 1 , kmx - 1 do i = 1 , imx - 1 do l = 1 , 3 dot = qp ( i , jmx - l , k , 2 ) * Jfaces ( i , jmx , k )% nx + qp ( i , jmx - l , k , 3 ) * Jfaces ( i , jmx , k )% ny + qp ( i , jmx - l , k , 4 ) * Jfaces ( i , jmx , k )% nz qp ( i , jmx + l - 1 , k , 2 ) = qp ( i , jmx - l , k , 2 ) - ( 2.0 * dot * Ifaces ( i , jmx , k )% nx ) qp ( i , jmx + l - 1 , k , 3 ) = qp ( i , jmx - l , k , 3 ) - ( 2.0 * dot * Ifaces ( i , jmx , k )% ny ) qp ( i , jmx + l - 1 , k , 4 ) = qp ( i , jmx - l , k , 4 ) - ( 2.0 * dot * Ifaces ( i , jmx , k )% nz ) end do end do end do case ( \"kmin\" ) do j = 1 , jmx - 1 do i = 1 , imx - 1 do l = 1 , 3 dot = qp ( i , j , l , 2 ) * Kfaces ( i , j , 1 )% nx + qp ( i , j , l , 3 ) * Kfaces ( i , j , 1 )% ny + qp ( i , j , l , 4 ) * Kfaces ( i , j , 1 )% nz qp ( i , j , - l + 1 , 2 ) = qp ( i , j , l , 2 ) - ( 2.0 * dot * Ifaces ( i , j , 1 )% nx ) qp ( i , j , - l + 1 , 3 ) = qp ( i , j , l , 3 ) - ( 2.0 * dot * Ifaces ( i , j , 1 )% ny ) qp ( i , j , - l + 1 , 4 ) = qp ( i , j , l , 4 ) - ( 2.0 * dot * Ifaces ( i , j , 1 )% nz ) end do end do end do case ( \"kmax\" ) do j = 1 , jmx - 1 do i = 1 , imx - 1 do l = 1 , 3 dot = qp ( i , j , kmx - l , 2 ) * Kfaces ( i , j , kmx )% nx + qp ( i , j , kmx - l , 3 ) * Kfaces ( i , j , kmx )% ny + qp ( i , j , kmx - l , 4 ) * Kfaces ( i , j , kmx )% nz qp ( i , j , kmx + l - 1 , 2 ) = qp ( i , j , kmx - l , 2 ) - ( 2.0 * dot * Ifaces ( i , j , kmx )% nx ) qp ( i , j , kmx + l - 1 , 3 ) = qp ( i , j , kmx - l , 3 ) - ( 2.0 * dot * Ifaces ( i , j , kmx )% ny ) qp ( i , j , kmx + l - 1 , 4 ) = qp ( i , j , kmx - l , 4 ) - ( 2.0 * dot * Ifaces ( i , j , kmx )% nz ) end do end do end do end select end subroutine flow_tangency","tags":"","loc":"proc/flow_tangency.html","title":"flow_tangency – FEST-3D"},{"text":"public subroutine read_fixed_values(files, scheme, flow, bc) Read fixed values for each block face Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow type( boundarytype ), intent(inout) :: bc Calls proc~~read_fixed_values~~CallsGraph proc~read_fixed_values read_fixed_values proc~fill_fixed_values fill_fixed_values proc~read_fixed_values->proc~fill_fixed_values proc~get_fixed_values get_fixed_values proc~read_fixed_values->proc~get_fixed_values proc~set_value set_value proc~fill_fixed_values->proc~set_value proc~get_fixed_values->proc~set_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_fixed_values~~CalledByGraph proc~read_fixed_values read_fixed_values proc~setup_bc setup_bc proc~setup_bc->proc~read_fixed_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_bc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_fixed_values Source Code subroutine read_fixed_values ( files , scheme , flow , bc ) !< Read fixed values for each block face implicit none type ( filetype ), intent ( in ) :: files type ( schemetype ), intent ( in ) :: scheme type ( flowtype ), intent ( in ) :: flow type ( boundarytype ), intent ( inout ) :: bc integer :: count = 0 call fill_fixed_values ( scheme , flow , bc ) open ( unit = files % BOUNDARY_CONDITIONS_FILE_UNIT , file = files % bcfile ) read ( files % BOUNDARY_CONDITIONS_FILE_UNIT , * ) read ( files % BOUNDARY_CONDITIONS_FILE_UNIT , * ) read ( files % BOUNDARY_CONDITIONS_FILE_UNIT , * ) do while ( count < 6 ) read ( files % BOUNDARY_CONDITIONS_FILE_UNIT , \"(A)\" ) buf if ( buf ( 1 : 1 ) == '#' ) then count = count + 1 call get_fixed_values ( files , scheme , flow , bc , count ) end if end do close ( files % BOUNDARY_CONDITIONS_FILE_UNIT ) end subroutine read_fixed_values","tags":"","loc":"proc/read_fixed_values.html","title":"read_fixed_values – FEST-3D"},{"text":"private subroutine get_fixed_values(files, scheme, flow, bc, count) Extract fixed value from the bc_**.md file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow type( boundarytype ), intent(inout) :: bc integer, intent(in) :: count Calls proc~~get_fixed_values~~CallsGraph proc~get_fixed_values get_fixed_values proc~set_value set_value proc~get_fixed_values->proc~set_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_fixed_values~~CalledByGraph proc~get_fixed_values get_fixed_values proc~read_fixed_values read_fixed_values proc~read_fixed_values->proc~get_fixed_values proc~setup_bc setup_bc proc~setup_bc->proc~read_fixed_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_bc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_fixed_values Source Code subroutine get_fixed_values ( files , scheme , flow , bc , count ) !< Extract fixed value from the bc_**.md file implicit none type ( filetype ), intent ( in ) :: files type ( schemetype ), intent ( in ) :: scheme type ( flowtype ), intent ( in ) :: flow type ( boundarytype ), intent ( inout ) :: bc integer , intent ( in ) :: count real ( wp ) :: fix_val integer :: ios do while (. true .) read ( files % BOUNDARY_CONDITIONS_FILE_UNIT , \"(A)\" ) buf if ( buf ( 1 : 2 ) == '- ' ) then read ( buf ( index ( buf ( 3 :), ' ' ) + 3 :), * , iostat = ios ) fix_val select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_DENSITY\" ) call set_value ( bc % fixed_density , fix_val , flow % density_inf , count , ios ) case ( \"FIX_X_SPEED\" ) call set_value ( bc % fixed_x_speed , fix_val , flow % x_speed_inf , count , ios ) case ( \"FIX_Y_SPEED\" ) call set_value ( bc % fixed_y_speed , fix_val , flow % y_speed_inf , count , ios ) case ( \"FIX_Z_SPEED\" ) call set_value ( bc % fixed_z_speed , fix_val , flow % z_speed_inf , count , ios ) case ( \"FIX_PRESSURE\" ) call set_value ( bc % fixed_pressure , fix_val , flow % pressure_inf , count , ios ) case ( \"WALL_TEMPERATURE\" ) call set_value ( bc % fixed_wall_temperature , fix_val , 0.0 , count , ios ) case ( \"TOTAL_TEMPERATURE\" ) call set_value ( bc % fixed_Ttemperature , fix_val , 0.0 , count , ios ) case ( \"TOTAL_PRESSURE\" ) call set_value ( bc % fixed_Tpressure , fix_val , 0.0 , count , ios ) end select select case ( scheme % turbulence ) case ( \"none\" ) !do nothing continue case ( \"sst\" , 'tw' , 'sst2003' ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tk\" ) call set_value ( bc % fixed_tk , fix_val , flow % tk_inf , count , ios ) case ( \"FIX_tw\" ) call set_value ( bc % fixed_tw , fix_val , flow % tw_inf , count , ios ) case DEFAULT ! no a value to fix continue end select case ( \"kkl\" ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tk\" ) call set_value ( bc % fixed_tk , fix_val , flow % tk_inf , count , ios ) case ( \"FIX_tkl\" ) call set_value ( bc % fixed_tkl , fix_val , flow % tkl_inf , count , ios ) case DEFAULT ! no a value to fix continue end select case ( \"sa\" , \"saBC\" ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tv\" ) call set_value ( bc % fixed_tk , fix_val , flow % tv_inf , count , ios ) case DEFAULT ! no a value to fix continue end select end select else exit end if end do end subroutine get_fixed_values","tags":"","loc":"proc/get_fixed_values.html","title":"get_fixed_values – FEST-3D"},{"text":"private subroutine fill_fixed_values(scheme, flow, bc) Fill the Fixed_var array with with free-stream value\n or default values. Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow type( boundarytype ), intent(inout) :: bc Calls proc~~fill_fixed_values~~CallsGraph proc~fill_fixed_values fill_fixed_values proc~set_value set_value proc~fill_fixed_values->proc~set_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fill_fixed_values~~CalledByGraph proc~fill_fixed_values fill_fixed_values proc~read_fixed_values read_fixed_values proc~read_fixed_values->proc~fill_fixed_values proc~setup_bc setup_bc proc~setup_bc->proc~read_fixed_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_bc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fill_fixed_values Source Code subroutine fill_fixed_values ( scheme , flow , bc ) !< Fill the Fixed_var array with with free-stream value !< or default values. implicit none type ( schemetype ), intent ( in ) :: scheme type ( flowtype ), intent ( in ) :: flow type ( boundarytype ), intent ( inout ) :: bc integer :: count integer :: ios =- 1 do count = 1 , 6 !case (\"FIX_DENSITY\") call set_value ( bc % fixed_density , flow % density_inf , flow % density_inf , count , ios ) !case (\"FIX_X_SPEED\") call set_value ( bc % fixed_x_speed , flow % x_speed_inf , flow % x_speed_inf , count , ios ) !case (\"FIX_Y_SPEED\") call set_value ( bc % fixed_y_speed , flow % y_speed_inf , flow % y_speed_inf , count , ios ) !case (\"FIX_Z_SPEED\") call set_value ( bc % fixed_z_speed , flow % z_speed_inf , flow % z_speed_inf , count , ios ) !case (\"FIX_PRESSURE\") call set_value ( bc % fixed_pressure , flow % pressure_inf , flow % pressure_inf , count , ios ) !case (\"WALL_TEMPERATURE\") call set_value ( bc % fixed_wall_temperature , 0.0 , 0.0 , count , ios ) !case (\"TOTAL_TEMPERATURE\") call set_value ( bc % fixed_Ttemperature , 0.0 , 0.0 , count , ios ) !case (\"TOTAL_PRESSURE\") call set_value ( bc % fixed_Tpressure , 0.0 , 0.0 , count , ios ) select case ( scheme % turbulence ) case ( \"none\" ) !do nothing continue case ( \"sst\" , 'tw' , 'sst2003' ) !case (\"FIX_tk\") call set_value ( bc % fixed_tk , flow % tk_inf , flow % tk_inf , count , ios ) !case (\"FIX_tw\") call set_value ( bc % fixed_tw , flow % tw_inf , flow % tw_inf , count , ios ) case ( \"kkl\" ) !case (\"FIX_tk\") call set_value ( bc % fixed_tk , flow % tk_inf , flow % tk_inf , count , ios ) !case (\"FIX_tkl\") call set_value ( bc % fixed_tkl , flow % tkl_inf , flow % tkl_inf , count , ios ) case ( \"sa\" , \"saBC\" ) !case (\"FIX_tv\") call set_value ( bc % fixed_tk , flow % tv_inf , flow % tv_inf , count , ios ) case DEFAULT Fatal_error end select end do end subroutine fill_fixed_values","tags":"","loc":"proc/fill_fixed_values.html","title":"fill_fixed_values – FEST-3D"},{"text":"private subroutine set_value(fixed_var, fix_val, inf_val, count, ios) Set particular value to the Fixed_var variable Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: fixed_var real(kind=wp), intent(in) :: fix_val real(kind=wp), intent(in) :: inf_val integer, intent(in) :: count integer, intent(in) :: ios Called by proc~~set_value~~CalledByGraph proc~set_value set_value proc~fill_fixed_values fill_fixed_values proc~fill_fixed_values->proc~set_value proc~get_fixed_values get_fixed_values proc~get_fixed_values->proc~set_value proc~read_fixed_values read_fixed_values proc~read_fixed_values->proc~fill_fixed_values proc~read_fixed_values->proc~get_fixed_values proc~setup_bc setup_bc proc~setup_bc->proc~read_fixed_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_bc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocset_valueCalledByGraph = svgPanZoom('#procset_valueCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_value Source Code subroutine set_value ( fixed_var , fix_val , inf_val , count , ios ) !< Set particular value to the Fixed_var variable implicit none integer , intent ( in ) :: ios integer , intent ( in ) :: count real ( wp ) , intent ( in ) :: fix_val real ( wp ) , intent ( in ) :: inf_val real ( wp ) , intent ( out ), dimension (:) :: fixed_var if ( ios == 0 ) then fixed_var ( count ) = fix_val else fixed_var ( count ) = inf_val end if end subroutine set_value","tags":"","loc":"proc/set_value.html","title":"set_value – FEST-3D"},{"text":"public subroutine reconstruct_boundary_state(qp, control, scheme, bc, dims) Call reconstruction based on the flag and boundary condition Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~reconstruct_boundary_state~~CallsGraph proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_jmin reconstruct_jmin proc~reconstruct_boundary_state->proc~reconstruct_jmin proc~reconstruct_imax reconstruct_imax proc~reconstruct_boundary_state->proc~reconstruct_imax proc~reconstruct_imin reconstruct_imin proc~reconstruct_boundary_state->proc~reconstruct_imin proc~reconstruct_jmax reconstruct_jmax proc~reconstruct_boundary_state->proc~reconstruct_jmax proc~reconstruct_kmin reconstruct_kmin proc~reconstruct_boundary_state->proc~reconstruct_kmin proc~reconstruct_kmax reconstruct_kmax proc~reconstruct_boundary_state->proc~reconstruct_kmax debugcall debugcall proc~reconstruct_boundary_state->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reconstruct_boundary_state~~CalledByGraph proc~reconstruct_boundary_state reconstruct_boundary_state proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_boundary_stateCalledByGraph = svgPanZoom('#procreconstruct_boundary_stateCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_boundary_state Source Code subroutine reconstruct_boundary_state ( qp , control , scheme , bc , dims ) !< Call reconstruction based on the flag and boundary condition implicit none type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc DebugCall ( 'recons_boundary_state' ) imx = dims % imx jmx = dims % jmx kmx = dims % kmx n_var = control % n_var if ( scheme % interpolant == 'ppm' . or . scheme % interpolant == 'weno' . or . scheme % interpolant == 'weno_NM' ) ppm_flag = 1 if ( bc % imin_id ==- 7 . or . bc % jmin_id ==- 7 . or . bc % kmin_id ==- 7 ) ppm_flag = 1 if ( bc % imax_id ==- 7 . or . bc % jmax_id ==- 7 . or . bc % kmax_id ==- 7 ) ppm_flag = 1 if ( scheme % interpolant /= 'none' ) then if ( bc % imin_id < 0 . and . bc % imin_id /=- 10 ) then DebugCall ( 'recons_bndry_state: imin' ) call reconstruct_imin ( qp , scheme , bc ) end if if ( bc % imax_id < 0 . and . bc % imax_id /=- 10 ) then DebugCall ( 'recons_bndry_state: imax' ) call reconstruct_imax ( qp , scheme , bc ) end if if ( bc % jmin_id < 0 . and . bc % jmin_id /=- 10 ) then DebugCall ( 'recons_bndry_state: jmin' ) call reconstruct_jmin ( qp , scheme , bc ) end if if ( bc % jmax_id < 0 . and . bc % jmax_id /=- 10 ) then DebugCall ( 'recons_bndry_state: jmax' ) call reconstruct_jmax ( qp , scheme , bc ) end if if ( bc % kmin_id < 0 . and . bc % kmin_id /=- 10 ) then DebugCall ( 'recons_bndry_state: kmin' ) call reconstruct_kmin ( qp , scheme , bc ) end if if ( bc % kmax_id < 0 . and . bc % kmax_id /=- 10 ) then DebugCall ( 'recons_bndry_state: kmax' ) call reconstruct_kmax ( qp , scheme , bc ) end if end if end subroutine reconstruct_boundary_state","tags":"","loc":"proc/reconstruct_boundary_state.html","title":"reconstruct_boundary_state – FEST-3D"},{"text":"private subroutine reconstruct_imin(qp, scheme, bc) Reconstruct state at the IMIN boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc Called by proc~~reconstruct_imin~~CalledByGraph proc~reconstruct_imin reconstruct_imin proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_imin proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_iminCalledByGraph = svgPanZoom('#procreconstruct_iminCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_imin Source Code subroutine reconstruct_imin ( qp , scheme , bc ) !< Reconstruct state at the IMIN boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc integer :: i , j , k , l real ( wp ) :: psi1 , psi2 , fd , bd , r real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % ilimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % itlimiter_switch do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! reconstruct first cell faces for ppm scheme fd = qp ( i + 1 , j , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - 1 , j , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right state of firsrt interior cell x_qp_left ( i + 1 , j , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) ! left face of first interior cell x_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end if if ( bc % imin_id ==- 8 . or . bc % imin_id ==- 9 ) then x_qp_left ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) x_qp_right ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) else ! right face of first ghost cell x_qp_left ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_imin","tags":"","loc":"proc/reconstruct_imin.html","title":"reconstruct_imin – FEST-3D"},{"text":"private subroutine reconstruct_imax(qp, scheme, bc) Reconstruct state at the IMAX boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc Called by proc~~reconstruct_imax~~CalledByGraph proc~reconstruct_imax reconstruct_imax proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_imax proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_imaxCalledByGraph = svgPanZoom('#procreconstruct_imaxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_imax Source Code subroutine reconstruct_imax ( qp , scheme , bc ) !< Reconstruct state at the IMAX boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc integer :: i , j , k , l real ( wp ) :: psi1 , psi2 , fd , bd , r real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % ilimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % itlimiter_switch do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 fd = qp ( i + 1 , j , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - 1 , j , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last interior cell x_qp_left ( i + 1 , j , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) ! left face of last interior cell x_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end if if ( bc % imax_id ==- 8 . or . bc % imax_id ==- 9 ) then x_qp_left ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) x_qp_right ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) else x_qp_right ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_imax","tags":"","loc":"proc/reconstruct_imax.html","title":"reconstruct_imax – FEST-3D"},{"text":"private subroutine reconstruct_jmin(qp, scheme, bc) Reconstruct state at the JMIN boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc Called by proc~~reconstruct_jmin~~CalledByGraph proc~reconstruct_jmin reconstruct_jmin proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_jmin proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_jminCalledByGraph = svgPanZoom('#procreconstruct_jminCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_jmin Source Code subroutine reconstruct_jmin ( qp , scheme , bc ) !< Reconstruct state at the JMIN boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc integer :: i , j , k , l real ( wp ) :: psi1 , psi2 , fd , bd , r real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % jlimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % jtlimiter_switch do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 fd = qp ( i , j + 1 , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j - 1 , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of first j cell y_qp_left ( i , j + 1 , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of first j cell y_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( bc % jmin_id ==- 8 . or . bc % jmin_id ==- 9 ) then y_qp_left ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var ) y_qp_right ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var ) else y_qp_left ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_jmin","tags":"","loc":"proc/reconstruct_jmin.html","title":"reconstruct_jmin – FEST-3D"},{"text":"private subroutine reconstruct_jmax(qp, scheme, bc) Reconstruct state at the JMAX boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc Called by proc~~reconstruct_jmax~~CalledByGraph proc~reconstruct_jmax reconstruct_jmax proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_jmax proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_jmaxCalledByGraph = svgPanZoom('#procreconstruct_jmaxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_jmax Source Code subroutine reconstruct_jmax ( qp , scheme , bc ) !< Reconstruct state at the JMAX boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc integer :: i , j , k , l real ( wp ) :: psi1 , psi2 , fd , bd , r real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % jlimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % jtlimiter_switch do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 fd = qp ( i , j + 1 , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j - 1 , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last j cell y_qp_left ( i , j + 1 , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of last j cell y_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( bc % jmax_id ==- 8 . or . bc % jmax_id ==- 9 ) then y_qp_left ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) y_qp_right ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) else y_qp_right ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_jmax","tags":"","loc":"proc/reconstruct_jmax.html","title":"reconstruct_jmax – FEST-3D"},{"text":"private subroutine reconstruct_kmin(qp, scheme, bc) Reconstruct state at the KMIN boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc Called by proc~~reconstruct_kmin~~CalledByGraph proc~reconstruct_kmin reconstruct_kmin proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_kmin proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_kminCalledByGraph = svgPanZoom('#procreconstruct_kminCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_kmin Source Code subroutine reconstruct_kmin ( qp , scheme , bc ) !< Reconstruct state at the KMIN boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc real ( wp ) :: psi1 , psi2 , fd , bd , r integer :: i , j , k , l real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % klimiter_switch if ( ppm_flag == 1 ) then do k = 1 , 1 do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % ktlimiter_switch if ( l < 6 ) switch_L = scheme % klimiter_switch do j = 1 , jmx - 1 do i = 1 , imx - 1 fd = qp ( i , j , k + 1 , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j , k - 1 , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of first k cell z_qp_left ( i , j , k + 1 , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of first k cell z_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( bc % kmin_id ==- 8 . or . bc % kmin_id ==- 9 ) then z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var ) z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var ) else z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var )) end if end subroutine reconstruct_kmin","tags":"","loc":"proc/reconstruct_kmin.html","title":"reconstruct_kmin – FEST-3D"},{"text":"private subroutine reconstruct_kmax(qp, scheme, bc) Reconstruct state at the KMAX boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc Called by proc~~reconstruct_kmax~~CalledByGraph proc~reconstruct_kmax reconstruct_kmax proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_kmax proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_kmaxCalledByGraph = svgPanZoom('#procreconstruct_kmaxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_kmax Source Code subroutine reconstruct_kmax ( qp , scheme , bc ) !< Reconstruct state at the KMAX boundary face with MUSCL scheme implicit none real ( wp ), dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) :: qp type ( schemetype ), intent ( in ) :: scheme type ( boundarytype ), intent ( in ) :: bc real ( wp ) :: psi1 , psi2 , fd , bd , r integer :: i , j , k , l real ( wp ) :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = scheme % klimiter_switch do k = kmx - 1 , kmx - 1 do l = 1 , n_var if ( l >= 6 ) switch_L = scheme % ktlimiter_switch if ( l < 6 ) switch_L = scheme % klimiter_switch do j = 1 , jmx - 1 do i = 1 , imx - 1 ! left face of kmx ghost cell z_qp_right ( i , j , k + 1 , l ) = 0.5 * ( qp ( i , j , k , l ) + qp ( i , j , k + 1 , l )) if ( ppm_flag == 1 ) then fd = qp ( i , j , k + 1 , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j , k - 1 , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last k interior cell z_qp_left ( i , j , k + 1 , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of last k cell z_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end if end do end do end do end do if ( bc % kmax_id ==- 8 . or . bc % kmax_id ==- 9 ) then z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) else z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var )) end if end subroutine reconstruct_kmax","tags":"","loc":"proc/reconstruct_kmax.html","title":"reconstruct_kmax – FEST-3D"},{"text":"public subroutine setup_wall_dist(files, dims) Allocate memory to the wall_distance variables\n and read the surface node file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( extent ), intent(in) :: dims Calls proc~~setup_wall_dist~~CallsGraph proc~setup_wall_dist setup_wall_dist debugcall debugcall proc~setup_wall_dist->debugcall interface~alloc alloc proc~setup_wall_dist->interface~alloc proc~read_destroy_nodefile read_destroy_nodefile proc~setup_wall_dist->proc~read_destroy_nodefile proc~setup_nodefile setup_nodefile proc~setup_wall_dist->proc~setup_nodefile proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_wall_dist~~CalledByGraph proc~setup_wall_dist setup_wall_dist proc~setup_solver setup_solver proc~setup_solver->proc~setup_wall_dist proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_wall_dist Source Code subroutine setup_wall_dist ( files , dims ) !< Allocate memory to the wall_distance variables !< and read the surface node file implicit none type ( filetype ), intent ( in ) :: files type ( extent ), intent ( in ) :: dims imx = dims % imx jmx = dims % jmx kmx = dims % kmx DebugCall ( 'setup_wall_dist' ) call setup_nodefile ( files ) call alloc ( wall_x , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( wall_y , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( wall_z , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( dist , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , & \"ERROR: unale to allocate memory to 'Dist' variable \" ) call read_destroy_nodefile ( files ) end subroutine setup_wall_dist","tags":"","loc":"proc/setup_wall_dist.html","title":"setup_wall_dist – FEST-3D"},{"text":"private subroutine setup_nodefile(files) Open and read first line of surface_node_point file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Called by proc~~setup_nodefile~~CalledByGraph proc~setup_nodefile setup_nodefile proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->proc~setup_nodefile proc~setup_solver setup_solver proc~setup_solver->proc~setup_wall_dist proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_nodefile Source Code subroutine setup_nodefile ( files ) !< Open and read first line of surface_node_point file implicit none type ( filetype ), intent ( in ) :: files integer :: ios open ( files % NODESURF_FILE_UNIT , file = files % surface_node_points , status = 'old' , IOSTAT = ios ) if ( ios /= 0 ) then print * , \"!!! -->file containg surface nodepoints not found\" Fatal_error end if read ( files % NODESURF_FILE_UNIT , * ) n_surfnodes end subroutine setup_nodefile","tags":"","loc":"proc/setup_nodefile.html","title":"setup_nodefile – FEST-3D"},{"text":"private subroutine read_destroy_nodefile(files) Read, and close surface_node_point file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Called by proc~~read_destroy_nodefile~~CalledByGraph proc~read_destroy_nodefile read_destroy_nodefile proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->proc~read_destroy_nodefile proc~setup_solver setup_solver proc~setup_solver->proc~setup_wall_dist proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_destroy_nodefile Source Code subroutine read_destroy_nodefile ( files ) !< Read, and close surface_node_point file implicit none type ( filetype ), intent ( in ) :: files integer :: i do i = 1 , n_surfnodes read ( files % NODESURF_FILE_UNIT , * ) wall_x ( i ), wall_y ( i ), wall_z ( i ) end do close ( files % NODESURF_FILE_UNIT ) end subroutine read_destroy_nodefile","tags":"","loc":"proc/read_destroy_nodefile.html","title":"read_destroy_nodefile – FEST-3D"},{"text":"public subroutine find_wall_dist(nodes, dims) Determine the minimum wall distance from the wall surface node points Arguments Type Intent Optional Attributes Name type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( extent ), intent(in) :: dims Calls proc~~find_wall_dist~~CallsGraph proc~find_wall_dist find_wall_dist interface~alloc alloc proc~find_wall_dist->interface~alloc debugcall debugcall proc~find_wall_dist->debugcall proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~find_wall_dist~~CalledByGraph proc~find_wall_dist find_wall_dist proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_wall_dist Source Code subroutine find_wall_dist ( nodes , dims ) !< Determine the minimum wall distance from the wall surface node points implicit none type ( extent ), intent ( in ) :: dims type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes integer :: i , j , k , n real ( wp ) :: current_dist real ( wp ), dimension (:,:,:), allocatable :: node_dist DebugCall ( 'find_wall_dist' ) call alloc ( node_dist , - 2 , imx + 3 , - 2 , jmx + 3 , - 2 , kmx + 3 ) do k = - 2 , dims % kmx + 3 do j = - 2 , dims % jmx + 3 do i = - 2 , dims % imx + 3 node_dist ( i , j , k ) = 1.e+20 do n = 1 , n_surfnodes current_dist = sqrt (( wall_x ( n ) - nodes ( i , j , k )% x ) ** 2 & + ( wall_y ( n ) - nodes ( i , j , k )% y ) ** 2 & + ( wall_z ( n ) - nodes ( i , j , k )% z ) ** 2 & ) node_dist ( i , j , k ) = min ( node_dist ( i , j , k ), current_dist ) end do end do end do end do do k =- 2 , dims % kmx + 2 do j =- 2 , dims % jmx + 2 do i =- 2 , dims % imx + 2 dist ( i , j , k ) = 0.125 * ( node_dist ( i , j , k )& + node_dist ( i , j + 1 , k )& + node_dist ( i , j + 1 , k + 1 )& + node_dist ( i , j , k + 1 )& + node_dist ( i + 1 , j , k + 1 )& + node_dist ( i + 1 , j , k )& + node_dist ( i + 1 , j + 1 , k )& + node_dist ( i + 1 , j + 1 , k + 1 )& ) end do end do end do deallocate ( node_dist ) DebugCall ( 'find_wall_dist-> complete' ) end subroutine find_wall_dist","tags":"","loc":"proc/find_wall_dist.html","title":"find_wall_dist – FEST-3D"},{"text":"public subroutine write_surfnode(files, nodes, control, bc, dims) Extract and write the wall surface node points\n in a file shared by all the MPI processes Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Calls proc~~write_surfnode~~CallsGraph proc~write_surfnode write_surfnode mpi_file_write_shared mpi_file_write_shared proc~write_surfnode->mpi_file_write_shared mpi_bcast mpi_bcast proc~write_surfnode->mpi_bcast mpi_type_commit mpi_type_commit proc~write_surfnode->mpi_type_commit mpi_barrier mpi_barrier proc~write_surfnode->mpi_barrier mpi_gather mpi_gather proc~write_surfnode->mpi_gather mpi_type_contiguous mpi_type_contiguous proc~write_surfnode->mpi_type_contiguous mpi_file_close mpi_file_close proc~write_surfnode->mpi_file_close proc~setup_surface setup_surface proc~write_surfnode->proc~setup_surface proc~surface_points surface_points proc~write_surfnode->proc~surface_points proc~setup_surface->mpi_barrier proc~allocate_memory~3 allocate_memory proc~setup_surface->proc~allocate_memory~3 debugcall debugcall proc~setup_surface->debugcall proc~find_wall find_wall proc~setup_surface->proc~find_wall mpi_file_open mpi_file_open proc~setup_surface->mpi_file_open proc~link_aliases link_aliases proc~setup_surface->proc~link_aliases proc~surface_points->debugcall proc~allocate_memory~3->debugcall interface~alloc alloc proc~allocate_memory~3->interface~alloc proc~link_aliases->debugcall proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_surfnode~~CalledByGraph proc~write_surfnode write_surfnode proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_surfnode Source Code subroutine write_surfnode ( files , nodes , control , bc , dims ) !< Extract and write the wall surface node points !< in a file shared by all the MPI processes implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( in ) :: control type ( extent ), intent ( in ) :: dims type ( boundarytype ), intent ( in ) :: bc type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes integer :: count integer :: i imx = dims % imx jmx = dims % jmx kmx = dims % kmx call setup_surface ( files , control , bc ) call surface_points ( nodes ) call MPI_GATHER ( n_wall , 1 , MPI_Integer , n_wall_buf , 1 , & MPI_integer , 0 , MPI_COMM_WORLD , ierr ) total_n_wall = sum ( n_wall_buf (:)) call MPI_Bcast ( total_n_wall , 1 , MPI_Integer , 0 , & MPI_COMM_WORLD , ierr ) call MPI_Bcast ( n_wall_buf , control % total_process , MPI_Integer , 0 , & MPI_COMM_WORLD , ierr ) write_flag = 0 count = 0 do i = 1 , control % total_process if ( n_wall_buf ( i ) > 0 ) then write_flag ( i ) = count count = count + 1 end if end do call MPI_TYPE_CONTIGUOUS ( maxlen , MPI_Character , new_type , ierr ) call MPI_TYPE_COMMIT ( new_type , ierr ) if ( process_id == 0 ) then write ( line , '(I0)' ) total_n_wall line ( len ( line ): len ( line )) = lf call MPI_FILE_WRITE_shared ( thisfile , line , 1 , & new_type , & MPI_STATUS_IGNORE , ierr ) end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) if ( n_wall > 0 ) then do i = 1 , n_wall write ( line , '(3(ES18.10E3,4x))' ) wall_x ( i ), wall_y ( i ), wall_z ( i ) line ( len ( line ): len ( line )) = lf call MPI_FILE_WRITE_shared ( thisfile , line , 1 , & new_type , & MPI_STATUS_IGNORE , ierr ) end do end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) call MPI_FILE_CLOSE ( thisfile , ierr ) end subroutine write_surfnode","tags":"","loc":"proc/write_surfnode.html","title":"write_surfnode – FEST-3D"},{"text":"private subroutine allocate_memory(control) Allocate memory to str and wallc variable array Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Calls proc~~allocate_memory~3~~CallsGraph proc~allocate_memory~3 allocate_memory interface~alloc alloc proc~allocate_memory~3->interface~alloc debugcall debugcall proc~allocate_memory~3->debugcall proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory~3~~CalledByGraph proc~allocate_memory~3 allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~3 proc~write_surfnode write_surfnode proc~write_surfnode->proc~setup_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory Source Code subroutine allocate_memory ( control ) !< Allocate memory to str and wallc variable array implicit none type ( controltype ), intent ( in ) :: control DebugCall ( 'setup_surface' ) n_wall = - 1 n_wall = (( jmx ) * ( kmx ) * ( NO_SLIP_flag ( 1 )) & + ( jmx ) * ( kmx ) * ( NO_SLIP_flag ( 2 )) & + ( kmx ) * ( imx ) * ( NO_SLIP_flag ( 3 )) & + ( kmx ) * ( imx ) * ( NO_SLIP_flag ( 4 )) & + ( imx ) * ( jmx ) * ( NO_SLIP_flag ( 5 )) & + ( imx ) * ( jmx ) * ( NO_SLIP_flag ( 6 )) & ) allocate ( str ( 1 : n_wall )) call alloc ( wallc , 1 , n_wall , 1 , 3 ,& errmsg = 'Error: Unable to allocate memory for wallc' ) allocate ( n_wall_buf ( 1 : control % total_process )) allocate ( write_flag ( 1 : control % total_process )) end subroutine allocate_memory","tags":"","loc":"proc/allocate_memory~3.html","title":"allocate_memory – FEST-3D"},{"text":"private subroutine link_aliases() Link pointers wall_x, wall_y, wall_z to wallc Arguments None Calls proc~~link_aliases~~CallsGraph proc~link_aliases link_aliases debugcall debugcall proc~link_aliases->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~link_aliases~~CalledByGraph proc~link_aliases link_aliases proc~setup_surface setup_surface proc~setup_surface->proc~link_aliases proc~write_surfnode write_surfnode proc~write_surfnode->proc~setup_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code link_aliases Source Code subroutine link_aliases () !< Link pointers wall_x, wall_y, wall_z to wallc implicit none DebugCall ( 'link_aliases' ) wall_x ( 1 : n_wall ) => wallc ( 1 : n_wall , 1 ) wall_y ( 1 : n_wall ) => wallc ( 1 : n_wall , 2 ) wall_z ( 1 : n_wall ) => wallc ( 1 : n_wall , 3 ) end subroutine link_aliases","tags":"","loc":"proc/link_aliases.html","title":"link_aliases – FEST-3D"},{"text":"private subroutine setup_surface(files, control, bc) Open MPI_shared write file, allocate memory and\n setup pointers Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(in) :: control type( boundarytype ), intent(in) :: bc Calls proc~~setup_surface~~CallsGraph proc~setup_surface setup_surface proc~find_wall find_wall proc~setup_surface->proc~find_wall proc~link_aliases link_aliases proc~setup_surface->proc~link_aliases proc~allocate_memory~3 allocate_memory proc~setup_surface->proc~allocate_memory~3 mpi_file_open mpi_file_open proc~setup_surface->mpi_file_open mpi_barrier mpi_barrier proc~setup_surface->mpi_barrier debugcall debugcall proc~setup_surface->debugcall proc~link_aliases->debugcall proc~allocate_memory~3->debugcall interface~alloc alloc proc~allocate_memory~3->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_surface~~CalledByGraph proc~setup_surface setup_surface proc~write_surfnode write_surfnode proc~write_surfnode->proc~setup_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_surface Source Code subroutine setup_surface ( files , control , bc ) !< Open MPI_shared write file, allocate memory and !< setup pointers implicit none type ( boundarytype ), intent ( in ) :: bc type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( in ) :: control integer :: stat DebugCall ( 'setup_surface' ) if ( process_id == 0 ) then open ( files % NODESURF_FILE_UNIT , file = files % surface_node_points , iostat = stat ) if ( stat == 0 ) close ( files % NODESURF_FILE_UNIT , status = 'delete' ) end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) call MPI_FILE_OPEN ( MPI_COMM_WORLD , files % surface_node_points , & MPI_MODE_WRONLY + MPI_MODE_CREATE + MPI_MODE_EXCL , & MPI_INFO_NULL , thisfile , ierr ) call find_wall ( bc ) call allocate_memory ( control ) call link_aliases () end subroutine setup_surface","tags":"","loc":"proc/setup_surface.html","title":"setup_surface – FEST-3D"},{"text":"private subroutine find_wall(bc) Setup wall flag for all six boundary of the block Arguments Type Intent Optional Attributes Name type( boundarytype ), intent(in) :: bc Called by proc~~find_wall~~CalledByGraph proc~find_wall find_wall proc~setup_surface setup_surface proc~setup_surface->proc~find_wall proc~write_surfnode write_surfnode proc~write_surfnode->proc~setup_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_wall Source Code subroutine find_wall ( bc ) !< Setup wall flag for all six boundary of the block implicit none type ( boundarytype ), intent ( in ) :: bc integer :: i NO_slip_flag = 0 do i = 1 , 6 if ( bc % id ( i ) ==- 5 ) NO_SLIP_FLAG ( i ) = 1 end do end subroutine find_wall","tags":"","loc":"proc/find_wall.html","title":"find_wall – FEST-3D"},{"text":"private subroutine surface_points(nodes) Extract surface points and store them\n in a string vector str(ind) Arguments Type Intent Optional Attributes Name type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Calls proc~~surface_points~~CallsGraph proc~surface_points surface_points debugcall debugcall proc~surface_points->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~surface_points~~CalledByGraph proc~surface_points surface_points proc~write_surfnode write_surfnode proc~write_surfnode->proc~surface_points proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code surface_points Source Code subroutine surface_points ( nodes ) !< Extract surface points and store them !< in a string vector str(ind) implicit none type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes integer :: OL integer :: i , j , k , ind integer :: im = 1 , ix = 1 integer :: jm = 1 , jx = 1 integer :: km = 1 , kx = 1 DebugCall ( 'surface_points' ) ind = 0 do OL = 1 , 6 if ( NO_SLIP_flag ( OL ) == 1 ) then select case ( OL ) case ( 1 ) km = 1 jm = 1 im = 1 kx = kmx jx = jmx ix = 1 case ( 2 ) km = 1 jm = 1 im = imx kx = kmx jx = jmx ix = imx case ( 3 ) km = 1 jm = 1 im = 1 kx = kmx jx = 1 ix = imx case ( 4 ) km = 1 jm = jmx im = 1 kx = kmx jx = jmx ix = imx case ( 5 ) km = 1 jm = 1 im = 1 kx = 1 jx = jmx ix = imx case ( 6 ) km = kmx jm = 1 im = 1 kx = kmx jx = jmx ix = imx case DEFAULT Fatal_error km = 1 jm = 1 im = 1 kx = - 1 jx = - 1 ix = - 1 end select do k = km , kx do j = jm , jx do i = im , ix ind = ind + 1 wall_x ( ind ) = nodes ( i , j , k )% x wall_y ( ind ) = nodes ( i , j , k )% y wall_z ( ind ) = nodes ( i , j , k )% z write ( str ( ind ), '(3(f0.16, 4x))' ) wall_x ( ind ), wall_y ( ind ), wall_z ( ind ) end do end do end do end if end do end subroutine surface_points","tags":"","loc":"proc/surface_points.html","title":"surface_points – FEST-3D"},{"text":"private function lcase(text) result(res) Make the whole string to lower case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Input string of any case Return Value character(len=STRING_BUFFER_LENGTH) Output string of lower case Called by proc~~lcase~~CalledByGraph proc~lcase lcase proc~verify_write_control verify_write_control proc~verify_write_control->proc~lcase proc~verify_read_control verify_read_control proc~verify_read_control->proc~lcase proc~initstate initstate proc~initstate->proc~verify_write_control proc~read_file~3 read_file proc~initstate->proc~read_file~3 proc~read_file~3->proc~verify_read_control proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panproclcaseCalledByGraph = svgPanZoom('#proclcaseCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code lcase Source Code function lcase ( text ) result ( res ) !< Make the whole string to lower case CHARACTER ( len =* ), intent ( in ) :: text !< Input string of any case character ( len = STRING_BUFFER_LENGTH ) :: res !< Output string of lower case integer :: I , C res = text DO I = 1 , LEN ( TEXT ) C = INDEX ( \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , TEXT ( I : I )) IF ( C . GT . 0 ) res ( I : I ) = \"abcdefghijklmnopqrstuvwxyz\" ( C : C ) END DO end function lcase","tags":"","loc":"proc/lcase.html","title":"lcase – FEST-3D"},{"text":"public subroutine verify_write_control(control, scheme, flow) Verify all the variable being asked to write in the output file. \n This is a fail-safe subroutine which do not allow to write the incorrect input variable Arguments Type Intent Optional Attributes Name type( controltype ), intent(inout) :: control type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow Calls proc~~verify_write_control~~CallsGraph proc~verify_write_control verify_write_control proc~lcase lcase proc~verify_write_control->proc~lcase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~verify_write_control~~CalledByGraph proc~verify_write_control verify_write_control proc~initstate initstate proc~initstate->proc~verify_write_control proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code verify_write_control Source Code subroutine verify_write_control ( control , scheme , flow ) !< Verify all the variable being asked to write in the output file. !< This is a fail-safe subroutine which do not allow to write the incorrect input variable implicit none type ( controltype ), intent ( inout ) :: control type ( schemetype ) , intent ( in ) :: scheme type ( flowtype ) , intent ( in ) :: flow integer :: n character ( len =* ), parameter :: err = \"Control Error: can't write variable - \" do n = 1 , control % w_count select case ( trim ( lcase ( control % w_list ( n )))) case ( 'velocity' , 'vel' , 'speed' , 'u' , 'v' ) control % w_list ( n ) = \"Velocity\" case ( 'density' , 'rho' ) control % w_list ( n ) = \"Density\" case ( 'pressure' , 'presssure' , 'p' ) control % w_list ( n ) = \"Pressure\" case ( 'mu' , 'viscosity' , 'mu_l' , 'laminar_viscosity' , 'muv' , 'mu_v' ) if ( flow % mu_ref /= 0.0 ) then control % w_list ( n ) = \"Mu\" else print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end if case ( 'mu_t' , 'turbulent_viscosity' , 'mut' ) if ( scheme % turbulence /= 'none' ) then control % w_list ( n ) = \"Mu_t\" else print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end if case ( 'tke' , 'tk' , 'turbulent_kinetic_enrgy' , 'k' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) control % w_list ( n ) = \"TKE\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'omega' , 'tw' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) control % w_list ( n ) = \"Omega\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dissipation' , 'te' , 'teps' , 'eps' ) select case ( trim ( scheme % turbulence )) case ( 'ke' ) control % w_list ( n ) = \"Dissipation\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'kl' ) select case ( trim ( scheme % turbulence )) case ( 'kkl' ) control % w_list ( n ) = \"Kl\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'tv' ) select case ( trim ( scheme % turbulence )) case ( 'sa' , 'saBC' ) control % w_list ( n ) = \"tv\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'wall_distance' , 'dist' , 'wall_dist' , 'wdist' ) if ( scheme % turbulence /= \"none\" ) then control % w_list ( n ) = \"Wall_distance\" else print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end if case ( 'resnorm' ) control % w_list ( n ) = \"Resnorm\" case ( 'tke_residue' ) control % w_list ( n ) = \"TKE_residue\" case ( 'omega_residue' ) control % w_list ( n ) = \"Omega_residue\" case ( 'tv_residue' ) control % w_list ( n ) = \"Tv_residue\" case ( 'mass_residue' ) control % w_list ( n ) = \"Mass_residue\" case ( 'x_mom_residue' ) control % w_list ( n ) = \"X_mom_residue\" case ( 'y_mom_residue' ) control % w_list ( n ) = \"Y_mom_residue\" case ( 'z_mom_residue' ) control % w_list ( n ) = \"Z_mom_residue\" case ( 'energy_residue' ) control % w_list ( n ) = \"Energy_residue\" case ( 'f1' ) if ( trim ( scheme % turbulence ) == 'sst' . or . trim ( scheme % turbulence ) == 'sst2003' ) then control % w_list ( n ) = \"F1\" else control % w_list ( n ) = 'do not write' end if case ( 'dudx' ) control % w_list ( n ) = \"Dudx\" case ( 'dudy' ) control % w_list ( n ) = \"Dudy\" case ( 'dudz' ) control % w_list ( n ) = \"Dudz\" case ( 'dvdx' ) control % w_list ( n ) = \"Dvdx\" case ( 'dvdy' ) control % w_list ( n ) = \"Dvdy\" case ( 'dvdz' ) control % w_list ( n ) = \"Dvdz\" case ( 'dwdx' ) control % w_list ( n ) = \"Dwdx\" case ( 'dwdy' ) control % w_list ( n ) = \"Dwdy\" case ( 'dwdz' ) control % w_list ( n ) = \"Dwdz\" case ( 'dTdx' ) control % w_list ( n ) = \"DTdx\" case ( 'dTdy' ) control % w_list ( n ) = \"DTdy\" case ( 'dTdz' ) control % w_list ( n ) = \"DTdz\" case ( 'dtkdx' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) control % w_list ( n ) = \"Dtkdx\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtkdy' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) control % w_list ( n ) = \"Dtkdy\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtkdz' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) control % w_list ( n ) = \"Dtkdz\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtwdx' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) control % w_list ( n ) = \"Dtwdx\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtwdy' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) control % w_list ( n ) = \"Dtwdy\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtwdz' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) control % w_list ( n ) = \"Dtwdz\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtedx' ) select case ( trim ( scheme % turbulence )) case ( 'ke' ) control % w_list ( n ) = \"Dtedx\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtedy' ) select case ( trim ( scheme % turbulence )) case ( 'ke' ) control % w_list ( n ) = \"Dtedy\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtedz' ) select case ( trim ( scheme % turbulence )) case ( 'ke' ) control % w_list ( n ) = \"Dtedz\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtkldx' ) select case ( trim ( scheme % turbulence )) case ( 'kkl' ) control % w_list ( n ) = \"Dtkldx\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtkldy' ) select case ( trim ( scheme % turbulence )) case ( 'kkl' ) control % w_list ( n ) = \"Dtkldy\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtkldz' ) select case ( trim ( scheme % turbulence )) case ( 'kkl' ) control % w_list ( n ) = \"Dtkldz\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtvdx' ) select case ( trim ( scheme % turbulence )) case ( 'sa' , 'saBC' ) control % w_list ( n ) = \"Dtvdx\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtvdy' ) select case ( trim ( scheme % turbulence )) case ( 'sa' , 'saBC' ) control % w_list ( n ) = \"Dtvdy\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'dtvdz' ) select case ( trim ( scheme % turbulence )) case ( 'sa' , 'saBC' ) control % w_list ( n ) = \"Dtvdz\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'intermittency' ) select case ( trim ( scheme % turbulence )) case ( 'saBC' ) control % w_list ( n ) = \"Intermittency\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'tgm' ) select case ( trim ( scheme % transition )) case ( 'lctm2015' ) control % w_list ( n ) = \"tgm\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select case ( 'extravar1' , 'extravar2' , 'extravar3' , 'extravar4' , 'extravar5' ) control % w_list ( n ) = trim ( lcase ( control % w_list ( n ))) case Default print * , err // trim ( control % w_list ( n )) // \" to file\" control % w_list ( n ) = \"do not write\" end select end do end subroutine verify_write_control","tags":"","loc":"proc/verify_write_control.html","title":"verify_write_control – FEST-3D"},{"text":"public subroutine verify_read_control(control, scheme) Verify all the variable being asked to read in the output file. \n This is a fail-safe subroutine which do not allow to read the incorrect input variable. \n Based on previous flow type some varible might be skipped Arguments Type Intent Optional Attributes Name type( controltype ), intent(inout) :: control type( schemetype ), intent(in) :: scheme Calls proc~~verify_read_control~~CallsGraph proc~verify_read_control verify_read_control proc~lcase lcase proc~verify_read_control->proc~lcase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~verify_read_control~~CalledByGraph proc~verify_read_control verify_read_control proc~read_file~3 read_file proc~read_file~3->proc~verify_read_control proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocverify_read_controlCalledByGraph = svgPanZoom('#procverify_read_controlCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code verify_read_control Source Code subroutine verify_read_control ( control , scheme ) !< Verify all the variable being asked to read in the output file. !< This is a fail-safe subroutine which do not allow to read the incorrect input variable. !< Based on previous flow type some varible might be skipped implicit none type ( controltype ), intent ( inout ) :: control type ( schemetype ) , intent ( in ) :: scheme integer :: n character ( len =* ), parameter :: err = \"Control Error: can't read variable - \" do n = 1 , control % r_count select case ( trim ( lcase ( control % r_list ( n )))) case ( 'velocity' , 'vel' , 'speed' , 'u' , 'v' ) control % r_list ( n ) = \"Velocity\" case ( 'density' , 'rho' ) control % r_list ( n ) = \"Density\" case ( 'pressure' , 'presssure' , 'p' ) control % r_list ( n ) = \"Pressure\" case ( 'mu' , 'viscosity' , 'mu_l' , 'laminar_viscosity' , 'muv' , 'mu_v' ) control % r_list ( n ) = \"do not read\" ! if (flow%mu_ref/=0.0) then !   control%r_list(n) = \"Mu\" ! else !   print*, err//trim(control%r_list(n))//\" from file\" !   control%r_list(n) = \"do not read\" ! end if case ( 'mu_t' , 'turbulent_viscosity' , 'mut' ) control % r_list ( n ) = \"do not read\" !if (scheme%turbulence/='none') then !  control%r_list(n) = \"Mu_t\" !else !  print*, err//trim(control%r_list(n))//\" from file\" !  control%r_list(n) = \"do not read\" !end if case ( 'tke' , 'tk' , 'turbulent_kinetic_enrgy' , 'k' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) select case ( trim ( control % previous_flow_type )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) control % r_list ( n ) = \"TKE\" end select case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case ( 'omega' , 'tw' ) select case ( trim ( scheme % turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) select case ( trim ( control % previous_flow_type )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) control % r_list ( n ) = \"Omega\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case ( 'dissipation' , 'te' , 'teps' , 'eps' ) select case ( trim ( scheme % turbulence )) case ( 'ke' ) select case ( trim ( control % previous_flow_type )) case ( 'ke' ) control % r_list ( n ) = \"Dissipation\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case ( 'kl' ) select case ( trim ( scheme % turbulence )) case ( 'kkl' ) select case ( trim ( control % previous_flow_type )) case ( 'kkl' ) control % r_list ( n ) = \"Kl\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case ( 'tv' ) select case ( trim ( scheme % turbulence )) case ( 'sa' , 'saBC' ) select case ( trim ( control % previous_flow_type )) case ( 'sa' , 'saBC' ) control % r_list ( n ) = \"tv\" case DEFAULT print * , err // trim ( control % w_list ( n )) // \" to file\" control % r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( control % w_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select case ( 'wall_distance' , 'dist' , 'wall_dist' , 'wdist' ) control % r_list ( n ) = \"do not read\" !if(scheme%turbulence/=\"none\") then !  control%r_list(n) = \"Wall_distance\" !else !  print*, err//trim(control%r_list(n))//\" from file\" !  control%r_list(n) = \"do not read\" !end if case ( 'intermittency' ) select case ( trim ( scheme % turbulence )) case ( 'saBC' ) select case ( trim ( control % previous_flow_type )) case ( 'saBC' ) control % r_list ( n ) = \"Intermittency\" case DEFAULT print * , err // trim ( control % r_list ( n )) // \" to file\" control % r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( control % r_list ( n )) // \" to file\" control % r_list ( n ) = \"do not read\" end select case ( 'tgm' ) select case ( trim ( scheme % transition )) case ( 'lctm2015' ) select case ( trim ( control % previous_flow_type )) case ( 'sst' , 'sst2003' ) control % r_list ( n ) = \"tgm\" case DEFAULT print * , err // trim ( control % r_list ( n )) // \" to file\" control % r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( control % r_list ( n )) // \" to file\" control % r_list ( n ) = \"do not read\" end select case ( 'resnorm' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Resnorm\" case ( 'tke_residue' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"TKE_residue\" case ( 'omega_residue' ) control % r_list ( n ) = \"do not read\" !control%w_list(n) = \"Omega_residue\" case ( 'f1' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"F1\" case ( 'dudx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dudx\" case ( 'dudy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dudy\" case ( 'dudz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dudz\" case ( 'dvdx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dvdx\" case ( 'dvdy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dvdy\" case ( 'dvdz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dvdz\" case ( 'dwdx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dwdx\" case ( 'dwdy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dwdy\" case ( 'dwdz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dwdz\" case ( 'dTdx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"DTdx\" case ( 'dTdy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"DTdy\" case ( 'dTdz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"DTdz\" case ( 'dtkdx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtkdx\" case ( 'dtkdy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtkdy\" case ( 'dtkdz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtkdz\" case ( 'dtwdx' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtwdx\" case ( 'dtwdy' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtwdy\" case ( 'dtwdz' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = \"Dtwdz\" case ( 'extravar1' , 'extravar2' , 'extravar3' , 'extravar4' , 'extravar5' ) control % r_list ( n ) = \"do not read\" !control%r_list(n) = trim(lcase(control%w_list(n))) case Default print * , err // trim ( control % r_list ( n )) // \" from file\" control % r_list ( n ) = \"do not read\" end select end do end subroutine verify_read_control","tags":"","loc":"proc/verify_read_control.html","title":"verify_read_control – FEST-3D"},{"text":"public subroutine write_file(file_handler, state, nodes, control, scheme, dims) Write output file in the tecplot format with node data Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims Calls proc~~write_file~~CallsGraph proc~write_file write_file debugcall debugcall proc~write_file->debugcall proc~write_scalar write_scalar proc~write_file->proc~write_scalar proc~write_header write_header proc~write_file->proc~write_header proc~write_grid write_grid proc~write_file->proc~write_grid proc~write_scalar->debugcall proc~write_header->debugcall proc~write_grid->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_file Source Code subroutine write_file ( file_handler , state , nodes , control , scheme , dims ) !< Write output file in the tecplot format with node data implicit none integer , intent ( in ) :: file_handler type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: state integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" DebugCall ( \"write_file\" ) OUT_FILE_UNIT = file_handler imx = dims % imx jmx = dims % jmx kmx = dims % kmx density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 8 ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call write_header ( control ) call write_grid ( nodes ) do n = 1 , control % w_count select case ( trim ( control % w_list ( n ))) case ( 'Velocity' ) call write_scalar ( x_speed , \"u\" , - 2 ) call write_scalar ( y_speed , \"v\" , - 2 ) call write_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) ! case('Wall_distance') !   call write_scalar(dist, \"Wall_dist\", 1) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'do not write' ) ! do not write continue case Default print * , err // trim ( control % w_list ( n )) // \" to file\" end select end do end subroutine write_file","tags":"","loc":"proc/write_file.html","title":"write_file – FEST-3D"},{"text":"private subroutine write_header(control) Write the header in the output file Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Calls proc~~write_header~~CallsGraph proc~write_header write_header debugcall debugcall proc~write_header->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_header~~CalledByGraph proc~write_header write_header proc~write_file write_file proc~write_file->proc~write_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_header Source Code subroutine write_header ( control ) !< Write the header in the output file implicit none type ( controltype ), intent ( in ) :: control integer :: n integer :: total DebugCall ( 'write_output_vtk: write_header' ) write ( OUT_FILE_UNIT , '(a)' ) \"variables = x y z \" total = 3 do n = 1 , control % w_count select case ( trim ( control % w_list ( n ))) case ( 'Velocity' ) write ( OUT_FILE_UNIT , '(a)' ) \" u v w \" total = total + 3 case ( 'do not write' ) !skip continue case Default write ( OUT_FILE_UNIT , '(a)' ) trim ( control % w_list ( n )) // \" \" total = total + 1 end select end do write ( OUT_FILE_UNIT , '(a,i4.4,3(a,i5.5),a)' ) \"zone T=block\" , process_id , \"  i=\" , imx , \" j=\" , jmx , \" k=\" , kmx - 1 , \" Datapacking=Block\" write ( OUT_FILE_UNIT , * ) \"Varlocation=([1-3]=Nodal)\" write ( OUT_FILE_UNIT , '(a,i2.2,a)' ) \"Varlocation=([4-\" , total , \"]=Nodal)\" write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"STRANDID=\" , 1 write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"SOLUTIONTIME=\" , control % checkpoint_iter_count end subroutine write_header","tags":"","loc":"proc/write_header.html","title":"write_header – FEST-3D"},{"text":"private subroutine write_grid(nodes) Write grid information in the output file Arguments Type Intent Optional Attributes Name type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Calls proc~~write_grid~~CallsGraph proc~write_grid write_grid debugcall debugcall proc~write_grid->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_grid~~CalledByGraph proc~write_grid write_grid proc~write_file write_file proc~write_file->proc~write_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_grid Source Code subroutine write_grid ( nodes ) !< Write grid information in the output file implicit none type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes ! write grid point coordinates DebugCall ( 'write_output_tec_node: write_grid' ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% x , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% y , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% z , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) end subroutine write_grid","tags":"","loc":"proc/write_grid.html","title":"write_grid – FEST-3D"},{"text":"private subroutine write_scalar(var, name, index) Write scalar variable in the output file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index Calls proc~~write_scalar~~CallsGraph proc~write_scalar write_scalar debugcall debugcall proc~write_scalar->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_scalar~~CalledByGraph proc~write_scalar write_scalar proc~write_file write_file proc~write_file->proc~write_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_scalar Source Code subroutine write_scalar ( var , name , index ) !< Write scalar variable in the output file implicit none integer , intent ( in ) :: index real ( wp ), dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( 'write_scalar' // trim ( name )) write ( OUT_FILE_UNIT , format ) ((( 0.25 * ( var ( i , j , k ) + var ( i - 1 , j , k )& + var ( i , j - 1 , k ) + var ( i - 1 , j - 1 , k ))& , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) end subroutine write_scalar","tags":"","loc":"proc/write_scalar.html","title":"write_scalar – FEST-3D"},{"text":"public subroutine write_file(file_handler, state, nodes, control, scheme, dims) Write the header and variables in the file \"process_xx.dat\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims Calls proc~~write_file~2~~CallsGraph proc~write_file~2 write_file debugcall debugcall proc~write_file~2->debugcall proc~write_header~2 write_header proc~write_file~2->proc~write_header~2 proc~write_grid~2 write_grid proc~write_file~2->proc~write_grid~2 proc~write_velocity write_velocity proc~write_file~2->proc~write_velocity proc~write_scalar~2 write_scalar proc~write_file~2->proc~write_scalar~2 proc~write_header~2->debugcall proc~write_grid~2->debugcall proc~write_velocity->debugcall proc~write_scalar~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_file Source Code subroutine write_file ( file_handler , state , nodes , control , scheme , dims ) !< Write the header and variables in the file \"process_xx.dat\" implicit none integer , intent ( in ) :: file_handler type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: state integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" DebugCall ( \"write_file\" ) OUT_FILE_UNIT = file_handler imx = dims % imx jmx = dims % jmx kmx = dims % kmx density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 8 ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call write_header ( control % Write_data_format ) call write_grid ( nodes ) do n = 1 , control % w_count select case ( trim ( control % w_list ( n ))) case ( 'Velocity' ) call write_velocity () case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) case ( 'tgm' ) call write_scalar ( tgm , \"tgm\" , - 2 ) case ( 'Dissipation' ) call write_scalar ( te , \"Dissipation\" , - 2 ) case ( 'Wall_distance' ) call write_scalar ( dist , \"dist\" , - 2 ) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'do not write' ) ! do nothing continue case Default print * , err // trim ( control % w_list ( n )) // \" to file\" end select end do end subroutine write_file","tags":"","loc":"proc/write_file~2.html","title":"write_file – FEST-3D"},{"text":"private subroutine write_header(Write_data_format) Write the header in the output file in the tecplot format Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Write_data_format Calls proc~~write_header~2~~CallsGraph proc~write_header~2 write_header debugcall debugcall proc~write_header~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_header~2~~CalledByGraph proc~write_header~2 write_header proc~write_file~2 write_file proc~write_file~2->proc~write_header~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_header Source Code subroutine write_header ( Write_data_format ) !< Write the header in the output file in the tecplot format implicit none character ( len =* ), intent ( in ) :: Write_data_format DebugCall ( \"write_header\" ) write ( OUT_FILE_UNIT , fmt = '(a)' ) '# vtk DataFile Version 3.1' write ( OUT_FILE_UNIT , '(a)' ) 'cfd-iitm output' ! comment line write ( OUT_FILE_UNIT , '(a)' ) trim ( Write_data_format ) write ( OUT_FILE_UNIT , '(a)' ) 'DATASET STRUCTURED_GRID' !write(OUT_FILE_UNIT, *) end subroutine write_header","tags":"","loc":"proc/write_header~2.html","title":"write_header – FEST-3D"},{"text":"private subroutine write_grid(nodes) Write the grid information in the output file Arguments Type Intent Optional Attributes Name type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Calls proc~~write_grid~2~~CallsGraph proc~write_grid~2 write_grid debugcall debugcall proc~write_grid~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_grid~2~~CalledByGraph proc~write_grid~2 write_grid proc~write_file~2 write_file proc~write_file~2->proc~write_grid~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_grid Source Code subroutine write_grid ( nodes ) !< Write the grid information in the output file implicit none type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes ! write grid point coordinates DebugCall ( \"write_grid\" ) write ( OUT_FILE_UNIT , fmt = '(a, i0, a, i0, a, i0)' ) & 'DIMENSIONS ' , imx , ' ' , jmx , ' ' , kmx write ( OUT_FILE_UNIT , fmt = '(a, i0, a)' ) & 'POINTS ' , imx * jmx * kmx , ' DOUBLE' do k = 1 , kmx do j = 1 , jmx do i = 1 , imx write ( OUT_FILE_UNIT , fmt = '(f0.16, a, f0.16, a, f0.16)' ) & nodes ( i , j , k )% x , ' ' , nodes ( i , j , k )% y , ' ' , nodes ( i , j , k )% z end do end do end do write ( OUT_FILE_UNIT , * ) end subroutine write_grid","tags":"","loc":"proc/write_grid~2.html","title":"write_grid – FEST-3D"},{"text":"private subroutine write_velocity() Write the velocity vector in the output file Arguments None Calls proc~~write_velocity~~CallsGraph proc~write_velocity write_velocity debugcall debugcall proc~write_velocity->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_velocity~~CalledByGraph proc~write_velocity write_velocity proc~write_file~2 write_file proc~write_file~2->proc~write_velocity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_velocity Source Code subroutine write_velocity () !< Write the velocity vector in the output file implicit none DebugCall ( \"write_velocity\" ) ! Cell data ! Writing Velocity write ( OUT_FILE_UNIT , fmt = '(a, i0)' ) 'CELL_DATA ' , ( imx - 1 ) * ( jmx - 1 ) * ( kmx - 1 ) write ( OUT_FILE_UNIT , '(a)' ) 'VECTORS Velocity FLOAT' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( OUT_FILE_UNIT , fmt = '(ES27.16E4, a, ES27.16E4, a, ES27.16E4)' ) & x_speed ( i , j , k ), ' ' , y_speed ( i , j , k ), ' ' , z_speed ( i , j , k ) end do end do end do write ( OUT_FILE_UNIT , * ) end subroutine write_velocity","tags":"","loc":"proc/write_velocity.html","title":"write_velocity – FEST-3D"},{"text":"private subroutine write_scalar(var, name, index) Write the scalar variable in the output file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index Calls proc~~write_scalar~2~~CallsGraph proc~write_scalar~2 write_scalar debugcall debugcall proc~write_scalar~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_scalar~2~~CalledByGraph proc~write_scalar~2 write_scalar proc~write_file~2 write_file proc~write_file~2->proc~write_scalar~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_scalar Source Code subroutine write_scalar ( var , name , index ) !< Write the scalar variable in the output file implicit none integer , intent ( in ) :: index real ( wp ), dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( \"write_scalar: \" // trim ( name )) write ( OUT_FILE_UNIT , '(a)' ) 'SCALARS ' // trim ( name ) // ' FLOAT' write ( OUT_FILE_UNIT , '(a)' ) 'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( OUT_FILE_UNIT , fmt = '(ES25.16E4)' ) var ( i , j , k ) end do end do end do write ( OUT_FILE_UNIT , * ) end subroutine write_scalar","tags":"","loc":"proc/write_scalar~2.html","title":"write_scalar – FEST-3D"},{"text":"public subroutine write_file(file_handler, state, nodes, control, scheme, dims) Write the header and variables in the file \"process_xx.dat\". Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims Calls proc~~write_file~3~~CallsGraph proc~write_file~3 write_file proc~write_scalar~3 write_scalar proc~write_file~3->proc~write_scalar~3 proc~write_grid~3 write_grid proc~write_file~3->proc~write_grid~3 proc~write_header~3 write_header proc~write_file~3->proc~write_header~3 debugcall debugcall proc~write_file~3->debugcall proc~write_scalar~3->debugcall proc~write_grid~3->debugcall proc~write_header~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_file Source Code subroutine write_file ( file_handler , state , nodes , control , scheme , dims ) !< Write the header and variables in the file \"process_xx.dat\". implicit none integer , intent ( in ) :: file_handler type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ), target :: state integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" DebugCall ( \"write_file\" ) OUT_FILE_UNIT = file_handler imx = dims % imx jmx = dims % jmx kmx = dims % kmx density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 8 ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call write_header ( control ) call write_grid ( nodes ) do n = 1 , control % w_count select case ( trim ( control % w_list ( n ))) case ( 'Velocity' ) call write_scalar ( x_speed , \"u\" , - 2 ) call write_scalar ( y_speed , \"v\" , - 2 ) call write_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) case ( 'tgm' ) call write_scalar ( tgm , \"tgm\" , - 2 ) case ( 'Wall_distance' ) call write_scalar ( dist , \"Wall_dist\" , - 2 ) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'do not write' ) ! do not write continue case Default print * , err // trim ( control % w_list ( n )) // \" to file\" end select end do end subroutine write_file","tags":"","loc":"proc/write_file~3.html","title":"write_file – FEST-3D"},{"text":"private subroutine write_header(control) Write the header in the output file in the tecplot format Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Calls proc~~write_header~3~~CallsGraph proc~write_header~3 write_header debugcall debugcall proc~write_header~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_header~3~~CalledByGraph proc~write_header~3 write_header proc~write_file~3 write_file proc~write_file~3->proc~write_header~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_header Source Code subroutine write_header ( control ) !< Write the header in the output file in the tecplot format implicit none type ( controltype ), intent ( in ) :: control integer :: n integer :: total DebugCall ( \"write_header\" ) write ( OUT_FILE_UNIT , '(a)' ) \"variables = x y z \" total = 3 do n = 1 , control % w_count select case ( trim ( control % w_list ( n ))) case ( 'Velocity' ) write ( OUT_FILE_UNIT , '(a)' ) \" u v w \" total = total + 3 case ( 'do not write' ) !skip continue case Default write ( OUT_FILE_UNIT , '(a)' ) trim ( control % w_list ( n )) // \" \" total = total + 1 end select end do write ( OUT_FILE_UNIT , '(a,i4.4,3(a,i5.5),a)' ) \"zone T=block\" , process_id , \"  i=\" , imx , \" j=\" , jmx , \" k=\" , kmx , \" Datapacking=Block\" write ( OUT_FILE_UNIT , * ) \"Varlocation=([1-3]=Nodal)\" write ( OUT_FILE_UNIT , '(a,i2.2,a)' ) \"Varlocation=([4-\" , total , \"]=CELLCENTERED)\" write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"STRANDID=\" , 1 write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"SOLUTIONTIME=\" , control % checkpoint_iter_count end subroutine write_header","tags":"","loc":"proc/write_header~3.html","title":"write_header – FEST-3D"},{"text":"private subroutine write_grid(nodes) Write the grid information in the output file Arguments Type Intent Optional Attributes Name type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Calls proc~~write_grid~3~~CallsGraph proc~write_grid~3 write_grid debugcall debugcall proc~write_grid~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_grid~3~~CalledByGraph proc~write_grid~3 write_grid proc~write_file~3 write_file proc~write_file~3->proc~write_grid~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_grid Source Code subroutine write_grid ( nodes ) !< Write the grid information in the output file implicit none type ( nodetype ), dimension ( - 2 : imx + 3 , - 2 : jmx + 3 , - 2 : kmx + 3 ), intent ( in ) :: nodes ! write grid point coordinates DebugCall ( \"write_grid\" ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% x , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% y , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) write ( OUT_FILE_UNIT , format ) ((( nodes ( i , j , k )% z , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) end subroutine write_grid","tags":"","loc":"proc/write_grid~3.html","title":"write_grid – FEST-3D"},{"text":"private subroutine write_scalar(var, name, index) Write the scalar variable in the output file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index Calls proc~~write_scalar~3~~CallsGraph proc~write_scalar~3 write_scalar debugcall debugcall proc~write_scalar~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_scalar~3~~CalledByGraph proc~write_scalar~3 write_scalar proc~write_file~3 write_file proc~write_file~3->proc~write_scalar~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_scalar Source Code subroutine write_scalar ( var , name , index ) !< Write the scalar variable in the output file implicit none integer , intent ( in ) :: index real ( wp ), dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( \"write_scalar: \" // trim ( name )) write ( OUT_FILE_UNIT , format ) ((( var ( i , j , k ), i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine write_scalar","tags":"","loc":"proc/write_scalar~3.html","title":"write_scalar – FEST-3D"},{"text":"public subroutine checkpoint(files, qp, nodes, control, scheme, dims) Create a checkpoint dump file if the time has come Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2, 1:dims%n_var) :: qp type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(inout) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims Calls proc~~checkpoint~~CallsGraph proc~checkpoint checkpoint proc~dump_data dump_data proc~checkpoint->proc~dump_data proc~purge_dump_dir purge_dump_dir proc~checkpoint->proc~purge_dump_dir debugcall debugcall proc~checkpoint->debugcall proc~make_dump_dir make_dump_dir proc~checkpoint->proc~make_dump_dir proc~dump_data->debugcall proc~write_restart_log write_restart_log proc~dump_data->proc~write_restart_log proc~write_file~4 write_file proc~dump_data->proc~write_file~4 proc~remove_directory remove_directory proc~purge_dump_dir->proc~remove_directory proc~create_directory create_directory proc~make_dump_dir->proc~create_directory proc~write_initial_resnorm write_initial_resnorm proc~write_restart_log->proc~write_initial_resnorm proc~close_file close_file proc~write_file~4->proc~close_file write_file_tec_nodal write_file_tec_nodal proc~write_file~4->write_file_tec_nodal proc~open_file open_file proc~write_file~4->proc~open_file proc~setup_file~2 setup_file proc~write_file~4->proc~setup_file~2 write_file_vtk write_file_vtk proc~write_file~4->write_file_vtk write_file_tec write_file_tec proc~write_file~4->write_file_tec proc~close_file->debugcall proc~open_file->debugcall proc~setup_file~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~checkpoint~~CalledByGraph proc~checkpoint checkpoint proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code checkpoint Source Code subroutine checkpoint ( files , qp , nodes , control , scheme , dims ) !< Create a checkpoint dump file if the time has come !----------------------------------------------------------- implicit none type ( filetype ), intent ( inout ) :: files type ( extent ), intent ( in ) :: dims type ( controltype ), intent ( inout ) :: control type ( schemetype ), intent ( in ) :: scheme type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp DebugCall ( 'checkpoint' ) if ( control % checkpoint_iter . ne . 0 ) then if ( mod ( control % current_iter , control % checkpoint_iter ) == 0 & . or . control % current_iter == control % max_iters ) then call make_dump_dir ( control ) call dump_data ( files , qp , nodes , control , scheme , dims ) print * , \"writing data at: \" , control % current_iter , control % checkpoint_iter_count call purge_dump_dir ( control ) control % checkpoint_iter_count = control % checkpoint_iter_count + 1 end if end if end subroutine checkpoint","tags":"","loc":"proc/checkpoint.html","title":"checkpoint – FEST-3D"},{"text":"private subroutine create_directory(dirname) Create a directory to keep the solution files from all the processor Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname Called by proc~~create_directory~~CalledByGraph proc~create_directory create_directory proc~make_dump_dir make_dump_dir proc~make_dump_dir->proc~create_directory proc~checkpoint checkpoint proc~checkpoint->proc~make_dump_dir proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panproccreate_directoryCalledByGraph = svgPanZoom('#proccreate_directoryCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code create_directory Source Code subroutine create_directory ( dirname ) !< Create a directory to keep the solution files from all the processor implicit none character ( len =* ), intent ( in ) :: dirname character ( len = FILE_NAME_LENGTH ) :: mkdircmd mkdircmd = 'mkdir -p ' // trim ( dirname ) call system ( mkdircmd ) end subroutine create_directory","tags":"","loc":"proc/create_directory.html","title":"create_directory – FEST-3D"},{"text":"private subroutine remove_directory(dirname) Remove a directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname Called by proc~~remove_directory~~CalledByGraph proc~remove_directory remove_directory proc~purge_dump_dir purge_dump_dir proc~purge_dump_dir->proc~remove_directory proc~checkpoint checkpoint proc~checkpoint->proc~purge_dump_dir proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocremove_directoryCalledByGraph = svgPanZoom('#procremove_directoryCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code remove_directory Source Code subroutine remove_directory ( dirname ) !< Remove a directory implicit none character ( len =* ), intent ( in ) :: dirname character ( len = FILE_NAME_LENGTH ) :: rmdircmd rmdircmd = 'rm -rf ' // trim ( dirname ) call system ( rmdircmd ) end subroutine remove_directory","tags":"","loc":"proc/remove_directory.html","title":"remove_directory – FEST-3D"},{"text":"private subroutine purge_dump_dir(control) Purge the directory based on the input Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Calls proc~~purge_dump_dir~~CallsGraph proc~purge_dump_dir purge_dump_dir proc~remove_directory remove_directory proc~purge_dump_dir->proc~remove_directory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~purge_dump_dir~~CalledByGraph proc~purge_dump_dir purge_dump_dir proc~checkpoint checkpoint proc~checkpoint->proc~purge_dump_dir proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code purge_dump_dir Source Code subroutine purge_dump_dir ( control ) !< Purge the directory based on the input implicit none type ( controltype ), intent ( in ) :: control integer :: purge_num purge_num = control % checkpoint_iter_count - control % purge_write if ( control % purge_write /= 0 . and . purge_num > 0 ) then write ( purge_dirname , '(A,I4.4)' ) 'time_directories/' , purge_num call remove_directory ( purge_dirname ) end if end subroutine purge_dump_dir","tags":"","loc":"proc/purge_dump_dir.html","title":"purge_dump_dir – FEST-3D"},{"text":"private subroutine make_dump_dir(control) Solution directory and sub-directory in created with particular number Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Calls proc~~make_dump_dir~~CallsGraph proc~make_dump_dir make_dump_dir proc~create_directory create_directory proc~make_dump_dir->proc~create_directory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~make_dump_dir~~CalledByGraph proc~make_dump_dir make_dump_dir proc~checkpoint checkpoint proc~checkpoint->proc~make_dump_dir proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code make_dump_dir Source Code subroutine make_dump_dir ( control ) !< Solution directory and sub-directory in created with particular number implicit none type ( controltype ), intent ( in ) :: control write ( dump_dirname , '(A,I4.4)' ) 'time_directories/' , control % checkpoint_iter_count call create_directory ( dump_dirname ) call create_directory ( trim ( dump_dirname ) // '/restart' ) end subroutine make_dump_dir","tags":"","loc":"proc/make_dump_dir.html","title":"make_dump_dir – FEST-3D"},{"text":"private subroutine dump_data(files, qp, nodes, control, scheme, dims) Call to write save files in the directory Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2, 1:dims%n_var) :: qp type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims Calls proc~~dump_data~~CallsGraph proc~dump_data dump_data debugcall debugcall proc~dump_data->debugcall proc~write_restart_log write_restart_log proc~dump_data->proc~write_restart_log proc~write_file~4 write_file proc~dump_data->proc~write_file~4 proc~write_initial_resnorm write_initial_resnorm proc~write_restart_log->proc~write_initial_resnorm proc~close_file close_file proc~write_file~4->proc~close_file write_file_tec_nodal write_file_tec_nodal proc~write_file~4->write_file_tec_nodal proc~open_file open_file proc~write_file~4->proc~open_file proc~setup_file~2 setup_file proc~write_file~4->proc~setup_file~2 write_file_vtk write_file_vtk proc~write_file~4->write_file_vtk write_file_tec write_file_tec proc~write_file~4->write_file_tec proc~close_file->debugcall proc~open_file->debugcall proc~setup_file~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dump_data~~CalledByGraph proc~dump_data dump_data proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dump_data Source Code subroutine dump_data ( files , qp , nodes , control , scheme , dims ) !< Call to write save files in the directory implicit none type ( filetype ), intent ( inout ) :: files type ( extent ), intent ( in ) :: dims type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp DebugCall ( 'dump_solution: dump_data' ) write ( files % restartfile , '(A,I2.2)' ) trim ( dump_dirname ) // '/restart/process_' , process_id write ( files % outfile , '(A,I2.2)' ) trim ( dump_dirname ) // '/process_' , process_id call write_restart_log ( files , scheme , control ) call write_file ( files , qp , nodes , control , scheme , dims ) end subroutine dump_data","tags":"","loc":"proc/dump_data.html","title":"dump_data – FEST-3D"},{"text":"private subroutine write_restart_log(files, scheme, control) Call to write log file in the subdirectory \"restart\". \n It is useful information while restarting the solver Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( schemetype ), intent(in) :: scheme type( controltype ), intent(in) :: control Calls proc~~write_restart_log~~CallsGraph proc~write_restart_log write_restart_log proc~write_initial_resnorm write_initial_resnorm proc~write_restart_log->proc~write_initial_resnorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_restart_log~~CalledByGraph proc~write_restart_log write_restart_log proc~dump_data dump_data proc~dump_data->proc~write_restart_log proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocwrite_restart_logCalledByGraph = svgPanZoom('#procwrite_restart_logCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_restart_log Source Code subroutine write_restart_log ( files , scheme , control ) !< Call to write log file in the subdirectory \"restart\". !< It is useful information while restarting the solver implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme open ( files % RESTART_FILE_UNIT , file = files % restartfile ) select case ( scheme % turbulence ) case ( 'none' ) write ( files % RESTART_FILE_UNIT , '(A)' ) 'viscous' case ( 'sst' , 'sst2003' , 'kkl' , 'ke' , 'kw' , 'sa' , 'saBC' , 'des-sst' ) write ( files % RESTART_FILE_UNIT , '(A)' ) trim ( scheme % turbulence ) case DEFAULT Fatal_error end select call write_initial_resnorm ( files , control ) close ( files % RESTART_FILE_UNIT ) end subroutine write_restart_log","tags":"","loc":"proc/write_restart_log.html","title":"write_restart_log – FEST-3D"},{"text":"private subroutine write_initial_resnorm(files, control) Writing Initial resnorom in the log file to \n maintian continuity of resnorm while restrarting Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(in) :: control Called by proc~~write_initial_resnorm~~CalledByGraph proc~write_initial_resnorm write_initial_resnorm proc~write_restart_log write_restart_log proc~write_restart_log->proc~write_initial_resnorm proc~dump_data dump_data proc~dump_data->proc~write_restart_log proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocwrite_initial_resnormCalledByGraph = svgPanZoom('#procwrite_initial_resnormCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_initial_resnorm Source Code subroutine write_initial_resnorm ( files , control ) !< Writing Initial resnorom in the log file to !< maintian continuity of resnorm while restrarting implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( in ) :: control integer :: i write ( files % RESTART_FILE_UNIT , '(I0)' ) control % current_iter + control % last_iter do i = 1 , control % n_var + 1 write ( files % RESTART_FILE_UNIT , '(f0.16)' ) control % previous_res ( i ) end do end subroutine write_initial_resnorm","tags":"","loc":"proc/write_initial_resnorm.html","title":"write_initial_resnorm – FEST-3D"},{"text":"private subroutine setup_file(control) Setup the file type based on the input Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Calls proc~~setup_file~2~~CallsGraph proc~setup_file~2 setup_file debugcall debugcall proc~setup_file~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_file~2~~CalledByGraph proc~setup_file~2 setup_file proc~write_file~4 write_file proc~write_file~4->proc~setup_file~2 proc~dump_data dump_data proc~dump_data->proc~write_file~4 proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocsetup_file2CalledByGraph = svgPanZoom('#procsetup_file2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_file Source Code subroutine setup_file ( control ) !< Setup the file type based on the input implicit none type ( controltype ), intent ( in ) :: control DebugCall ( 'write_output_vtk: setup_file' ) if ( control % write_file_format == \"vtk\" ) then file_format = \".vtk\" elseif ( control % write_file_format == \"tecplot\" . or . control % write_file_format == \"tecplot_nodal\" ) then file_format = \".dat\" else print * , \"File format not recoganised. Accepted formats are\" print * , \"'vtk', 'tecplot' and 'tecplot_nodal' \" end if if ( control % write_data_format == \"ASCII\" ) then data_format = \"formatted\" elseif ( control % write_data_format == \"BINARY\" ) then data_format = \"unformatted\" else print * , \"Data format not recoganised. Accepted formats are\" print * , \"'ASCII' and 'BINARY' \" end if end subroutine setup_file","tags":"","loc":"proc/setup_file~2.html","title":"setup_file – FEST-3D"},{"text":"private subroutine open_file(file_handler, filename) Open the file to write the solution Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler character(len=*), intent(in) :: filename Calls proc~~open_file~~CallsGraph proc~open_file open_file debugcall debugcall proc~open_file->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~open_file~~CalledByGraph proc~open_file open_file proc~write_file~4 write_file proc~write_file~4->proc~open_file proc~dump_data dump_data proc~dump_data->proc~write_file~4 proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocopen_fileCalledByGraph = svgPanZoom('#procopen_fileCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code open_file Source Code subroutine open_file ( file_handler , filename ) !< Open the file to write the solution implicit none integer , intent ( in ) :: file_handler character ( len =* ), intent ( in ) :: filename DebugCall ( 'write_output: open_file' ) open ( file_handler , file = trim ( filename ) // trim ( file_format ) // '.part' , form = trim ( data_format )) end subroutine open_file","tags":"","loc":"proc/open_file.html","title":"open_file – FEST-3D"},{"text":"private subroutine close_file(file_handler, filename) Close the file after writing solution. Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler character(len=*), intent(in) :: filename Calls proc~~close_file~~CallsGraph proc~close_file close_file debugcall debugcall proc~close_file->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~close_file~~CalledByGraph proc~close_file close_file proc~write_file~4 write_file proc~write_file~4->proc~close_file proc~dump_data dump_data proc~dump_data->proc~write_file~4 proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocclose_fileCalledByGraph = svgPanZoom('#procclose_fileCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code close_file Source Code subroutine close_file ( file_handler , filename ) !< Close the file after writing solution. implicit none integer , intent ( in ) :: file_handler character ( len =* ), intent ( in ) :: filename DebugCall ( 'write_output_vtk: close_file' ) call rename ( trim ( filename ) // trim ( file_format ) // '.part' , trim ( filename ) // trim ( file_format )) close ( file_handler ) end subroutine close_file","tags":"","loc":"proc/close_file.html","title":"close_file – FEST-3D"},{"text":"public subroutine write_file(files, qp, nodes, control, scheme, dims) Writing output in the file according to the input file type Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2,-2:dims%kmx+2, 1:dims%n_var) :: qp type( nodetype ), intent(in), dimension(-2:dims%imx+3, -2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims Calls proc~~write_file~4~~CallsGraph proc~write_file~4 write_file proc~close_file close_file proc~write_file~4->proc~close_file write_file_tec_nodal write_file_tec_nodal proc~write_file~4->write_file_tec_nodal proc~open_file open_file proc~write_file~4->proc~open_file proc~setup_file~2 setup_file proc~write_file~4->proc~setup_file~2 write_file_vtk write_file_vtk proc~write_file~4->write_file_vtk write_file_tec write_file_tec proc~write_file~4->write_file_tec debugcall debugcall proc~close_file->debugcall proc~open_file->debugcall proc~setup_file~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_file~4~~CalledByGraph proc~write_file~4 write_file proc~dump_data dump_data proc~dump_data->proc~write_file~4 proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_file Source Code subroutine write_file ( files , qp , nodes , control , scheme , dims ) !< Writing output in the file according to the input file type implicit none type ( filetype ), intent ( in ) :: files type ( extent ), intent ( in ) :: dims type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( nodetype ), dimension ( - 2 : dims % imx + 3 , - 2 : dims % jmx + 3 , - 2 : dims % kmx + 3 ), intent ( in ) :: nodes real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( in ) :: qp integer :: file_handler file_handler = files % OUT_FILE_UNIT call setup_file ( control ) call open_file ( file_handler , files % outfile ) select case ( control % write_file_format ) case ( 'vtk' ) call write_file_vtk ( file_handler , qp , nodes , control , scheme , dims ) case ( 'tecplot' ) call write_file_tec ( file_handler , qp , nodes , control , scheme , dims ) case ( 'tecplot_nodal' ) call write_file_tec_nodal ( file_handler , qp , nodes , control , scheme , dims ) case DEFAULT Fatal_error end select call close_file ( file_handler , files % outfile ) end subroutine write_file","tags":"","loc":"proc/write_file~4.html","title":"write_file – FEST-3D"},{"text":"public subroutine read_file(file_handler, state, control, scheme, dims) Read all the variable for the vtk restart file Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims Calls proc~~read_file~~CallsGraph proc~read_file read_file proc~read_scalar read_scalar proc~read_file->proc~read_scalar proc~read_header read_header proc~read_file->proc~read_header proc~read_velocity read_velocity proc~read_file->proc~read_velocity proc~skip_scalar skip_scalar proc~read_file->proc~skip_scalar proc~read_grid read_grid proc~read_file->proc~read_grid debugcall debugcall proc~read_scalar->debugcall proc~read_header->debugcall proc~read_velocity->debugcall proc~skip_scalar->debugcall proc~read_grid->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_file Source Code subroutine read_file ( file_handler , state , control , scheme , dims ) !< Read all the variable for the vtk restart file implicit none integer , intent ( in ) :: file_handler type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: state integer :: n IN_FILE_UNIT = file_handler imx = dims % imx jmx = dims % jmx kmx = dims % kmx density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 8 ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call read_header () call read_grid () do n = 1 , control % r_count select case ( trim ( control % r_list ( n ))) case ( 'Velocity' ) call read_velocity () case ( 'Density' ) call read_scalar ( density , 'Density' , - 2 ) case ( 'Pressure' ) call read_scalar ( pressure , 'Pressure' , - 2 ) case ( 'TKE' ) call read_scalar ( tk , 'TKE' , - 2 ) case ( 'Omega' ) call read_scalar ( tw , 'Omega' , - 2 ) case ( 'Kl' ) call read_scalar ( tkl , 'Kl' , - 2 ) case ( 'tv' ) call read_scalar ( tv , 'tv' , - 2 ) case ( 'tgm' ) call read_scalar ( tgm , 'tgm' , - 2 ) case ( 'do not read' ) call skip_scalar () case Default Print * , \"read error: list var : \" // trim ( control % r_list ( n )) end select end do end subroutine read_file","tags":"","loc":"proc/read_file.html","title":"read_file – FEST-3D"},{"text":"private subroutine read_header() Skip read the header in the vtk file Arguments None Calls proc~~read_header~~CallsGraph proc~read_header read_header debugcall debugcall proc~read_header->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_header~~CalledByGraph proc~read_header read_header proc~read_file read_file proc~read_file->proc~read_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_header Source Code subroutine read_header () !< Skip read the header in the vtk file implicit none DebugCall ( 'read_output_vtk: read_header' ) read ( IN_FILE_UNIT , * ) !'# vtk DataFile Version 3.1' read ( IN_FILE_UNIT , * ) !'cfd-iitm output'   ! comment line read ( IN_FILE_UNIT , * ) !trim(read_data_format) read ( IN_FILE_UNIT , * ) !'DATASET STRUCTURED_GRID' !read(IN_FILE_UNIT, *) end subroutine read_header","tags":"","loc":"proc/read_header.html","title":"read_header – FEST-3D"},{"text":"private subroutine read_grid() Skip the grid read in the restart file Arguments None Calls proc~~read_grid~~CallsGraph proc~read_grid read_grid debugcall debugcall proc~read_grid->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_grid~~CalledByGraph proc~read_grid read_grid proc~read_file read_file proc~read_file->proc~read_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_grid Source Code subroutine read_grid () !< Skip the grid read in the restart file implicit none ! read grid point coordinates DebugCall ( 'read_output_vtk: read_grid' ) read ( IN_FILE_UNIT , * ) !'DIMENSIONS ', imx, ' ', jmx, ' ', kmx read ( IN_FILE_UNIT , * ) !'POINTS ', imx*jmx*kmx, ' DOUBLE' do k = 1 , kmx do j = 1 , jmx do i = 1 , imx read ( IN_FILE_UNIT , * ) !point(i, j, k)%x, ' ', point(i, j, k)%y, ' ', point(i, j, k)%z end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_grid","tags":"","loc":"proc/read_grid.html","title":"read_grid – FEST-3D"},{"text":"private subroutine read_velocity() Read velocity vector from the vtk file Arguments None Calls proc~~read_velocity~~CallsGraph proc~read_velocity read_velocity debugcall debugcall proc~read_velocity->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_velocity~~CalledByGraph proc~read_velocity read_velocity proc~read_file read_file proc~read_file->proc~read_velocity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_velocity Source Code subroutine read_velocity () !< Read velocity vector from the vtk file implicit none DebugCall ( 'read_output_vtk: read_velocity' ) read ( IN_FILE_UNIT , * ) !'CELL_DATA ', (imx-1)*(jmx-1)*(kmx-1) read ( IN_FILE_UNIT , * ) !'VECTORS Velocity FLOAT' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) x_speed ( i , j , k ), y_speed ( i , j , k ), z_speed ( i , j , k ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_velocity","tags":"","loc":"proc/read_velocity.html","title":"read_velocity – FEST-3D"},{"text":"private subroutine read_scalar(var, name, index) Read scalar from the vtk file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index Calls proc~~read_scalar~~CallsGraph proc~read_scalar read_scalar debugcall debugcall proc~read_scalar->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_scalar~~CalledByGraph proc~read_scalar read_scalar proc~read_file read_file proc~read_file->proc~read_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_scalar Source Code subroutine read_scalar ( var , name , index ) !< Read scalar from the vtk file implicit none integer , intent ( in ) :: index real ( wp ), dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( out ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( 'read_output_vtk' // trim ( name )) read ( IN_FILE_UNIT , * ) !'SCALARS '//trim(name)//' FLOAT' read ( IN_FILE_UNIT , * ) !'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) var ( i , j , k ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_scalar","tags":"","loc":"proc/read_scalar.html","title":"read_scalar – FEST-3D"},{"text":"private subroutine skip_scalar() Skip read scalar from the vtk file Arguments None Calls proc~~skip_scalar~~CallsGraph proc~skip_scalar skip_scalar debugcall debugcall proc~skip_scalar->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~skip_scalar~~CalledByGraph proc~skip_scalar skip_scalar proc~read_file read_file proc~read_file->proc~skip_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code skip_scalar Source Code subroutine skip_scalar () !< Skip read scalar from the vtk file implicit none DebugCall ( 'read_output_vtk: skip_scalar' ) read ( IN_FILE_UNIT , * ) !'SCALARS '//trim(name)//' FLOAT' read ( IN_FILE_UNIT , * ) !'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine skip_scalar","tags":"","loc":"proc/skip_scalar.html","title":"skip_scalar – FEST-3D"},{"text":"public subroutine read_file(file_handler, state, control, scheme, dims) Read all the variable for the tecplot restart file Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims Calls proc~~read_file~2~~CallsGraph proc~read_file~2 read_file proc~read_header~2 read_header proc~read_file~2->proc~read_header~2 proc~skip_scalar~2 skip_scalar proc~read_file~2->proc~skip_scalar~2 proc~read_grid~2 read_grid proc~read_file~2->proc~read_grid~2 proc~read_scalar~2 read_scalar proc~read_file~2->proc~read_scalar~2 debugcall debugcall proc~read_header~2->debugcall proc~skip_scalar~2->debugcall proc~read_grid~2->debugcall proc~read_scalar~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_file Source Code subroutine read_file ( file_handler , state , control , scheme , dims ) !< Read all the variable for the tecplot restart file implicit none integer , intent ( in ) :: file_handler type ( controltype ), intent ( in ) :: control type ( schemetype ), intent ( in ) :: scheme type ( extent ), intent ( in ) :: dims real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: state integer :: n IN_FILE_UNIT = file_handler imx = dims % imx jmx = dims % jmx kmx = dims % kmx density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 5 ) select case ( trim ( scheme % turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 7 ) case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( scheme % transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => state (:, :, :, 8 ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select call read_header ( control ) call read_grid () do n = 1 , control % r_count select case ( trim ( control % r_list ( n ))) case ( 'Velocity' ) call read_scalar ( x_speed , \"u\" , - 2 ) call read_scalar ( y_speed , \"v\" , - 2 ) call read_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call read_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call read_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'TKE' ) call read_scalar ( tk , 'TKE' , - 2 ) case ( 'Omega' ) call read_scalar ( tw , 'Omega' , - 2 ) case ( 'Kl' ) call read_scalar ( tkl , 'Kl' , - 2 ) case ( 'tv' ) call read_scalar ( tv , 'tv' , - 2 ) case ( 'tgm' ) call read_scalar ( tgm , 'tgm' , - 2 ) case ( 'do not read' ) call skip_scalar () case Default Print * , \"read error: list var : \" // trim ( control % r_list ( n )) end select end do end subroutine read_file","tags":"","loc":"proc/read_file~2.html","title":"read_file – FEST-3D"},{"text":"private subroutine read_header(control) Skip read the header in the tecplot file Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Calls proc~~read_header~2~~CallsGraph proc~read_header~2 read_header debugcall debugcall proc~read_header~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_header~2~~CalledByGraph proc~read_header~2 read_header proc~read_file~2 read_file proc~read_file~2->proc~read_header~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_header Source Code subroutine read_header ( control ) !< Skip read the header in the tecplot file implicit none type ( controltype ), intent ( in ) :: control integer :: n DebugCall ( 'read_output_tec: read_header' ) read ( IN_FILE_UNIT , * ) !\"variables = x y z \" do n = 1 , control % r_count read ( IN_FILE_UNIT , * ) !trim(w_list(n)) end do read ( IN_FILE_UNIT , * ) ! \"zone T=block\" ... read ( IN_FILE_UNIT , * ) !\"Varlocation=([1-3]=Nodal)\" read ( IN_FILE_UNIT , * ) !\"Varlocation=([4-\",total,\"]=CELLCENTERED)\" read ( IN_FILE_UNIT , * ) !\"STRANDID\" read ( IN_FILE_UNIT , * ) !\"SolutionTime\" end subroutine read_header","tags":"","loc":"proc/read_header~2.html","title":"read_header – FEST-3D"},{"text":"private subroutine read_grid() Skip the grid read in the restart file Arguments None Calls proc~~read_grid~2~~CallsGraph proc~read_grid~2 read_grid debugcall debugcall proc~read_grid~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_grid~2~~CalledByGraph proc~read_grid~2 read_grid proc~read_file~2 read_file proc~read_file~2->proc~read_grid~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_grid Source Code subroutine read_grid () !< Skip the grid read in the restart file implicit none real ( wp ) :: dummy ! read grid point coordinates DebugCall ( 'read_output_tec: read_grid' ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) end subroutine read_grid","tags":"","loc":"proc/read_grid~2.html","title":"read_grid – FEST-3D"},{"text":"private subroutine read_scalar(var, name, index) Read scalar from the tecplot file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index Calls proc~~read_scalar~2~~CallsGraph proc~read_scalar~2 read_scalar debugcall debugcall proc~read_scalar~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_scalar~2~~CalledByGraph proc~read_scalar~2 read_scalar proc~read_file~2 read_file proc~read_file~2->proc~read_scalar~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_scalar Source Code subroutine read_scalar ( var , name , index ) !< Read scalar from the tecplot file implicit none integer , intent ( in ) :: index real ( wp ), dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( out ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( 'read_output_tec' // trim ( name )) read ( IN_FILE_UNIT , * ) ((( var ( i , j , k ), i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine read_scalar","tags":"","loc":"proc/read_scalar~2.html","title":"read_scalar – FEST-3D"},{"text":"private subroutine skip_scalar() Skip read scalar from the tecplot file Arguments None Calls proc~~skip_scalar~2~~CallsGraph proc~skip_scalar~2 skip_scalar debugcall debugcall proc~skip_scalar~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~skip_scalar~2~~CalledByGraph proc~skip_scalar~2 skip_scalar proc~read_file~2 read_file proc~read_file~2->proc~skip_scalar~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code skip_scalar Source Code subroutine skip_scalar () !< Skip read scalar from the tecplot file implicit none real ( wp ) :: dummy DebugCall ( 'read_output_tec: skip_scalar' ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine skip_scalar","tags":"","loc":"proc/skip_scalar~2.html","title":"skip_scalar – FEST-3D"},{"text":"private function get_number_of_line(till, infile) result(number) Get number of lines till some character like \"#\" Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: till integer, intent(in) :: infile Return Value integer Called by proc~~get_number_of_line~~CalledByGraph proc~get_number_of_line get_number_of_line proc~read_res_list read_Res_list proc~read_res_list->proc~get_number_of_line proc~get_count_within_braces get_count_within_braces proc~read_res_list->proc~get_count_within_braces proc~get_count_within_braces->proc~get_number_of_line proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_res_list proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocget_number_of_lineCalledByGraph = svgPanZoom('#procget_number_of_lineCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_number_of_line Source Code function get_number_of_line ( till , infile ) result ( number ) !< Get number of lines till some character like \"#\" implicit none integer , intent ( in ) :: infile character ( len = 1 ), intent ( in ) :: till character ( len = 64 ) :: buf integer :: ios integer :: number number = 0 do while (. true .) read ( infile , * , iostat = ios ) buf if ( trim ( buf ) == till ) EXIT if ( is_iostat_end ( ios )) EXIT number = number + 1 end do end function get_number_of_line","tags":"","loc":"proc/get_number_of_line.html","title":"get_number_of_line – FEST-3D"},{"text":"public subroutine read_input_and_controls(files, control, scheme, flow) Read all the input control files Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control type( schemetype ), intent(inout) :: scheme type( flowtype ), intent(inout) :: flow Calls proc~~read_input_and_controls~~CallsGraph proc~read_input_and_controls read_input_and_controls proc~read_output_control read_output_control proc~read_input_and_controls->proc~read_output_control proc~read_controls read_controls proc~read_input_and_controls->proc~read_controls proc~read_res_list read_Res_list proc~read_input_and_controls->proc~read_res_list proc~read_scheme read_scheme proc~read_input_and_controls->proc~read_scheme proc~read_flow read_flow proc~read_input_and_controls->proc~read_flow proc~get_rw_count get_rw_count proc~read_output_control->proc~get_rw_count debuginfo debuginfo proc~read_controls->debuginfo proc~get_next_token get_next_token proc~read_controls->proc~get_next_token debugcall debugcall proc~read_controls->debugcall proc~get_count_within_braces get_count_within_braces proc~read_res_list->proc~get_count_within_braces proc~get_number_of_line get_number_of_line proc~read_res_list->proc~get_number_of_line proc~read_scheme->debuginfo proc~read_scheme->proc~get_next_token proc~read_scheme->debugcall proc~read_flow->debuginfo proc~read_flow->proc~get_next_token proc~read_flow->debugcall proc~get_count_within_braces->proc~get_number_of_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_input_and_controls~~CalledByGraph proc~read_input_and_controls read_input_and_controls proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_input_and_controls Source Code subroutine read_input_and_controls ( files , control , scheme , flow ) !< Read all the input control files implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control type ( schemetype ), intent ( inout ) :: scheme type ( flowtype ), intent ( inout ) :: flow call read_controls ( files , control ) call read_scheme ( files , scheme ) call read_flow ( files , control , flow ) call read_output_control ( files , control ) call read_Res_list ( files , control ) end subroutine read_input_and_controls","tags":"","loc":"proc/read_input_and_controls.html","title":"read_input_and_controls – FEST-3D"},{"text":"private subroutine get_next_token(token_file_unit, buf) Extract the next token from the config file Each token is on a separate line.\n There may be multiple comments (lines beginning with #) \n and blank lines in between.\n The purpose of this subroutine is to ignore all these \n lines and return the next \"useful\" line. Arguments Type Intent Optional Attributes Name integer, intent(in) :: token_file_unit character(len=STRING_BUFFER_LENGTH), intent(out) :: buf Called by proc~~get_next_token~~CalledByGraph proc~get_next_token get_next_token proc~read_controls read_controls proc~read_controls->proc~get_next_token proc~read_scheme read_scheme proc~read_scheme->proc~get_next_token proc~read_flow read_flow proc~read_flow->proc~get_next_token proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_controls proc~read_input_and_controls->proc~read_scheme proc~read_input_and_controls->proc~read_flow proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocget_next_tokenCalledByGraph = svgPanZoom('#procget_next_tokenCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_next_token Source Code subroutine get_next_token ( token_file_unit , buf ) !< Extract the next token from the config file !< !< Each token is on a separate line. !< There may be multiple comments (lines beginning with #) !< and blank lines in between. !< The purpose of this subroutine is to ignore all these !< lines and return the next \"useful\" line. !----------------------------------------------------------- implicit none integer , intent ( in ) :: token_file_unit character ( len = STRING_BUFFER_LENGTH ), intent ( out ) :: buf integer :: ios do read ( token_file_unit , '(A)' , iostat = ios ) buf if ( ios /= 0 ) then print * , 'Error while reading config file.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH stop end if if ( index ( buf , '#' ) == 1 ) then ! The current line begins with a hash ! Ignore it continue else if ( len_trim ( buf ) == 0 ) then ! The current line is empty ! Ignore it continue else ! A new token has been found ! Break out exit end if end do end subroutine get_next_token","tags":"","loc":"proc/get_next_token.html","title":"get_next_token – FEST-3D"},{"text":"private subroutine read_controls(files, control) Read control.md file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control Calls proc~~read_controls~~CallsGraph proc~read_controls read_controls debuginfo debuginfo proc~read_controls->debuginfo debugcall debugcall proc~read_controls->debugcall proc~get_next_token get_next_token proc~read_controls->proc~get_next_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_controls~~CalledByGraph proc~read_controls read_controls proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_controls proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_controls Source Code subroutine read_controls ( files , control ) !< Read control.md file !--------------------------------------------- implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control character ( len = STRING_BUFFER_LENGTH ) :: buf DebugCall ( 'read_controls' ) open ( files % CONTROL_FILE_UNIT , file = files % control_file , status = 'old' , action = 'read' ) !ignoring file header read ( files % CONTROL_FILE_UNIT , * ) read ( files % CONTROL_FILE_UNIT , * ) read ( files % CONTROL_FILE_UNIT , * ) ! READ CFL call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % CFL DebugInfo ( \"CFL = \" // trim ( buf )) ! READ start_from call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % start_from DebugInfo ( 'Start from  level = ' // trim ( buf )) ! READ max_iters call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % max_iters DebugInfo ( 'Stop at iteration = ' // trim ( buf )) ! READ checkpoint_iter call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % checkpoint_iter DebugInfo ( ' Solution write interval = ' // trim ( buf )) ! READ write_file_format call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % write_file_format DebugInfo ( 'Solution file format  = ' // trim ( buf )) ! READ write_data_format call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % write_data_format DebugInfo ( 'solution file data format = ' // trim ( buf )) ! READ read_file_format call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % read_file_format DebugInfo ( 'Restart file format  = ' // trim ( buf )) ! READ_read data_format call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % read_data_format DebugInfo ( 'Restart file data format = ' // trim ( buf )) ! READ write_percision call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % write_percision DebugInfo ( 'File write percision = ' // trim ( buf )) ! READ purge_write call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % purge_write DebugInfo ( 'Purge folder more then  = ' // trim ( buf )) ! READ res_write_interval call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % res_write_interval DebugInfo ( 'resnorm write interval  = ' // trim ( buf )) ! READ tolerance call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % tolerance , control % tolerance_type DebugInfo ( trim ( control % tolerance_type ) // ' Tolerance  = ' // trim ( buf )) ! READ DEBUG_LEVEL call get_next_token ( files % CONTROL_FILE_UNIT , buf ) read ( buf , * ) control % DEBUG_LEVEL DebugInfo ( 'DEBUG_LEVEL = ' // trim ( buf )) close ( files % CONTROL_FILE_UNIT ) end subroutine read_controls","tags":"","loc":"proc/read_controls.html","title":"read_controls – FEST-3D"},{"text":"private subroutine read_scheme(files, scheme) Read fvscheme.md control file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( schemetype ), intent(inout) :: scheme Calls proc~~read_scheme~~CallsGraph proc~read_scheme read_scheme debuginfo debuginfo proc~read_scheme->debuginfo debugcall debugcall proc~read_scheme->debugcall proc~get_next_token get_next_token proc~read_scheme->proc~get_next_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_scheme~~CalledByGraph proc~read_scheme read_scheme proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_scheme proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_scheme Source Code subroutine read_scheme ( files , scheme ) !< Read fvscheme.md control file !-------------------------------------------- implicit none type ( filetype ), intent ( in ) :: files type ( schemetype ), intent ( inout ) :: scheme character ( len = STRING_BUFFER_LENGTH ) :: buf integer :: ios DebugCall ( 'read_scheme' ) open ( files % SCHEME_FILE_UNIT , file = files % scheme_file , status = 'old' , action = 'read' ) ! ignoring file header read ( files % SCHEME_FILE_UNIT , * ) read ( files % SCHEME_FILE_UNIT , * ) read ( files % SCHEME_FILE_UNIT , * ) ! read scheme name call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % scheme_name DebugInfo ( 'scheme_name = ' // trim ( buf )) ! read interpolant call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % interpolant scheme % interpolant = trim ( scheme % interpolant ) DebugInfo ( 'interpolant = ' // trim ( buf )) ! read ilimiter and PB switch call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % ilimiter_switch , scheme % jlimiter_switch , scheme % klimiter_switch , & scheme % iPB_switch , scheme % jPB_switch , scheme % kPB_switch DebugInfo ( 'ilimiter switch = ' // trim ( buf ) ) DebugInfo ( 'jlimiter switch = ' // trim ( buf ) ) DebugInfo ( 'klimiter switch = ' // trim ( buf ) ) DebugInfo ( 'PB switch = ' // trim ( buf ) ) ! read turbulent limiter call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % itlimiter_switch , scheme % jtlimiter_switch , scheme % ktlimiter_switch DebugInfo ( 'ilimiter switch = ' // trim ( buf ) ) DebugInfo ( 'jlimiter switch = ' // trim ( buf ) ) DebugInfo ( 'klimiter switch = ' // trim ( buf ) ) ! read turbulence model call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % turbulence DebugInfo ( 'Turbulence Model = ' // trim ( buf )) ! read transition model call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % transition DebugInfo ( 'Transition Model = ' // trim ( buf )) ! read time stepping method call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * , iostat = ios ) scheme % time_stepping_method , scheme % global_time_step if ( ios /= 0 ) then read ( buf , * ) scheme % time_stepping_method scheme % global_time_step = - 1 end if DebugInfo ( 'time_stepping_method = ' // trim ( buf )) DebugInfo ( 'global_time_step = ' // trim ( buf )) ! read time integration method call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % time_step_accuracy DebugInfo ( 'time_step_accuracy  = ' // trim ( buf )) ! read higher order boundary call get_next_token ( files % SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme % accur DebugInfo ( 'higher order boundary  = ' // trim ( buf )) close ( files % SCHEME_FILE_UNIT ) end subroutine read_scheme","tags":"","loc":"proc/read_scheme.html","title":"read_scheme – FEST-3D"},{"text":"private subroutine read_flow(files, control, flow) Read flow.md control file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control type( flowtype ), intent(inout) :: flow Calls proc~~read_flow~~CallsGraph proc~read_flow read_flow debuginfo debuginfo proc~read_flow->debuginfo debugcall debugcall proc~read_flow->debugcall proc~get_next_token get_next_token proc~read_flow->proc~get_next_token Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_flow~~CalledByGraph proc~read_flow read_flow proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_flow proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_flow Source Code subroutine read_flow ( files , control , flow ) !< Read flow.md control file !-------------------------------------------- implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control type ( flowtype ), intent ( inout ) :: flow character ( len = STRING_BUFFER_LENGTH ) :: buf DebugCall ( 'read_flow' ) open ( files % FLOW_FILE_UNIT , file = files % flow_file , status = 'old' , action = 'read' ) ! ignoring file header read ( files % FLOW_FILE_UNIT , * ) read ( files % FLOW_FILE_UNIT , * ) read ( files % FLOW_FILE_UNIT , * ) ! read number of variable call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) control % n_var DebugInfo ( 'Number of variables = ' // trim ( buf )) ! read rho_inf call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % density_inf DebugInfo ( 'free_stream_density = ' // trim ( buf )) ! read u_inf call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % x_speed_inf DebugInfo ( 'free_stream_x_speed = ' // trim ( buf )) ! read v_inf call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % y_speed_inf DebugInfo ( 'free_stream_y_speed = ' // trim ( buf )) ! read w_inf call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % z_speed_inf DebugInfo ( 'free_stream_z_speed = ' // trim ( buf )) ! read P_inf call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % pressure_inf DebugInfo ( 'free_stream_pressure = ' // trim ( buf )) ! read turbulence intensity in percentage call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % tu_inf DebugInfo ( 'free_stream_Turb_intensity = ' // trim ( buf )) ! read viscosity ratio call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % mu_ratio_inf DebugInfo ( 'free_stream_mu_ratio = ' // trim ( buf )) ! read intermittency call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % tgm_inf DebugInfo ( 'free_stream_Intermittency = ' // trim ( buf )) ! read reference viscosity call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % mu_ref DebugInfo ( 'mu_reference = ' // trim ( buf )) ! Type of variation for viscosity call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % mu_variation DebugInfo ( 'mu_variation = ' // trim ( buf )) ! read T_red call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % T_ref DebugInfo ( 'T_reference = ' // trim ( buf )) ! read Sutherland temp call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % Sutherland_temp DebugInfo ( 'Sutherland temperature = ' // trim ( buf )) ! read prandtl number call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % Pr , flow % tPr DebugInfo ( 'Prandtl Number = ' // trim ( buf )) ! read gamma call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % gm DebugInfo ( 'gamma = ' // trim ( buf )) ! read universal gas constant call get_next_token ( files % FLOW_FILE_UNIT , buf ) read ( buf , * ) flow % R_gas DebugInfo ( 'R_gas = ' // trim ( buf )) close ( files % FLOW_FILE_UNIT ) end subroutine read_flow","tags":"","loc":"proc/read_flow.html","title":"read_flow – FEST-3D"},{"text":"private subroutine read_output_control(files, control) Read output_contorl.md file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control Calls proc~~read_output_control~~CallsGraph proc~read_output_control read_output_control proc~get_rw_count get_rw_count proc~read_output_control->proc~get_rw_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_output_control~~CalledByGraph proc~read_output_control read_output_control proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_output_control proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_output_control Source Code subroutine read_output_control ( files , control ) !< Read output_contorl.md file implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control integer :: i character ( len = 64 ) :: buf integer :: ios logical :: ok call get_rw_count ( files , control ) inquire ( files % OUTIN_FILE_UNIT , opened = ok ) if ( ok ) close ( files % OUTIN_FILE_UNIT ) !call close_file(files%OUTIN_FILE_UNIT) open ( files % OUTIN_FILE_UNIT , file = files % outin_file , status = 'old' , action = 'read' ) ! variables to write do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do do i = 1 , control % w_count read ( files % OUTIN_FILE_UNIT , * ) buf read ( buf , * ) control % w_list ( i ) end do ! restart variables to read do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do do i = 1 , control % r_count read ( files % OUTIN_FILE_UNIT , * ) buf read ( buf , * ) control % r_list ( i ) end do if ( control % r_count == 0 ) control % r_list = control % w_list close ( files % OUTIN_FILE_UNIT ) end subroutine read_output_control","tags":"","loc":"proc/read_output_control.html","title":"read_output_control – FEST-3D"},{"text":"private subroutine get_rw_count(files, control) Get read/write count Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control Called by proc~~get_rw_count~~CalledByGraph proc~get_rw_count get_rw_count proc~read_output_control read_output_control proc~read_output_control->proc~get_rw_count proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_output_control proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocget_rw_countCalledByGraph = svgPanZoom('#procget_rw_countCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_rw_count Source Code subroutine get_rw_count ( files , control ) !< Get read/write count implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control integer :: ios character ( len = 64 ) :: buf logical :: ok control % r_count = 0 control % w_count = 0 inquire ( files % OUTIN_FILE_UNIT , opened = ok ) if ( ok ) close ( files % OUTIN_FILE_UNIT ) !call close_file(files%OUTIN_FILE_UNIT) open ( files % OUTIN_FILE_UNIT , file = files % outin_file , status = 'old' , action = 'read' ) ! write list dimension do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do control % w_count = 0 do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '}' ) EXIT if ( is_iostat_end ( ios )) EXIT control % w_count = control % w_count + 1 end do if ( control % w_count > 0 ) then allocate ( control % w_list ( 1 : control % w_count )) else control % w_count = 3 allocate ( control % w_list ( 1 : control % w_count )) control % w_list ( 1 ) = \"Velocity\" control % w_list ( 2 ) = \"Density\" control % w_list ( 3 ) = \"Pressure\" end if ! read list dimesnion do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do control % r_count = 0 do while (. true .) read ( files % OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '}' ) EXIT if ( is_iostat_end ( ios )) EXIT control % r_count = control % r_count + 1 end do if ( control % r_count == 0 ) then allocate ( control % r_list ( 1 : control % w_count )) else allocate ( control % r_list ( 1 : control % r_count )) end if close ( files % OUTIN_FILE_UNIT ) end subroutine get_rw_count","tags":"","loc":"proc/get_rw_count.html","title":"get_rw_count – FEST-3D"},{"text":"private subroutine get_count_within_braces(handler, count) Get number of variables between two curly braces Arguments Type Intent Optional Attributes Name integer, intent(in) :: handler File handler from which list number is extracted integer, intent(out) :: count Extracted count Calls proc~~get_count_within_braces~~CallsGraph proc~get_count_within_braces get_count_within_braces proc~get_number_of_line get_number_of_line proc~get_count_within_braces->proc~get_number_of_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_count_within_braces~~CalledByGraph proc~get_count_within_braces get_count_within_braces proc~read_res_list read_Res_list proc~read_res_list->proc~get_count_within_braces proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_res_list proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocget_count_within_bracesCalledByGraph = svgPanZoom('#procget_count_within_bracesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_count_within_braces Source Code subroutine get_count_within_braces ( handler , count ) !< Get number of variables between two curly braces implicit none integer , intent ( in ) :: handler !< File handler from which list number is extracted integer , intent ( out ) :: count !< Extracted count integer :: skip ! skipping lines outside braces skip = get_number_of_line ( '{' , handler ) ! finding actual count if any count = get_number_of_line ( '}' , handler ) end subroutine get_count_within_braces","tags":"","loc":"proc/get_count_within_braces.html","title":"get_count_within_braces – FEST-3D"},{"text":"private subroutine read_Res_list(files, control) Read Residual file: res_control.md Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control Calls proc~~read_res_list~~CallsGraph proc~read_res_list read_Res_list proc~get_number_of_line get_number_of_line proc~read_res_list->proc~get_number_of_line proc~get_count_within_braces get_count_within_braces proc~read_res_list->proc~get_count_within_braces proc~get_count_within_braces->proc~get_number_of_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_res_list~~CalledByGraph proc~read_res_list read_Res_list proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_res_list proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_Res_list Source Code subroutine read_Res_list ( files , control ) !< Read Residual file: res_control.md implicit none type ( filetype ), intent ( in ) :: files type ( controltype ), intent ( inout ) :: control integer :: i integer :: skip logical :: ok open ( files % RES_CONTROL_FILE_UNIT , file = files % res_control_file , status = 'old' , action = 'read' ) call get_count_within_braces ( files % RES_CONTROL_FILE_UNIT , control % Res_count ) !call close_file(files%RES_CONTROL_FILE_UNIT) inquire ( files % RES_CONTROL_FILE_UNIT , opened = ok ) if ( ok ) close ( files % RES_CONTROL_FILE_UNIT ) open ( files % RES_CONTROL_FILE_UNIT , file = files % res_control_file , status = 'old' , action = 'read' ) ! skipping line skip = get_number_of_line ( '{' , files % RES_CONTROL_FILE_UNIT ) !reading vaules if ( control % Res_count == 0 ) then allocate ( control % Res_list ( 1 : 2 )) control % Res_count = 2 control % Res_list ( 1 ) = \"Mass_abs\" control % Res_list ( 2 ) = \"Resnorm_abs\" else allocate ( control % Res_list ( 1 : control % Res_count )) end if do i = 1 , control % Res_count read ( files % RES_CONTROL_FILE_UNIT , * ) control % Res_list ( i ) end do close ( files % RES_CONTROL_FILE_UNIT ) end subroutine read_Res_list","tags":"","loc":"proc/read_res_list.html","title":"read_Res_list – FEST-3D"},{"text":"public subroutine read_file(files, qp, control, scheme, dims) Read restart file Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp type( controltype ), intent(inout) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims Calls proc~~read_file~3~~CallsGraph proc~read_file~3 read_file proc~verify_read_control verify_read_control proc~read_file~3->proc~verify_read_control read_file_tec read_file_tec proc~read_file~3->read_file_tec proc~open_file~2 open_file proc~read_file~3->proc~open_file~2 proc~read_restart_file read_restart_file proc~read_file~3->proc~read_restart_file proc~close_file~2 close_file proc~read_file~3->proc~close_file~2 read_file_vtk read_file_vtk proc~read_file~3->read_file_vtk proc~setup_file~3 setup_file proc~read_file~3->proc~setup_file~3 proc~lcase lcase proc~verify_read_control->proc~lcase debugcall debugcall proc~open_file~2->debugcall proc~close_file~2->debugcall proc~setup_file~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_file~3~~CalledByGraph proc~read_file~3 read_file proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_file Source Code subroutine read_file ( files , qp , control , scheme , dims ) !< Read restart file implicit none type ( filetype ), intent ( inout ) :: files type ( extent ), intent ( in ) :: dims type ( controltype ), intent ( inout ) :: control type ( schemetype ) , intent ( in ) :: scheme real ( wp ), dimension ( - 2 : dims % imx + 2 , - 2 : dims % jmx + 2 , - 2 : dims % kmx + 2 , 1 : dims % n_var ), intent ( inout ), target :: qp call setup_file ( control ) call open_file ( files , control ) call read_restart_file ( files % RESTART_FILE_UNIT , control ) call verify_read_control ( control , scheme ) select case ( control % read_file_format ) case ( 'vtk' ) call read_file_vtk ( files % IN_FILE_UNIT , qp , control , scheme , dims ) case ( 'tecplot' ) call read_file_tec ( files % IN_FILE_UNIT , qp , control , scheme , dims ) case DEFAULT Fatal_error end select call close_file ( files ) end subroutine read_file","tags":"","loc":"proc/read_file~3.html","title":"read_file – FEST-3D"},{"text":"private subroutine setup_file(control) Steup the file to read the restart state. Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Calls proc~~setup_file~3~~CallsGraph proc~setup_file~3 setup_file debugcall debugcall proc~setup_file~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_file~3~~CalledByGraph proc~setup_file~3 setup_file proc~read_file~3 read_file proc~read_file~3->proc~setup_file~3 proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_file Source Code subroutine setup_file ( control ) !< Steup the file to read the restart state. implicit none type ( controltype ), intent ( in ) :: control DebugCall ( 'setup_file' ) if ( control % read_file_format == \"vtk\" ) then file_format = \".vtk\" elseif ( control % read_file_format == \"tecplot\" ) then file_format = \".dat\" else print * , \"File format not recoganised. Accepted formats are\" print * , \"'vtk' and 'tecplot' \" end if if ( control % read_data_format == \"ASCII\" ) then data_format = \"formatted\" elseif ( control % read_data_format == \"BINARY\" ) then data_format = \"unformatted\" else print * , \"Data format not recoganised. Accepted formats are\" print * , \"'ASCII' and 'BINARY' \" end if end subroutine setup_file","tags":"","loc":"proc/setup_file~3.html","title":"setup_file – FEST-3D"},{"text":"private subroutine open_file(files, control) Open file from the restart folder Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files type( controltype ), intent(in) :: control Calls proc~~open_file~2~~CallsGraph proc~open_file~2 open_file debugcall debugcall proc~open_file~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~open_file~2~~CalledByGraph proc~open_file~2 open_file proc~read_file~3 read_file proc~read_file~3->proc~open_file~2 proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code open_file Source Code subroutine open_file ( files , control ) !< Open file from the restart folder implicit none type ( filetype ), intent ( inout ) :: files type ( controltype ), intent ( in ) :: control DebugCall ( 'open_file' ) write ( files % restartfile , '(A,I4.4,A,I2.2)' ) 'time_directories/' , control % start_from ,& '/restart/process_' , process_id open ( files % IN_FILE_UNIT , file = trim ( files % infile ) // trim ( file_format )) !, form=trim(data_format)) open ( files % RESTART_FILE_UNIT , file = files % restartfile , status = 'old' ) end subroutine open_file","tags":"","loc":"proc/open_file~2.html","title":"open_file – FEST-3D"},{"text":"private subroutine close_file(files) Close the file after reading Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Calls proc~~close_file~2~~CallsGraph proc~close_file~2 close_file debugcall debugcall proc~close_file~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~close_file~2~~CalledByGraph proc~close_file~2 close_file proc~read_file~3 read_file proc~read_file~3->proc~close_file~2 proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code close_file Source Code subroutine close_file ( files ) !< Close the file after reading implicit none type ( filetype ), intent ( in ) :: files DebugCall ( 'close_files' ) close ( files % IN_FILE_UNIT ) close ( files % RESTART_FILE_UNIT ) end subroutine close_file","tags":"","loc":"proc/close_file~2.html","title":"close_file – FEST-3D"},{"text":"private subroutine read_restart_file(RESTART_FILE_UNIT, control) Read the sub-directory log file in the restart folder Arguments Type Intent Optional Attributes Name integer, intent(in) :: RESTART_FILE_UNIT type( controltype ), intent(inout) :: control Called by proc~~read_restart_file~~CalledByGraph proc~read_restart_file read_restart_file proc~read_file~3 read_file proc~read_file~3->proc~read_restart_file proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocread_restart_fileCalledByGraph = svgPanZoom('#procread_restart_fileCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_restart_file Source Code subroutine read_restart_file ( RESTART_FILE_UNIT , control ) !< Read the sub-directory log file in the restart folder implicit none integer , intent ( in ) :: RESTART_FILE_UNIT type ( controltype ), intent ( inout ) :: control integer :: i read ( RESTART_FILE_UNIT , * ) control % previous_flow_type read ( RESTART_FILE_UNIT , * ) control % last_iter do i = 1 , control % n_var + 1 read ( RESTART_FILE_UNIT , * ) control % previous_res ( i ) end do end subroutine read_restart_file","tags":"","loc":"proc/read_restart_file.html","title":"read_restart_file – FEST-3D"},{"text":"This module handles the MPI Communication calls for interface boundary conditions Uses mapping mpi vartypes utils module~~interface1~~UsesGraph module~interface1 interface1 module~utils utils module~interface1->module~utils module~mapping mapping module~interface1->module~mapping module~vartypes vartypes module~interface1->module~vartypes mpi mpi module~interface1->mpi module~mapping->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~interface1~~UsedByGraph module~interface1 interface1 module~solver solver module~solver->module~interface1 module~update update module~solver->module~update module~update->module~interface1 program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables layers ibuf_size jbuf_size kbuf_size imin_send_buf jmin_send_buf kmin_send_buf imin_recv_buf jmin_recv_buf kmin_recv_buf imax_send_buf jmax_send_buf kmax_send_buf imax_recv_buf jmax_recv_buf kmax_recv_buf Subroutines setup_interface apply_interface apply_periodic_bc Variables Type Visibility Attributes Name Initial integer, private :: layers = 3 integer, private :: ibuf_size Size of the buffer for I face interface integer, private :: jbuf_size Size of the buffer for J face interface integer, private :: kbuf_size Size of the buffer for K face interface real(kind=wp), private, dimension(:), allocatable :: imin_send_buf Array to store data to send data for Imin face real(kind=wp), private, dimension(:), allocatable :: jmin_send_buf Array to store data to send data for Jmin face real(kind=wp), private, dimension(:), allocatable :: kmin_send_buf Array to store data to send data for Kmin face real(kind=wp), private, dimension(:), allocatable :: imin_recv_buf Array to store data to receive data for Imin face real(kind=wp), private, dimension(:), allocatable :: jmin_recv_buf Array to store data to receive data for Jmin face real(kind=wp), private, dimension(:), allocatable :: kmin_recv_buf Array to store data to receive data for Kmin face real(kind=wp), private, dimension(:), allocatable :: imax_send_buf Array to store data to send data for Imax face real(kind=wp), private, dimension(:), allocatable :: jmax_send_buf Array to store data to send data for Jmax face real(kind=wp), private, dimension(:), allocatable :: kmax_send_buf Array to store data to send data for Kmax face real(kind=wp), private, dimension(:), allocatable :: imax_recv_buf Array to store data to receive data for Imax face real(kind=wp), private, dimension(:), allocatable :: jmax_recv_buf Array to store data to receive data for Jmax face real(kind=wp), private, dimension(:), allocatable :: kmax_recv_buf Array to store data to receive data for Kmax face Subroutines public subroutine setup_interface (control, dims) Allocate memory for the data communication between processors Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters: n_var type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine apply_interface (qp, control, bc, dims) MPISEND_RECV call to exchange interface infromation between\n connected blocks. Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2,1:dims%n_var) :: qp Store primitive variable at cell center type( controltype ), intent(in) :: control Control parameters type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine apply_periodic_bc (qp, control, bc, dims) If a block is connected to another block in perodic\nfashion, this subroutine will take care of that boundary condition. Arguments Type Intent Optional Attributes Name real(kind=wp), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2,1:dims%n_var) :: qp Store primitive variable at cell center type( controltype ), intent(in) :: control Control parameters type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/interface1.html","title":"interface1 – FEST-3D"},{"text":"Utility module to allocate, deallocate and debug message Used by module~~utils~~UsedByGraph module~utils utils module~wall_dist wall_dist module~wall_dist->module~utils module~write_output_vtk write_output_vtk module~write_output_vtk->module~utils module~write_output_vtk->module~wall_dist module~viscosity viscosity module~write_output_vtk->module~viscosity module~gradients gradients module~write_output_vtk->module~gradients module~viscosity->module~utils module~viscosity->module~wall_dist module~viscosity->module~gradients module~wall wall module~wall->module~utils module~write_output write_output module~write_output->module~utils module~write_output->module~write_output_vtk module~write_output_tec_node write_output_tec_node module~write_output->module~write_output_tec_node module~write_output_tec write_output_tec module~write_output->module~write_output_tec module~read_output_vtk read_output_vtk module~read_output_vtk->module~utils module~bc bc module~bc->module~utils module~geometry geometry module~geometry->module~utils module~scheme scheme module~scheme->module~utils module~face_interpolant face_interpolant module~scheme->module~face_interpolant module~ausmp ausmP module~scheme->module~ausmp module~source source module~source->module~utils module~source->module~wall_dist module~source->module~viscosity module~source->module~gradients module~cc CC module~source->module~cc module~resnorm resnorm module~resnorm->module~utils module~write_output_tec_node->module~utils module~write_output_tec_node->module~wall_dist module~write_output_tec_node->module~viscosity module~write_output_tec_node->module~gradients module~update update module~update->module~utils module~update->module~wall_dist module~update->module~viscosity module~update->module~scheme module~update->module~source module~interface1 interface1 module~update->module~interface1 module~time time module~update->module~time module~viscous viscous module~update->module~viscous module~plusgs plusgs module~update->module~plusgs module~update->module~gradients module~lusgs lusgs module~update->module~lusgs module~update->module~face_interpolant module~boundary_state_reconstruction boundary_state_reconstruction module~update->module~boundary_state_reconstruction module~bc_primitive bc_primitive module~update->module~bc_primitive module~interface1->module~utils module~time->module~utils module~time->module~viscosity module~time->module~face_interpolant module~viscous->module~utils module~viscous->module~viscosity module~viscous->module~gradients module~state state module~state->module~utils module~read_output read_output module~state->module~read_output module~plusgs->module~utils module~plusgs->module~wall_dist module~plusgs->module~viscosity module~plusgs->module~gradients module~write_output_tec->module~utils module~write_output_tec->module~wall_dist module~write_output_tec->module~viscosity module~write_output_tec->module~gradients module~gradients->module~utils module~cc->module~utils module~cc->module~wall_dist module~dump_solution dump_solution module~dump_solution->module~utils module~dump_solution->module~write_output module~read_output->module~utils module~read_output->module~read_output_vtk module~read_output_tec read_output_tec module~read_output->module~read_output_tec module~lusgs->module~utils module~lusgs->module~wall_dist module~lusgs->module~viscosity module~lusgs->module~gradients module~face_interpolant->module~utils module~read_output_tec->module~utils module~boundary_state_reconstruction->module~face_interpolant module~solver solver module~solver->module~wall_dist module~solver->module~viscosity module~solver->module~wall module~solver->module~bc module~solver->module~geometry module~solver->module~scheme module~solver->module~resnorm module~solver->module~update module~solver->module~interface1 module~solver->module~time module~solver->module~viscous module~solver->module~state module~solver->module~gradients module~solver->module~cc module~solver->module~dump_solution module~ausmp->module~face_interpolant module~bc_primitive->module~wall_dist module~convergence convergence module~convergence->module~resnorm program~main main program~main->module~solver program~main->module~convergence var panmoduleutilsUsedByGraph = svgPanZoom('#moduleutilsUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces alloc Subroutines alloc_rank1_real alloc_rank2_real alloc_rank3_real alloc_rank4_real alloc_rank5_real alloc_rank6_real alloc_rank1_integer alloc_rank2_integer alloc_rank3_integer Interfaces public interface alloc private subroutine alloc_rank1_real (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_real (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_real (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank4_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, errmsg) Allcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank5_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, errmsg) Allcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank6_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, start6, stop6, errmsg) Allcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :,:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension integer, intent(in) :: start6 Starting index of Var array's dimension integer, intent(in) :: stop6 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank1_integer (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_integer (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_integer (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Subroutines private subroutine alloc_rank1_real (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_real (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_real (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank4_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, errmsg) Allcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank5_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, errmsg) Allcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank6_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, start6, stop6, errmsg) Allcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :,:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension integer, intent(in) :: start6 Starting index of Var array's dimension integer, intent(in) :: stop6 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank1_integer (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_integer (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_integer (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful)","tags":"","loc":"module/utils.html","title":"utils – FEST-3D"},{"text":"Reference: Kitamura, K., Shima, E., Fujimoto, K. and Wang, Z.J.,\n Performance of low-dissipation Euler fluxes and preconditioned LU-SGS \n at low speeds, Communications in Computational Physics, vol. 10 no. 1, pp.90-119, 2011 Uses global_sst viscosity utils vartypes gradients global_sa global_kkl wall_dist module~~plusgs~~UsesGraph module~plusgs plusgs module~wall_dist wall_dist module~plusgs->module~wall_dist module~global_kkl global_kkl module~plusgs->module~global_kkl module~global_sst global_sst module~plusgs->module~global_sst module~viscosity viscosity module~plusgs->module~viscosity module~gradients gradients module~plusgs->module~gradients module~utils utils module~plusgs->module~utils module~vartypes vartypes module~plusgs->module~vartypes module~global_sa global_sa module~plusgs->module~global_sa module~wall_dist->module~utils module~wall_dist->module~vartypes iso_fortran_env iso_fortran_env module~global_kkl->iso_fortran_env module~global_sst->iso_fortran_env module~viscosity->module~wall_dist module~viscosity->module~global_kkl module~viscosity->module~global_sst module~viscosity->module~gradients module~viscosity->module~utils module~viscosity->module~vartypes module~viscosity->module~global_sa module~copy_bc copy_bc module~viscosity->module~copy_bc module~gradients->module~utils module~gradients->module~vartypes module~vartypes->iso_fortran_env module~global_sa->iso_fortran_env module~copy_bc->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~plusgs~~UsedByGraph module~plusgs plusgs module~update update module~update->module~plusgs module~solver solver module~solver->module~update program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables delQ delQstar dummy tmu mmu imx jmx kmx n_var gm mu_ref Reynolds_number free_stream_tu tk_inf tkl_inf tPr Pr R_gas MInf Functions Flux SpectralRadius SSTFlux SAFlux lctm2015flux Subroutines setup_plusgs update_with_plusgs update_laminar_variables update_SST_variables update_SA_variables update_lctm2015 Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:,:), allocatable :: delQ Change of state variable (solution) over one time-step real(kind=wp), public, dimension(:,:,:,:), allocatable :: delQstar Intermediate change of state variable over one time-step real(kind=wp), public, dimension(:,:,:), allocatable, target :: dummy Dummy variable real(kind=wp), public, dimension(:,:,:), pointer :: tmu Pointer to turbulent viscosity real(kind=wp), public, dimension(:,:,:), pointer :: mmu Pointer to molecular viscosity integer, public :: imx integer, public :: jmx integer, public :: kmx integer, public :: n_var real(kind=wp), public :: gm real(kind=wp), public :: mu_ref real(kind=wp), public :: Reynolds_number real(kind=wp), public :: free_stream_tu real(kind=wp), public :: tk_inf real(kind=wp), public :: tkl_inf real(kind=wp), public :: tPr real(kind=wp), public :: Pr real(kind=wp), public :: R_gas real(kind=wp), public :: MInf Functions public function Flux (ql, qr, du, inputs) Calculate the total flux through face for laminar flow. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql left state real(kind=wp), intent(in), dimension(1:n_var) :: qr right state real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:7) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) public function SpectralRadius (ql, qr, inputs, c1, c2, eps) Calculated spectral radius Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql left state real(kind=wp), intent(in), dimension(1:n_var) :: qr right state real(kind=wp), intent(in), dimension(1:7) :: inputs real(kind=wp), intent(in), dimension(1:3) :: c1 cell center 1 real(kind=wp), intent(in), dimension(1:3) :: c2 cell center 2 real(kind=wp), intent(in) :: eps Return Value real(kind=wp) public function SSTFlux (ql, qr, du, inputs) Calculate the total flux through face for turbulent flow (SST) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:8) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) public function SAFlux (ql, qr, du, inputs) Calculate the total flux through face for turbulent flow (SA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:7) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) public function lctm2015flux (ql, qr, du, inputs) Calculate the total flux through face for turbulent/transition flow (LCTM2015) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:8) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Subroutines public subroutine setup_plusgs (control, scheme, flow, dims) Allocate array memory for data communication Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_with_plusgs (qp, delta_t, cells, Ifaces, Jfaces, Kfaces, residue, scheme, dims) Time-integrate with LU_SGS method Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center type( schemetype ), intent(in) :: scheme finite-volume Schemes type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_laminar_variables (qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update laminar flow with LU-SGS scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_SST_variables (qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (SST) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_SA_variables (qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (SA) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_lctm2015 (qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS/transition (LCTM2015) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/plusgs.html","title":"plusgs – FEST-3D"},{"text":"Allocate memory to laminar gradients if flow is viscous and\n allocate memory to tubulence gradients base upon the model being used Uses vartypes utils module~~gradients~~UsesGraph module~gradients gradients module~utils utils module~gradients->module~utils module~vartypes vartypes module~gradients->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~gradients~~UsedByGraph module~gradients gradients module~source source module~source->module~gradients module~viscosity viscosity module~source->module~viscosity module~plusgs plusgs module~plusgs->module~gradients module~plusgs->module~viscosity module~write_output_vtk write_output_vtk module~write_output_vtk->module~gradients module~write_output_vtk->module~viscosity module~write_output_tec write_output_tec module~write_output_tec->module~gradients module~write_output_tec->module~viscosity module~lusgs lusgs module~lusgs->module~gradients module~lusgs->module~viscosity module~solver solver module~solver->module~gradients module~solver->module~viscosity module~update update module~solver->module~update module~viscous viscous module~solver->module~viscous module~time time module~solver->module~time module~dump_solution dump_solution module~solver->module~dump_solution module~write_output_tec_node write_output_tec_node module~write_output_tec_node->module~gradients module~write_output_tec_node->module~viscosity module~viscosity->module~gradients module~update->module~gradients module~update->module~source module~update->module~plusgs module~update->module~lusgs module~update->module~viscosity module~update->module~viscous module~update->module~time module~viscous->module~gradients module~viscous->module~viscosity program~main main program~main->module~solver module~time->module~viscosity module~write_output write_output module~write_output->module~write_output_vtk module~write_output->module~write_output_tec module~write_output->module~write_output_tec_node module~dump_solution->module~write_output var panmodulegradientsUsedByGraph = svgPanZoom('#modulegradientsUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables n_grad gradqp_x gradqp_y gradqp_z gradu_x gradu_y gradu_z gradv_x gradv_y gradv_z gradw_x gradw_y gradw_z gradT_x gradT_y gradT_z gradtk_x gradtk_y gradtk_z gradtw_x gradtw_y gradtw_z gradtkl_x gradtkl_y gradtkl_z gradte_x gradte_y gradte_z gradtv_x gradtv_y gradtv_z gradtgm_x gradtgm_y gradtgm_z R_gas imx jmx kmx n_var Derived Types singlesub Subroutines setup_gradients get_n_grad evaluate_all_gradients compute_gradient_G apply_gradient_bc apply_gradient_bc_face Variables Type Visibility Attributes Name Initial integer, public :: n_grad = 4 Number of variable to store gradient for real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: gradqp_x Store gradient of n_grad variables with respect to direction x real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: gradqp_y Store gradient of n_grad variables with respect to direction y real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: gradqp_z Store gradient of n_grad variables with respect to direction z real(kind=wp), public, dimension(:, :, :), pointer :: gradu_x Gradient of variable U with respect to direction x real(kind=wp), public, dimension(:, :, :), pointer :: gradu_y Gradient of variable U with respect to direction y real(kind=wp), public, dimension(:, :, :), pointer :: gradu_z Gradient of variable U with respect to direction z real(kind=wp), public, dimension(:, :, :), pointer :: gradv_x Gradient of variable V with respect to direction x real(kind=wp), public, dimension(:, :, :), pointer :: gradv_y Gradient of variable V with respect to direction y real(kind=wp), public, dimension(:, :, :), pointer :: gradv_z Gradient of variable V with respect to direction z real(kind=wp), public, dimension(:, :, :), pointer :: gradw_x Gradient of variable W with respect to direction x real(kind=wp), public, dimension(:, :, :), pointer :: gradw_y Gradient of variable W with respect to direction y real(kind=wp), public, dimension(:, :, :), pointer :: gradw_z Gradient of variable W with respect to direction z real(kind=wp), public, dimension(:, :, :), pointer :: gradT_x Gradient of variable Temperature with respect to direction x real(kind=wp), public, dimension(:, :, :), pointer :: gradT_y Gradient of variable Temperature with respect to direction y real(kind=wp), public, dimension(:, :, :), pointer :: gradT_z Gradient of variable Temperature with respect to direction z real(kind=wp), public, dimension(:, :, :), pointer :: gradtk_x Gradient of variable turbulent kinetic energy with respect to direction x real(kind=wp), public, dimension(:, :, :), pointer :: gradtk_y Gradient of variable turbulent kinetic energy with respect to direction y real(kind=wp), public, dimension(:, :, :), pointer :: gradtk_z Gradient of variable turbulent kinetic energy with respect to direction z real(kind=wp), public, dimension(:, :, :), pointer :: gradtw_x Gradient of variable dissipation rate with respect to direction x real(kind=wp), public, dimension(:, :, :), pointer :: gradtw_y Gradient of variable dissipation rate with respect to direction y real(kind=wp), public, dimension(:, :, :), pointer :: gradtw_z Gradient of variable dissipation rate with respect to direction z real(kind=wp), public, dimension(:, :, :), pointer :: gradtkl_x Gradient of variable kL with respect to direction x real(kind=wp), public, dimension(:, :, :), pointer :: gradtkl_y Gradient of variable kL with respect to direction y real(kind=wp), public, dimension(:, :, :), pointer :: gradtkl_z Gradient of variable kL with respect to direction z real(kind=wp), public, dimension(:, :, :), pointer :: gradte_x Gradient of variable turbulent energy dissiaption with respect to direction x real(kind=wp), public, dimension(:, :, :), pointer :: gradte_y Gradient of variable turbulent energy dissiaption with respect to direction y real(kind=wp), public, dimension(:, :, :), pointer :: gradte_z Gradient of variable turbulent energy dissiaption with respect to direction z real(kind=wp), public, dimension(:, :, :), pointer :: gradtv_x Gradient of variable turbulenct visocity(SA mode) with respect to direction x real(kind=wp), public, dimension(:, :, :), pointer :: gradtv_y Gradient of variable turbulenct visocity(SA mode) with respect to direction y real(kind=wp), public, dimension(:, :, :), pointer :: gradtv_z Gradient of variable turbulenct visocity(SA mode) with respect to direction z real(kind=wp), public, dimension(:, :, :), pointer :: gradtgm_x Gradient of variable intermittency with respect to direction x real(kind=wp), public, dimension(:, :, :), pointer :: gradtgm_y Gradient of variable intermittency with respect to direction y real(kind=wp), public, dimension(:, :, :), pointer :: gradtgm_z Gradient of variable intermittency with respect to direction z real(kind=wp), public :: R_gas integer, public :: imx integer, public :: jmx integer, public :: kmx integer, public :: n_var Derived Types type, public :: singlesub Components Type Visibility Attributes Name Initial integer, public :: imin integer, public :: imax integer, public :: il integer, public :: iu integer, public :: jmin integer, public :: jmax integer, public :: jl integer, public :: ju integer, public :: kmin integer, public :: kmax integer, public :: kl integer, public :: ku integer, public :: sig = 1 Subroutines public subroutine setup_gradients (control, scheme, flow, dims) Memoery allocation to the gradient variables and \n setup pointer to the slice to the main gradient variable\n based on the various models being used. Read more… Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine get_n_grad (scheme) Set number of variables for which\n gradient is required based on the\n being used Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme finite-volume Schemes public subroutine evaluate_all_gradients (qp, Temp, cells, Ifaces, Jfaces, Kfaces, scheme, bc, dims) Call to all the required gradients and \n apply boundary condition for ghost cell\n gradients Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), Target :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2) :: Temp Store Temperature variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( schemetype ), intent(in) :: scheme finite-volume Schemes type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_gradient_G (grad, var, cells, Ifaces, Jfaces, Kfaces, dims, dir) Compute gradient of any input scalar Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension( 0:dims%imx  , 0:dims%jmx  , 0:dims%kmx  ) :: grad Output variable storing the graident of var real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: var Input variable of which graident is required type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims character(len=*), intent(in) :: dir Direction with respect to which gradients are calculated public subroutine apply_gradient_bc (qp, Temp, cells, Ifaces, Jfaces, Kfaces, bc, dims) Call same subroutine for all the face\n Apply/set value of all gradient in the ghost cells\n gradqp_G = (qp_I - qp_G) Area_W unit_normal_G/(volume_G)\n volume_G = volume_I Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2, 1:dims%n_var) :: qp Input variable of which graident is required real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2) :: Temp Intput Temperature variable type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine apply_gradient_bc_face (qp, Temp, cells, faces, dims, domain, bc_id, fixed_temp) Call same subroutine for all the face\n Apply/set value of all gradient in the ghost cells\n gradqp_G = (qp_I - qp_G) Area_W unit_normal_G/(volume_G)\n volume_G = volume_I Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2, 1:dims%n_var) :: qp Input variable of which graident is required real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2) :: Temp Intput Temperature variable type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: faces Input varaible which stores any(I,J,K) faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx type( singlesub ), intent(in) :: domain flags for direction integer, intent(in) :: bc_id real(kind=wp), intent(in) :: fixed_temp","tags":"","loc":"module/gradients.html","title":"gradients – FEST-3D"},{"text":"Calculate the time step for the current iteration Uses face_interpolant mpi utils read viscosity vartypes module~~time~~UsesGraph module~time time module~read read module~time->module~read module~face_interpolant face_interpolant module~time->module~face_interpolant mpi mpi module~time->mpi module~viscosity viscosity module~time->module~viscosity module~utils utils module~time->module~utils module~vartypes vartypes module~time->module~vartypes module~read->module~vartypes module~face_interpolant->module~utils module~face_interpolant->module~vartypes module~ppm ppm module~face_interpolant->module~ppm module~muscl muscl module~face_interpolant->module~muscl module~weno weno module~face_interpolant->module~weno module~weno_nm weno_NM module~face_interpolant->module~weno_nm module~viscosity->module~utils module~viscosity->module~vartypes module~global_kkl global_kkl module~viscosity->module~global_kkl module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sst global_sst module~viscosity->module~global_sst module~gradients gradients module~viscosity->module~gradients module~global_sa global_sa module~viscosity->module~global_sa module~wall_dist wall_dist module~viscosity->module~wall_dist iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~ppm->module~vartypes module~muscl->module~vartypes module~global_kkl->iso_fortran_env module~copy_bc->module~vartypes module~global_sst->iso_fortran_env module~weno->module~vartypes module~gradients->module~utils module~gradients->module~vartypes module~weno_nm->module~vartypes module~global_sa->iso_fortran_env module~wall_dist->module~utils module~wall_dist->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~time~~UsedByGraph module~time time module~solver solver module~solver->module~time module~update update module~solver->module~update module~update->module~time program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables nb_ticks_initial nb_ticks_final nb_ticks_max nb_ticks_sec nb_ticks elapsed_time t1 t2 cpu_time_elapsed sim_clock imx jmx kmx n_var Functions write_time Subroutines setup_time destroy_time compute_local_time_step compute_global_time_step compute_time_step update_simulation_clock add_viscous_time add_turbulent_time Variables Type Visibility Attributes Name Initial integer, private :: nb_ticks_initial Initial value of the clock tick counter\n Final value of the clock tick counter\n Maximum value of the clock counter\n Number of clock ticks per second\n Number of clock ticks of the code integer, private :: nb_ticks_final Initial value of the clock tick counter\n Final value of the clock tick counter\n Maximum value of the clock counter\n Number of clock ticks per second\n Number of clock ticks of the code integer, private :: nb_ticks_max Initial value of the clock tick counter\n Final value of the clock tick counter\n Maximum value of the clock counter\n Number of clock ticks per second\n Number of clock ticks of the code integer, private :: nb_ticks_sec Initial value of the clock tick counter\n Final value of the clock tick counter\n Maximum value of the clock counter\n Number of clock ticks per second\n Number of clock ticks of the code integer, private :: nb_ticks Initial value of the clock tick counter\n Final value of the clock tick counter\n Maximum value of the clock counter\n Number of clock ticks per second\n Number of clock ticks of the code real(kind=wp), private :: elapsed_time real(wp) time in seconds real(kind=wp), private :: t1 Start clock time real(kind=wp), private :: t2 Finish clock time real(kind=wp), private :: cpu_time_elapsed real(kind=wp), private :: sim_clock = 0.0 integer, private :: imx integer, private :: jmx integer, private :: kmx integer, private :: n_var Functions private function write_time (time_in_seconds) result(string) Particular format to write time in output log file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: time_in_seconds Time to output Return Value character(len=64) Time as string in particlar format Subroutines public subroutine setup_time (delta_t, control, dims) Allocate memeroy and setup initial clock Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:,:,:), allocatable :: delta_t Local time increment value at each cell center type( controltype ), intent(in) :: control Control parameters type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine destroy_time (control) Deallocate memory and find simulation time. Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters private subroutine compute_local_time_step (qp, delta_t, cells, Ifaces, Jfaces, Kfaces, CFL, scheme, flow, dims) Compute the time step to be used at each cell center Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces real(kind=wp), intent(in) :: CFL CFL number type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine compute_global_time_step (qp, delta_t, cells, Ifaces, Jfaces, Kfaces, CFL, scheme, flow, dims) Compute a common time step to be used at all cell centers Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces real(kind=wp), intent(in) :: CFL CFL number type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_time_step (qp, delta_t, CFL, cells, Ifaces, Jfaces, Kfaces, scheme, flow, dims) Compute the time step to be used Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center real(kind=wp), intent(in) :: CFL CFL number type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_simulation_clock (delta_t, scheme, dims) Update the simulation clock Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( schemetype ), intent(in) :: scheme finite-volume Schemes: time stepping methods type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine add_viscous_time (qp, delta_t, cells, Ifaces, Jfaces, Kfaces, CFL, flow, dims) Addition to local time step due to viscous effects Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces real(kind=wp), intent(in) :: CFL CFL number type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine add_turbulent_time (qp, delta_t, cells, Ifaces, Jfaces, Kfaces, CFL, flow, dims) Addition to local time step due to turbulence Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces real(kind=wp), intent(in) :: CFL CFL number type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/time.html","title":"time – FEST-3D"},{"text":"Allocate memory to the state variables and initialize them\n The state of the system is defined using the density, velocity and\n pressure (primitive variables qp), and trubulent and transition\n variables at the cell-center points. Uses read_output check_output_control vartypes utils module~~state~~UsesGraph module~state state module~utils utils module~state->module~utils module~check_output_control check_output_control module~state->module~check_output_control module~read_output read_output module~state->module~read_output module~vartypes vartypes module~state->module~vartypes module~check_output_control->module~vartypes module~read_output->module~utils module~read_output->module~check_output_control module~read_output->module~vartypes module~read_output_vtk read_output_vtk module~read_output->module~read_output_vtk module~read_output_tec read_output_tec module~read_output->module~read_output_tec iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~read_output_vtk->module~utils module~read_output_vtk->module~vartypes module~read_output_tec->module~utils module~read_output_tec->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~state~~UsedByGraph module~state state module~solver solver module~solver->module~state program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables n_var imx jmx kmx Functions sound_speed_inf Subroutines setup_state init_infinity_values initstate init_state_with_infinity_values set_n_var_value Variables Type Visibility Attributes Name Initial integer, private :: n_var integer, private :: imx integer, private :: jmx integer, private :: kmx Functions private function sound_speed_inf (flow) result(a) Return the free stream speed of sound. Arguments Type Intent Optional Attributes Name type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. Return Value real(kind=wp) output variable: speed of sound Subroutines public subroutine setup_state (files, qp, control, scheme, flow, dims) Setup the state module.\n This subroutine should be run before the state variables\n are initilized. This subroutine allocates the memory for \n state variables and sets up the aliases to refer to the \n components of the state Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files Files' name and handler real(kind=wp), intent(inout), dimension(:,:,:,:), allocatable, target :: qp Store primitive variable at cell center type( controltype ), intent(inout) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(inout) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(inout) :: dims Extent of the domain:imx,jmx,kmx private subroutine init_infinity_values (scheme, flow) Set the values of the infinity variables \"qp_inf\" Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme finite-volume Schemes: turbulence, transition model, etc type( flowtype ), intent(inout) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. private subroutine initstate (files, qp, control, scheme, flow, dims) Initialize the state.\n If load file(start_from) is 0, then the state should be \n set to the infinity values. Otherwise, read the state_file\n to get the state values Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files Files' name and handler real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center type( controltype ), intent(inout) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine init_state_with_infinity_values (qp, scheme, flow, dims) Initialize the state based on the infinity values Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp Store primitive variable at cell center type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine set_n_var_value (control, scheme) Set number of variable to solver for based on\n the tubulence and transition model being used Arguments Type Intent Optional Attributes Name type( controltype ), intent(inout) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes","tags":"","loc":"module/state.html","title":"state – FEST-3D"},{"text":"In order to calculate pressure gradient in the transition model, two\n quantities are required: the distance of the cell-center from the wall \n andn the normal made by the distance vector field (from wall to cell-center).\n This module calucate both with gradient of V.n also. Uses utils vartypes wall_dist module~~cc~~UsesGraph module~cc CC module~utils utils module~cc->module~utils module~vartypes vartypes module~cc->module~vartypes module~wall_dist wall_dist module~cc->module~wall_dist iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~wall_dist->module~utils module~wall_dist->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~cc~~UsedByGraph module~cc CC module~source source module~source->module~cc module~solver solver module~solver->module~cc module~update update module~solver->module~update program~main main program~main->module~solver module~update->module~source Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables CCnormalX CCnormalY CCnormalZ CCVn DCCVnX DCCVnY DCCVnZ Subroutines setupCC find_CCnormal find_CCVn find_DCCVn compute_gradient Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:, :, :), allocatable :: CCnormalX Cell-Center normal nx with respect to wall; used for transition model (pressure gradient calcualtion) real(kind=wp), public, dimension(:, :, :), allocatable :: CCnormalY Cell-Center normal ny with respect to wall; used for transiton model (pressure gradient calculation) real(kind=wp), public, dimension(:, :, :), allocatable :: CCnormalZ Cell-Center normal nz with respect to wall; used for transiton model (pressure gradient calculation) real(kind=wp), private, dimension(:, :, :), allocatable :: CCVn Store value at Cell-Center of dot product between velocity vector and cell-center normal. {vec(Velocity).normal} real(kind=wp), public, dimension(:, :, :), allocatable :: DCCVnX Store Derivative of Cell-Center CCVn with respect to x real(kind=wp), public, dimension(:, :, :), allocatable :: DCCVnY Store Derivative of Cell-Center CCVn with respect to y real(kind=wp), public, dimension(:, :, :), allocatable :: DCCVnZ Store Derivative of Cell-Center CCVn with respect to z Subroutines public subroutine setupCC (scheme, cells, Ifaces, Jfaces, Kfaces, dims) Allocate memory for the cell center variable only in case of transition model Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims private subroutine find_CCnormal (cells, Ifaces, Jfaces, Kfaces, dims) Find the cell-center unit normal Arguments Type Intent Optional Attributes Name type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims private subroutine find_CCVn (qp, dims) Taking a dot product between Cell-center velocity and unit normal Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx,-2:dims%jmx,-2:dims%kmx,-2:dims%n_var) :: qp type( extent ), intent(in) :: dims public subroutine find_DCCVn (qp, cells, Ifaces, Jfaces, Kfaces, dims) Find gradient of the dot product between cell velocity and unit normal Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx,-2:dims%jmx,-2:dims%kmx,-2:dims%n_var) :: qp type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims private subroutine compute_gradient (grad, var, cells, Ifaces, Jfaces, Kfaces, dir, dims) Generalized subroutine to calculate gradients Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: grad real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: var type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal character(len=*), intent(in) :: dir type( extent ), intent(in) :: dims","tags":"","loc":"module/cc.html","title":"CC – FEST-3D"},{"text":"The viscous module contains the viscous fluxes calculations Uses global_sst utils gradients global_kkl global_sa viscosity vartypes module~~viscous~~UsesGraph module~viscous viscous module~global_kkl global_kkl module~viscous->module~global_kkl module~global_sst global_sst module~viscous->module~global_sst module~viscosity viscosity module~viscous->module~viscosity module~gradients gradients module~viscous->module~gradients module~utils utils module~viscous->module~utils module~vartypes vartypes module~viscous->module~vartypes module~global_sa global_sa module~viscous->module~global_sa iso_fortran_env iso_fortran_env module~global_kkl->iso_fortran_env module~global_sst->iso_fortran_env module~viscosity->module~global_kkl module~viscosity->module~global_sst module~viscosity->module~gradients module~viscosity->module~utils module~viscosity->module~vartypes module~viscosity->module~global_sa module~copy_bc copy_bc module~viscosity->module~copy_bc module~wall_dist wall_dist module~viscosity->module~wall_dist module~gradients->module~utils module~gradients->module~vartypes module~vartypes->iso_fortran_env module~global_sa->iso_fortran_env module~copy_bc->module~vartypes module~wall_dist->module~utils module~wall_dist->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~viscous~~UsedByGraph module~viscous viscous module~solver solver module~solver->module~viscous module~update update module~solver->module~update module~update->module~viscous program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables imx jmx kmx Subroutines compute_viscous_fluxes compute_viscous_fluxes_laminar compute_viscous_fluxes_sst compute_viscous_fluxes_kkl compute_viscous_fluxes_sa compute_viscous_fluxes_lctm2015 Variables Type Visibility Attributes Name Initial integer, private :: imx integer, private :: jmx integer, private :: kmx Subroutines public subroutine compute_viscous_fluxes (F, G, H, qp, cells, Ifaces, Jfaces, Kfaces, scheme, flow, dims) Call to all viscous flux subroutine based on \n the drection and turbulence/transition model being\n used Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F real(kind=wp), intent(inout), dimension(:, :, :, :) :: G real(kind=wp), intent(inout), dimension(:, :, :, :) :: H real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine compute_viscous_fluxes_laminar (F, qp, cells, faces, flags, scheme, flow, dims) Compute viscous fluxes for first five Navier-Stokes equation Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Flux array real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine compute_viscous_fluxes_sst (F, qp, cells, faces, flags, dims) Compute viscous fluxes for additianal equations due to SST turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F flux array real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces quantities on the face integer, intent(in), dimension(3) :: flags flags for direction swithc type( extent ), intent(in) :: dims Extent of the domain: imx,jmx,kmx private subroutine compute_viscous_fluxes_kkl (F, qp, cells, faces, flags, dims) Compute viscous fluxes for additianal equations due to k-kL turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Flux array real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for directions switch type( extent ), intent(in) :: dims Extent of the domain: imx,jmx,kmx private subroutine compute_viscous_fluxes_sa (F, qp, cells, faces, flags, dims) Compute viscous fluxes for additianal equations due to SA turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Flux array real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( extent ), intent(in) :: dims Extent of the domain: imx,jmx,kmx private subroutine compute_viscous_fluxes_lctm2015 (F, qp, cells, faces, flags, dims) Compute viscous fluxes for additianal equations due to LCTM2015 transition model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Flux array real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( extent ), intent(in) :: dims Extent of the doamin:imx,jmx,kmx","tags":"","loc":"module/viscous.html","title":"viscous – FEST-3D"},{"text":"Add source's contribution to the residual Uses global_sst CC global_sa utils vartypes gradients viscosity global_kkl wall_dist module~~source~~UsesGraph module~source source module~wall_dist wall_dist module~source->module~wall_dist module~global_kkl global_kkl module~source->module~global_kkl module~global_sst global_sst module~source->module~global_sst module~viscosity viscosity module~source->module~viscosity module~gradients gradients module~source->module~gradients module~utils utils module~source->module~utils module~cc CC module~source->module~cc module~vartypes vartypes module~source->module~vartypes module~global_sa global_sa module~source->module~global_sa module~wall_dist->module~utils module~wall_dist->module~vartypes iso_fortran_env iso_fortran_env module~global_kkl->iso_fortran_env module~global_sst->iso_fortran_env module~viscosity->module~wall_dist module~viscosity->module~global_kkl module~viscosity->module~global_sst module~viscosity->module~gradients module~viscosity->module~utils module~viscosity->module~vartypes module~viscosity->module~global_sa module~copy_bc copy_bc module~viscosity->module~copy_bc module~gradients->module~utils module~gradients->module~vartypes module~cc->module~wall_dist module~cc->module~utils module~cc->module~vartypes module~vartypes->iso_fortran_env module~global_sa->iso_fortran_env module~copy_bc->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~source~~UsedByGraph module~source source module~update update module~update->module~source module~solver solver module~solver->module~update program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines add_source_term_residue add_sst_source add_sst_source_lctm2015 add_sst_bc_source add_kkl_source add_sa_source add_saBC_source Subroutines public subroutine add_source_term_residue (qp, residue, cells, Ifaces, Jfaces, Kfaces, scheme, flow, dims) Call to add different source terms to the residual of different equations. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine add_sst_source (qp, residue, cells, scheme, dims) Add residual due to source terms of the SST turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume\n Store residue at each cell-center type( schemetype ), intent(in) :: scheme finite-volume Schemes type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine add_sst_source_lctm2015 (qp, residue, cells, Ifaces, Jfaces, Kfaces, scheme, dims) Add residual due to source terms of the LCTM2015 transition model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( schemetype ), intent(in) :: scheme finite-volume Schemes type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine add_sst_bc_source (qp, residue, cells, flow, dims) Add residual due to source terms of the SST-BC transition model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine add_kkl_source (qp, residue, cells, Ifaces, Jfaces, Kfaces, dims) Add residual due to source terms of the k-kL turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine add_sa_source (qp, residue, cells, Ifaces, Jfaces, Kfaces, dims) Add residual due to source terms of SA turbulence model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine add_saBC_source (qp, residue, cells, Ifaces, Jfaces, Kfaces, flow, dims) Add residual due to source terms of SABC transition model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/source.html","title":"source – FEST-3D"},{"text":"Derived data types Uses iso_fortran_env module~~vartypes~~UsesGraph module~vartypes vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~vartypes~~UsedByGraph module~vartypes vartypes module~mapping mapping module~mapping->module~vartypes module~wall_dist wall_dist module~wall_dist->module~vartypes module~check_output_control check_output_control module~check_output_control->module~vartypes module~write_output_vtk write_output_vtk module~write_output_vtk->module~vartypes module~write_output_vtk->module~wall_dist module~viscosity viscosity module~write_output_vtk->module~viscosity module~gradients gradients module~write_output_vtk->module~gradients module~viscosity->module~vartypes module~viscosity->module~wall_dist module~copy_bc copy_bc module~viscosity->module~copy_bc module~viscosity->module~gradients module~weno weno module~weno->module~vartypes module~wall wall module~wall->module~vartypes module~write_output write_output module~write_output->module~vartypes module~write_output->module~write_output_vtk module~write_output_tec_node write_output_tec_node module~write_output->module~write_output_tec_node module~write_output_tec write_output_tec module~write_output->module~write_output_tec module~cc CC module~cc->module~vartypes module~cc->module~wall_dist module~read_output_vtk read_output_vtk module~read_output_vtk->module~vartypes module~bc bc module~bc->module~vartypes module~read_bc read_bc module~bc->module~read_bc module~weno_nm weno_NM module~weno_nm->module~vartypes module~geometry geometry module~geometry->module~vartypes module~read read module~read->module~vartypes module~van_leer van_leer module~van_leer->module~vartypes module~scheme scheme module~scheme->module~vartypes module~scheme->module~van_leer module~ausmp ausmP module~scheme->module~ausmp module~ausmup ausmUP module~scheme->module~ausmup module~slau slau module~scheme->module~slau module~ausm ausm module~scheme->module~ausm module~face_interpolant face_interpolant module~scheme->module~face_interpolant module~ldfss0 ldfss0 module~scheme->module~ldfss0 module~read_output_tec read_output_tec module~read_output_tec->module~vartypes module~source source module~source->module~vartypes module~source->module~wall_dist module~source->module~viscosity module~source->module~cc module~source->module~gradients module~bc_primitive bc_primitive module~bc_primitive->module~vartypes module~bc_primitive->module~wall_dist module~bc_primitive->module~copy_bc module~ft_bc FT_bc module~bc_primitive->module~ft_bc module~copy_bc->module~vartypes module~resnorm resnorm module~resnorm->module~vartypes module~write_output_tec_node->module~vartypes module~write_output_tec_node->module~wall_dist module~write_output_tec_node->module~viscosity module~write_output_tec_node->module~gradients module~update update module~update->module~vartypes module~update->module~wall_dist module~update->module~viscosity module~update->module~scheme module~update->module~source module~update->module~bc_primitive module~interface1 interface1 module~update->module~interface1 module~time time module~update->module~time module~viscous viscous module~update->module~viscous module~plusgs plusgs module~update->module~plusgs module~update->module~gradients module~boundary_state_reconstruction boundary_state_reconstruction module~update->module~boundary_state_reconstruction module~lusgs lusgs module~update->module~lusgs module~update->module~face_interpolant module~interface1->module~vartypes module~interface1->module~mapping module~time->module~vartypes module~time->module~viscosity module~time->module~read module~time->module~face_interpolant module~convergence convergence module~convergence->module~vartypes module~convergence->module~resnorm module~viscous->module~vartypes module~viscous->module~viscosity module~viscous->module~gradients module~state state module~state->module~vartypes module~state->module~check_output_control module~read_output read_output module~state->module~read_output module~ausmp->module~vartypes module~ausmp->module~face_interpolant module~ppm ppm module~ppm->module~vartypes module~layout layout module~layout->module~vartypes module~ft_bc->module~vartypes module~ft_bc->module~copy_bc module~plusgs->module~vartypes module~plusgs->module~wall_dist module~plusgs->module~viscosity module~plusgs->module~gradients module~write_output_tec->module~vartypes module~write_output_tec->module~wall_dist module~write_output_tec->module~viscosity module~write_output_tec->module~gradients module~solver solver module~solver->module~vartypes module~solver->module~wall_dist module~solver->module~viscosity module~solver->module~wall module~solver->module~cc module~solver->module~bc module~solver->module~geometry module~solver->module~read module~solver->module~scheme module~solver->module~resnorm module~solver->module~update module~solver->module~interface1 module~solver->module~time module~solver->module~viscous module~solver->module~state module~solver->module~layout module~solver->module~gradients module~dump_solution dump_solution module~solver->module~dump_solution module~grid grid module~solver->module~grid module~gradients->module~vartypes module~boundary_state_reconstruction->module~vartypes module~boundary_state_reconstruction->module~face_interpolant module~ausmup->module~vartypes module~slau->module~vartypes module~dump_solution->module~vartypes module~dump_solution->module~write_output module~dump_solution->module~layout module~read_bc->module~vartypes module~ausm->module~vartypes module~grid->module~vartypes module~grid->module~mapping module~muscl muscl module~muscl->module~vartypes module~lusgs->module~vartypes module~lusgs->module~wall_dist module~lusgs->module~viscosity module~lusgs->module~gradients module~face_interpolant->module~vartypes module~face_interpolant->module~weno module~face_interpolant->module~weno_nm module~face_interpolant->module~ppm module~face_interpolant->module~muscl module~ldfss0->module~vartypes module~read_output->module~vartypes module~read_output->module~check_output_control module~read_output->module~read_output_vtk module~read_output->module~read_output_tec program~main main program~main->module~convergence program~main->module~solver var panmodulevartypesUsedByGraph = svgPanZoom('#modulevartypesUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables process_id FILE_NAME_LENGTH STRING_BUFFER_LENGTH FORMAT_LENGTH Derived Types nodetype extent celltype facetype filetype controltype schemetype flowtype boundarytype Variables Type Visibility Attributes Name Initial integer, public :: process_id = 0 Id no. of each processor assinged by MPICH library integer, public, parameter :: FILE_NAME_LENGTH = 64 Length of string used for defining any filename integer, public, parameter :: STRING_BUFFER_LENGTH = 128 User to define a string of medium length integer, public, parameter :: FORMAT_LENGTH = 16 Length of string used for file format: tecplot or vtk Derived Types type, public :: nodetype Components Type Visibility Attributes Name Initial real(kind=wp), public :: x real(kind=wp), public :: y real(kind=wp), public :: z type, public :: extent Components Type Visibility Attributes Name Initial integer, public :: imx integer, public :: jmx integer, public :: kmx integer, public :: n_var type, public :: celltype Components Type Visibility Attributes Name Initial real(kind=wp), public :: volume Store cell volume real(kind=wp), public :: centerx real(kind=wp), public :: centery real(kind=wp), public :: centerz Store Cell-center location type, public :: facetype Components Type Visibility Attributes Name Initial real(kind=wp), public :: A Store magnitude of face area vector of direction faces real(kind=wp), public :: nx real(kind=wp), public :: ny real(kind=wp), public :: nz Store unit face normal vector for all faces type, public :: filetype Components Type Visibility Attributes Name Initial integer, public :: CONFIG_FILE_UNIT = 16 Handler unit for config.md file integer, public :: GRID_FILE_UNIT = 17 Handler for input Gridfile; eg: grid_00.txt integer, public :: BOUNDARY_CONDITIONS_FILE_UNIT = 18 Handler for Boundary condition file; eg: bc_00.md Read more… integer, public :: IN_FILE_UNIT = 19 Handler for restart file for block: eg: time_drectories/0001/process_00.dat integer, public :: OUT_FILE_UNIT = 20 Handler for output file for each block integer, public :: RESNORM_FILE_UNIT = 21 Handler for Residual output file. filename: time_directories/aux/resnorm integer, public :: LAYOUT_FILE_UNIT = 31 Handler for input multi-block layout and boundary condition file. integer, public :: NODESURF_FILE_UNIT = 32 Handler for storing node point on the wall Read more… integer, public :: RES_CONTROL_FILE_UNIT = 34 Handler for residual control file. filename: system/res_control.md Read more… integer, public :: CONTROL_FILE_UNIT = 36 Handler for input system/control.md file integer, public :: SCHEME_FILE_UNIT = 37 Handler for input system/fvscheme.md file integer, public :: FLOW_FILE_UNIT = 38 Handler for input system/flow.md  file integer, public :: RESTART_FILE_UNIT = 39 Handler for Restart file in Restart folder. eg: time_directories/0001/Restart/process_00 integer, public :: OUTIN_FILE_UNIT = 40 Handler for file which controls what variables will be read or stored. system/output_control.md integer, public :: MAP_FILE_UNIT = 41 Handler for input multi-block mapping file with index and direction. integer, public :: PERIODIC_FILE_UNIT = 42 Handler for input periodic boundary condition file integer, public :: STOP_FILE_UNIT = 43 Handler for Stop file character(len=FILE_NAME_LENGTH), public :: control_file = \"system/control.md\" FILENAME string: Control file character(len=FILE_NAME_LENGTH), public :: scheme_file = \"system/fvscheme.md\" FILENAME string: Scheme file character(len=FILE_NAME_LENGTH), public :: flow_file = \"system/flow.md\" FILENAME string: FLow condition file character(len=FILE_NAME_LENGTH), public :: outin_file = \"system/output_control.md\" FILENAME string: Ouput/Input variable control file character(len=FILE_NAME_LENGTH), public :: layout_file = 'system/mesh/layout/layout.md' FILENAME string: Multiple layout/boundary condition file character(len=FILE_NAME_LENGTH), public :: nodefile_temp = \"scratch.dat\" FILENAME string: Temperory file for nodesurface points character(len=FILE_NAME_LENGTH), public :: surface_node_points = 'time_directories/aux/surfnode.dat' FILENAME string: Wall surface node points character(len=FILE_NAME_LENGTH), public :: res_control_file = 'system/res_control.md' FILENAME string: Residual write control file character(len=FILE_NAME_LENGTH), public :: resnorm_file = 'time_directories/aux/resnorm' FILENAME string: Residual output file character(len=FILE_NAME_LENGTH), public :: stop_file = 'system/stopfile' FILENAME string: Halt/stop file character(len=FILE_NAME_LENGTH), public :: mapfile = 'system/mesh/layout/mapping.txt' FILENAME string: Detailed multiblock mapping file with indicies and direction information at interface character(len=FILE_NAME_LENGTH), public :: periodicfile = 'system/mesh/layout/periodic.txt' FILENAME string: Multiblock periodic boundary condition detials character(len=FILE_NAME_LENGTH), public :: gridfile FILENAME string: Grid file character(len=FILE_NAME_LENGTH), public :: bcfile FILENAME string: single block boundary condition detials character(len=FILE_NAME_LENGTH), public :: outfile FILENAME string: single block solution output file character(len=FILE_NAME_LENGTH), public :: infile FILENAME string: single block solution input file character(len=FILE_NAME_LENGTH), public :: restartfile FILENAME string: single block restart file type, public :: controltype Components Type Visibility Attributes Name Initial real(kind=wp), public :: CFL = 1.0 Courant–Friedrichs–Lewy (CFL) (Read from input) integer, public :: start_from = 0 Number of the folder (in time_directories) to load stored state from to restart computation integer, public :: min_iter = 1 Minimum iteration value, starting iteration value integer, public :: max_iters = 1 Maximum iteration value, stop after these many iteration integer, public :: checkpoint_iter = 0 Write interval for output file. Number of iteration after which solver will dump/store a state in a folder in time_directories integer, public :: checkpoint_iter_count = 0 Counter of folder number to write in time_directories/ integer, public :: current_iter = 0 Current iteration number integer, public :: res_write_interval = 10 Write resnorm after every \"res_write_interval\" iteration integer, public :: purge_write = 1 Remove unwanted folder. If Purge_write=2, latest two folder in time_direcotires are kept and 0=no purge integer, public :: last_iter = 0 Last iteration that is stored in the restart file integer, public :: write_percision = 6 Number of place after decimal. Only used for resnorm file character(len=FORMAT_LENGTH), public :: write_data_format = 'ASCII' write data type. Either ASCII or BINARY character(len=FORMAT_LENGTH), public :: write_file_format = 'tecplot' Write file type. Either vtk or tecplot character(len=FORMAT_LENGTH), public :: read_data_format = 'ASCII' Read data type in file. Either ASCII or BINARY character(len=FORMAT_LENGTH), public :: read_file_format = 'tecplot' Read file type. Either vtk or tecplot real(kind=wp), public :: tolerance = 1e-14 Minimum value of resnorm after which simulation stop character(len=STRING_BUFFER_LENGTH), public :: tolerance_type = \"abs\" Type of tolerance to check:absolute or relative integer, public :: DEBUG_LEVEL = 1 Debug level is an input from the control file.\n 5-> important calls only, and, \n 1-> all the calls character(len=STRING_BUFFER_LENGTH), public :: previous_flow_type = \"none\" Type of flow:inviscid, laminar, etc, stored in the load file integer, public :: n_var = 5 character(len=STRING_BUFFER_LENGTH), public, dimension(:), allocatable :: r_list Read variable list character(len=STRING_BUFFER_LENGTH), public, dimension(:), allocatable :: w_list Write variable list integer, public :: r_count = 0 Number of variable to read from the restart file integer, public :: w_count = 0 Number of variable to write in the output file character(len=STRING_BUFFER_LENGTH), public, dimension(:), allocatable :: Res_list Write residual variable list integer, public :: Res_count No of residual variable to save integer, public :: total_process = 1 Total number of process to be used for computation integer, public :: process_id = 0 Id no. of each processor assinged by MPICH library integer, public :: want_to_stop = 0 0: continue the solver; 1=Stop the solver logical, public :: Halt = .FALSE. Logical value used to stop the solver in main program file. real(kind=wp), public, dimension(:), allocatable :: previous_res starting resnrom of previous run type, public :: schemetype Components Type Visibility Attributes Name Initial character(len=STRING_BUFFER_LENGTH), public :: scheme_name = 'ausm' Flux Scheme to use: ausm, ldfss0, vanleer, ausmup, ausmp, slau character(len=STRING_BUFFER_LENGTH), public :: interpolant = 'muscl' Face state reconstruction  method to user: muscl, ppm, none, weno, and wenoNM real(kind=wp), public :: global_time_step = 1e-5 Value of global time step to march the solution with character, public :: time_stepping_method = 'l' Either local time stepping or global time stepping character(len=STRING_BUFFER_LENGTH), public :: time_step_accuracy = 'implicit' Type of time_integration scheme: RK4, none(firt order explicit) implicit, integer, public :: ilimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for I direction faces. integer, public :: jlimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for J direction faces. integer, public :: klimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for K direction faces. integer, public :: itlimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for I direction faces. integer, public :: jtlimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for J direction faces. integer, public :: ktlimiter_switch = 1 Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for K direction faces. integer, public :: iPB_switch = 0 Turn on/off application of pressure based switching for higher order methods for I direction faces. integer, public :: jPB_switch = 0 Turn on/off application of pressure based switching for higher order methods for J direction faces. integer, public :: kPB_switch = 0 Turn on/off application of pressure based switching for higher order methods for K direction faces. character(len=8), public :: turbulence = 'none' Store Turbulence model name character(len=8), public :: transition = 'none' Store Transition model name integer, public :: accur = 1 Switch for higher order boundary condition type, public :: flowtype Components Type Visibility Attributes Name Initial real(kind=wp), public :: density_inf = 1.2 Read freestream Density from control file real(kind=wp), public :: x_speed_inf = 100.0 Read freestream U from control file real(kind=wp), public :: y_speed_inf = 0.0 Read freestream V from control file real(kind=wp), public :: z_speed_inf = 0.0 Read freestream W from control file real(kind=wp), public :: pressure_inf = 101325 Read freestream Pressure from control file real(kind=wp), public :: tk_inf = 0.0 Read freestream turbulent kinetic energy rate from control file real(kind=wp), public :: tw_inf = 0.0 Read freestream turbulent dissipation rate from control file real(kind=wp), public :: te_inf = 0.0 Read freestream turbulent dissipation from control file real(kind=wp), public :: tv_inf = 0.0 Read freestream turbulent viscosity(SA) from control file real(kind=wp), public :: tkl_inf = 0.0 Read freestream kL variable from control file real(kind=wp), public :: tu_inf = 1.0 Read freestream turbulence intensity (percentage) from control file real(kind=wp), public :: tgm_inf = 1.0 Read freestream turbulence intermittency from control file real(kind=wp), public :: vel_mag = 100.0 Calulated freestream Velocity Magnitude from control file real(kind=wp), public :: MInf = 0.0 Calulated freestream Mach number real(kind=wp), public :: Reynolds_number = 0.0 Calculated free_stream Reynolds_number real(kind=wp), public :: mu_ratio_inf = 1.0 Read freestream turbulent viscosity to molecular viscosity ratio real(kind=wp), public :: Turb_intensity_inf = 0.01 Calculate free_stream turbulence intensity real(kind=wp), public :: gm = 1.4 Gamma commonly 1.4 real(kind=wp), public :: R_gas = 287 Univarsal gas constant real(kind=wp), public :: mu_ref = 0.0 Molecular viscoity reference character(len=FILE_NAME_LENGTH), public :: mu_variation = \"constant\" Type of viscosity variaiton: Sutherland or constant real(kind=wp), public :: T_ref = 300 Reference Temperature of flow for viscosity calculation real(kind=wp), public :: Sutherland_temp = 110 Sutherland temperature for viscosity calculation real(kind=wp), public :: Pr = 0.7 prandtl number real(kind=wp), public :: tPr = 0.9 turbulent Prandtl number type, public :: boundarytype Components Type Visibility Attributes Name Initial integer, public :: imin_id Boundary condition number/ID at imin for particulat processor integer, public :: imax_id Boundary condition number/ID at imax for particulat processor integer, public :: jmin_id Boundary condition number/ID at jmin for particulat processor integer, public :: jmax_id Boundary condition number/ID at jmax for particulat processor integer, public :: kmin_id Boundary condition number/ID at kmin for particulat processor integer, public :: kmax_id Boundary condition number/ID at kmax for particulat processor character(len=4), public, dimension(6) :: face_names Store name of all six boundary faces integer, public, dimension(6) :: id Store the boundary condition ID of all six faces real(kind=wp), public :: c1 First coefficient user for higher order boundary condition real(kind=wp), public :: c2 Second coefficient user for higher order boundary condition real(kind=wp), public :: c3 Third coefficient user for higher order boundary condition real(kind=wp), public, dimension(6) :: fixed_density = 0. Density value to fix at particular boundary real(kind=wp), public, dimension(6) :: fixed_pressure = 0. Pressure value to fix at particular boundary real(kind=wp), public, dimension(6) :: fixed_x_speed = 0. X component of velocity to fix at particular boundary condition real(kind=wp), public, dimension(6) :: fixed_y_speed = 0. Y component of velocity to fix at particular boundary condition real(kind=wp), public, dimension(6) :: fixed_z_speed = 0. Z component of velocity to fix at particular boundary condition real(kind=wp), public, dimension(6) :: fixed_tk = 0. Turbulent kinetic energy value to fix at particular boundary condition real(kind=wp), public, dimension(6) :: fixed_tw = 0. Turbulent kinetic energy dissiaption rate value to fix at particular boundary condition(k-omega and SST model) real(kind=wp), public, dimension(6) :: fixed_te = 0. Turbulent kinetic energy dissiaption value to fix at particular boundary condition (K-eplision model) real(kind=wp), public, dimension(6) :: fixed_tv = 0. Turbulent viscosity varialble value to fix at particular boundary condition (for SA turbulence model) real(kind=wp), public, dimension(6) :: fixed_tkl = 0. (Turbulent kinetic energy x length) varialble value to fix at particular boundary condition (for k-kL turbulence model) real(kind=wp), public, dimension(6) :: fixed_tgm = 0. Fixed intermittency value to apply at particular boundary condition (for SST2003-gamma transition model) real(kind=wp), public, dimension(6) :: fixed_wall_temperature = 0. Fixed wall temperature value to apply at isothermal wall boundary condition. real(kind=wp), public, dimension(6) :: fixed_Tpressure = 0. Fixed Total Pressure value to apply at particular boundary condition real(kind=wp), public, dimension(6) :: fixed_Ttemperature = 0. Fixed Total Temperature value to apply at particular boundary condition integer, public, dimension(6) :: ilo Store the lower and upper bound of the indecies of I loop for the interface mapping integer, public, dimension(6) :: ihi Store the lower and upper bound of the indecies of I loop for the interface mapping integer, public, dimension(6) :: jlo Store the lower and upper bound of the indecies of J loop for the interface mapping integer, public, dimension(6) :: jhi Store the lower and upper bound of the indecies of J loop for the interface mapping integer, public, dimension(6) :: klo Store the lower and upper bound of the indecies of K loop for the interface mapping integer, public, dimension(6) :: khi Store the lower and upper bound of the indecies of K loop for the interface mapping integer, public, dimension(6) :: dir_switch = 0 Switch for each boundary face. Activated only if ( for eg I-direction in the mapping is mapped with J-direction) integer, public, dimension(6) :: otherface Store the face number with which the current interface is connected. integer, public, dimension(:), allocatable :: make_F_flux_zero Store zero to boundary face, which has wall ID, to make F flux zero integer, public, dimension(:), allocatable :: make_G_flux_zero Store zero to boundary face, which has wall ID, to make G flux zero integer, public, dimension(:), allocatable :: make_H_flux_zero Store zero to boundary face, which has wall ID, to make H flux zero integer, public, dimension(6) :: PbcId = -1 Block ID for Periodic boundary condition","tags":"","loc":"module/vartypes.html","title":"vartypes – FEST-3D"},{"text":"Check for solution's convergence Uses vartypes resnorm module~~convergence~~UsesGraph module~convergence convergence module~resnorm resnorm module~convergence->module~resnorm module~vartypes vartypes module~convergence->module~vartypes module~resnorm->module~vartypes module~utils utils module~resnorm->module~utils mpi mpi module~resnorm->mpi iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~convergence~~UsedByGraph module~convergence convergence program~main main program~main->module~convergence Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions converged Functions public function converged (control) result(c) Check if the solution seems to have converged\n The solution is said to have converged if the change in \n the residue norm is \"negligible\". Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control control parameters Return Value logical convergence result:True or false","tags":"","loc":"module/convergence.html","title":"convergence – FEST-3D"},{"text":"The grid module contains the grid definition (locations of the \n grid points) as well as procedures to load these from a file. Uses mapping mpi vartypes module~~grid~~UsesGraph module~grid grid module~mapping mapping module~grid->module~mapping module~vartypes vartypes module~grid->module~vartypes mpi mpi module~grid->mpi module~mapping->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~grid~~UsedByGraph module~grid grid module~solver solver module~solver->module~grid program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup_grid extract_grid_size populate_grid_points ghost_grid Subroutines public subroutine setup_grid (files, nodes, control, bc, dims) Read the grid file and initialize the grid Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Files' name and handler type( nodetype ), intent(out), dimension(:,:,:), allocatable :: nodes Grid points type( controltype ), intent(in) :: control Control parameters type( boundarytype ), intent(inout) :: bc boundary conditions and fixed values type( extent ), intent(out) :: dims Extent of the domain:imx,jmx,kmx private subroutine extract_grid_size (file_handler, dims) Extract the grid size from the grid file header Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler (input)file handling unit type( extent ), intent(out) :: dims Extent of the domain:imx,jmx,kmx private subroutine populate_grid_points (file_handler, nodes, dims) Use the grid file to populate the grid points. Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler (input)file handling unit type( nodetype ), intent(out), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes Grid points type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine ghost_grid (nodes, dims) generate ghost grid for the various operations later. Arguments Type Intent Optional Attributes Name type( nodetype ), intent(inout), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes grid points type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/grid.html","title":"grid – FEST-3D"},{"text":"Reference: Sharov, D., Luo, H., Baum, J., and Loehner, R., \n “Implementation of unstructured grid GMRES+LU-SGS method on \n shared-memory, cache-based parallel computers,” \n 38th Aerospace Sciences Meeting and Exhibit, vol. 927, 2000, p. 2000. Uses global_sst viscosity utils vartypes gradients global_sa global_kkl wall_dist module~~lusgs~~UsesGraph module~lusgs lusgs module~wall_dist wall_dist module~lusgs->module~wall_dist module~global_kkl global_kkl module~lusgs->module~global_kkl module~global_sst global_sst module~lusgs->module~global_sst module~viscosity viscosity module~lusgs->module~viscosity module~gradients gradients module~lusgs->module~gradients module~utils utils module~lusgs->module~utils module~vartypes vartypes module~lusgs->module~vartypes module~global_sa global_sa module~lusgs->module~global_sa module~wall_dist->module~utils module~wall_dist->module~vartypes iso_fortran_env iso_fortran_env module~global_kkl->iso_fortran_env module~global_sst->iso_fortran_env module~viscosity->module~wall_dist module~viscosity->module~global_kkl module~viscosity->module~global_sst module~viscosity->module~gradients module~viscosity->module~utils module~viscosity->module~vartypes module~viscosity->module~global_sa module~copy_bc copy_bc module~viscosity->module~copy_bc module~gradients->module~utils module~gradients->module~vartypes module~vartypes->iso_fortran_env module~global_sa->iso_fortran_env module~copy_bc->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~lusgs~~UsedByGraph module~lusgs lusgs module~update update module~update->module~lusgs module~solver solver module~solver->module~update program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables delQ delQstar dummy tmu mmu imx jmx kmx n_var gm mu_ref Reynolds_number free_stream_tu tk_inf tkl_inf tPr Pr R_gas Functions Flux SpectralRadius SSTFlux KKLFlux SAFlux lctm2015flux Subroutines setup_lusgs update_with_lusgs update_laminar_variables update_SST_variables update_KKL_variables update_SA_variables update_lctm2015 Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:,:), allocatable :: delQ change of state variable (solution) over one time-step real(kind=wp), public, dimension(:,:,:,:), allocatable :: delQstar Intermediate change of state variable over one time-step real(kind=wp), public, dimension(:,:,:), allocatable, target :: dummy dummy variable real(kind=wp), public, dimension(:,:,:), pointer :: tmu Pionter to turbulent viscosity real(kind=wp), public, dimension(:,:,:), pointer :: mmu Pointer to molecular viscosity integer, public :: imx integer, public :: jmx integer, public :: kmx integer, public :: n_var real(kind=wp), public :: gm real(kind=wp), public :: mu_ref real(kind=wp), public :: Reynolds_number real(kind=wp), public :: free_stream_tu real(kind=wp), public :: tk_inf real(kind=wp), public :: tkl_inf real(kind=wp), public :: tPr real(kind=wp), public :: Pr real(kind=wp), public :: R_gas Functions public function Flux (ql, qr, du, inputs) calculate the total flux through face for laminar flow. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:7) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) public function SpectralRadius (ql, qr, inputs, c1, c2) Calculate the spectral radius Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:7) :: inputs real(kind=wp), intent(in), dimension(1:3) :: c1 real(kind=wp), intent(in), dimension(1:3) :: c2 Return Value real(kind=wp) public function SSTFlux (ql, qr, du, inputs) calculate the total flux through face for turbulent flow (SST) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:8) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) public function KKLFlux (ql, qr, du, inputs) calculate the total flux through face for turbulent flow (k-kL) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:7) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) public function SAFlux (ql, qr, du, inputs) calculate the total flux through face for turbulent flow (SA) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:7) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) public function lctm2015flux (ql, qr, du, inputs) calculate the total flux through face for turbulent/transition flow (LCTM2015) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:n_var) :: ql real(kind=wp), intent(in), dimension(1:n_var) :: qr real(kind=wp), intent(in), dimension(1:n_var) :: du real(kind=wp), intent(in), dimension(1:8) :: inputs Return Value real(kind=wp),\n  dimension(1:n_var) Subroutines public subroutine setup_lusgs (control, scheme, flow, dims) allocate array memory for data communication Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_with_lusgs (qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, scheme, dims) Time-integrate with LU_SGS method Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( schemetype ), intent(in) :: scheme finite-volume Schemes type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_laminar_variables (qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update laminar flow with LU-SGS scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_SST_variables (qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (SST) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_KKL_variables (qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (k-kL) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_SA_variables (qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (SA) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine update_lctm2015 (qp, residue, delta_t, cells, Ifaces, Jfaces, Kfaces, dims) Update the RANS (LCTM2015 transition model with SST2003) equation with LU-SGS Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/lusgs.html","title":"lusgs – FEST-3D"},{"text":"This module contains subroutine that \n 1. check if time for resnorm dump is arrived\n 2. calculate resnorm\n 3. send those resnorm to processor number 0\n 4. Recalulate resnorm based on information \n    availble from all processors\n 5. Append the data to resnorm file Uses mpi vartypes utils module~~resnorm~~UsesGraph module~resnorm resnorm module~utils utils module~resnorm->module~utils module~vartypes vartypes module~resnorm->module~vartypes mpi mpi module~resnorm->mpi iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~resnorm~~UsedByGraph module~resnorm resnorm module~solver solver module~solver->module~resnorm module~convergence convergence module~convergence->module~resnorm program~main main program~main->module~solver program~main->module~convergence Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables merror buffer Res_itr Res_abs Res_rel Res_save Res_scale Subroutines setup_resnorm find_resnorm setup_file allocate_memory setup_scale get_absolute_resnorm collect_resnorm_from_all_blocks assemble_resnom_at_each_process get_relative_resnorm write_resnorm Variables Type Visibility Attributes Name Initial real(kind=wp), private :: merror mass error real(kind=wp), private, dimension(:), allocatable :: buffer Buffer for mpi communication integer, private, parameter :: Res_itr = 3 Iteration after which Res_save is stores real(kind=wp), public, dimension(:), allocatable :: Res_abs Absolute value of residual norm real(kind=wp), public, dimension(:), allocatable :: Res_rel Relative value of residual norm real(kind=wp), private, dimension(:), allocatable :: Res_save Saved iteration for relative values real(kind=wp), private, dimension(:), allocatable :: Res_scale Scaling factor for normalization Subroutines public subroutine setup_resnorm (files, control, scheme, flow) Allocate memory, setup scale and file to write Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Files' name and handler type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-{u,v,rho,p}, etc. public subroutine find_resnorm (file_handler, residue, F, G, H, control, scheme, dims) Find the normalized residual for each processor Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler residual file handler real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(in), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(in), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( controltype ), intent(inout) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine setup_file (files, control) Open the residual file to write Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Files' name and handler type( controltype ), intent(in) :: control Control parameters private subroutine allocate_memory (control) Allocate memory to MPI Communication Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control private subroutine setup_scale (scheme, flow) Setup scale required for relative and absolute\n residual for writing in the file. Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. private subroutine get_absolute_resnorm (residue, F, G, H, control, dims) Get absolute residual for current process Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(in), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(in), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( controltype ), intent(in) :: control Control parameters: number of variables type( extent ), intent(in) :: dims extent of the 3D domain private subroutine collect_resnorm_from_all_blocks (control) MPI Communication to gather residual from all processes Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters: number of variables private subroutine assemble_resnom_at_each_process (control) Sum residual obtained from all the processes after MPI_Communication Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters: number of variables and total mpi processes private subroutine get_relative_resnorm (control) Get relative residual with respect to first iteration residual Arguments Type Intent Optional Attributes Name type( controltype ), intent(inout) :: control Control parameters: iterations private subroutine write_resnorm (RESNORM_FILE_UNIT, control, scheme) Writing the residual in the file to save. Arguments Type Intent Optional Attributes Name integer, intent(in) :: RESNORM_FILE_UNIT Resnorm file handler unit type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme turbulenca and transition schemes","tags":"","loc":"module/resnorm.html","title":"resnorm – FEST-3D"},{"text":"Setup, run, and destroy the solver\n allocate/deallcoate memory, initialize, iterate Uses resnorm interface1 viscosity CC wall update geometry wall_dist mpi state vartypes time bc scheme gradients layout read dump_solution grid viscous module~~solver~~UsesGraph module~solver solver module~state state module~solver->module~state module~read read module~solver->module~read module~scheme scheme module~solver->module~scheme module~layout layout module~solver->module~layout module~wall_dist wall_dist module~solver->module~wall_dist mpi mpi module~solver->mpi module~resnorm resnorm module~solver->module~resnorm module~geometry geometry module~solver->module~geometry module~viscosity viscosity module~solver->module~viscosity module~update update module~solver->module~update module~wall wall module~solver->module~wall module~gradients gradients module~solver->module~gradients module~interface1 interface1 module~solver->module~interface1 module~cc CC module~solver->module~cc module~bc bc module~solver->module~bc module~vartypes vartypes module~solver->module~vartypes module~viscous viscous module~solver->module~viscous module~time time module~solver->module~time module~dump_solution dump_solution module~solver->module~dump_solution module~grid grid module~solver->module~grid module~state->module~vartypes module~check_output_control check_output_control module~state->module~check_output_control module~utils utils module~state->module~utils module~read_output read_output module~state->module~read_output module~read->module~vartypes module~scheme->module~vartypes module~ausmup ausmUP module~scheme->module~ausmup module~van_leer van_leer module~scheme->module~van_leer module~scheme->module~utils module~slau slau module~scheme->module~slau module~ausmp ausmP module~scheme->module~ausmp module~ausm ausm module~scheme->module~ausm module~face_interpolant face_interpolant module~scheme->module~face_interpolant module~ldfss0 ldfss0 module~scheme->module~ldfss0 module~layout->mpi module~layout->module~vartypes module~wall_dist->module~vartypes module~wall_dist->module~utils module~resnorm->mpi module~resnorm->module~vartypes module~resnorm->module~utils module~geometry->module~vartypes module~geometry->module~utils module~viscosity->module~wall_dist module~viscosity->module~gradients module~viscosity->module~vartypes module~global_kkl global_kkl module~viscosity->module~global_kkl module~viscosity->module~utils module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sa global_sa module~viscosity->module~global_sa module~global_sst global_sst module~viscosity->module~global_sst module~update->module~scheme module~update->module~wall_dist module~update->module~viscosity module~update->module~gradients module~update->module~interface1 module~update->module~vartypes module~update->module~viscous module~update->module~time module~update->module~global_kkl module~bc_primitive bc_primitive module~update->module~bc_primitive module~source source module~update->module~source module~update->module~utils module~update->module~global_sa module~plusgs plusgs module~update->module~plusgs module~update->module~global_sst module~boundary_state_reconstruction boundary_state_reconstruction module~update->module~boundary_state_reconstruction module~lusgs lusgs module~update->module~lusgs module~update->module~face_interpolant module~wall->mpi module~wall->module~vartypes module~wall->module~utils module~gradients->module~vartypes module~gradients->module~utils module~interface1->mpi module~interface1->module~vartypes module~mapping mapping module~interface1->module~mapping module~interface1->module~utils module~cc->module~wall_dist module~cc->module~vartypes module~cc->module~utils module~bc->module~vartypes module~bc->module~utils module~read_bc read_bc module~bc->module~read_bc iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~viscous->module~viscosity module~viscous->module~gradients module~viscous->module~vartypes module~viscous->module~global_kkl module~viscous->module~utils module~viscous->module~global_sa module~viscous->module~global_sst module~time->module~read module~time->mpi module~time->module~viscosity module~time->module~vartypes module~time->module~utils module~time->module~face_interpolant module~dump_solution->module~layout module~dump_solution->module~vartypes module~write_output write_output module~dump_solution->module~write_output module~dump_solution->module~utils module~grid->mpi module~grid->module~vartypes module~grid->module~mapping var panmodulesolverUsesGraph = svgPanZoom('#modulesolverUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~solver~~UsedByGraph module~solver solver program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dims nodes cells Ifaces Jfaces Kfaces control schemes flow files boundary qp Temp F G H residue delta_t Subroutines abort_run finish_run start_run setup_solver destroy_solver initmisc iterate_one_more_time_step Variables Type Visibility Attributes Name Initial type( extent ), private :: dims Extent of the domain:imx,jmx,kmx type( nodetype ), private, dimension(:,:,:), allocatable :: nodes Grid points type( celltype ), private, dimension(:,:,:), allocatable :: cells Cell center quantities: volume, cellCenter type( facetype ), private, dimension(:,:,:), allocatable :: Ifaces Face quantities: area and unit normal type( facetype ), private, dimension(:,:,:), allocatable :: Jfaces Face quantities: area and unit normal type( facetype ), private, dimension(:,:,:), allocatable :: Kfaces Face quantities: area and unit normal type( controltype ), public :: control Control parameters type( schemetype ), public :: schemes finite-volume Schemes type( flowtype ), private :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( filetype ), private :: files Files' name and handler type( boundarytype ), private :: boundary boundary conditions and fixed values real(kind=wp), private, dimension(:, :, :, :), allocatable :: qp Store primitive variable at cell center real(kind=wp), private, dimension(:, :, :   ), allocatable :: Temp Store Temperature variable at cell center real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: F Store fluxes throught the I faces real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: G Store fluxes throught the J faces real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: H Store fluxes throught the K faces real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: residue Store residue at each cell-center real(kind=wp), private, dimension(:, :, :), allocatable :: delta_t Local time increment value at each cell center Subroutines public subroutine abort_run () Aborting the solver Arguments None public subroutine finish_run () Finishing the solution computation Arguments None public subroutine start_run () Starting the solver setup Arguments None public subroutine setup_solver () Call to allocate memoery and initialize domain Arguments None public subroutine destroy_solver () Call to different modules to deallocate memory Arguments None private subroutine initmisc () Initilize miscellaneous variables Arguments None public subroutine iterate_one_more_time_step () Perform one time step iteration Arguments None","tags":"","loc":"module/solver.html","title":"solver – FEST-3D"},{"text":"Setup the indicies map at interface between two blocks Uses vartypes module~~mapping~~UsesGraph module~mapping mapping module~vartypes vartypes module~mapping->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~mapping~~UsedByGraph module~mapping mapping module~interface1 interface1 module~interface1->module~mapping module~grid grid module~grid->module~mapping module~solver solver module~solver->module~interface1 module~solver->module~grid module~update update module~solver->module~update module~update->module~interface1 program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilo jlo klo ihi jhi khi Pilo Pjlo Pklo Pihi Pjhi Pkhi PiDir PjDir PkDir Gilo Gjlo Gklo Gihi Gjhi Gkhi mpi_class Subroutines read_interface_map change_map_to_particular_range read_periodic_bc_file Variables Type Visibility Attributes Name Initial integer, private, dimension(6) :: ilo Read Lowest index of I direction integer, private, dimension(6) :: jlo Read Lowest index of J direction integer, private, dimension(6) :: klo Read Lowest index of K direction integer, private, dimension(6) :: ihi Read Highest index of I direction integer, private, dimension(6) :: jhi Read Highest index of J direction integer, private, dimension(6) :: khi Read Highest index of K direction integer, public, dimension(6) :: Pilo Modified lowest index of I direction integer, public, dimension(6) :: Pjlo Modified lowest index of J direction integer, public, dimension(6) :: Pklo Modified lowest index of K direction integer, public, dimension(6) :: Pihi Modified Highest index of I direction integer, public, dimension(6) :: Pjhi Modified Highest index of J direction integer, public, dimension(6) :: Pkhi Modified Highest index of K direction integer, public, dimension(6) :: PiDir Switch for communication direction from \n (low-high) to (hight-low) for I direction integer, public, dimension(6) :: PjDir Switch for communication direction from \n (low-high) to (hight-low) for J direction integer, public, dimension(6) :: PkDir Switch for communication direction from \n (low-high) to (hight-low) for K direction integer, public, dimension(6) :: Gilo Modified lowest index of I direction for Grid data exchange integer, public, dimension(6) :: Gjlo Modified lowest index of J direction for Grid data exchange integer, public, dimension(6) :: Gklo Modified lowest index of K direction for Grid data exchange integer, public, dimension(6) :: Gihi Modified highest index of I direction for Grid data exchange integer, public, dimension(6) :: Gjhi Modified highest index of J direction for Grid data exchange integer, public, dimension(6) :: Gkhi Modified highest index of K direction for Grid data exchange integer, public, dimension(6) :: mpi_class = -1 Class flag for master or slave Subroutines public subroutine read_interface_map (files, control, bc, dims) Read mapping file in the system/mesh/layout/mapping.txt Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Files' name and handler type( controltype ), intent(in) :: control Control parameters type( boundarytype ), intent(inout) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine change_map_to_particular_range () Modified the indicies for MPI communication Arguments None private subroutine read_periodic_bc_file (files, control, bc) Read periodic.md file in the system/mesh/layout/periodic.md Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files Files' name and handler type( controltype ), intent(in) :: control Control parameters type( boundarytype ), intent(inout) :: bc boundary conditions and fixed values","tags":"","loc":"module/mapping.html","title":"mapping – FEST-3D"},{"text":"Contains routine to load layout file and sets the layout variables\n and gets process id and total process Uses mpi vartypes module~~layout~~UsesGraph module~layout layout module~vartypes vartypes module~layout->module~vartypes mpi mpi module~layout->mpi iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~layout~~UsedByGraph module~layout layout module~solver solver module~solver->module~layout module~dump_solution dump_solution module~solver->module~dump_solution module~dump_solution->module~layout program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines get_process_data get_next_token_parallel read_layout_file Subroutines public subroutine get_process_data (control) Get Processor Id and total number of processors Arguments Type Intent Optional Attributes Name type( controltype ), intent(inout) :: control Control parameters public subroutine get_next_token_parallel (handler, buf) Extract the next token from the layout file Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: handler character(len=STRING_BUFFER_LENGTH), intent(out) :: buf public subroutine read_layout_file (files, control, bc) Read the layout file for particular processor Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files Files' name and handler type( controltype ), intent(in) :: control Processor id for current block type( boundarytype ), intent(inout) :: bc boundary conditions and fixed values","tags":"","loc":"module/layout.html","title":"layout – FEST-3D"},{"text":"Setup, destroy, calculate molecular and turbulence viscosity Uses global_sst copy_bc utils wall_dist gradients global_sa global_kkl vartypes module~~viscosity~~UsesGraph module~viscosity viscosity module~wall_dist wall_dist module~viscosity->module~wall_dist module~global_kkl global_kkl module~viscosity->module~global_kkl module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sst global_sst module~viscosity->module~global_sst module~gradients gradients module~viscosity->module~gradients module~utils utils module~viscosity->module~utils module~vartypes vartypes module~viscosity->module~vartypes module~global_sa global_sa module~viscosity->module~global_sa module~wall_dist->module~utils module~wall_dist->module~vartypes iso_fortran_env iso_fortran_env module~global_kkl->iso_fortran_env module~copy_bc->module~vartypes module~global_sst->iso_fortran_env module~gradients->module~utils module~gradients->module~vartypes module~vartypes->iso_fortran_env module~global_sa->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~viscosity~~UsedByGraph module~viscosity viscosity module~source source module~source->module~viscosity module~plusgs plusgs module~plusgs->module~viscosity module~write_output_vtk write_output_vtk module~write_output_vtk->module~viscosity module~write_output_tec write_output_tec module~write_output_tec->module~viscosity module~lusgs lusgs module~lusgs->module~viscosity module~solver solver module~solver->module~viscosity module~update update module~solver->module~update module~time time module~solver->module~time module~viscous viscous module~solver->module~viscous module~dump_solution dump_solution module~solver->module~dump_solution module~write_output_tec_node write_output_tec_node module~write_output_tec_node->module~viscosity module~update->module~viscosity module~update->module~source module~update->module~plusgs module~update->module~lusgs module~update->module~time module~update->module~viscous module~time->module~viscosity module~viscous->module~viscosity program~main main program~main->module~solver module~write_output write_output module~write_output->module~write_output_vtk module~write_output->module~write_output_tec module~write_output->module~write_output_tec_node module~dump_solution->module~write_output Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables mu mu_t Subroutines calculate_viscosity setup_viscosity Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:, :, :), allocatable, target :: mu Cell-center molecular viscosity real(kind=wp), public, dimension(:, :, :), allocatable, target :: mu_t Cell-center turbulent viscosity Subroutines public subroutine calculate_viscosity (qp, scheme, flow, bc, dims) Calculate molecular and turbulent viscosity Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine setup_viscosity (scheme, flow, dims) Allocate and pointer for molecular and turbulent viscosity Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/viscosity.html","title":"viscosity – FEST-3D"},{"text":"This module march the solution is time. Uses lusgs global_sst face_interpolant viscosity source utils vartypes time boundary_state_reconstruction scheme gradients global_sa viscous global_kkl bc_primitive plusgs wall_dist interface1 module~~update~~UsesGraph module~update update module~global_sa global_sa module~update->module~global_sa module~wall_dist wall_dist module~update->module~wall_dist module~scheme scheme module~update->module~scheme module~lusgs lusgs module~update->module~lusgs module~utils utils module~update->module~utils module~plusgs plusgs module~update->module~plusgs module~boundary_state_reconstruction boundary_state_reconstruction module~update->module~boundary_state_reconstruction module~global_sst global_sst module~update->module~global_sst module~viscosity viscosity module~update->module~viscosity module~gradients gradients module~update->module~gradients module~bc_primitive bc_primitive module~update->module~bc_primitive module~face_interpolant face_interpolant module~update->module~face_interpolant module~global_kkl global_kkl module~update->module~global_kkl module~interface1 interface1 module~update->module~interface1 module~time time module~update->module~time module~vartypes vartypes module~update->module~vartypes module~viscous viscous module~update->module~viscous module~source source module~update->module~source iso_fortran_env iso_fortran_env module~global_sa->iso_fortran_env module~wall_dist->module~utils module~wall_dist->module~vartypes module~scheme->module~utils module~scheme->module~face_interpolant module~scheme->module~vartypes module~ausm ausm module~scheme->module~ausm module~ausmp ausmP module~scheme->module~ausmp module~van_leer van_leer module~scheme->module~van_leer module~ldfss0 ldfss0 module~scheme->module~ldfss0 module~ausmup ausmUP module~scheme->module~ausmup module~slau slau module~scheme->module~slau module~lusgs->module~global_sa module~lusgs->module~wall_dist module~lusgs->module~utils module~lusgs->module~global_sst module~lusgs->module~viscosity module~lusgs->module~gradients module~lusgs->module~global_kkl module~lusgs->module~vartypes module~plusgs->module~global_sa module~plusgs->module~wall_dist module~plusgs->module~utils module~plusgs->module~global_sst module~plusgs->module~viscosity module~plusgs->module~gradients module~plusgs->module~global_kkl module~plusgs->module~vartypes module~boundary_state_reconstruction->module~face_interpolant module~boundary_state_reconstruction->module~vartypes module~global_sst->iso_fortran_env module~viscosity->module~global_sa module~viscosity->module~wall_dist module~viscosity->module~utils module~viscosity->module~global_sst module~viscosity->module~gradients module~viscosity->module~global_kkl module~viscosity->module~vartypes module~copy_bc copy_bc module~viscosity->module~copy_bc module~gradients->module~utils module~gradients->module~vartypes module~bc_primitive->module~wall_dist module~bc_primitive->module~global_sst module~bc_primitive->module~vartypes module~ft_bc FT_bc module~bc_primitive->module~ft_bc module~bc_primitive->module~copy_bc module~face_interpolant->module~utils module~face_interpolant->module~vartypes module~ppm ppm module~face_interpolant->module~ppm module~muscl muscl module~face_interpolant->module~muscl module~weno weno module~face_interpolant->module~weno module~weno_nm weno_NM module~face_interpolant->module~weno_nm module~global_kkl->iso_fortran_env module~interface1->module~utils module~interface1->module~vartypes module~mapping mapping module~interface1->module~mapping mpi mpi module~interface1->mpi module~time->module~utils module~time->module~viscosity module~time->module~face_interpolant module~time->module~vartypes module~read read module~time->module~read module~time->mpi module~vartypes->iso_fortran_env module~viscous->module~global_sa module~viscous->module~utils module~viscous->module~global_sst module~viscous->module~viscosity module~viscous->module~gradients module~viscous->module~global_kkl module~viscous->module~vartypes module~source->module~global_sa module~source->module~wall_dist module~source->module~utils module~source->module~global_sst module~source->module~viscosity module~source->module~gradients module~source->module~global_kkl module~source->module~vartypes module~cc CC module~source->module~cc module~mapping->module~vartypes module~ausm->module~vartypes module~ausmp->module~face_interpolant module~ausmp->module~vartypes module~ppm->module~vartypes module~muscl->module~vartypes module~ft_bc->module~vartypes module~ft_bc->module~copy_bc module~copy_bc->module~vartypes module~read->module~vartypes module~van_leer->module~vartypes module~ldfss0->module~vartypes module~weno->module~vartypes module~cc->module~wall_dist module~cc->module~utils module~cc->module~vartypes module~ausmup->module~vartypes module~weno_nm->module~vartypes module~slau->module~vartypes var panmoduleupdateUsesGraph = svgPanZoom('#moduleupdateUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~update~~UsedByGraph module~update update module~solver solver module~solver->module~update program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables U_store R_store aux u1 u2 R imx jmx kmx n_var Subroutines setup_update get_next_solution update_with get_total_conservative_Residue Variables Type Visibility Attributes Name Initial real(kind=wp), private, dimension(:,:,:,:), allocatable :: U_store Array to store the intermediate solution real(kind=wp), private, dimension(:,:,:,:), allocatable :: R_store Array to store the intermediate Residue real(kind=wp), private, dimension(:,:,:,:), allocatable, target :: aux Array to store some auxilary intermediate variables real(kind=wp), private, dimension(:), allocatable :: u1 Variable array old for each cell center real(kind=wp), private, dimension(:), allocatable :: u2 Variable array new for each cell center real(kind=wp), private, dimension(:), allocatable :: R Residue array for each cell center integer, private :: imx integer, private :: jmx integer, private :: kmx integer, private :: n_var Subroutines public subroutine setup_update (control, scheme, flow, dims) Allocate memory to variables required based \n on the time-integration scheme. Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine get_next_solution (qp, Temp, residue, delta_t, cells, F, G, H, Ifaces, Jfaces, Kfaces, control, scheme, flow, bc, dims) Get solution at next time-step using scheme\n given in the input file. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2,1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: Temp Store Temperature variable at cell center real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(inout), dimension(1:dims%imx-1, 1:dims%jmx-1, 1:dims%kmx-1) :: delta_t Local time increment value at each cell center\n Store residue at each cell-center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine update_with (qp, residue, delta_t, cells, scheme, flow, type, time_factor, store_factor, use, Rn, un) A generalized scheme to updat the solution explicitly using\n any RK method and even first order euler explicit. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(1:imx-1,1:jmx-1,1:kmx-1) :: delta_t Local time increment value at each cell center type( celltype ), intent(in), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: cells Cell center quantities: volume type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. character(len=*), intent(in) :: type real(kind=wp), intent(in), optional :: time_factor real(kind=wp), intent(in), optional :: store_factor logical, intent(in), optional :: use real(kind=wp), intent(inout), optional dimension(1:imx-1,1:jmx-1,1:kmx-1,1:n_var) :: Rn real(kind=wp), intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un private subroutine get_total_conservative_Residue (qp, Temp, cells, residue, F, G, H, Ifaces, Jfaces, Kfaces, control, scheme, flow, bc, dims) For each iteration it apply boundary conditions,\n use higher order method to reconstruct state at\n face, evalute fluxes at each face, calculate \n inviscid residual, and introuduce additional \n residual due to  viscosity, turbulence and source\n terms. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2,1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: Temp Store Temperature variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume real(kind=wp), intent(inout), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( controltype ), intent(in) :: control Control parameters type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/update.html","title":"update – FEST-3D"},{"text":"The geometry module calculates various geometrical quantities like \n face-normals, face-areas and cell-volumes to be used in computations. Uses vartypes utils module~~geometry~~UsesGraph module~geometry geometry module~utils utils module~geometry->module~utils module~vartypes vartypes module~geometry->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~geometry~~UsedByGraph module~geometry geometry module~solver solver module~solver->module~geometry program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables imx jmx kmx Functions vol_tetrahedron vol_hexahedron Subroutines allocate_memory normalize_face_normals compute_face_areas compute_face_area_vectors compute_face_areas_and_normals compute_volumes compute_ghost_cell_centroid setup_geometry Variables Type Visibility Attributes Name Initial integer, private :: imx integer, private :: jmx integer, private :: kmx Functions private function vol_tetrahedron (p1, p2, p3, p4) Compute the volume of a tetrahedron, given 4 points which\n are 1-D arrays\n Since we know that the determinant is to be evaluated of \n a 3x3 matrix, we write the expression itself Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: p1 real(kind=wp), intent(in), dimension(:) :: p2 real(kind=wp), intent(in), dimension(:) :: p3 real(kind=wp), intent(in), dimension(:) :: p4 Return Value real(kind=wp) private function vol_hexahedron (p_list) Compute the volume of a hexahedron, given a list of points Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:3, 1:8) :: p_list Return Value real(kind=wp) Subroutines private subroutine allocate_memory (cells, Ifaces, Jfaces, Kfaces) Allocate memory for the required variables. Read more… Arguments Type Intent Optional Attributes Name type( celltype ), intent(out), dimension(:,:,:), allocatable :: cells Store cell center quantities: volume, cell center coordinate type( facetype ), intent(out), dimension(:,:,:), allocatable :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(out), dimension(:,:,:), allocatable :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(out), dimension(:,:,:), allocatable :: Kfaces Store face quantites for K faces: normal and area private subroutine normalize_face_normals (Ifaces, Jfaces, Kfaces, bc) Normalize the face normal vectors computed to get unit\n vectors Arguments Type Intent Optional Attributes Name type( facetype ), intent(inout), dimension(-2:imx+3,-2:jmx+2,-2:kmx+2) :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+3,-2:kmx+2) :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+2,-2:kmx+3) :: Kfaces Store face quantites for K faces: normal and area type( boundarytype ), intent(in) :: bc private subroutine compute_face_areas (Ifaces, Jfaces, Kfaces, bc) Compute face areas based on area vectors Read more… Arguments Type Intent Optional Attributes Name type( facetype ), intent(inout), dimension(-2:imx+3,-2:jmx+2,-2:kmx+2) :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+3,-2:kmx+2) :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+2,-2:kmx+3) :: Kfaces Store face quantites for K faces: normal and area type( boundarytype ), intent(in) :: bc private subroutine compute_face_area_vectors (Ifaces, Jfaces, Kfaces, nodes) Compute face area vectors Read more… Arguments Type Intent Optional Attributes Name type( facetype ), intent(inout), dimension(-2:imx+3,-2:jmx+2,-2:kmx+2) :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+3,-2:kmx+2) :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+2,-2:kmx+3) :: Kfaces Store face quantites for K faces: normal and area type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Grid points private subroutine compute_face_areas_and_normals (Ifaces, Jfaces, Kfaces, nodes, bc) Compute the face areas and normals Read more… Arguments Type Intent Optional Attributes Name type( facetype ), intent(inout), dimension(-2:imx+3,-2:jmx+2,-2:kmx+2) :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+3,-2:kmx+2) :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(inout), dimension(-2:imx+2,-2:jmx+2,-2:kmx+3) :: Kfaces Store face quantites for K faces: normal and area type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Grid points type( boundarytype ), intent(in) :: bc boundary condition and fixed values private subroutine compute_volumes (cells, nodes) Compute the grid cell volumes\n Each grid is a hexahedron, whose volume is calculated by\n splitting it into 5 tetrahedrons, whose volume is known Arguments Type Intent Optional Attributes Name type( celltype ), intent(out), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: cells Cell center quanties: volume and coordiantes of cell center type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Grid points private subroutine compute_ghost_cell_centroid (cells, nodes) Compute cell center of all cell including ghost cells Arguments Type Intent Optional Attributes Name type( celltype ), intent(out), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: cells Cell center quanties: volume and coordiantes of cell center type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Grid points public subroutine setup_geometry (cells, Ifaces, Jfaces, Kfaces, nodes, bc, dims) Make the geometry module useful Read more… Arguments Type Intent Optional Attributes Name type( celltype ), intent(inout), dimension(:,:,:), allocatable :: cells Cell center quanties: volume and coordiantes of cell center type( facetype ), intent(inout), dimension(:,:,:), allocatable :: Ifaces Store face quantites for I faces: normal and area type( facetype ), intent(inout), dimension(:,:,:), allocatable :: Jfaces Store face quantites for J faces: normal and area type( facetype ), intent(inout), dimension(:,:,:), allocatable :: Kfaces Store face quantites for K faces: normal and area type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes Grid points type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims","tags":"","loc":"module/geometry.html","title":"geometry – FEST-3D"},{"text":"Reference: Van Leer, B., Flux-vector splitting for the Euler equation. \n In Upwind and High-Resolution Schemes, Springer, Berlin, Heidelberg, pp. 80-89, 1997 Uses vartypes module~~van_leer~~UsesGraph module~van_leer van_leer module~vartypes vartypes module~van_leer->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~van_leer~~UsedByGraph module~van_leer van_leer module~scheme scheme module~scheme->module~van_leer module~solver solver module~solver->module~scheme module~update update module~solver->module~update module~update->module~scheme program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines compute_flux compute_fluxes Subroutines private subroutine compute_flux (Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input-argument direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variable at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variable at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_fluxes (F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/van_leer.html","title":"van_leer – FEST-3D"},{"text":"Shima, E., and Kitamura, K., “Parameter-Free Simple\n Low-Dissipation AUSM-Family Scheme for All Speeds,” \n AIAA Journal, vol. 49, pp. 1693–1709, 2011 Uses vartypes module~~slau~~UsesGraph module~slau slau module~vartypes vartypes module~slau->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~slau~~UsedByGraph module~slau slau module~scheme scheme module~scheme->module~slau module~solver solver module~solver->module~scheme module~update update module~solver->module~update module~update->module~scheme program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines compute_flux compute_fluxes Subroutines private subroutine compute_flux (Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variable at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variable at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_fluxes (F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/slau.html","title":"slau – FEST-3D"},{"text":"Inviscid flux calculation through faces Uses ausmP face_interpolant van_leer ausmUP utils ldfss0 slau vartypes ausm module~~scheme~~UsesGraph module~scheme scheme module~van_leer van_leer module~scheme->module~van_leer module~ausmp ausmP module~scheme->module~ausmp module~face_interpolant face_interpolant module~scheme->module~face_interpolant module~ldfss0 ldfss0 module~scheme->module~ldfss0 module~ausm ausm module~scheme->module~ausm module~utils utils module~scheme->module~utils module~ausmup ausmUP module~scheme->module~ausmup module~vartypes vartypes module~scheme->module~vartypes module~slau slau module~scheme->module~slau module~van_leer->module~vartypes module~ausmp->module~face_interpolant module~ausmp->module~vartypes module~face_interpolant->module~utils module~face_interpolant->module~vartypes module~weno_nm weno_NM module~face_interpolant->module~weno_nm module~weno weno module~face_interpolant->module~weno module~ppm ppm module~face_interpolant->module~ppm module~muscl muscl module~face_interpolant->module~muscl module~ldfss0->module~vartypes module~ausm->module~vartypes module~ausmup->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~slau->module~vartypes module~weno_nm->module~vartypes module~weno->module~vartypes module~ppm->module~vartypes module~muscl->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~scheme~~UsedByGraph module~scheme scheme module~solver solver module~solver->module~scheme module~update update module~solver->module~update module~update->module~scheme program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables imx jmx kmx n_var Subroutines setup_scheme compute_fluxes compute_residue Variables Type Visibility Attributes Name Initial integer, public :: imx integer, public :: jmx integer, public :: kmx integer, public :: n_var Subroutines public subroutine setup_scheme (residue, F, G, H, control, dims) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:, :, :, :), allocatable, target :: residue Store residue at each cell-center real(kind=wp), intent(out), dimension(:, :, :, :), allocatable :: F Store fluxes throught the I faces real(kind=wp), intent(out), dimension(:, :, :, :), allocatable :: G Store fluxes throught the J faces real(kind=wp), intent(out), dimension(:, :, :, :), allocatable :: H Store fluxes throught the K faces type( controltype ), intent(in) :: control Control parameters type( extent ), intent(in) :: dims extent of the 3D domain public subroutine compute_fluxes (F, G, H, Ifaces, Jfaces, Kfaces, scheme, flow, bc, dims) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims extent of the 3D domain public subroutine compute_residue (residue, F, G, H, dims) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:, :, :, :) :: residue Store residue at each cell-center real(kind=wp), intent(in), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(in), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(in), dimension(:, :, :, :) :: H Store fluxes throught the K faces type( extent ), intent(in) :: dims extent of the 3D domain","tags":"","loc":"module/scheme.html","title":"scheme – FEST-3D"},{"text":"Reference: Liou, M. S., “A sequel to AUSM, Part II: \n AUSM+-up for all speeds,” Journal of Computational Physics, \n vol. 214, 2006, pp. 137–170 Uses vartypes module~~ausmup~~UsesGraph module~ausmup ausmUP module~vartypes vartypes module~ausmup->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ausmup~~UsedByGraph module~ausmup ausmUP module~scheme scheme module~scheme->module~ausmup module~solver solver module~solver->module~scheme module~update update module~solver->module~update module~update->module~scheme program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines compute_flux compute_fluxes Subroutines private subroutine compute_flux (Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variable at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variable at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_fluxes (F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/ausmup.html","title":"ausmUP – FEST-3D"},{"text":"Flux splitting scheme: AUSM+ module ausmP !< \n Reference: Liou, M. S., “A sequel to AUSM: AUSM+,” \n Journal of Computational Physics, vol. 129, pp. 364–382, 1996 Uses vartypes face_interpolant module~~ausmp~~UsesGraph module~ausmp ausmP module~face_interpolant face_interpolant module~ausmp->module~face_interpolant module~vartypes vartypes module~ausmp->module~vartypes module~face_interpolant->module~vartypes module~ppm ppm module~face_interpolant->module~ppm module~muscl muscl module~face_interpolant->module~muscl module~utils utils module~face_interpolant->module~utils module~weno weno module~face_interpolant->module~weno module~weno_nm weno_NM module~face_interpolant->module~weno_nm iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~ppm->module~vartypes module~muscl->module~vartypes module~weno->module~vartypes module~weno_nm->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ausmp~~UsedByGraph module~ausmp ausmP module~scheme scheme module~scheme->module~ausmp module~solver solver module~solver->module~scheme module~update update module~solver->module~update module~update->module~scheme program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines compute_flux compute_fluxes Subroutines private subroutine compute_flux (Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variable at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variable at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_fluxes (F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/ausmp.html","title":"ausmP – FEST-3D"},{"text":"Reference: Liou, M.S. and Steffen Jr, C.J., A new flux splitting scheme, \n Journal of Computational physics, vol. 107, no. 1, pp.23-39, 1993 Uses vartypes module~~ausm~~UsesGraph module~ausm ausm module~vartypes vartypes module~ausm->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ausm~~UsedByGraph module~ausm ausm module~scheme scheme module~scheme->module~ausm module~solver solver module~solver->module~scheme module~update update module~solver->module~update module~update->module~scheme program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines compute_flux compute_fluxes Subroutines private subroutine compute_flux (Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input-argument direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variables at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variables at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_fluxes (F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/ausm.html","title":"ausm – FEST-3D"},{"text":"Reference: Edwards, J.R., A low-diffusion flux-splitting scheme \n for Navier-Stokes calculations, Computers & Fluids, vol. 26,\n no. 6, pp.635-659, 1997 Uses vartypes module~~ldfss0~~UsesGraph module~ldfss0 ldfss0 module~vartypes vartypes module~ldfss0->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ldfss0~~UsedByGraph module~ldfss0 ldfss0 module~scheme scheme module~scheme->module~ldfss0 module~solver solver module~solver->module~scheme module~update update module~solver->module~update module~update->module~scheme program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines compute_flux compute_fluxes Subroutines private subroutine compute_flux (Flux, f_qp_left, f_qp_right, faces, flags, flow, bc, dims) A generalized subroutine to calculate\n flux through the input-argument direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: Flux Store fluxes throught the any(I,J,K) faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitve state variable at face real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitve state variable at face type( facetype ), intent(in), dimension(-2:dims%imx+2+flags(1),-2:dims%jmx+2+flags(2),-2:dims%kmx+2+flags(3)) :: faces Face quantities: area and unit normal integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_fluxes (F, G, H, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, Ifaces, Jfaces, Kfaces, flow, bc, dims) Call to compute fluxes throught faces in each direction Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:, :, :, :) :: F Store fluxes throught the I faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: G Store fluxes throught the J faces real(kind=wp), intent(inout), dimension(:, :, :, :) :: H Store fluxes throught the K faces real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Store face quantites for I faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Store face quantites for J faces type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Store face quantites for K faces type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( boundarytype ), intent(in) :: bc boundary conditions and fixed values type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/ldfss0.html","title":"ldfss0 – FEST-3D"},{"text":"Reference:Hirsch, C., Numerical computation of internal \nand external flows: The fundamentals of computational fluid \ndynamics, Elsevier, 2007 MUSCL (Monotone Upwing Schemes for Scalar Conservation Laws is\n a scheme which replaces the piecewise constant approximation by\n reconstructing the states at the left and right side of each face.\n This is a one parameter upwind scheme which results in at most 3rd\n order accuracy. Uses vartypes module~~muscl~~UsesGraph module~muscl muscl module~vartypes vartypes module~muscl->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~muscl~~UsedByGraph module~muscl muscl module~face_interpolant face_interpolant module~face_interpolant->module~muscl module~boundary_state_reconstruction boundary_state_reconstruction module~boundary_state_reconstruction->module~face_interpolant module~time time module~time->module~face_interpolant module~ausmp ausmP module~ausmp->module~face_interpolant module~scheme scheme module~scheme->module~face_interpolant module~scheme->module~ausmp module~update update module~update->module~face_interpolant module~update->module~boundary_state_reconstruction module~update->module~time module~update->module~scheme module~solver solver module~solver->module~time module~solver->module~scheme module~solver->module~update program~main main program~main->module~solver var panmodulemusclUsedByGraph = svgPanZoom('#modulemusclUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables phi kappa switch_L Subroutines pressure_based_switching compute_face_state compute_muscl_states Variables Type Visibility Attributes Name Initial real(kind=wp), private :: phi = 1.0 real(kind=wp), private :: kappa = 1./3. integer, private :: switch_L = 1 Limiter switch Subroutines private subroutine pressure_based_switching (qp, f_qp_left, f_qp_right, pdif, flags, flow, dims) Pressure based switching. \n User x,y, or z for I,J,or K face respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitive variable at cell faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitive variable at cell faces real(kind=wp), intent(inout), dimension(0:dims%imx,0:dims%jmx,0:dims%kmx) :: pdif pressure difference integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine compute_face_state (qp, f_qp_left, f_qp_right, flags, lam_switch, turb_switch, dims) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitive variable at cell faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitive variable at cell faces integer, intent(in), dimension(3) :: flags Flags for direction switch integer, intent(in) :: lam_switch Limiter switch for laminar variables integer, intent(in) :: turb_switch Limiter switch for turbulent variables type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_muscl_states (qp, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, pdif, scheme, flow, dims) Implement MUSCL scheme to get left and right states at\n each face. The computation is done through all cells\n and first level ghost cells Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face real(kind=wp), intent(inout), dimension(0:dims%imx,0:dims%jmx,0:dims%kmx) :: pdif pressure difference type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/muscl.html","title":"muscl – FEST-3D"},{"text":"Reference: 1 Shu, C.-W., “High-order Finite Difference and Finite Volume \n WENO Schemes and Discontinuous Galerkin Methods for CFD,” \n International Journal of Computational Fluid Dynamics, vol. 17, 2003, pp. 107–118.\n Reference: 2 Huang, W. F., Ren, Y. X., and Jiang, X., \n“A simple algorithm to improve the performance of the WENO scheme on non-uniform grids,” \nActa Mechanica Sinica/Lixue Xuebao, 2017, pp. 1–11. Uses vartypes module~~weno~~UsesGraph module~weno weno module~vartypes vartypes module~weno->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~weno~~UsedByGraph module~weno weno module~face_interpolant face_interpolant module~face_interpolant->module~weno module~boundary_state_reconstruction boundary_state_reconstruction module~boundary_state_reconstruction->module~face_interpolant module~time time module~time->module~face_interpolant module~ausmp ausmP module~ausmp->module~face_interpolant module~scheme scheme module~scheme->module~face_interpolant module~scheme->module~ausmp module~update update module~update->module~face_interpolant module~update->module~boundary_state_reconstruction module~update->module~time module~update->module~scheme module~solver solver module~solver->module~time module~solver->module~scheme module~solver->module~update program~main main program~main->module~solver var panmodulewenoUsedByGraph = svgPanZoom('#modulewenoUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines compute_face_states compute_weno_states Subroutines private subroutine compute_face_states (qp, f_qp_left, f_qp_right, flags, dims) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitive state variable at faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitive state variable at faces integer, intent(in), dimension(3) :: flags flags for direction switch type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_weno_states (qp, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, dims) Call Weno scheme for all the three direction I,J, and K Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/weno.html","title":"weno – FEST-3D"},{"text":"Reference: 2 Huang, W. F., Ren, Y. X., and Jiang, X., \n“A simple algorithm to improve the performance of the WENO scheme on non-uniform grids,” \nActa Mechanica Sinica/Lixue Xuebao, 2017, pp. 1–11. Uses vartypes module~~weno_nm~~UsesGraph module~weno_nm weno_NM module~vartypes vartypes module~weno_nm->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~weno_nm~~UsedByGraph module~weno_nm weno_NM module~face_interpolant face_interpolant module~face_interpolant->module~weno_nm module~boundary_state_reconstruction boundary_state_reconstruction module~boundary_state_reconstruction->module~face_interpolant module~time time module~time->module~face_interpolant module~ausmp ausmP module~ausmp->module~face_interpolant module~scheme scheme module~scheme->module~face_interpolant module~scheme->module~ausmp module~update update module~update->module~face_interpolant module~update->module~boundary_state_reconstruction module~update->module~time module~update->module~scheme module~solver solver module~solver->module~time module~solver->module~scheme module~solver->module~update program~main main program~main->module~solver var panmoduleweno_nmUsedByGraph = svgPanZoom('#moduleweno_nmUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines compute_face_states compute_weno_NM_states Subroutines private subroutine compute_face_states (qp, f_qp_left, f_qp_right, flags, cells, dims) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_left primitive state at faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3), 1:dims%n_var) :: f_qp_right primitive state at faces integer, intent(in), dimension(3) :: flags flags for direction switch type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Input cell quantities: volume type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_weno_NM_states (qp, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, cells, dims) Call Weno scheme for all the three direction I,J, and K Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/weno_nm.html","title":"weno_NM – FEST-3D"},{"text":"Interpolation of primitive variable from cell centers to faces Uses weno_NM ppm muscl utils vartypes weno module~~face_interpolant~~UsesGraph module~face_interpolant face_interpolant module~vartypes vartypes module~face_interpolant->module~vartypes module~ppm ppm module~face_interpolant->module~ppm module~muscl muscl module~face_interpolant->module~muscl module~utils utils module~face_interpolant->module~utils module~weno weno module~face_interpolant->module~weno module~weno_nm weno_NM module~face_interpolant->module~weno_nm iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~ppm->module~vartypes module~muscl->module~vartypes module~weno->module~vartypes module~weno_nm->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~face_interpolant~~UsedByGraph module~face_interpolant face_interpolant module~boundary_state_reconstruction boundary_state_reconstruction module~boundary_state_reconstruction->module~face_interpolant module~time time module~time->module~face_interpolant module~ausmp ausmP module~ausmp->module~face_interpolant module~scheme scheme module~scheme->module~face_interpolant module~scheme->module~ausmp module~update update module~update->module~face_interpolant module~update->module~boundary_state_reconstruction module~update->module~time module~update->module~scheme module~solver solver module~solver->module~time module~solver->module~scheme module~solver->module~update program~main main program~main->module~solver var panmoduleface_interpolantUsedByGraph = svgPanZoom('#moduleface_interpolantUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x_qp_left x_qp_right y_qp_left y_qp_right z_qp_left z_qp_right pdif Subroutines setup_interpolant_scheme extrapolate_cell_averages_to_faces compute_face_interpolant Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: x_qp_left Store primitive state at the I-face real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: x_qp_right Store primitive state at the I-face real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: y_qp_left Store primitive state at the J-face real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: y_qp_right Store primitive state at the J-face real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: z_qp_left Store primitive state at the K-face real(kind=wp), public, dimension(:, :, :, :), allocatable, target :: z_qp_right Store primitive state at the K-face real(kind=wp), public, dimension(:, :, :), allocatable :: pdif pressure difference\n Used for pressure based witch Subroutines public subroutine setup_interpolant_scheme (dims) Arguments Type Intent Optional Attributes Name type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine extrapolate_cell_averages_to_faces (qp, dims) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_face_interpolant (qp, cells, scheme, flow, dims) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center type( celltype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2) :: cells Cell center quantities: volume, cellCenter type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/face_interpolant.html","title":"face_interpolant – FEST-3D"},{"text":"Reference: Colella, P. and Woodward, P.R., The piecewise \nparabolic method (PPM) for gas-dynamical simulations, Journal\nof computational physics, vol. 54, no. 1, pp.174-201, 1984 Uses vartypes module~~ppm~~UsesGraph module~ppm ppm module~vartypes vartypes module~ppm->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ppm~~UsedByGraph module~ppm ppm module~face_interpolant face_interpolant module~face_interpolant->module~ppm module~boundary_state_reconstruction boundary_state_reconstruction module~boundary_state_reconstruction->module~face_interpolant module~time time module~time->module~face_interpolant module~ausmp ausmP module~ausmp->module~face_interpolant module~scheme scheme module~scheme->module~face_interpolant module~scheme->module~ausmp module~update update module~update->module~face_interpolant module~update->module~boundary_state_reconstruction module~update->module~time module~update->module~scheme module~solver solver module~solver->module~time module~solver->module~scheme module~solver->module~update program~main main program~main->module~solver var panmoduleppmUsedByGraph = svgPanZoom('#moduleppmUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines compute_face_estimates remove_extrema pressure_based_switching compute_ppm_states Subroutines private subroutine compute_face_estimates (qp, f_qp_left, f_qp_right, flags, dims) Subroutine to calculate state at the face, generalized for Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_left primitive state at faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_right primitive state at faces integer, intent(in), dimension(3) :: flags Flags for direction switch type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine remove_extrema (qp, f_qp_left, f_qp_right, flags, dims) Remove extrema from the state estimated. \n Limiting the value in case of PPM Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_left primitve state variable at faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_right primitve state variable at faces integer, intent(in), dimension(3) :: flags flags for direction switch type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx private subroutine pressure_based_switching (qp, f_qp_left, f_qp_right, pdif, flags, flow, dims) Pressure based switching. \n User x,y, or z for I,J,or K face respectively Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_left primitive state at faces real(kind=wp), intent(inout), dimension(1-flags(1):dims%imx-1+2*flags(1), 1-flags(2):dims%jmx-1+2*flags(2), 1-flags(3):dims%kmx-1+2*flags(3),1:dims%n_var) :: f_qp_right primitive state at faces real(kind=wp), intent(inout), dimension(0:dims%imx,0:dims%jmx,0:dims%kmx) :: pdif pressure difference integer, intent(in), dimension(3) :: flags flags for direction switch type( flowtype ), intent(in) :: flow type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx public subroutine compute_ppm_states (qp, x_qp_l, x_qp_r, y_qp_l, y_qp_r, z_qp_l, z_qp_r, pdif, scheme, flow, dims) Call PPM face-state reconstruction for each face\n with optional call for remove extrema based on\n input limter switch and call pressure based switching\n based on input pressure based switch Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp Store primitive variable at cell center real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_l Store primitive state at the I-face real(kind=wp), intent(inout), dimension(0:dims%imx+1,1:dims%jmx-1,1:dims%kmx-1,1:dims%n_var) :: x_qp_r Store primitive state at the I-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_l Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,0:dims%jmx+1,1:dims%kmx-1,1:dims%n_var) :: y_qp_r Store primitive state at the J-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_l Store primitive state at the K-face real(kind=wp), intent(inout), dimension(1:dims%imx-1,1:dims%jmx-1,0:dims%kmx+1,1:dims%n_var) :: z_qp_r Store primitive state at the K-face real(kind=wp), intent(inout), dimension(0:dims%imx,0:dims%jmx,0:dims%kmx) :: pdif pressure difference type( schemetype ), intent(in) :: scheme finite-volume Schemes type( flowtype ), intent(in) :: flow Information about fluid flow: freestream-speed, ref-viscosity,etc. type( extent ), intent(in) :: dims Extent of the domain:imx,jmx,kmx","tags":"","loc":"module/ppm.html","title":"ppm – FEST-3D"},{"text":"Setup boundary condition for the domain Uses read_bc vartypes utils module~~bc~~UsesGraph module~bc bc module~utils utils module~bc->module~utils module~read_bc read_bc module~bc->module~read_bc module~vartypes vartypes module~bc->module~vartypes module~read_bc->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~bc~~UsedByGraph module~bc bc module~solver solver module~solver->module~bc program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup_bc Subroutines public subroutine setup_bc (files, scheme, flow, bc, dims) Initialization and allocate memory of boundary condition variables Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow type( boundarytype ), intent(inout) :: bc type( extent ), intent(in) :: dims","tags":"","loc":"module/bc.html","title":"bc – FEST-3D"},{"text":"A module contains generalized subroutine to copy variable in ghost cells Uses vartypes module~~copy_bc~~UsesGraph module~copy_bc copy_bc module~vartypes vartypes module~copy_bc->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~copy_bc~~UsedByGraph module~copy_bc copy_bc module~ft_bc FT_bc module~ft_bc->module~copy_bc module~viscosity viscosity module~viscosity->module~copy_bc module~bc_primitive bc_primitive module~bc_primitive->module~copy_bc module~bc_primitive->module~ft_bc module~source source module~source->module~viscosity module~plusgs plusgs module~plusgs->module~viscosity module~write_output_vtk write_output_vtk module~write_output_vtk->module~viscosity module~write_output_tec write_output_tec module~write_output_tec->module~viscosity module~lusgs lusgs module~lusgs->module~viscosity module~solver solver module~solver->module~viscosity module~update update module~solver->module~update module~time time module~solver->module~time module~viscous viscous module~solver->module~viscous module~dump_solution dump_solution module~solver->module~dump_solution module~write_output_tec_node write_output_tec_node module~write_output_tec_node->module~viscosity module~update->module~viscosity module~update->module~bc_primitive module~update->module~source module~update->module~plusgs module~update->module~lusgs module~update->module~time module~update->module~viscous module~time->module~viscosity module~viscous->module~viscosity program~main main program~main->module~solver module~write_output write_output module~write_output->module~write_output_vtk module~write_output->module~write_output_tec module~write_output->module~write_output_tec_node module~dump_solution->module~write_output var panmodulecopy_bcUsedByGraph = svgPanZoom('#modulecopy_bcUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines copy1 copy3 Subroutines public subroutine copy1 (var, type, face, dims) Copy 1 layer of interior cell to first ghost cell layer Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2) :: var Varible over which these operation has to be performed character(len=*), intent(in) :: type Type of copy: flat, symmetry, anti-symmetry character(len=*), intent(in) :: face Face over which boundary condition is being called type( extent ), intent(in) :: dims public subroutine copy3 (var, type, face, bc, dims) Copy 3 layer of interior cell to three ghost cell layer Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2) :: var Varible over which these operation has to be performed character(len=*), intent(in) :: type Type of copy: flat, symmetry, anti-symmetry character(len=*), intent(in) :: face Face over which boundary condition is being called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims","tags":"","loc":"module/copy_bc.html","title":"copy_bc – FEST-3D"},{"text":"Apply boundary condition at every iteration Uses global_sst FT_bc copy_bc vartypes wall_dist module~~bc_primitive~~UsesGraph module~bc_primitive bc_primitive module~global_sst global_sst module~bc_primitive->module~global_sst module~ft_bc FT_bc module~bc_primitive->module~ft_bc module~copy_bc copy_bc module~bc_primitive->module~copy_bc module~wall_dist wall_dist module~bc_primitive->module~wall_dist module~vartypes vartypes module~bc_primitive->module~vartypes iso_fortran_env iso_fortran_env module~global_sst->iso_fortran_env module~ft_bc->module~copy_bc module~ft_bc->module~vartypes module~copy_bc->module~vartypes module~wall_dist->module~vartypes module~utils utils module~wall_dist->module~utils module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~bc_primitive~~UsedByGraph module~bc_primitive bc_primitive module~update update module~update->module~bc_primitive module~solver solver module~solver->module~update program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables face_num current_iter imx jmx kmx n_var turbulence transition gm R_gas mu_ref T_ref Sutherland_temp x_speed_inf y_speed_inf z_speed_inf density_inf pressure_inf tk_inf tw_inf te_inf tv_inf tgm_inf tkl_inf qp density x_speed y_speed z_speed pressure tk tw te tv tkl tgm Subroutines populate_ghost_primitive supersonic_inlet supersonic_outlet subsonic_inlet subsonic_outlet wall slip_wall pole fix no_slip set_omega_at_wall far_field total_pressure temp_based_density periodic_bc Variables Type Visibility Attributes Name Initial integer, private :: face_num integer, private :: current_iter Number of the face : 1:imin, 2:imax, 3:jmin, 4:jmax, 5:kmin, 6:kmax integer, private :: imx Number of the face : 1:imin, 2:imax, 3:jmin, 4:jmax, 5:kmin, 6:kmax integer, private :: jmx Number of the face : 1:imin, 2:imax, 3:jmin, 4:jmax, 5:kmin, 6:kmax integer, private :: kmx Number of the face : 1:imin, 2:imax, 3:jmin, 4:jmax, 5:kmin, 6:kmax integer, private :: n_var Number of the face : 1:imin, 2:imax, 3:jmin, 4:jmax, 5:kmin, 6:kmax character(len=32), private :: turbulence character(len=32), private :: transition real(kind=wp), private :: gm real(kind=wp), private :: R_gas real(kind=wp), private :: mu_ref real(kind=wp), private :: T_ref real(kind=wp), private :: Sutherland_temp real(kind=wp), private :: x_speed_inf real(kind=wp), private :: y_speed_inf real(kind=wp), private :: z_speed_inf real(kind=wp), private :: density_inf real(kind=wp), private :: pressure_inf real(kind=wp), private :: tk_inf real(kind=wp), private :: tw_inf real(kind=wp), private :: te_inf real(kind=wp), private :: tv_inf real(kind=wp), private :: tgm_inf real(kind=wp), private :: tkl_inf real(kind=wp), private, dimension(:, :, :, :), pointer :: qp real(kind=wp), private, dimension(:, :, :), pointer :: density Rho pointer, point to slice of qp (:,:,:,1) real(kind=wp), private, dimension(:, :, :), pointer :: x_speed U pointer, point to slice of qp (:,:,:,2) real(kind=wp), private, dimension(:, :, :), pointer :: y_speed V pointer, point to slice of qp (:,:,:,3) real(kind=wp), private, dimension(:, :, :), pointer :: z_speed W pointer, point to slice of qp (:,:,:,4) real(kind=wp), private, dimension(:, :, :), pointer :: pressure P pointer, point to slice of qp (:,:,:,5) real(kind=wp), private, dimension(:, :, :), pointer :: tk TKE/mass real(kind=wp), private, dimension(:, :, :), pointer :: tw Omega real(kind=wp), private, dimension(:, :, :), pointer :: te Dissipation real(kind=wp), private, dimension(:, :, :), pointer :: tv SA visocity real(kind=wp), private, dimension(:, :, :), pointer :: tkl KL K-KL method real(kind=wp), private, dimension(:, :, :), pointer :: tgm Intermittency of LCTM2015 Subroutines public subroutine populate_ghost_primitive (state, Ifaces, Jfaces, Kfaces, control, scheme, flow, bc, dims) Populate the state variables in the ghost cell\n with particular value based on the boundary conditio \n being applied at that face Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state state variables type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine supersonic_inlet (face, bc) Supersonic inlet boundary condition\n All the values of state variables are fixed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face type( boundarytype ), intent(in) :: bc Name of the face at which boundary condition is called private subroutine supersonic_outlet (face, bc, dims) Supersonic outlet boundary condition. \n All the values of state variables are copied \n from inside the domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine subsonic_inlet (face, bc, dims) Subsonic inlet boundary condition. \n All the state variables's value expect pressure\n is fixed and pressure is copied from inside the \n domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine subsonic_outlet (face, bc, dims) Subsonic outlet boundary condition. \n All the state variables's value expect pressure\n is copied from the inside of the domain and pressure \n is fixed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine wall (face, bc, dims) Adiabatic/Isothermal wall boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face type( boundarytype ), intent(in) :: bc Name of the face at which boundary condition is called type( extent ), intent(in) :: dims private subroutine slip_wall (face, Ifaces, Jfaces, Kfaces, bc, dims) Slip wall boundary condition. \n Maintain flow tangency Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal\n Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine pole (face, bc, dims) Boundary condition for the block face\n with zero area; turning into a pole Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine fix (var, fix_val, face) Generalized subroutine to fix particular value\n at particular face Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2) :: var Variable of which values are being fixed in the ghost cell real(kind=wp), intent(in), dimension(1:6) :: fix_val Amount of value that need to be fixed. character(len=*), intent(in) :: face Name of the face at which boundary condition is called private subroutine no_slip (face, bc, dims) No-slip wall boundary condition. All the \n component of velocity throught face is zero Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine set_omega_at_wall (face) Set value of turbulence variable: omega (turbulenct dissipation rate). \n Value fixed is accourding to the SST turbulence model Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face private subroutine far_field (face, Ifaces, Jfaces, Kfaces, bc, dims) Far-field Riemann boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine total_pressure (face, Ifaces, Jfaces, Kfaces, bc, dims) Total Pressure Riemann boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine temp_based_density (temperature, face, bc, dims) Specify the density in the ghost cell based on the\n temperature on the wall. Isothermal or adiabatic Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:6) :: temperature character(len=*), intent(in) :: face type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine periodic_bc (face) Single block periodic boundary condition.\n Not to be used for multiblock boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face","tags":"","loc":"module/bc_primitive.html","title":"bc_primitive – FEST-3D"},{"text":"Apply flow tangency boundary condition Uses copy_bc vartypes module~~ft_bc~~UsesGraph module~ft_bc FT_bc module~copy_bc copy_bc module~ft_bc->module~copy_bc module~vartypes vartypes module~ft_bc->module~vartypes module~copy_bc->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ft_bc~~UsedByGraph module~ft_bc FT_bc module~bc_primitive bc_primitive module~bc_primitive->module~ft_bc module~update update module~update->module~bc_primitive module~solver solver module~solver->module~update program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines flow_tangency Subroutines public subroutine flow_tangency (qp, face, Ifaces, Jfaces, Kfaces, dims) Apply flow tangency boundary condition Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp character(len=*), intent(in) :: face Face over which flow tangency condition has to be applied type( facetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+2,-2:dims%kmx+2) :: Ifaces Input varaible which stores I faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+3,-2:dims%kmx+2) :: Jfaces Input varaible which stores J faces' area and unit normal type( facetype ), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+3) :: Kfaces Input varaible which stores K faces' area and unit normal type( extent ), intent(in) :: dims","tags":"","loc":"module/ft_bc.html","title":"FT_bc – FEST-3D"},{"text":"Get all the fixed values from the bc_**.md file Uses vartypes module~~read_bc~~UsesGraph module~read_bc read_bc module~vartypes vartypes module~read_bc->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read_bc~~UsedByGraph module~read_bc read_bc module~bc bc module~bc->module~read_bc module~solver solver module~solver->module~bc program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables buf Subroutines read_fixed_values get_fixed_values fill_fixed_values set_value Variables Type Visibility Attributes Name Initial character(len=STRING_BUFFER_LENGTH), private :: buf String to extract single line from the file Subroutines public subroutine read_fixed_values (files, scheme, flow, bc) Read fixed values for each block face Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow type( boundarytype ), intent(inout) :: bc private subroutine get_fixed_values (files, scheme, flow, bc, count) Extract fixed value from the bc_**.md file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow type( boundarytype ), intent(inout) :: bc integer, intent(in) :: count private subroutine fill_fixed_values (scheme, flow, bc) Fill the Fixed_var array with with free-stream value\n or default values. Arguments Type Intent Optional Attributes Name type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow type( boundarytype ), intent(inout) :: bc private subroutine set_value (fixed_var, fix_val, inf_val, count, ios) Set particular value to the Fixed_var variable Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: fixed_var real(kind=wp), intent(in) :: fix_val real(kind=wp), intent(in) :: inf_val integer, intent(in) :: count integer, intent(in) :: ios","tags":"","loc":"module/read_bc.html","title":"read_bc – FEST-3D"},{"text":"Reconstruct the boundary face in case of 4th and 5th order higher order\n face state reconstruction method. Since the limited information\n is available at the boundaries, the boundary face is limiter to \n 3rd order accurate and is reconstructed using MUSCL Scheme even when\n rest of the domain is using WENO or PPM Uses vartypes face_interpolant module~~boundary_state_reconstruction~~UsesGraph module~boundary_state_reconstruction boundary_state_reconstruction module~face_interpolant face_interpolant module~boundary_state_reconstruction->module~face_interpolant module~vartypes vartypes module~boundary_state_reconstruction->module~vartypes module~face_interpolant->module~vartypes module~ppm ppm module~face_interpolant->module~ppm module~muscl muscl module~face_interpolant->module~muscl module~utils utils module~face_interpolant->module~utils module~weno weno module~face_interpolant->module~weno module~weno_nm weno_NM module~face_interpolant->module~weno_nm iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~ppm->module~vartypes module~muscl->module~vartypes module~weno->module~vartypes module~weno_nm->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~boundary_state_reconstruction~~UsedByGraph module~boundary_state_reconstruction boundary_state_reconstruction module~update update module~update->module~boundary_state_reconstruction module~solver solver module~solver->module~update program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ppm_flag switch_L imx jmx kmx n_var Subroutines reconstruct_boundary_state reconstruct_imin reconstruct_imax reconstruct_jmin reconstruct_jmax reconstruct_kmin reconstruct_kmax Variables Type Visibility Attributes Name Initial integer, private :: ppm_flag = 0 Flag to check if reconstruction is required integer, private :: switch_L = 1 Limiter switch integer, private :: imx integer, private :: jmx integer, private :: kmx integer, private :: n_var Subroutines public subroutine reconstruct_boundary_state (qp, control, scheme, bc, dims) Call reconstruction based on the flag and boundary condition Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var) :: qp type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine reconstruct_imin (qp, scheme, bc) Reconstruct state at the IMIN boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc private subroutine reconstruct_imax (qp, scheme, bc) Reconstruct state at the IMAX boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc private subroutine reconstruct_jmin (qp, scheme, bc) Reconstruct state at the JMIN boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc private subroutine reconstruct_jmax (qp, scheme, bc) Reconstruct state at the JMAX boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc private subroutine reconstruct_kmin (qp, scheme, bc) Reconstruct state at the KMIN boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc private subroutine reconstruct_kmax (qp, scheme, bc) Reconstruct state at the KMAX boundary face with MUSCL scheme Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2, 1:n_var) :: qp type( schemetype ), intent(in) :: scheme type( boundarytype ), intent(in) :: bc","tags":"","loc":"module/boundary_state_reconstruction.html","title":"boundary_state_reconstruction – FEST-3D"},{"text":"Calculate the distance from the wall \n for each cell-center in the domain Uses vartypes utils module~~wall_dist~~UsesGraph module~wall_dist wall_dist module~utils utils module~wall_dist->module~utils module~vartypes vartypes module~wall_dist->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~wall_dist~~UsedByGraph module~wall_dist wall_dist module~source source module~source->module~wall_dist module~viscosity viscosity module~source->module~viscosity module~cc CC module~source->module~cc module~plusgs plusgs module~plusgs->module~wall_dist module~plusgs->module~viscosity module~write_output_vtk write_output_vtk module~write_output_vtk->module~wall_dist module~write_output_vtk->module~viscosity module~write_output_tec write_output_tec module~write_output_tec->module~wall_dist module~write_output_tec->module~viscosity module~lusgs lusgs module~lusgs->module~wall_dist module~lusgs->module~viscosity module~solver solver module~solver->module~wall_dist module~solver->module~viscosity module~solver->module~cc module~update update module~solver->module~update module~time time module~solver->module~time module~viscous viscous module~solver->module~viscous module~dump_solution dump_solution module~solver->module~dump_solution module~write_output_tec_node write_output_tec_node module~write_output_tec_node->module~wall_dist module~write_output_tec_node->module~viscosity module~viscosity->module~wall_dist module~bc_primitive bc_primitive module~bc_primitive->module~wall_dist module~cc->module~wall_dist module~update->module~wall_dist module~update->module~source module~update->module~plusgs module~update->module~lusgs module~update->module~viscosity module~update->module~bc_primitive module~update->module~time module~update->module~viscous program~main main program~main->module~solver module~time->module~viscosity module~viscous->module~viscosity module~write_output write_output module~write_output->module~write_output_vtk module~write_output->module~write_output_tec module~write_output->module~write_output_tec_node module~dump_solution->module~write_output var panmodulewall_distUsedByGraph = svgPanZoom('#modulewall_distUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables n_surfnodes wall_x wall_y wall_z dist imx jmx kmx Subroutines setup_wall_dist setup_nodefile read_destroy_nodefile find_wall_dist Variables Type Visibility Attributes Name Initial integer, private :: n_surfnodes Number of surfce node points real(kind=wp), private, dimension(:), allocatable :: wall_x X component of wall surface node point real(kind=wp), private, dimension(:), allocatable :: wall_y Y component of wall surface node point real(kind=wp), private, dimension(:), allocatable :: wall_z Z component of wall surface node point real(kind=wp), public, dimension(:, :, :), allocatable :: dist integer, private :: imx integer, private :: jmx integer, private :: kmx Subroutines public subroutine setup_wall_dist (files, dims) Allocate memory to the wall_distance variables\n and read the surface node file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( extent ), intent(in) :: dims private subroutine setup_nodefile (files) Open and read first line of surface_node_point file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files private subroutine read_destroy_nodefile (files) Read, and close surface_node_point file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files public subroutine find_wall_dist (nodes, dims) Determine the minimum wall distance from the wall surface node points Arguments Type Intent Optional Attributes Name type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( extent ), intent(in) :: dims","tags":"","loc":"module/wall_dist.html","title":"wall_dist – FEST-3D"},{"text":"Detect all the grid points on the wall boundary condition\n and store them in a single file Uses mpi vartypes utils module~~wall~~UsesGraph module~wall wall module~utils utils module~wall->module~utils module~vartypes vartypes module~wall->module~vartypes mpi mpi module~wall->mpi iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~wall~~UsedByGraph module~wall wall module~solver solver module~solver->module~wall program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ierr new_type thisfile maxlen wallc wall_x wall_y wall_z no_slip_flag n_wall total_n_wall str line lf n_wall_buf write_flag imx jmx kmx Subroutines write_surfnode allocate_memory link_aliases setup_surface find_wall surface_points Variables Type Visibility Attributes Name Initial integer, private :: ierr Integer to store error integer, private :: new_type Create new type for MPI integer, private :: thisfile File hadler integer, private, parameter :: maxlen = 70 Maximum length for string real(kind=wp), private, dimension(:, :), allocatable, target :: wallc Centre of wall surface real(kind=wp), private, dimension(:), pointer :: wall_x X coordiante of center of wall surface real(kind=wp), private, dimension(:), pointer :: wall_y Y coordiante of center of wall surface real(kind=wp), private, dimension(:), pointer :: wall_z Z coordiante of center of wall surface integer, private, dimension(6) :: no_slip_flag = 0 Flag to detect wall integer, public :: n_wall Number of points on the wall integer, public :: total_n_wall Total number of points on the block across all processes character(len=maxlen), private, dimension(:), allocatable :: str Store all wall corridnate of current process in a string vector character(len=maxlen), private :: line Line to write in output file character, private, parameter :: lf = Achar(10) End of line character integer, private, dimension(:), allocatable :: n_wall_buf Store n_wall points of all processors in a array form integer, private, dimension(:), allocatable :: write_flag Check if current processor has any wall points to write integer, private :: imx integer, private :: jmx integer, private :: kmx Subroutines public subroutine write_surfnode (files, nodes, control, bc, dims) Extract and write the wall surface node points\n in a file shared by all the MPI processes Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( boundarytype ), intent(in) :: bc type( extent ), intent(in) :: dims private subroutine allocate_memory (control) Allocate memory to str and wallc variable array Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control private subroutine link_aliases () Link pointers wall_x, wall_y, wall_z to wallc Arguments None private subroutine setup_surface (files, control, bc) Open MPI_shared write file, allocate memory and\n setup pointers Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(in) :: control type( boundarytype ), intent(in) :: bc private subroutine find_wall (bc) Setup wall flag for all six boundary of the block Arguments Type Intent Optional Attributes Name type( boundarytype ), intent(in) :: bc private subroutine surface_points (nodes) Extract surface points and store them\n in a string vector str(ind) Arguments Type Intent Optional Attributes Name type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes","tags":"","loc":"module/wall.html","title":"wall – FEST-3D"},{"text":"Check for the input from the output_control.md file Uses vartypes module~~check_output_control~~UsesGraph module~check_output_control check_output_control module~vartypes vartypes module~check_output_control->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~check_output_control~~UsedByGraph module~check_output_control check_output_control module~state state module~state->module~check_output_control module~read_output read_output module~state->module~read_output module~read_output->module~check_output_control module~solver solver module~solver->module~state program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions lcase Subroutines verify_write_control verify_read_control Functions private function lcase (text) result(res) Make the whole string to lower case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Input string of any case Return Value character(len=STRING_BUFFER_LENGTH) Output string of lower case Subroutines public subroutine verify_write_control (control, scheme, flow) Verify all the variable being asked to write in the output file. \n This is a fail-safe subroutine which do not allow to write the incorrect input variable Arguments Type Intent Optional Attributes Name type( controltype ), intent(inout) :: control type( schemetype ), intent(in) :: scheme type( flowtype ), intent(in) :: flow public subroutine verify_read_control (control, scheme) Verify all the variable being asked to read in the output file. \n This is a fail-safe subroutine which do not allow to read the incorrect input variable. \n Based on previous flow type some varible might be skipped Arguments Type Intent Optional Attributes Name type( controltype ), intent(inout) :: control type( schemetype ), intent(in) :: scheme","tags":"","loc":"module/check_output_control.html","title":"check_output_control – FEST-3D"},{"text":"Writing solution in the output file in tecplot format with\n node data instead of cell-center data. Uses global_sst utils wall_dist gradients viscosity vartypes module~~write_output_tec_node~~UsesGraph module~write_output_tec_node write_output_tec_node module~wall_dist wall_dist module~write_output_tec_node->module~wall_dist module~utils utils module~write_output_tec_node->module~utils module~global_sst global_sst module~write_output_tec_node->module~global_sst module~viscosity viscosity module~write_output_tec_node->module~viscosity module~gradients gradients module~write_output_tec_node->module~gradients module~vartypes vartypes module~write_output_tec_node->module~vartypes module~wall_dist->module~utils module~wall_dist->module~vartypes iso_fortran_env iso_fortran_env module~global_sst->iso_fortran_env module~viscosity->module~wall_dist module~viscosity->module~utils module~viscosity->module~global_sst module~viscosity->module~gradients module~viscosity->module~vartypes module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sa global_sa module~viscosity->module~global_sa module~global_kkl global_kkl module~viscosity->module~global_kkl module~gradients->module~utils module~gradients->module~vartypes module~vartypes->iso_fortran_env module~copy_bc->module~vartypes module~global_sa->iso_fortran_env module~global_kkl->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~write_output_tec_node~~UsedByGraph module~write_output_tec_node write_output_tec_node module~write_output write_output module~write_output->module~write_output_tec_node module~dump_solution dump_solution module~dump_solution->module~write_output module~solver solver module~solver->module~dump_solution program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables OUT_FILE_UNIT i j k format imx jmx kmx density x_speed y_speed z_speed pressure tk tw te tv tkl tgm Subroutines write_file write_header write_grid write_scalar Variables Type Visibility Attributes Name Initial integer, private :: OUT_FILE_UNIT integer, private :: i integer, private :: j integer, private :: k character(len=*), private, parameter :: format = \"(35e25.15)\" integer, private :: imx integer, private :: jmx integer, private :: kmx real(kind=wp), private, dimension(:, :, :), pointer :: density Rho pointer, point to slice of qp (:,:,:,1) real(kind=wp), private, dimension(:, :, :), pointer :: x_speed U pointer, point to slice of qp (:,:,:,2) real(kind=wp), private, dimension(:, :, :), pointer :: y_speed V pointer, point to slice of qp (:,:,:,3) real(kind=wp), private, dimension(:, :, :), pointer :: z_speed W pointer, point to slice of qp (:,:,:,4) real(kind=wp), private, dimension(:, :, :), pointer :: pressure P pointer, point to slice of qp (:,:,:,5) real(kind=wp), private, dimension(:, :, :), pointer :: tk TKE, point to slice of qp (:,:,:,6) real(kind=wp), private, dimension(:, :, :), pointer :: tw Omega, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: te Dissipation, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: tv SA visocity, point to slice of qp (:,:,:,6) real(kind=wp), private, dimension(:, :, :), pointer :: tkl KL K-KL method, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: tgm Intermittency of LCTM2015, point to slice of qp (:,:,:,8) Subroutines public subroutine write_file (file_handler, state, nodes, control, scheme, dims) Write output file in the tecplot format with node data Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims private subroutine write_header (control) Write the header in the output file Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control private subroutine write_grid (nodes) Write grid information in the output file Arguments Type Intent Optional Attributes Name type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes private subroutine write_scalar (var, name, index) Write scalar variable in the output file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index","tags":"","loc":"module/write_output_tec_node.html","title":"write_output_tec_node – FEST-3D"},{"text":"Vtk module to write the solution in the vtk format Uses global_sst utils wall_dist gradients viscosity vartypes module~~write_output_vtk~~UsesGraph module~write_output_vtk write_output_vtk module~wall_dist wall_dist module~write_output_vtk->module~wall_dist module~utils utils module~write_output_vtk->module~utils module~global_sst global_sst module~write_output_vtk->module~global_sst module~viscosity viscosity module~write_output_vtk->module~viscosity module~gradients gradients module~write_output_vtk->module~gradients module~vartypes vartypes module~write_output_vtk->module~vartypes module~wall_dist->module~utils module~wall_dist->module~vartypes iso_fortran_env iso_fortran_env module~global_sst->iso_fortran_env module~viscosity->module~wall_dist module~viscosity->module~utils module~viscosity->module~global_sst module~viscosity->module~gradients module~viscosity->module~vartypes module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sa global_sa module~viscosity->module~global_sa module~global_kkl global_kkl module~viscosity->module~global_kkl module~gradients->module~utils module~gradients->module~vartypes module~vartypes->iso_fortran_env module~copy_bc->module~vartypes module~global_sa->iso_fortran_env module~global_kkl->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~write_output_vtk~~UsedByGraph module~write_output_vtk write_output_vtk module~write_output write_output module~write_output->module~write_output_vtk module~dump_solution dump_solution module~dump_solution->module~write_output module~solver solver module~solver->module~dump_solution program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables OUT_FILE_UNIT i j k imx jmx kmx density x_speed y_speed z_speed pressure tk tw te tv tkl tgm Subroutines write_file write_header write_grid write_velocity write_scalar Variables Type Visibility Attributes Name Initial integer, private :: OUT_FILE_UNIT integer, private :: i integer, private :: j integer, private :: k integer, private :: imx integer, private :: jmx integer, private :: kmx real(kind=wp), private, dimension(:, :, :), pointer :: density Rho pointer, point to slice of qp (:,:,:,1) real(kind=wp), private, dimension(:, :, :), pointer :: x_speed U pointer, point to slice of qp (:,:,:,2) real(kind=wp), private, dimension(:, :, :), pointer :: y_speed V pointer, point to slice of qp (:,:,:,3) real(kind=wp), private, dimension(:, :, :), pointer :: z_speed W pointer, point to slice of qp (:,:,:,4) real(kind=wp), private, dimension(:, :, :), pointer :: pressure P pointer, point to slice of qp (:,:,:,5) real(kind=wp), private, dimension(:, :, :), pointer :: tk TKE, point to slice of qp (:,:,:,6) real(kind=wp), private, dimension(:, :, :), pointer :: tw Omega, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: te Dissipation, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: tv SA visocity, point to slice of qp (:,:,:,6) real(kind=wp), private, dimension(:, :, :), pointer :: tkl KL K-KL method, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: tgm Intermittency of LCTM2015, point to slice of qp (:,:,:,8) Subroutines public subroutine write_file (file_handler, state, nodes, control, scheme, dims) Write the header and variables in the file \"process_xx.dat\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims private subroutine write_header (Write_data_format) Write the header in the output file in the tecplot format Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Write_data_format private subroutine write_grid (nodes) Write the grid information in the output file Arguments Type Intent Optional Attributes Name type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes private subroutine write_velocity () Write the velocity vector in the output file Arguments None private subroutine write_scalar (var, name, index) Write the scalar variable in the output file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index","tags":"","loc":"module/write_output_vtk.html","title":"write_output_vtk – FEST-3D"},{"text":"Tecplot module to write the solution in the tecplot format Uses global_sst utils wall_dist gradients viscosity vartypes module~~write_output_tec~~UsesGraph module~write_output_tec write_output_tec module~wall_dist wall_dist module~write_output_tec->module~wall_dist module~utils utils module~write_output_tec->module~utils module~global_sst global_sst module~write_output_tec->module~global_sst module~viscosity viscosity module~write_output_tec->module~viscosity module~gradients gradients module~write_output_tec->module~gradients module~vartypes vartypes module~write_output_tec->module~vartypes module~wall_dist->module~utils module~wall_dist->module~vartypes iso_fortran_env iso_fortran_env module~global_sst->iso_fortran_env module~viscosity->module~wall_dist module~viscosity->module~utils module~viscosity->module~global_sst module~viscosity->module~gradients module~viscosity->module~vartypes module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sa global_sa module~viscosity->module~global_sa module~global_kkl global_kkl module~viscosity->module~global_kkl module~gradients->module~utils module~gradients->module~vartypes module~vartypes->iso_fortran_env module~copy_bc->module~vartypes module~global_sa->iso_fortran_env module~global_kkl->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~write_output_tec~~UsedByGraph module~write_output_tec write_output_tec module~write_output write_output module~write_output->module~write_output_tec module~dump_solution dump_solution module~dump_solution->module~write_output module~solver solver module~solver->module~dump_solution program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables OUT_FILE_UNIT i j k format imx jmx kmx density x_speed y_speed z_speed pressure tk tw te tv tkl tgm Subroutines write_file write_header write_grid write_scalar Variables Type Visibility Attributes Name Initial integer, private :: OUT_FILE_UNIT integer, private :: i integer, private :: j integer, private :: k character(len=*), private, parameter :: format = \"(1ES28.15E4)\" integer, private :: imx integer, private :: jmx integer, private :: kmx real(kind=wp), private, dimension(:, :, :), pointer :: density Rho pointer, point to slice of qp (:,:,:,1) real(kind=wp), private, dimension(:, :, :), pointer :: x_speed U pointer, point to slice of qp (:,:,:,2) real(kind=wp), private, dimension(:, :, :), pointer :: y_speed V pointer, point to slice of qp (:,:,:,3) real(kind=wp), private, dimension(:, :, :), pointer :: z_speed W pointer, point to slice of qp (:,:,:,4) real(kind=wp), private, dimension(:, :, :), pointer :: pressure P pointer, point to slice of qp (:,:,:,5) real(kind=wp), private, dimension(:, :, :), pointer :: tk TKE, point to slice of qp (:,:,:,6) real(kind=wp), private, dimension(:, :, :), pointer :: tw Omega, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: te Dissipation, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: tv SA visocity, point to slice of qp (:,:,:,6) real(kind=wp), private, dimension(:, :, :), pointer :: tkl KL K-KL method, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: tgm Intermittency of LCTM2015, point to slice of qp (:,:,:,8) Subroutines public subroutine write_file (file_handler, state, nodes, control, scheme, dims) Write the header and variables in the file \"process_xx.dat\". Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims private subroutine write_header (control) Write the header in the output file in the tecplot format Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control private subroutine write_grid (nodes) Write the grid information in the output file Arguments Type Intent Optional Attributes Name type( nodetype ), intent(in), dimension(-2:imx+3,-2:jmx+3,-2:kmx+3) :: nodes private subroutine write_scalar (var, name, index) Write the scalar variable in the output file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index","tags":"","loc":"module/write_output_tec.html","title":"write_output_tec – FEST-3D"},{"text":"This module contians subroutine that\n  1. check if point of dumping condition is arrived.\n  2. create particular folder for dump.\n  3. dump data in that folder.\n  4. purge folders if required. Uses write_output layout vartypes utils module~~dump_solution~~UsesGraph module~dump_solution dump_solution module~layout layout module~dump_solution->module~layout module~vartypes vartypes module~dump_solution->module~vartypes module~write_output write_output module~dump_solution->module~write_output module~utils utils module~dump_solution->module~utils module~layout->module~vartypes mpi mpi module~layout->mpi iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~write_output->module~vartypes module~write_output->module~utils module~write_output_tec write_output_tec module~write_output->module~write_output_tec module~write_output_tec_node write_output_tec_node module~write_output->module~write_output_tec_node module~write_output_vtk write_output_vtk module~write_output->module~write_output_vtk module~write_output_tec->module~vartypes module~write_output_tec->module~utils module~global_sst global_sst module~write_output_tec->module~global_sst module~viscosity viscosity module~write_output_tec->module~viscosity module~wall_dist wall_dist module~write_output_tec->module~wall_dist module~gradients gradients module~write_output_tec->module~gradients module~write_output_tec_node->module~vartypes module~write_output_tec_node->module~utils module~write_output_tec_node->module~global_sst module~write_output_tec_node->module~viscosity module~write_output_tec_node->module~wall_dist module~write_output_tec_node->module~gradients module~write_output_vtk->module~vartypes module~write_output_vtk->module~utils module~write_output_vtk->module~global_sst module~write_output_vtk->module~viscosity module~write_output_vtk->module~wall_dist module~write_output_vtk->module~gradients module~global_sst->iso_fortran_env module~viscosity->module~vartypes module~viscosity->module~utils module~viscosity->module~global_sst module~viscosity->module~wall_dist module~viscosity->module~gradients module~global_kkl global_kkl module~viscosity->module~global_kkl module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sa global_sa module~viscosity->module~global_sa module~wall_dist->module~vartypes module~wall_dist->module~utils module~gradients->module~vartypes module~gradients->module~utils module~global_kkl->iso_fortran_env module~copy_bc->module~vartypes module~global_sa->iso_fortran_env var panmoduledump_solutionUsesGraph = svgPanZoom('#moduledump_solutionUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~dump_solution~~UsedByGraph module~dump_solution dump_solution module~solver solver module~solver->module~dump_solution program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dump_dirname purge_dirname Subroutines checkpoint create_directory remove_directory purge_dump_dir make_dump_dir dump_data write_restart_log write_initial_resnorm Variables Type Visibility Attributes Name Initial character(len=FILE_NAME_LENGTH), private :: dump_dirname Name(check point number) of the directory to create character(len=FILE_NAME_LENGTH), private :: purge_dirname Name(check point number) of the directory to remove Subroutines public subroutine checkpoint (files, qp, nodes, control, scheme, dims) Create a checkpoint dump file if the time has come Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2, 1:dims%n_var) :: qp type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(inout) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims private subroutine create_directory (dirname) Create a directory to keep the solution files from all the processor Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname private subroutine remove_directory (dirname) Remove a directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname private subroutine purge_dump_dir (control) Purge the directory based on the input Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control private subroutine make_dump_dir (control) Solution directory and sub-directory in created with particular number Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control private subroutine dump_data (files, qp, nodes, control, scheme, dims) Call to write save files in the directory Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files real(kind=wp), intent(in), dimension(-2:dims%imx+2,-2:dims%jmx+2,-2:dims%kmx+2, 1:dims%n_var) :: qp type( nodetype ), intent(in), dimension(-2:dims%imx+3,-2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims private subroutine write_restart_log (files, scheme, control) Call to write log file in the subdirectory \"restart\". \n It is useful information while restarting the solver Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( schemetype ), intent(in) :: scheme type( controltype ), intent(in) :: control private subroutine write_initial_resnorm (files, control) Writing Initial resnorom in the log file to \n maintian continuity of resnorm while restrarting Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(in) :: control","tags":"","loc":"module/dump_solution.html","title":"dump_solution – FEST-3D"},{"text":"Open/close and call other modules for writing solution\n based on the input: type of file, either vtk or tecplot\n modules are called Uses write_output_vtk write_output_tec_node write_output_tec vartypes utils module~~write_output~~UsesGraph module~write_output write_output module~utils utils module~write_output->module~utils module~write_output_tec_node write_output_tec_node module~write_output->module~write_output_tec_node module~write_output_tec write_output_tec module~write_output->module~write_output_tec module~write_output_vtk write_output_vtk module~write_output->module~write_output_vtk module~vartypes vartypes module~write_output->module~vartypes module~write_output_tec_node->module~utils module~write_output_tec_node->module~vartypes module~global_sst global_sst module~write_output_tec_node->module~global_sst module~viscosity viscosity module~write_output_tec_node->module~viscosity module~wall_dist wall_dist module~write_output_tec_node->module~wall_dist module~gradients gradients module~write_output_tec_node->module~gradients module~write_output_tec->module~utils module~write_output_tec->module~vartypes module~write_output_tec->module~global_sst module~write_output_tec->module~viscosity module~write_output_tec->module~wall_dist module~write_output_tec->module~gradients module~write_output_vtk->module~utils module~write_output_vtk->module~vartypes module~write_output_vtk->module~global_sst module~write_output_vtk->module~viscosity module~write_output_vtk->module~wall_dist module~write_output_vtk->module~gradients iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~global_sst->iso_fortran_env module~viscosity->module~utils module~viscosity->module~vartypes module~viscosity->module~global_sst module~viscosity->module~wall_dist module~viscosity->module~gradients module~global_kkl global_kkl module~viscosity->module~global_kkl module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sa global_sa module~viscosity->module~global_sa module~wall_dist->module~utils module~wall_dist->module~vartypes module~gradients->module~utils module~gradients->module~vartypes module~global_kkl->iso_fortran_env module~copy_bc->module~vartypes module~global_sa->iso_fortran_env var panmodulewrite_outputUsesGraph = svgPanZoom('#modulewrite_outputUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~write_output~~UsedByGraph module~write_output write_output module~dump_solution dump_solution module~dump_solution->module~write_output module~solver solver module~solver->module~dump_solution program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables data_format file_format Subroutines setup_file open_file close_file write_file Variables Type Visibility Attributes Name Initial character(len=16), private :: data_format character(len=16), private :: file_format Subroutines private subroutine setup_file (control) Setup the file type based on the input Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control private subroutine open_file (file_handler, filename) Open the file to write the solution Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler character(len=*), intent(in) :: filename private subroutine close_file (file_handler, filename) Close the file after writing solution. Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler character(len=*), intent(in) :: filename public subroutine write_file (files, qp, nodes, control, scheme, dims) Writing output in the file according to the input file type Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files real(kind=wp), intent(in), dimension(-2:dims%imx+2, -2:dims%jmx+2,-2:dims%kmx+2, 1:dims%n_var) :: qp type( nodetype ), intent(in), dimension(-2:dims%imx+3, -2:dims%jmx+3,-2:dims%kmx+3) :: nodes type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims","tags":"","loc":"module/write_output.html","title":"write_output – FEST-3D"},{"text":"Read the restart file in the vtk format Uses vartypes utils module~~read_output_vtk~~UsesGraph module~read_output_vtk read_output_vtk module~utils utils module~read_output_vtk->module~utils module~vartypes vartypes module~read_output_vtk->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read_output_vtk~~UsedByGraph module~read_output_vtk read_output_vtk module~read_output read_output module~read_output->module~read_output_vtk module~state state module~state->module~read_output module~solver solver module~solver->module~state program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables IN_FILE_UNIT imx jmx kmx i j k density x_speed y_speed z_speed pressure tk tw te tv tkl tgm Subroutines read_file read_header read_grid read_velocity read_scalar skip_scalar Variables Type Visibility Attributes Name Initial integer, private :: IN_FILE_UNIT integer, private :: imx integer, private :: jmx integer, private :: kmx integer, private :: i integer, private :: j integer, private :: k real(kind=wp), private, dimension(:, :, :), pointer :: density Rho pointer, point to slice of qp (:,:,:,1) real(kind=wp), private, dimension(:, :, :), pointer :: x_speed U pointer, point to slice of qp (:,:,:,2) real(kind=wp), private, dimension(:, :, :), pointer :: y_speed V pointer, point to slice of qp (:,:,:,3) real(kind=wp), private, dimension(:, :, :), pointer :: z_speed W pointer, point to slice of qp (:,:,:,4) real(kind=wp), private, dimension(:, :, :), pointer :: pressure P pointer, point to slice of qp (:,:,:,5) real(kind=wp), private, dimension(:, :, :), pointer :: tk TKE, point to slice of qp (:,:,:,6) real(kind=wp), private, dimension(:, :, :), pointer :: tw Omega, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: te Dissipation, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: tv SA visocity, point to slice of qp (:,:,:,6) real(kind=wp), private, dimension(:, :, :), pointer :: tkl KL K-KL method, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: tgm Intermittency of LCTM2015, point to slice of qp (:,:,:,8) Subroutines public subroutine read_file (file_handler, state, control, scheme, dims) Read all the variable for the vtk restart file Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims private subroutine read_header () Skip read the header in the vtk file Arguments None private subroutine read_grid () Skip the grid read in the restart file Arguments None private subroutine read_velocity () Read velocity vector from the vtk file Arguments None private subroutine read_scalar (var, name, index) Read scalar from the vtk file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index private subroutine skip_scalar () Skip read scalar from the vtk file Arguments None","tags":"","loc":"module/read_output_vtk.html","title":"read_output_vtk – FEST-3D"},{"text":"Read the restart file in the tecplot format Uses vartypes utils module~~read_output_tec~~UsesGraph module~read_output_tec read_output_tec module~utils utils module~read_output_tec->module~utils module~vartypes vartypes module~read_output_tec->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read_output_tec~~UsedByGraph module~read_output_tec read_output_tec module~read_output read_output module~read_output->module~read_output_tec module~state state module~state->module~read_output module~solver solver module~solver->module~state program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables IN_FILE_UNIT imx jmx kmx i j k density x_speed y_speed z_speed pressure tk tw te tv tkl tgm Subroutines read_file read_header read_grid read_scalar skip_scalar Variables Type Visibility Attributes Name Initial integer, private :: IN_FILE_UNIT integer, private :: imx integer, private :: jmx integer, private :: kmx integer, private :: i integer, private :: j integer, private :: k real(kind=wp), private, dimension(:, :, :), pointer :: density Rho pointer, point to slice of qp (:,:,:,1) real(kind=wp), private, dimension(:, :, :), pointer :: x_speed U pointer, point to slice of qp (:,:,:,2) real(kind=wp), private, dimension(:, :, :), pointer :: y_speed V pointer, point to slice of qp (:,:,:,3) real(kind=wp), private, dimension(:, :, :), pointer :: z_speed W pointer, point to slice of qp (:,:,:,4) real(kind=wp), private, dimension(:, :, :), pointer :: pressure P pointer, point to slice of qp (:,:,:,5) real(kind=wp), private, dimension(:, :, :), pointer :: tk TKE, point to slice of qp (:,:,:,6) real(kind=wp), private, dimension(:, :, :), pointer :: tw Omega, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: te Dissipation, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: tv SA visocity, point to slice of qp (:,:,:,6) real(kind=wp), private, dimension(:, :, :), pointer :: tkl KL K-KL method, point to slice of qp (:,:,:,7) real(kind=wp), private, dimension(:, :, :), pointer :: tgm Intermittency of LCTM2015, point to slice of qp (:,:,:,8) Subroutines public subroutine read_file (file_handler, state, control, scheme, dims) Read all the variable for the tecplot restart file Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_handler real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: state type( controltype ), intent(in) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims private subroutine read_header (control) Skip read the header in the tecplot file Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control private subroutine read_grid () Skip the grid read in the restart file Arguments None private subroutine read_scalar (var, name, index) Read scalar from the tecplot file Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index private subroutine skip_scalar () Skip read scalar from the tecplot file Arguments None","tags":"","loc":"module/read_output_tec.html","title":"read_output_tec – FEST-3D"},{"text":"This module read input control files which include:\n   1. control.md\n   2. fvscheme.md\n   3. flow.md\n   4. res_control.md\n   5. state_read_write_control.md Uses vartypes module~~read~~UsesGraph module~read read module~vartypes vartypes module~read->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read~~UsedByGraph module~read read module~time time module~time->module~read module~solver solver module~solver->module~read module~solver->module~time module~update update module~solver->module~update program~main main program~main->module~solver module~update->module~time Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions get_number_of_line Subroutines read_input_and_controls get_next_token read_controls read_scheme read_flow read_output_control get_rw_count get_count_within_braces read_Res_list Functions private function get_number_of_line (till, infile) result(number) Get number of lines till some character like \"#\" Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: till integer, intent(in) :: infile Return Value integer Subroutines public subroutine read_input_and_controls (files, control, scheme, flow) Read all the input control files Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control type( schemetype ), intent(inout) :: scheme type( flowtype ), intent(inout) :: flow private subroutine get_next_token (token_file_unit, buf) Extract the next token from the config file Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: token_file_unit character(len=STRING_BUFFER_LENGTH), intent(out) :: buf private subroutine read_controls (files, control) Read control.md file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control private subroutine read_scheme (files, scheme) Read fvscheme.md control file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( schemetype ), intent(inout) :: scheme private subroutine read_flow (files, control, flow) Read flow.md control file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control type( flowtype ), intent(inout) :: flow private subroutine read_output_control (files, control) Read output_contorl.md file Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control private subroutine get_rw_count (files, control) Get read/write count Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control private subroutine get_count_within_braces (handler, count) Get number of variables between two curly braces Arguments Type Intent Optional Attributes Name integer, intent(in) :: handler File handler from which list number is extracted integer, intent(out) :: count Extracted count private subroutine read_Res_list (files, control) Read Residual file: res_control.md Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files type( controltype ), intent(inout) :: control","tags":"","loc":"module/read.html","title":"read – FEST-3D"},{"text":"Read output files from the restart folder Free-stream velocity magnitude Uses read_output_vtk check_output_control vartypes utils read_output_tec module~~read_output~~UsesGraph module~read_output read_output module~read_output_vtk read_output_vtk module~read_output->module~read_output_vtk module~utils utils module~read_output->module~utils module~check_output_control check_output_control module~read_output->module~check_output_control module~vartypes vartypes module~read_output->module~vartypes module~read_output_tec read_output_tec module~read_output->module~read_output_tec module~read_output_vtk->module~utils module~read_output_vtk->module~vartypes module~check_output_control->module~vartypes iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~read_output_tec->module~utils module~read_output_tec->module~vartypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read_output~~UsedByGraph module~read_output read_output module~state state module~state->module~read_output module~solver solver module~solver->module~state program~main main program~main->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables file_format data_format Subroutines read_file setup_file open_file close_file read_restart_file Variables Type Visibility Attributes Name Initial character(len=8), private :: file_format Read file format character(len=16), private :: data_format Read file data type Subroutines public subroutine read_file (files, qp, control, scheme, dims) Read restart file Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files real(kind=wp), intent(inout), dimension(-2:dims%imx+2, -2:dims%jmx+2, -2:dims%kmx+2, 1:dims%n_var), target :: qp type( controltype ), intent(inout) :: control type( schemetype ), intent(in) :: scheme type( extent ), intent(in) :: dims private subroutine setup_file (control) Steup the file to read the restart state. Arguments Type Intent Optional Attributes Name type( controltype ), intent(in) :: control private subroutine open_file (files, control) Open file from the restart folder Arguments Type Intent Optional Attributes Name type( filetype ), intent(inout) :: files type( controltype ), intent(in) :: control private subroutine close_file (files) Close the file after reading Arguments Type Intent Optional Attributes Name type( filetype ), intent(in) :: files private subroutine read_restart_file (RESTART_FILE_UNIT, control) Read the sub-directory log file in the restart folder Arguments Type Intent Optional Attributes Name integer, intent(in) :: RESTART_FILE_UNIT type( controltype ), intent(inout) :: control","tags":"","loc":"module/read_output.html","title":"read_output – FEST-3D"},{"text":"Declare all the constants used by SA turbulence model Uses iso_fortran_env module~~global_sa~~UsesGraph module~global_sa global_sa iso_fortran_env iso_fortran_env module~global_sa->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~global_sa~~UsedByGraph module~global_sa global_sa module~source source module~source->module~global_sa module~viscosity viscosity module~source->module~viscosity module~plusgs plusgs module~plusgs->module~global_sa module~plusgs->module~viscosity module~lusgs lusgs module~lusgs->module~global_sa module~lusgs->module~viscosity module~viscosity->module~global_sa module~update update module~update->module~global_sa module~update->module~source module~update->module~plusgs module~update->module~lusgs module~update->module~viscosity module~viscous viscous module~update->module~viscous module~time time module~update->module~time module~viscous->module~global_sa module~viscous->module~viscosity module~solver solver module~solver->module~viscosity module~solver->module~update module~solver->module~viscous module~solver->module~time module~dump_solution dump_solution module~solver->module~dump_solution module~write_output_tec_node write_output_tec_node module~write_output_tec_node->module~viscosity module~time->module~viscosity module~write_output_vtk write_output_vtk module~write_output_vtk->module~viscosity module~write_output_tec write_output_tec module~write_output_tec->module~viscosity program~main main program~main->module~solver module~write_output write_output module~write_output->module~write_output_tec_node module~write_output->module~write_output_vtk module~write_output->module~write_output_tec module~dump_solution->module~write_output var panmoduleglobal_saUsedByGraph = svgPanZoom('#moduleglobal_saUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cb1 cb2 cw2 cw3 cv1 ct3 ct4 sigma_sa kappa_sa cw1 cv1_3 cw3_6 Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: cb1 = 0.1355 real(kind=wp), public, parameter :: cb2 = 0.6220 real(kind=wp), public, parameter :: cw2 = 0.3 real(kind=wp), public, parameter :: cw3 = 2.0 real(kind=wp), public, parameter :: cv1 = 7.1 real(kind=wp), public, parameter :: ct3 = 1.2 real(kind=wp), public, parameter :: ct4 = 0.5 real(kind=wp), public, parameter :: sigma_sa = 2./3. real(kind=wp), public, parameter :: kappa_sa = 0.41 real(kind=wp), public, parameter :: cw1 = (cb1/(kappa_sa**2))+((1+cb2)/sigma_sa) real(kind=wp), public, parameter :: cv1_3 = cv1**3 real(kind=wp), public, parameter :: cw3_6 = cw3**6","tags":"","loc":"module/global_sa.html","title":"global_sa – FEST-3D"},{"text":"Declare all the constants used by SST turbulence model Uses iso_fortran_env module~~global_sst~~UsesGraph module~global_sst global_sst iso_fortran_env iso_fortran_env module~global_sst->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~global_sst~~UsedByGraph module~global_sst global_sst module~source source module~source->module~global_sst module~viscosity viscosity module~source->module~viscosity module~plusgs plusgs module~plusgs->module~global_sst module~plusgs->module~viscosity module~write_output_vtk write_output_vtk module~write_output_vtk->module~global_sst module~write_output_vtk->module~viscosity module~write_output_tec write_output_tec module~write_output_tec->module~global_sst module~write_output_tec->module~viscosity module~lusgs lusgs module~lusgs->module~global_sst module~lusgs->module~viscosity module~write_output_tec_node write_output_tec_node module~write_output_tec_node->module~global_sst module~write_output_tec_node->module~viscosity module~viscosity->module~global_sst module~bc_primitive bc_primitive module~bc_primitive->module~global_sst module~update update module~update->module~global_sst module~update->module~source module~update->module~plusgs module~update->module~lusgs module~update->module~viscosity module~update->module~bc_primitive module~viscous viscous module~update->module~viscous module~time time module~update->module~time module~viscous->module~global_sst module~viscous->module~viscosity module~solver solver module~solver->module~viscosity module~solver->module~update module~solver->module~viscous module~solver->module~time module~dump_solution dump_solution module~solver->module~dump_solution module~time->module~viscosity module~write_output write_output module~write_output->module~write_output_vtk module~write_output->module~write_output_tec module~write_output->module~write_output_tec_node program~main main program~main->module~solver module~dump_solution->module~write_output var panmoduleglobal_sstUsedByGraph = svgPanZoom('#moduleglobal_sstUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables sigma_k1 sigma_k2 sigma_w1 sigma_w2 beta1 beta2 bstar kappa a1 gama1 gama2 beta sigma_w sigma_k gama sst_F1 Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: sigma_k1 = 0.85 real(kind=wp), public, parameter :: sigma_k2 = 1.0 real(kind=wp), public, parameter :: sigma_w1 = 0.5 real(kind=wp), public, parameter :: sigma_w2 = 0.856 real(kind=wp), public, parameter :: beta1 = 0.075 real(kind=wp), public, parameter :: beta2 = 0.0828 real(kind=wp), public, parameter :: bstar = 0.09 real(kind=wp), public, parameter :: kappa = 0.41 real(kind=wp), public, parameter :: a1 = 0.31 real(kind=wp), public :: gama1 = (beta1/bstar)-((sigma_w1*(kappa**2))/sqrt(bstar)) real(kind=wp), public :: gama2 = (beta2/bstar)-((sigma_w2*(kappa**2))/sqrt(bstar)) real(kind=wp), public :: beta real(kind=wp), public :: sigma_w real(kind=wp), public :: sigma_k real(kind=wp), public :: gama real(kind=wp), public, dimension(:,:,:), allocatable, target :: sst_F1","tags":"","loc":"module/global_sst.html","title":"global_sst – FEST-3D"},{"text":"Declare all the constants used by k-kL turbulence model Uses iso_fortran_env module~~global_kkl~~UsesGraph module~global_kkl global_kkl iso_fortran_env iso_fortran_env module~global_kkl->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~global_kkl~~UsedByGraph module~global_kkl global_kkl module~source source module~source->module~global_kkl module~viscosity viscosity module~source->module~viscosity module~plusgs plusgs module~plusgs->module~global_kkl module~plusgs->module~viscosity module~lusgs lusgs module~lusgs->module~global_kkl module~lusgs->module~viscosity module~viscosity->module~global_kkl module~update update module~update->module~global_kkl module~update->module~source module~update->module~plusgs module~update->module~lusgs module~update->module~viscosity module~viscous viscous module~update->module~viscous module~time time module~update->module~time module~viscous->module~global_kkl module~viscous->module~viscosity module~solver solver module~solver->module~viscosity module~solver->module~update module~solver->module~viscous module~solver->module~time module~dump_solution dump_solution module~solver->module~dump_solution module~write_output_tec_node write_output_tec_node module~write_output_tec_node->module~viscosity module~time->module~viscosity module~write_output_vtk write_output_vtk module~write_output_vtk->module~viscosity module~write_output_tec write_output_tec module~write_output_tec->module~viscosity program~main main program~main->module~solver module~write_output write_output module~write_output->module~write_output_tec_node module~write_output->module~write_output_vtk module~write_output->module~write_output_tec module~dump_solution->module~write_output var panmoduleglobal_kklUsedByGraph = svgPanZoom('#moduleglobal_kklUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables zeta1 zeta2 zeta3 sigma_k sigma_phi cmu kappa c11 c12 cd1 cphi1 cphi2 fphi eta Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: zeta1 = 1.2 real(kind=wp), public, parameter :: zeta2 = 0.97 real(kind=wp), public, parameter :: zeta3 = 0.13 real(kind=wp), public, parameter :: sigma_k = 1.0 real(kind=wp), public, parameter :: sigma_phi = 1.0 real(kind=wp), public, parameter :: cmu = 0.09 real(kind=wp), public, parameter :: kappa = 0.41 real(kind=wp), public, parameter :: c11 = 10.0 real(kind=wp), public, parameter :: c12 = 1.3 real(kind=wp), public, parameter :: cd1 = 4.7 real(kind=wp), public :: cphi1 real(kind=wp), public :: cphi2 real(kind=wp), public :: fphi real(kind=wp), public :: eta","tags":"","loc":"module/global_kkl.html","title":"global_kkl – FEST-3D"},{"text":"Uses solver convergence program~~main~~UsesGraph program~main main module~solver solver program~main->module~solver module~convergence convergence program~main->module~convergence module~state state module~solver->module~state module~read read module~solver->module~read module~scheme scheme module~solver->module~scheme module~layout layout module~solver->module~layout module~wall_dist wall_dist module~solver->module~wall_dist mpi mpi module~solver->mpi module~resnorm resnorm module~solver->module~resnorm module~geometry geometry module~solver->module~geometry module~viscosity viscosity module~solver->module~viscosity module~update update module~solver->module~update module~wall wall module~solver->module~wall module~gradients gradients module~solver->module~gradients module~interface1 interface1 module~solver->module~interface1 module~cc CC module~solver->module~cc module~bc bc module~solver->module~bc module~vartypes vartypes module~solver->module~vartypes module~viscous viscous module~solver->module~viscous module~time time module~solver->module~time module~dump_solution dump_solution module~solver->module~dump_solution module~grid grid module~solver->module~grid module~convergence->module~resnorm module~convergence->module~vartypes module~state->module~vartypes module~check_output_control check_output_control module~state->module~check_output_control module~utils utils module~state->module~utils module~read_output read_output module~state->module~read_output module~read->module~vartypes module~scheme->module~vartypes module~ausmup ausmUP module~scheme->module~ausmup module~van_leer van_leer module~scheme->module~van_leer module~scheme->module~utils module~slau slau module~scheme->module~slau module~ausmp ausmP module~scheme->module~ausmp module~ausm ausm module~scheme->module~ausm module~face_interpolant face_interpolant module~scheme->module~face_interpolant module~ldfss0 ldfss0 module~scheme->module~ldfss0 module~layout->mpi module~layout->module~vartypes module~wall_dist->module~vartypes module~wall_dist->module~utils module~resnorm->mpi module~resnorm->module~vartypes module~resnorm->module~utils module~geometry->module~vartypes module~geometry->module~utils module~viscosity->module~wall_dist module~viscosity->module~gradients module~viscosity->module~vartypes module~global_kkl global_kkl module~viscosity->module~global_kkl module~viscosity->module~utils module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sa global_sa module~viscosity->module~global_sa module~global_sst global_sst module~viscosity->module~global_sst module~update->module~scheme module~update->module~wall_dist module~update->module~viscosity module~update->module~gradients module~update->module~interface1 module~update->module~vartypes module~update->module~viscous module~update->module~time module~update->module~global_kkl module~bc_primitive bc_primitive module~update->module~bc_primitive module~source source module~update->module~source module~update->module~utils module~update->module~global_sa module~plusgs plusgs module~update->module~plusgs module~update->module~global_sst module~boundary_state_reconstruction boundary_state_reconstruction module~update->module~boundary_state_reconstruction module~lusgs lusgs module~update->module~lusgs module~update->module~face_interpolant module~wall->mpi module~wall->module~vartypes module~wall->module~utils module~gradients->module~vartypes module~gradients->module~utils module~interface1->mpi module~interface1->module~vartypes module~mapping mapping module~interface1->module~mapping module~interface1->module~utils module~cc->module~wall_dist module~cc->module~vartypes module~cc->module~utils module~bc->module~vartypes module~bc->module~utils module~read_bc read_bc module~bc->module~read_bc iso_fortran_env iso_fortran_env module~vartypes->iso_fortran_env module~viscous->module~viscosity module~viscous->module~gradients module~viscous->module~vartypes module~viscous->module~global_kkl module~viscous->module~utils module~viscous->module~global_sa module~viscous->module~global_sst module~time->module~read module~time->mpi module~time->module~viscosity module~time->module~vartypes module~time->module~utils module~time->module~face_interpolant module~dump_solution->module~layout module~dump_solution->module~vartypes module~write_output write_output module~dump_solution->module~write_output module~dump_solution->module~utils module~grid->mpi module~grid->module~vartypes module~grid->module~mapping var panprogrammainUsesGraph = svgPanZoom('#programmainUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Main program Calls program~~main~~CallsGraph program~main main proc~iterate_one_more_time_step iterate_one_more_time_step program~main->proc~iterate_one_more_time_step proc~finish_run finish_run program~main->proc~finish_run proc~converged converged program~main->proc~converged proc~start_run start_run program~main->proc~start_run mpi_bcast mpi_bcast proc~iterate_one_more_time_step->mpi_bcast proc~checkpoint checkpoint proc~iterate_one_more_time_step->proc~checkpoint debugcall debugcall proc~iterate_one_more_time_step->debugcall proc~find_resnorm find_resnorm proc~iterate_one_more_time_step->proc~find_resnorm proc~get_next_solution get_next_solution proc~iterate_one_more_time_step->proc~get_next_solution proc~destroy_solver destroy_solver proc~finish_run->proc~destroy_solver mpi_finalize mpi_finalize proc~finish_run->mpi_finalize mpi_init mpi_init proc~start_run->mpi_init proc~setup_solver setup_solver proc~start_run->proc~setup_solver proc~destroy_solver->debugcall proc~destroy_time destroy_time proc~destroy_solver->proc~destroy_time proc~setup_solver->proc~checkpoint proc~setup_solver->debugcall proc~initmisc initmisc proc~setup_solver->proc~initmisc mpi_barrier mpi_barrier proc~setup_solver->mpi_barrier proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~setup_time setup_time proc~setup_solver->proc~setup_time proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setupcc setupCC proc~setup_solver->proc~setupcc proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_scheme setup_scheme proc~setup_solver->proc~setup_scheme proc~find_wall_dist find_wall_dist proc~setup_solver->proc~find_wall_dist proc~setup_wall_dist setup_wall_dist proc~setup_solver->proc~setup_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~read_input_and_controls read_input_and_controls proc~setup_solver->proc~read_input_and_controls proc~setup_interface setup_interface proc~setup_solver->proc~setup_interface proc~setup_bc setup_bc proc~setup_solver->proc~setup_bc proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_viscosity setup_viscosity proc~setup_solver->proc~setup_viscosity proc~get_process_data get_process_data proc~setup_solver->proc~get_process_data proc~setup_update setup_update proc~setup_solver->proc~setup_update proc~read_layout_file read_layout_file proc~setup_solver->proc~read_layout_file proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~checkpoint->debugcall proc~make_dump_dir make_dump_dir proc~checkpoint->proc~make_dump_dir proc~purge_dump_dir purge_dump_dir proc~checkpoint->proc~purge_dump_dir proc~dump_data dump_data proc~checkpoint->proc~dump_data proc~write_resnorm write_resnorm proc~find_resnorm->proc~write_resnorm proc~collect_resnorm_from_all_blocks collect_resnorm_from_all_blocks proc~find_resnorm->proc~collect_resnorm_from_all_blocks proc~assemble_resnom_at_each_process assemble_resnom_at_each_process proc~find_resnorm->proc~assemble_resnom_at_each_process proc~get_absolute_resnorm get_absolute_resnorm proc~find_resnorm->proc~get_absolute_resnorm proc~get_relative_resnorm get_relative_resnorm proc~find_resnorm->proc~get_relative_resnorm proc~update_with_lusgs update_with_lusgs proc~get_next_solution->proc~update_with_lusgs proc~compute_time_step compute_time_step proc~get_next_solution->proc~compute_time_step proc~update_with update_with proc~get_next_solution->proc~update_with proc~update_with_plusgs update_with_plusgs proc~get_next_solution->proc~update_with_plusgs proc~get_total_conservative_residue get_total_conservative_Residue proc~get_next_solution->proc~get_total_conservative_residue var panprogrammainCallsGraph = svgPanZoom('#programmainCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code main Source Code program main !< Main program !------------------------------------------------- use solver , only : iterate_one_more_time_step use solver , only : control use convergence , only : converged use solver , only : start_run use solver , only : finish_run !--------Start---------! call start_run () do while (( control % current_iter <= control % max_iters ) . and . (. not . converged ( control )) . and . (. not . control % Halt )) call iterate_one_more_time_step () end do call finish_run () !--------Stop---------! end program main","tags":"","loc":"program/main.html","title":"main – FEST-3D"},{"text":"Introduction FEST-3D is a finite-volume solver build to compute incompressible/compressible, and inviscid/laminar/transitonal/turbulent fluid flow problems on structured grids. Highlights: The solver provides multiple choices to the user in terms of inviscid flux calculation\nscheme, higher-order face-state reconstruction scheme, time-integration scheme, and turbulence and transition models. Schemes Inviscid flux calculation AUSM Liou, M.-S. and Steffen, C., “A New Flux Splitting Scheme,” J. Comput. Phys., vol. 107, no. 1, pp. 23-39, 1993. LDFSS Edwards, J.R., A low-diffusion flux-splitting scheme for Navier-Stokes calculations. Computers & Fluids, vol. 26, no. 6, pp.635-659, 1997. AUSM+ Liou, M. S., “A sequel to AUSM: AUSM+,” Journal of Computational Physics, vol. 129, no. 2, pp. 364–382, 1996. AUSM+-UP Liou, M. S., “A sequel to AUSM, Part II: AUSM+-up for all speeds,” Journal of Computational Physics, vol. 214, no. 1, pp. 137–170, 2006. SLAU Shima, E., and Kitamura, K., “Parameter-Free Simple Low-Dissipation AUSM-Family Scheme for All Speeds,” AIAA Journal, vol. 49, no. 8, pp. 1693–1709, 2011. Higher-order spatial reconstruction None 1rst order accurate in space MUSCL 3rd order accurate in space van Leer, B., Towards the Ultimate Conservative Difference Scheme, V. A Second Order Sequel to Godunov's Method, J. Com. Phys., vol. 32, no. 1, pp. 101–136, 1979 PPM 4th order accurate in space Colella, P., and Woodward, P. R., “The Piecewise Parabolic Method (PPM) for gas-dynamical simulations,” Journal of Computational Physics, vol. 54, no. 1, pp. 174–201, 1984. WENO 5th order accurate in space Shu, C.-W., “High-order Finite Difference and Finite Volume WENO Schemes and Discontinuous Galerkin Methods for CFD,” International Journal of Computational Fluid Dynamics, vol. 17, no. 2, pp. 107–118, 2003. WENO-NM 5th order accurate in space (specifically for non-uniform grid) Huang, W.-F., Ren, Y.-X., and Jiang, X., “A simple algorithm to improve the performance of the WENO scheme on non-uniform grids,” Acta Mechanica Sinica, vol. 34, no. 1, pp. 37–47, 2018. Temporal integration Explicit Euler Explicit First order accurate in time RK2 2nd order accurate in time, Runge-Kutta method RK4 4th order accurate in time, Runge-Kutta method TVDRK2 Total variation diminishing RK2 method for Weno scheme TVDRK3 Total variation diminishing RK3 method for Weno scheme Hoffmann, Klaus A., and Steve T. Chiang. \"Computational fluid dynamics volume I.\" Engineering Education System, 2000. Implicit implicit Matrix free LU-SGS method, first order accurate in time. Chen, R. F., and Wang, Z. J., “Fast , Block Lower-Upper Symmetric Gauss – Seidel Scheme Introduction,” AIAA Journal, vol. 38, no. 12, pp. 2238–2245, 2000. PLUSGS Preconditioned Matrix free LU-SGS method for very low speed flow; first order accuate in time Kitamura, K., Shima, E., Fujimoto, K., and Wang, Z. J., “Performance of Low-Dissipation Euler Fluxes and Preconditioned LU-SGS at Low Speeds,” Communications in Computational Physics, vol. 10, no. 1, pp. 90–119, 2011. Turbulence model SA Allmaras, S. R., Johnson, F. T., and Spalart, P. R., “Modifications and Clarifications for the Implementation of the Spalart-Allmaras Turbulence Model,” Seventh International Conference on Computational Fluid Dynamics (ICCFD7), 2012. Spalart, P. R., and Allmaras, S., “A one-equation turbulence model for aerodynamic flows,” 30th Aerospace Sciences Meeting and Exhibit, 1992. SST Menter, F. R., \"Two-Equation Eddy-Viscosity Turbulence Models for Engineering Applications,\" AIAA Journal, vol. 32, no. 8, pp. 1598-1605, 1994. SST2003 Menter, F. R., Kuntz, M., and Langtry, R., \"Ten Years of Industrial Experience with the SST Turbulence Model,\" Turbulence, Heat and Mass Transfer 4, ed: K. Hanjalic, Y. Nagano, and M. Tummers, Begell House, Inc., pp. 625 - 632, 2003. k-kL Menter, F. R., and Egorov, Y., “The scale-adaptive simulation method for unsteady turbulent flow predictions. part 1: Theory and model description,” Flow, Turbulence and Combustion, vol. 85, no. 1, pp. 113–138, 2010. Transition model Gamma LCTM2015 Menter, F. R., Smirnov, P. E., Liu, T., and Avancha, R., “A One-Equation Local Correlation-Based Transition Model,” Flow, Turbulence and Combustion, vol. 95, no. 4, pp. 583–619, 2015. SA-BC Cakmakcioglu, S. C., Bas, O., and Kaynak, U., “A correlation-based algebraic transition model,” Proceedings of the Institution of Mechanical Engineers, Part C: Journal of Mechanical Engineering Science, vol. 232, no. 21, pp. 3915–3929, 2018. FEST-3D Team Over the last five years, many individuals have contributed to the development of FEST-3D. The team includes: Jatinder Pal Singh Sandhu Ph.D. Student (Current) Added turbulence and transition models:SST, SA, k-kL; implicit time-integration method: LU-SGS and PLU-SGS; approximate Reimann solver: SLAU, AUSM+-UP, AUSM+; and 5th order weno scheme R. D. Teja B.Tech Student (2016) Parallelized FEST-3D using MPI routines Raskesh Ramakrishnan Dual Degree Student (2016) Modified FEST-3D into a three-dimensional laminar flow solver_ Anant Girdhar B.Tech Student (2015) Developed the FEST-3D code as a modular two-dimensional inviscid flow solver for strutured grids All the above individuals were guided by Dr. Santanu Ghosh .","tags":"","loc":"page//index.html","title":"Documentation – FEST-3D"},{"text":"How to download FEST-3D The FEST-3D solver is available at GitHub to download.  The tutorials are provided in a separate GitHub repository and the same is used as a submodule in the main source code with folder name [RootFolder]/run . The grid files for the tutorials are provided in the respective test case folders. Note In case you do not have Git installed on you local machine, you can do so by using following command on ubuntu: sudo apt-get install git A similar command can be used for other Linux package platforms. Use the following command to clone the git repository without tutorials git clone https://github.com/FEST3D/FEST-3D.git Note The tutorials are submodule to main FEST-3D source code on  GitHub. Use the following command to get git repository with tutorials git clone --recursive https://github.com/FEST3D/FEST-3D.git If you already have source code without tutorials, then use following to downlaod tutorials git submodule update --init If you are downloading the FEST-3D package as a zip file from GitHub or Home page on Linux system, use the command \"unzip\", which can be  installed (if not available)  using the command: sudo apt-get install unzip and then use the following command to unzip the folder unzip FEST-3D-master.zip -d FEST3D The run folder is not part of the main zip folder.","tags":"","loc":"page/./00_download.html","title":"Download – FEST-3D"},{"text":"An installation bash script has been provided for Ubuntu(Debain), CentOs, and MacOS. Run the script using the following command: $ . install.sh This will install dependecies, build executable, run unit and integrated tests, and add FEST3D as enviornment variable into either .bashrc or .bash_profile . So, after installation you can call FEST-3D using $FEST3D enviornment variable. The dependencies are installed using apt-get , yum or Homebrew based on the platform. If you are install FEST-3D on some different platform, please follow the manual install instruction below. Check Make sure FEST3D enviornment variable is set by $ echo $FEST3D If it results in a string of zero length please set the FEST3D variable explicitly by using the following command: export FEST3D=\"<path of FEST3D source folder>bin/FEST3D\" Replace the the content with angular braces with absolute path to the root of FEST-3D on your machine. Add above line in the .bashrc or .bash_profile for permanentaly defining the FEST3D variable. Manually installing FEST-3D The installation instructions are listed here for Linux platforms. Specifically, examples are given for UBUNTU distribution. Dependencies FEST-3D has the following dependencies: Fortran compiler MPI library CMAKE and MAKE Compiler To build the FEST-3D code written in FORTRAN 90 code, a FORTRAN compiler is required. Either open-source gfortran or commercial ifort FORTRAN compilers can be used.\nTo install gfortran on Ubuntu, use the following command: $sudo apt-get install gfortran Distributive MPI Library To have a faster computation, the FEST-3D code uses the MPICH library to distribute the computation load across different processors within one machine or across multiple machines. You can install MPICH on Ubuntu  using: $sudo apt-get install mpich CMAKE and Make CMake is required to generate a Makefile, which in turn generates the executable. The following command is useful to install cmake: $sudo apt-get install build-essential $sudo apt-get install cmake So, in summary, all the dependencies can be installed using  the  following commands: $sudo apt-get update\n$sudo apt-get install build-essential\n$sudo apt-get install cmake\n$sudo apt-get install gfortran\n$sudo apt-get install mpich\n$sudo apt-get install python3-numpy Building To build the FEST-3D code, we first generate a new \"build\" directory/folder in the root directory of the FEST-3D code. Inside the build directory, we execute Cmake with specific FORTRAN compiler. $cmake .. $make -j 4 Here -j is a parallel building option that speeds up the building process. You can replace the number after \"-j\" with the number of processors you want to use for  building the code. Note if you have installed OPENMPI also along with MPICH, then  mpif90 may point to mpif90.openmpi instead of mpif90.mpich . In that case use the following command $FC=mpif90.mpich cmake .. So, in summary, the following list of commands are required to build the executable $mkdir build && cd build\n$cmake ..\n$make -j 4 These commands will create a binary file named FEST3D in the bin folder; located in the root directory of the FEST-3D code. Once the binary for FEST-3D is created, you can define the FEST3D enviornment variable by adding following line in either .bashrc or .bash_profile : export FEST3D=\"<path of FEST3D source folder>bin/FEST3D\" Replace the the content with angular braces with absolute path to the root of FEST-3D on your machine.","tags":"","loc":"page/./01_install.html","title":"Installation – FEST-3D"},{"text":"How to run the code to solve a real problem To set up the run folder, for solving a problem, few \ninput files are needed by the FEST-3D solver. To facilitate the process of setting up\nall these input files, a Python code is provided at Github . Dependencies C++11 compiler Python 3 bash Inputs Note A python scipt is provided to ease the user interface with FEST-3D solver.\nIn order to run the script provide all the input variables described below\nand run the script  using: python edit-automaton.py Above command will create a new directory. This new directory host all the input files.\nBefore runing the solver, change directory to newly created directory with name provide in variable $RunDir eg: $python edit-automaton.py $cd <New directory> If required, tweak the input files, and after that, run the solver using $nohup bash run.sh & To check the current run status $tail -f time_directories/aux/out To plot the residual using gnuplot script gnplt $gnuplot gnplt First, we need to create a directory to perform simulation and save all the input/output data. RunDir = 'Test' Give any name to the Run directory One of the important input is the grid/mesh files. FEST-3D code requires a separate file for each process.\nIf the domain is decomposed into 4 blocks, then 4 separate files are required. Although, you can give\nany unique name to the grid files, for simplicity the python code expect grid file name in grid_nn.txt , where\nthe nn is the block-number-1 . So, for 4 blocks, we will use the following: grid_00.txt, grid_01.txt, grid_02.txt, and\ngrid_03.txt. You should keep all the grid files in a separate folder and mention name of that folder \nat GridDir='Mesh' , here Mesh is the folder in which all the grid files are kept. For more details about the grid/mesh read the subsection Mesh NumberOfBlocks = 1 Total number of blocks Now, you are required to fix different input parameter of the solver based on the problem you are simulating.\nMeaning of the most input is self-explanatory from the name. Variable Expected Input Description Control['CFL'] Real Number greater than zero Courant–Friedrichs–Lewy number. Low value (less than 1) for explicit scheme and high value for implicit scheme Control['LoadLevel'] Integer Restart folder number in the time_directories/ directory Control['MaxIterations'] Integer greater than SaveIterations Maximum number of iteration Control['SaveIterations'] Integer lesser than MaxIterations Save solution state after every these many iteration Control['OutputFileFormat'] 'vtk' or 'tecplot' Format of the solution output file Control['OutputDataFormat'] 'ASCII' Type of the data in the output folder. Only ASCII for now. BINARY will be added in later release Control['InputFileFormat'] 'vtk' or 'tecplot' Format of the solution file from which solution will be restarted Control['InputDataFormat'] 'ASCII' Type of the data in the restart file . Similar to output data type, only ASCII is supported for now. Control['Precision'] Integer, lesser than 14 and greater than 1 Data precision for residual output, not used for solution output. Control['Purge'] Integer Number of recent solution folder to keep and delete others. 0 input will keep all the folders Control['ResidualWriteInterval'] Integer greater than zero Number of iteration after which to save the residual output in the file Control['Tolerance'] Real number and [\"Mass_abs\", \"Viscous_abs\", \"Mass_abs\", \"Resnorm_abs\", \"Viscous_abs\", \"Turbulent_abs\", \"Continuity_abs\", \"X-mom_abs\", \"Y-mom_abs\", \"Z-mom_abs\", \"Energy_abs\", \"Mass_rel\", \"Resnorm_rel\", \"Viscous_rel\", \"Turublent_rel\", \"Continuity_abs\", \"X-mom_rel\", \"Y-mom_rel\", \"Z-mom_rel\", \"Energy_rel\", \"TKE_abs\", \"Tv_abs\", \"Dissipation_abs\", \"Omega_abs\", \"Kl_abs\", \"TKE_rel\", \"Tv_rel\", \"Dissipation_rel\", \"Omega_rel\", \"Kl_rel\"] Tolerance value and variable. The solver will stop once this value is achived. List of tolerace variables is given in expected input column. You can use only one input at a time. Control['DebugLevel'] 1, 2, 3, 4, or 5 Print the information about the function/subroutines called in the solver. This helps in debugging the code. 5-Only important information is logged, 1-All the information is logged which helps in debuging. Will be remove in later release Scheme['InviscidFlux'] 'ausm', 'slau', 'ausmUP', or 'ldfss0' Scheme to calcualte inviscid fluxes through cell faces Scheme['FaceState'] 'none', 'muscl', 'ppm', or 'weno' Scheme for higher-order face-state reconstuction Scheme['Limiter'] '1 1 1  0 0 0' or '0 0 0 0 0 0' Switch for limiters and pressure based switching when using higher order face-state reconstuction. Three value for i,j, and k direction 1->on  and 0-> off. Koren limiter is being used with MUSCL scheme. Scheme['TurbulenceLimiter'] '1 1 1' or '0 0 0' Switch for limiters when used for higher-order face-state reconstuctio of turbulent variables.  1->on  and 0-> off Scheme['TurbulenceModel'] 'none', 'sa', 'sst', or 'sst2003' Turbulence model Scheme['TransitionModel'] 'none', 'bc', 'lctm2015' Transition model Scheme['TimeStep'] 'l' or 'g [optional time step]' Time-step for time-integration. 'l' for local and 'g' for global. In case for global method you can provide exact value to time-step here. Scheme['TimeIntegration'] 'none', 'RK2', 'RK4', 'TVDRK2', 'TVDRK3', 'implicit', or 'plusgs' Method for time-integration Scheme['HigherOrderBC'] 0 or 1 Higher order boundary conditions.  1->on  and 0-> off. Flow[\"NumberOfVariables\"] 5 Total number of variables to solver. Reduntant and will be depricated in later release. Flow[\"DensityInf\"] Real Number Free-stream density Flow[\"UInf\"] Real Number Free-stream x-component of velocity Flow[\"VInf\"] Real Number Free-stream y-component of velocity Flow[\"WInf\"] Real Number Free-stream z-component of velocity Flow[\"PressureInf\"] Real Number Free-stream pressure Flow[\"TurbulenceIntensity\"] Real Number Free-stream trubulent intensity in (percentage) Flow[\"ViscosityRatio\"] Real Number Free-stream ratio of turbulence viscosity to molecular viscosity Flow[\"Intermitency\"] Real Number Free-stream turbulent intermittency Flow[\"ReferenceViscosity\"] Real Number Reference viscosity Flow[\"ViscosityLaw\"] 'sutherland_law' or 'constant' Law used for viscosity variation Flow[\"ReferenceTemp\"] Real Number Reference temperature for viscosity variation Flow[\"SutherlandTemp\"] Real Number Sutherland temperature Flow[\"PrandtlNumbers\"] Two real numbers Prandtl number and turbulent prandtl number Flow[\"SpecificHeatRatio\"] Real number Specific heat ratio Flow[\"GasConstant\"] Real Gas Constant OutputControl['Out'] [ \"Velocity\" , \"Density\" , \"Pressure\" , \"Mu\" , \"Mu_t\" , \"TKE\" , \"Omega\" , \"kL\" , \"tv\" , \"Wall_distance\" , \"DuDx\",   \"Dudy\",   \"DuDz\" , \"DvDx\",   \"DvDy\",   \"DvDz\" , \"DwDx\",   \"DWDy\",   \"DwDz\" , \"DTDx\",   \"DTDy\",   \"DTDz\" , \"DtkDx\",  \"DtkDy\",  \"DtkDz\" , \"DtwDx\",  \"DtwDy\",  \"DtwDz\" , \"DtvDx\",  \"DtvDy\",  \"DtvDz\" , \"DtkLDx\", \"DtkLDy\", \"DtkLDz\"] Variables to write in the output file OutputControl['In'] [\"Velocity\" ,\"Density\" ,\"Pressure\" ,\"viscosity\" ,\"TKE\" ,\"Omega\" ,\"kL\" ,\"tv\"] Variables to read in case of restrart ResidualControl['Out'] [\"Mass_abs\", \"Viscous_abs\", \"Mass_abs\", \"Resnorm_abs\", \"Viscous_abs\", \"Turbulent_abs\", \"Continuity_abs\", \"X-mom_abs\", \"Y-mom_abs\", \"Z-mom_abs\", \"Energy_abs\", \"Mass_rel\", \"Resnorm_rel\", \"Viscous_rel\", \"Turublent_rel\", \"Continuity_abs\", \"X-mom_rel\", \"Y-mom_rel\", \"Z-mom_rel\", \"Energy_rel\", \"TKE_abs\", \"Tv_abs\", \"Dissipation_abs\", \"Omega_abs\", \"Kl_abs\", \"TKE_rel\", \"Tv_rel\", \"Dissipation_rel\", \"Omega_rel\", \"Kl_rel\"] Residual to write in the resnorm file BoundaryConditions [-3, -4, -5, -8, -6, -6]  where <-1:'SUPERSONIC INLET', -2:'SUPERSONIC OUTFLOW', -3:'SUBSONIC INFLOW', -4:'SUBSONIC OUTFLOW', -5:'WALL', -6:'SYMMETRY', -7:'Pole', -8:'Far-field', -11:'Total inlet'> Boundary conditions to used for the six face of the domain $python edit-automaton.py Note Make sure to provide the absolute path of the FEST3D binary in the edit-automaton.py script before executing. And also\nthe number of files in the GridDir folder should be equal to the number of blocks as input. Directory structure Executing edit-automaton.py will create a directory with usual directory structure: system :all the input files including the mesh files and boundary condition file is located in this directory time_directory : all the output files will be stored in this folder. bin : a soft link between original FEST-3D binary is stored here. run.sh : bash script to run the solver. This helps to remove log clutter on screen and save it in a log file named out in the time_directory/aux/ directory along with resnorm file which store the residual values. Check Layout file Although, edit-automaton.py python script tries to handle the boundary condition by its own; it is still not full-proof. So, always the check the layout.md file in the system/mesh/layout directory. Make sure all the boundary condition number are as you expect. In the case of pole boundary condition, some random number will be mentioned and required to change manually to -007. The layout file in explained in the later section. Execute $mpiexec .hydra -np 16 bin/FEST3D On linux os you can use following command to run FEST-3D in the background: nohup bash run.sh & Check Status The screen output is directed to the text file: [RunDir]/time_directories/aux/out The residual are stored in the text file: [RunDir]/time_directories/aux/resnorm You can output the current status or Current iteration number of the run on screen using tail -f time_directories/aux/out or you can check the residual by using Gnuplot or other similar software: gnuplot gnplt gnplt is the script provided for the Gnuplot software. You can download Gnuplot using: sudo apt-get install gnuplot Use ctl-c to stop the Gnuplot. Post Processing Since FEST-3D output solution file in Tecplot and VTK format, you can use either commerical TECPLOT software or open-source softwares like: Visit , Paraview , Mayavi .","tags":"","loc":"page/02_run/index.html","title":"Run – FEST-3D"},{"text":"Fig.1 Domain of interest divide into 4 sub-domain. To solve a real-life problem, like flow over\nan airfoil, first, a domain of computation has to be defined. This \ndomain represents the system of interest which we\nlike to study. Now to apply a numerical method\nto solve the governing equation (Navier-Stokes) on this domain, it needed\nto be discretized. This process is not part of the FEST-3D\ncode and it assume a predefine discretized domain(grid) will\nbe provided as input. You can use softwares like Pointwise to generate the\ngood quality mesh. The FEST-3D expect structured grid in\n the following format Imax  Jmax  Kmax\nX(1,1,1)   Y(1,1,1)   Z(1,1,1)\nX(2,1,1)   Y(2,1,1)   Z(2,1,1)\nX(3,1,1)   Y(3,1,1)   Z(3,1,1)\n...\nX(Imax,1,1)   Y(Imax,1,1)   Z(Imax,1,1)\nX(1,2,1)   Y(1,2,1)   Z(1,2,1)\nX(2,2,1)   Y(2,2,1)   Z(2,2,1)\n...\n...\nX(Imax,Jmax,1)   Y(Imax,Jmax,1)   Z(Imax,Jmax,1)\nX(1,1,2)   Y(1,1,2)   Z(1,1,2)\nX(2,1,2)   Y(2,1,2)   Z(2,1,2)\nX(3,1,2)   Y(3,1,2)   Z(3,1,2)\n...\n...\n...\nX(Imax,Jmax,kmax)   Y(Imax,Jmax,kmax)   Z(Imax,Jmax,kmax) In the case of multi-block, as shown in Fig. 1, each process requires a separate grid file\nand block should be created such that every face of that\nblock employs only a single boundary condition. For now, two different types of boundary\nconditions at a single face  of a block is not supported by the FEST-3D. Fig.2 Example Mesh. A very simple example of grid file is given below for 2D-smooth bump test case, shown in Fig. 3: Blocks: 2 Number of blocks in I-direction are 2. So, two files will be written: grid_00.txt for first block and grid__01.txt for second block Imax: 3 Jmin: 2 Kmin: 2 Fig.2 Simple coarse grid for 2D smooth bump test case. grid_00.txt 2 2 2\n-1.5000e+00  2.3271e-26  0.0000e+00\n 0.0000e+00  6.2500e-02  0.0000e+00\n-1.5000e+00  8.0000e-01  0.0000e+00\n 0.0000e+00  8.0000e-01  0.0000e+00\n-1.5000e+00  2.3271e-26  1.0000e-01\n 0.0000e+00  6.2500e-02  1.0000e-01\n-1.5000e+00  8.0000e-01  1.0000e-01\n 0.0000e+00  8.0000e-01  1.0000e-01 grid_01.txt 2 2 2\n0.0000e+00  6.2500e-02  0.0000e+00\n1.5000e+00  2.3271e-26  0.0000e+00\n0.0000e+00  8.0000e-01  0.0000e+00\n1.5000e+00  8.0000e-01  0.0000e+00\n0.0000e+00  6.2500e-02  1.0000e-01\n1.5000e+00  2.3271e-26  1.0000e-01\n0.0000e+00  8.0000e-01  1.0000e-01\n1.5000e+00  8.0000e-01  1.0000e-01","tags":"","loc":"page/02_run/02_mesh.html","title":"Mesh – FEST-3D"},{"text":"Fig.1 Example for interface between blocks. When performing a multi-block simulation, some information has to communicate between adjacent\nblocks. For this process, a setup file is provide called layout.md in the system/mesh/layout folder. This file contains information about the adjacent blocks and physical boundary conditions.\nAll the non-negative numbers in this file represent the interface boundary condition, and negative\nnumbers represent the physical boundary conditions. For each block/process a row of information is \nwritten: Block number Grid file name in the system/mesh/gridfile/ directory Boundary condition file name in the system/mesh/bc/ directory Boundary condition at Imin face. Boundary condition at Imax face. Boundary condition at Jmin face. Boundary condition at Jmax face. Boundary condition at Kmin face. Boundary condition at Kmax face. Fig.2 Each block has six faces and hence six boundary conditions to set. So for four blocks the layout file looks like following. ## BLOCK LAYOUT FILE\n ## ==========================\n ## NUMBER OF PROCESSES\n 4\n ## NUMBER OF ENTRIES PER PROCESS\n 9\n ## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n ## ===================================\n ## PROCESS 0\n 00  grid_00.txt  bc_00.md  -005  0001  -005  0002  -006  -006\n ## PROCESS 1\n 01  grid_01.txt  bc_01.md  0000  -005  -005  0003  -006  -006\n ## PROCESS 2\n 02  grid_02.txt  bc_02.md  -005  0003  0000  -003  -006  -006\n ## PROCESS 3\n 03  grid_03.txt  bc_03.md  0002  -005  0001  -003  -006  -006 Each line starting with # is a comment line and hence will be ignored while reading. \nThe first non-comment line\nstate for how many blocks the layout file is written for and second line state how many entries\nto read for each block. This number is same as the number of entries in the list above. After these two\nlines, every non-comment line represents a block. The positive boundary condition at any face represents \nthe interface boundary condition, and  the exact number represents the block number to which the current block \nis connected through that face. The physical boundary conditions are listed below: Boundary conditions -1: Supersonic Inlet -2: Supersonic Outflow -3: Subsonic Inflow -4: Subsonic Outflow -5: Wall -6: Symmetry or Slip-Wall -7: Pole -8: Far-field -9: Total inlet","tags":"","loc":"page/02_run/04_layout.html","title":"Layout file – FEST-3D"},{"text":"Although the boundary conditions are already defined in the layout.md file, it is not possible to define a particular value to the state variable on a boundary face.\nIn order to defined a fixed value at the boundary face you can use the boundary condition file. Once layout.md file is defined, the boundary condition file can be created using following command in the system/mesh/layout/ directory: $. compile.sh generate_bc.cpp\n$./a.out For each block a separate boundary condition files is written in system/mesh/bc/ . The sample boundary condition is as follows: BOUNDARY CONDITIONS CONFIGURATION \n================================= \n\n# imn\n- INTERFACE\n\n# imx\n- COPY_DENSITY\n- COPY_X_SPEED\n- COPY_Y_SPEED\n- COPY_Z_SPEED\n- FIX_PRESSURE\n\n# jmn\n- COPY_DENSITY\n- COPY_PRESSURE\n- NO_SLIP\n- WALL_TEMPERATURE\n\n# jmx\n- INTERFACE\n\n# kmn\n- COPY_DENSITY\n- COPY_PRESSURE\n- FLOW_TANGENCY\n\n# kmx\n- COPY_DENSITY\n- COPY_PRESSURE\n- FLOW_TANGENCY\n\nFIN In order to fix the value of a particular variable, depending on the boundary condition type, just input the value in front of Fix_var line. For example, at imx boundary, the back pressure is fixed to 101325 Pa. So the boundary condition file is change to : BOUNDARY CONDITIONS CONFIGURATION \n================================= \n\n# imn\n- INTERFACE\n\n# imx\n- COPY_DENSITY\n- COPY_X_SPEED\n- COPY_Y_SPEED\n- COPY_Z_SPEED\n- FIX_PRESSURE 101325\n\n# jmn\n- COPY_DENSITY\n- COPY_PRESSURE\n- NO_SLIP\n- WALL_TEMPERATURE\n\n# jmx\n- INTERFACE\n\n# kmn\n- COPY_DENSITY\n- COPY_PRESSURE\n- FLOW_TANGENCY\n\n# kmx\n- COPY_DENSITY\n- COPY_PRESSURE\n- FLOW_TANGENCY\n\nFIN Input value only in SI units.","tags":"","loc":"page/02_run/05_bc.html","title":"Boundary condition file – FEST-3D"},{"text":"Since it is not possible to perform unit tests with the current status of FEST-3D,\nwe have defined a few integrated test cases. Using this integrated method, \nyou can test the implementation of various flux-schemes, higher-order methods, and turbulence models.\nAny new scheme added to FEST-3D can also be tested using the same framework.\nA python script, Test.py , is provided in the test/ directory to run the integrated tests\nwith a particular flux scheme, higher-order method, and turbulence model.\nUse the following command to run all tests in the test/ directory. How to run Test.py script $cd <FEST-3D/root/directory>/test/\n$python Test.py <arg1> <arg2> <arg3> <arg1> : Flux scheme allowed options: ausm ldfss0 ausmUP ausmP slau <arg2> : Higher order method allowed options: muscl ppm weno <arg3> : Turbulence model allowed options: sst sst2003 kkl sa Examples: $python Test.py ausm   muscl sst $python Test.py slau   weno  sa $python Test.py ausmUP ppm   kkl You will see following output on the screen: ----- Integrated Tests Started -----  \nTotal two processes will be used with MPICH library\nRunning Test number 1  --->  Subsonic flow over a smooth bump\nRunning Test number 2  --->  Laminar flow over a flat plate\nRunning Test number 3  --->  Turbulent flow over a flat plate\n ----- All tests completed -----\n\nTests passed:  3 out of 3\nCheck test summary in 'Report.txt' file. The integrated tests use two processes with MPICH library. Three different test cases are defined: Inviscid test case: Subsonic flow over a 2D smooth bump . Laminar test csae: Laminar flow over a flat plate . Turbulent test case: Fully turbulent flow over a flat plate . S.No. Test case Expected value Tolereance % 1 Inviscid Change in entropy = 0.0% 0.1% 2. Laminar Cofficient of drag = 0.00133 1% 3. Turbulent Cofficient of drag = 0.00290 2% The percentage change or error(Tolerance) in entropy is calculated using following expression: Here, S is entropy, and V is volume. Subscript cell is used for cell variable, infinity is used for freestream quantity, and total is used for to whole domain value. For more details about domain, boundary conditions and flow conditions of these test cases, \ncheck the Tutorial section. The solver setup (domain, grid, flow and boundary conditions) is same as listed in the separate tutorials. Once the tests are complete, you can check the test summary in Report.txt file. Ran Test number 1  --->  Subsonic flow over a smooth bump\n __________Report__________  \n ---------- Inviscid Test case: Smooth Bump ---------- \n Flux Scheme        : ausm\n Higher order method: muscl\n Turbulence model   : none\n Expected Change in entropy           : 0.000E+00\n Calculated relative change in entropy: 1.046E-06\n Difference                           : 1.046E-04 %\n Allowed Tolerance                    : 0.1 %\n------------ >>> Test Passed  <<< --------------\n\n\nRan Test number 2  --->  Laminar flow over a flat plate\n  __________Report__________   \n ------ Laminar Test case: Flat plate ------ \n Flux Scheme        : ausm\n Higher order method: muscl\n Turbulence model   : none\n Expected drag coeffcient    : 1.330E-03\n Calculated drag coefficient : 1.329E-03\n Difference                  : 4.638E-02 %\n Allowed Tolerance           : 1 %\n------------ >>> Test Passed  <<< --------------\n\n\nRan Test number 3  --->  Turbulent flow over a flat plate\n  __________Report__________   \n ------ Turbulent Test case: Flat plate ------ \n Flux Scheme        : ausm\n Higher order method: muscl\n Turbulence model   : sst\n Expected drag coeffcient    : 2.900E-03\n Calculated drag coefficient : 2.873E-03\n Difference                  : 9.312E-01 %\n Allowed Tolerance           : 2 %\n------------ >>> Test Passed  <<< --------------","tags":"","loc":"page/./03_test.html","title":"Test – FEST-3D"},{"text":"Steps to run FEST-3D Once you have downloaded and installed the FEST-3D code, you are ready to use the FEST-3D solver. A step by step guide for the LiD-Driven cavity is given on this page. Run folder First, change the current directory to run/ directory. Now check if run/ directory is empty or it already has files in it. Use: $ls If run/ folder is empty, that means the submodule run has not been download. You should use the following command to get all the files: $git submodule update --init The $ls command in run/ directory should show the following file/folder name as output: edit-automaton.py  README.md  Tutorials/ Sample edit-automaton.py script The edit-automaton.py in the run directory is a sample script file. This script file is not supposed to be executed as the inputs are randomly provided as an explanation for the variables. Users are supposed to copy this script and modify as according to need. In the Tutorial/ subfolder, different edit-automaton.py file is provided with specific inputs. README.md This markdown file contains information about: Software dependencies of run module Information about all the input variables in edit-automaton.py Directory structure created for each test case. How to start the simulation once setup for the test case is done. Tutorial Few test cases are provided in Tutorials/ folder for learning and verification purpose. Generate Grid before executing edit-automaton.py script For all the tutorial, a grid file is provided in CreateBlocks/ subfolder. You can generate the grid by just changing directory to CreateBlocks/ subfolder, and type following make command: $make It will create a grids/ subfolder in CreateBlocks . In the grid/ multiple grid files are written, one for each processor. For each tutorial, an input is provided for the number of processors to be used for the simulation. Except for 2D bump test case, the number of blocks in i,j,k direction can be changed in blocking_point.f90 file at: integer, parameter :: xblocks = 4\n  integer, parameter :: yblocks = 1\n  integer, parameter :: zblocks = 1 It should be noted that the grid generation process is not part of the FEST-3D solver and has to be handled separately. You can write your code for grid-generation of simple geometries. An example for such code is bump.py python script for 2D smooth bump grid generation. You can also use software like pointwise for complicated geometries. Modify and execute edit-automaton.py edit-automaton.py script is provided in each tutorial folder. Although most of the input in the edit-automaton.py has been set according to the test case, you still need to change the first few lines of this file: RunDir = 'GiveAnyName'\nGridDir= 'PathToAllGridFiles'\nNumberOfBlocks = 4 #Make sure it is same as the number of grid-files If you are not able to run or set up the test case, then the above lines in the edit-automaton.py may be the culprit. You can give any name for RunDir . A new folder will be created with the name you supply here. You can give a different name for a different version for the input you give in edit-automaton.py . For GridDir variable provide folder name in which all the grid files are present. For all the tutorials, grid files created are situated at \" CreateBlocks/grids \". For NumberOfBlocks provide the number of processors you want to use for the simulation. Make sure the NumberOfBlocks and number of grid files in GridDir are the same. This will be asserted in the latter part of the script. If this is not the case following error will be thrown: ERROR: Traceback (most recent call last):\n  File \"edit-automaton.py\", line 340, in <module>\n    CheckInput(ExpectedControl, ExpectedScheme, ExpectedFlow, ExpectedOutputControl, ExpectedResidualControl, Control, Scheme, Flow, OutputControl, ResidualControl)\n  File \"edit-automaton.py\", line 183, in CheckInput\n    assert len(next(os.walk(GridDir))[2]) == NumberOfBlocks\nStopIteration Same error will be shown if the folder name provided for GridDir is invalid. Steps to run Lid-Driven Cavity tutorial Fig.1 Domain and boundary condition for Lid-driven cavity test case. Make sure the run directory has the Turtorial folder. Change directory to the FEST-3D/run/Tutorials/LidDrivenCavity/ . This folder contains edit-automaton.py file and CreateBlocks/ subfolder Change directory to CreateBlocks/ subfolder and open blocking_point.f90. Change number of I-direction blocks and J-direction blocks to what you desire. Do not change the \nK-direction blocks as there is only one cell in the third direction. integer, parameter :: xblocks = 2\n  !< Number of block in I-directions\n  integer, parameter :: yblocks = 2\n  !< Number of block in J-directions\n  integer, parameter :: zblocks = 1\n  !< Number of block in Z-directions A makefile is provided to automate the grid generation and blocking process. Use the following command to generate the grid/ folder which contains all the grid files. $make An important point to note here is that the grid generation requires numpy version 1.10 or above for Python2.7 Once the grids are generated, go one-directory up to run/Tutorials/LidDrivenCavity/ . Open edit-automaton.py and change first three variables: RunDir = 'LDC-Test1'\nGridDir= 'CreateBlocks/grid'\nNumberOfBlocks = 4 #Make sure it is same as the number of grid-files Run the python script python edit-automaton.py If you have provided a wrong path to grid files or incorrect number of blocks to use, you will get the following error: ERROR : Traceback ( most recent call last ): File \"edit-automaton.py\" , line 340 , in < module > CheckInput ( ExpectedControl , ExpectedScheme , ExpectedFlow , ExpectedOutputControl , ExpectedResidualControl , Control , Scheme , Flow , OutputControl , ResidualControl ) File \"edit-automaton.py\" , line 183 , in CheckInput assert len ( next ( os . walk ( GridDir ))[ 2 ]) == NumberOfBlocks StopIteration If not error occured, a new folder: LDC-Test1 will be generated. Change to newly created folder LDC-Test1 . You will find the following directory structure:\n        bin/  fill_vtk_name.sh  gnplt  pp/  pre/  run.sh  system/  time_directories/ bin/ soft link to FEST-3D binary resides in this folder. gnplt is GNUPLOT script to live plot the residual while a simulation is running in the background. pp/ and pre/ are the directories to keep you pre-processing and post-processing code. Currently, they should be empty. run.sh is the bash script which will be executed. It contains the instruction to pipe all the screen output to the time_directories/aux/out file. system/ contains the information about the grid, boundary condition, layout of blocks, and input and output configuration of current simulation. control.md contains information about all the control parameters like CFL, Maximum number of iteration, output file format, etc. fvscheme.md contains information about the numerical schemes to use for the current simulation. flow.md contains information about the flow: reference velocity, density, pressure, viscosity, etc. output_control.md contains the name of the variable to read or write to the solution file in the time_directories. res_control.md contains the name of the residual which you want to track. mesh/ Contains information about the grid and its layout. Fig.2 Domain and mesh decomposition in to 4 blocks. Gridfiles/ Contains all the grid file used for the simulation layout/ contains the information about the layout of the grid file and some script to most of the information about \n      the layout automatically from the grid file in the Gridfiles/ folder. Fig.3 Boundary faces of each block indicated with 'Imin', 'Imax', 'Jmin', and 'Jmax' labels. layout.md file contains layout information. For more information about layout file check this page .\n    The layout.md file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -005  0001  -005  0002  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  -005  -005  0003  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  -005  0003  0000  -003  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -005  0001  -003  -006  -006 here the boundary condition numbers are as follow: * -1: Supersonic Inlet\n  * -2: Supersonic Outflow\n  * -3: Subsonic Inflow\n  * -4: Subsonic Outflow\n  * -5: Wall\n  * -6: Symmetry or Slip-Wall\n  * -7: Pole\n  * -8: Far-field\n  * -9: Total inlet bc/ folder contains a separate boundary condition file for each block. In layout.md file you can fix the type of boundary but in bc_xx.md file you can give a particular value to the variable you want to fix. For Lid-Driven cavity test case, we need to fix velocity of the top lid. This can be done easily by opening the file of the block, which contains the lid, and set value of velocity to the boundary face, which represents the lid. Change # jmx\n    - FIX_DENSITY\n    - FIX_X_SPEED\n    - FIX_Y_SPEED\n    - FIX_Z_SPEED\n    - COPY_PRESSURE to # jmx\n    - FIX_DENSITY\n    - FIX_X_SPEED 100.0\n    - FIX_Y_SPEED 0.0\n    - FIX_Z_SPEED 0.0\n    - COPY_PRESSURE Fig.4. For lid-driven cavity a velocity vectory of (100,0,0) will be fixed at top boundary. time_direcories/ contains a folder for each save point. aux/ contains the auxiliary files like out output of all the print command in the solver resnorm residual which you can plot using gnplt script surfacenode.dat : In case of turbulence model being used, this file is written to calculate wall-distance. Finally, to run the simulation, use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal.\n If you do not get any error, but still simulation terminates as soon it begins, run following command: $mpiexec.hydra -np 4 bin/FEST3D it will provide output on the screen and help you debug. You can use GNUPLOT to plot the residual using $gnuplot gnplt Results Post-processing is not part of the FEST-3D solver. FEST-3D provides two output file formats: vtk and Tecplot, which you can specify in the edit-automaton.py file. You can use software like visit , paraview , Tecplot to visualize the obtained solution data from FEST-3D. Fig.5 Contour of y-component of velocity vector.","tags":"","loc":"page/./04_Steps_to_run_FEST3D.html","title":"How to run FEST-3D solver? – FEST-3D"},{"text":"Fig.1 Pressure contour simlulated with FEST-3D for transonic flow over RAE2822 airfoil. Getting Started In order to understand better that how to use different options in FEST-3D,\nsome verification test cases are provided as tutorials. Summary of Testcases Supersonic inviscid flow over a ramp (2D) Subsonic inviscid flow over a smooth bump (2D) Lid-driven cavity (2D) Laminar flow over a plate (2D) Turbulent flow over a plate  (2D) Turbulent flow over a transonic airfoil RAE-2822 (2D) Transition flow over a flat plate (2D)","tags":"","loc":"page/05_tutorials/index.html","title":"Tutorials – FEST-3D"},{"text":"Supersonic inviscid flow of Mach 2.0 past a 15-degree ramp Fig.1 Mach contours simlulated with FEST-3D for supersonic flow over a 15-degree ramp. Problem Statement In this test case, a supersonic inviscid flow of Mach 2.0 past a 15-degree ramp will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 2. The case definition and grid used were obtained from NPARC\nAlliance Validation Archive . Fig.2 Domain and boundary conditions for supersonic flow over a 15-degree ramp. Mesh A structured grid of size 153 × 91 × 2 will be used, as shown in Fig. 3. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/Ramp/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, only one block will\nbe used. integer, parameter :: xblocks = 1 integer, parameter :: yblocks = 1 In order to compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/Ramp/CreateBlocks/ directory. Fig.3 The Mesh for supersonic flow over a 15-degree ramp. Setup In order to setup the case directory, a python automation script is provided: automaton.py . First setup the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'GiveAnyName' Name of the run directory to create for current case. You can give any\nname for this directory. This new directory will contains all the required files. All following command expect python automaton.py will be executed in this directory. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains grid file. NumberOfBlocks = 1 Total number of blocks. It should match with number of gridfiles avaiable in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 10.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 4000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'tecplot' Type of solution file to write. If you have vtk file viewer you can user vtk instead of tecplot Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 5 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'slau' Inviscid flux-reconstruction shceme. You can use: ausm , ldfss0 , ausmP , and ausmUP instead of __slau . Scheme['FaceState'] = 'muscl' Higher-order  face-state reconstruction method. you can use: none , ppm , and weno . Scheme['Limiter'] = '1 1 1  0 0 0' Switch on the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TimeStep']='l' Local time-stepping method. You can use global time-stepping method also g . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.225 Free-stream density. Flow[\"UInf\"] = 680.588 Free-stream x-component of velcotiy vector. Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 101325.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 0.0 Set reference viscosity to zero for inviscid flow. OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-1, -2, -6, -6, -6, -6] Broad boundary condition.[supersonic inlet, supersonic outlet, rest are Slip-walls]. Rest of the variables should be left to thier default value. In order to execute this script use following command: $python automaton.py Now you will see a new folder created with RunDir name. Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n1\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -001  -002  -006  -006  -006  -006 The last line, in sequence, indicates the following: Block_Number    GridFile   Boundary_condition_file   Imin_boundary_condition_number    Imax_boundary_condition_number Jmin_boundary_condition_number Jmax_boundary_condition_number Kmin_boundary_condition_number  Kmax_boundary_condition_number Finally, to run the simulation use following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.5 Surface pressure comparasion with theory. Documentation Download Installation Run Mesh Layout file Boundary condition file Test How to run FEST-3D solver? Tutorials Supersonic flow over Wedge 2D Smooth Bump Lid-Driven Cavity Flat plate (laminar) Flat plate (Turbulent) RAE2822 airfoil Flat plate (Transition)","tags":"","loc":"page/05_tutorials/01_ramp.html","title":"Supersonic flow over Wedge – FEST-3D"},{"text":"Subsonic inviscid flow of Mach 0.5 past a smooth 2D-bump Fig.1 Pressure contour over smoooth bump. Problem Statement In this test case, a subsonic inviscid flow of Mach 0.5 past a smooth 2D-bump will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 2. The case definition and grid used were obtained from 4th International Workshop on High-Order CFD Methods . Fig.2 Domain and boundary conditions for subsonic flow over 2D smooth bump. Mesh A structured grid of size 97 x 49 × 2 will be used, as shown in Fig. 3. \nThe grid is available in the tutorial folder |rootFolder|/run/Tutorial/2DBump/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the bump.py edit the number of blocks in the I-direction . In this test case, only two blocks will\nbe used. imax = 97 Maximum number of grid points in the I-direction jmax = 49 Maximum number of grid points in the J-direction kmax = 2 Maximum number of grid points in the K-direction blocks = 2 Number of blocks in the I-direction In order to execute the bump.py script with python, all commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/2DBump/CreateBlocks/ directory. Fig.3 The Mesh for subsonic flow over 2D smooth bump. Setup To setup the case directory, a python automation script is provided: automaton.py . First setup the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'GiveAnyName' Name of the run directory to create for current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains grid file. NumberOfBlocks = 2 Total number of blocks. It should match with number of gridfiles avaiable in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 10.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 10000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'tecplot' Type of solution file to write. If you have vtk file viewer you can user vtk instead of tecplot Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 5 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'slau' Inviscid flux-reconstruction shceme. You can use: ausm , ldfss0 , ausmP , and ausmUP instead of __slau . Scheme['FaceState'] = 'muscl' Higher-order  face-state reconstruction method. you can use: none , ppm , and weno . Scheme['Limiter'] = '0 0 0  0 0 0' Switch on the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TimeStep']='l' Local time-stepping method. You can use global time-stepping method also g . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.225 Free-stream density. Flow[\"UInf\"] = 170.14 Free-stream x-component of velcotiy vector. Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 101325.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 0.0 Set reference viscosity to zero for inviscid flow. OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-8, -4, -6, -6, -6, -6] Broad boundary condition.[Riemann-inlet, subsonic outlet, rest are Slip-walls]. Free-stream pressure is used to fix the pressure outlet value. Rest of the variables should be left to their default value. In order to execute this script use following command: $python automaton.py Now you will see a new folder created with RunDir name. Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n2\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -008  0001  -006  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  -004  -006  -006  -006  -006 The last two uncommented line, in sequence, indicates following: Block_Number    GridFile   Boundary_condition_file   Imin_boundary_condition_number    Imax_boundary_condition_number Jmin_boundary_condition_number Jmax_boundary_condition_number Kmin_boundary_condition_number  Kmax_boundary_condition_number Since there are two blocks, there are two rows of entries, one for each block. All the lines with # as the first character are skipped while reading by the FEST-3D solver.\nAll the positive numbers define the interface boundary condition, and negative numbers define the physical boundary conditions.\nFinally, to run the simulation use following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.4 Pressure contour for different higher order methods. Documentation Download Installation Run Mesh Layout file Boundary condition file Test How to run FEST-3D solver? Tutorials Supersonic flow over Wedge 2D Smooth Bump Lid-Driven Cavity Flat plate (laminar) Flat plate (Turbulent) RAE2822 airfoil Flat plate (Transition)","tags":"","loc":"page/05_tutorials/02_2dbump.html","title":"2D Smooth Bump – FEST-3D"},{"text":"Lid-driven cavity Fig.1 Contour of x-component of velocity vector. Problem Statement In this test case, we calculate the flow inside the cavity formed simulated due to the tangential velocity of the upper plate\n. The domain used, and boundary condition applied to the domain are illustrated in Fig. 2. \nThe case definition and grid used were obtained from NPARC Alliance Validation Archive . Fig.2 Domain and boundary conditions for lid-driven cavity. Mesh A uniform structured grid of size 129 x 129 × 2 will be used as shown in Fig. 3. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/LidDrivenCavity/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, four blocks will\nbe used. integer, parameter :: xblocks = 2 integer, parameter :: yblocks = 2 In order to compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/LidDrivenCavity/CreateBlocks/ directory. Note Make sure you are using numpy version greater than 1.10 for python script to generate grid. Fig.3 The Mesh for lid-driven cavity test case. Setup To setup the case directory, a python automation script is provided: automaton.py . First setup the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'GiveAnyName' Name of the run directory to create for current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains grid file. NumberOfBlocks = 4 Total number of blocks. It should match with number of gridfiles avaiable in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 10.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 10000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'vtk' Type of solution file to write. If you have tecplot file viewer you can user tecplot instead of vtk Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 20 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'slau' Inviscid flux-reconstruction shceme. You can use: ausm , ldfss0 , ausmP , and ausmUP instead of __slau . Scheme['FaceState'] = 'ppm' Higher-order  face-state reconstruction method. you can use: none , muscl , and weno . Scheme['Limiter'] = '0 0 0  0 0 0' Switch off the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TimeStep']='g 1e-5' Global time-stepping method and time-step. You can use local time-stepping method also l . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.2 Free-stream density. Note The domain is initialized with zero velocity vector and Lid velocity is defined\nlater in the boundary condition file. As the residual are normalized with \nfree-stream velocity, residual written in resnom file will be Nan. But solution\nis correct. Flow[\"UInf\"] = 0.0 Free-stream x-component of velcotiy vector. Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 103338.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 1.2e-1 Reference viscosity is set to 0.12 so that the Reynolds number based on the lid-velocity (100m/s) is 1000 OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\", \"Mu\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-5, -5, -5, -3, -6, -6] Broad boundary condition.[Noslip adiabatic side and lower wall, and upper wall with slip velocity of 100 m/s ]. The velocity at the upper wall is set manually, later, in the bc_02.md and bc_03.md boundary condition file. Rest of the variables should be left to their default value. In order to execute this script use following command: $python automaton.py Now you will see a new folder created with RunDir name. Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -005  0001  -005  0002  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  -005  -005  0003  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  -005  0003  0000  -003  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -005  0001  -003  -006  -006 If all the boundary conditions are defined in the layout.md file then fix the upper wall velocity in the \nbc_02.md and bc_03.md file in system/mesh/bc/ folder. Change the bc_02.md file from # jmx\n- FIX_DENSITY\n- FIX_X_SPEED\n- FIX_Y_SPEED\n- FIX_Z_SPEED\n- COPY_PRESSURE to # jmx\n- FIX_DENSITY\n- FIX_X_SPEED 100.0\n- FIX_Y_SPEED 0.0\n- FIX_Z_SPEED 0.0\n- COPY_PRESSURE and same for bc_03.md file. Finally, to run the simulation use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.4 Contour of y-component of velocity vector. Fig.5 Comparision of x-component of velocity with experiment. Fig.6 Comparision of y-comoponent of velocity with experiment.","tags":"","loc":"page/05_tutorials/03_LDC.html","title":"Lid-Driven Cavity – FEST-3D"},{"text":"Subsonic laminar flow of Mach 0.5, Reynolds number 1 million over a flat plate Fig.1 Contour of v-component of velocity vector. Problem Statement In this test case, a subsonic laminar flow of Mach 0.5 over a flat plate will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 2. The case definition and grid used were obtained from 3rd International Workshop on High-Order CFD Methods . Fig.2 Domain and boundary conditions for laminar flow over flat plate test case. Mesh A structured grid of size 113 × 81 x 2 will be used as shown in Fig. 3. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/LaminarFlatPlate/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, four blocks will\nbe used. integer, parameter :: xblocks = 4 integer, parameter :: yblocks = 1 In order to compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/LaminarFlatPlate/CreateBlocks/ directory. Fig.3 The Mesh for laminar flow over flat plate test case. Setup To setup the case directory, a python automation script is provided: automaton.py . First setup the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'FlatPlate_Lam' Name of the run directory to create for current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains grid file. NumberOfBlocks = 4 Total number of blocks. It should match with number of gridfiles avaiable in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 100.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 10000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'vtk' Type of solution file to write. If you have tecplot file viewer you can user tecplot instead of vtk Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 20 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'slau' Inviscid flux-reconstruction shceme. You can use: ausm , ldfss0 , ausmP , and ausmUP instead of __slau . Scheme['FaceState'] = 'ppm' Higher-order  face-state reconstruction method. you can use: none , muscl , and weno . Scheme['Limiter'] = '0 0 0  0 0 0' Switch off the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TurbulenceModel']='none' since no turbulence is required, none is mentioned here. Scheme['TransitionModel']='none' Similar to turbulence model option, none is metioned for no transition model. Scheme['TimeStep']='l' Local time stepping method. You can use global time-stepping method also g . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.2 Free-stream density. Flow[\"UInf\"] = 173.59 Free-stream x-component of velcotiy vector. (Mach = 0.5 at T_ref=300K) Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 103338.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 2.083e-4 Reference viscosity is set to 0.0002083 kg/ms so that the Reynolds number (L_ref=1m) is 1 million OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\", \"Mu\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-8, -4, -5, -6, -6, -6] Broad boundary condition.[Riemann inlet, subsonic outlet, no-slip wall and slip wall for rest ]. Since the bottom faces\nof the full domain have two different boundary conditions, as shown in Fig. 2, and the blocking provided here is such that first two of the four blocks\nhave inviscid region as a boundary condition at the bottom faces and other two have the no-slip adiabatic wall as a boundary condition at\nthe bottom faces. The boundary condition at the bottom face (Jmin) will be changed manually in the layout.md file after the automatic \ncase setup. Rest of the variables should be left to their default value. In order to execute this script, use the following command: $python automaton.py Now you will see a new folder created with RunDir name ( FlatPlate_Lam ). Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -008  0001  -005  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Change the Jmin boundary condition for first two blocks from no-slip wall (-5) to slip wall (-6). ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -008  0001  -006  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -006  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Finally, to run the simulation use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.4 Coefficient of friction along the surface of the plate.","tags":"","loc":"page/05_tutorials/04_LamFp.html","title":"Flat plate (laminar) – FEST-3D"},{"text":"Subsonic turbulent flow of Mach 0.2, Reynolds number 5 million over a flat plate Fig.1 Domain of computation for turbulent flow over flat plate test case. Problem Statement In this test case, a subsonic turbulent flow of Mach 0.2 over a flat plate will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 1. The case definition and grid used were obtained from Turbulence Modeling Resource . Mesh A structured grid of size 113 × 81 x 2 will be used as shown in Fig. 3. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/TurbulentFlatPlate/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, four blocks will\nbe used. integer, parameter :: xblocks = 4 integer, parameter :: yblocks = 1 To compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/TurbulentFlatPlate/CreateBlocks/ directory. Fig.3 The Mesh for turbulent flow over flat plate test case. Setup To set up the case directory, a python automation script is provided: automaton.py . First, set up the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'FlatPlate_Turb' Name of the run directory to create for the current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains the grid files. NumberOfBlocks = 4 Total number of blocks. It should match with the number of grid files available in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 100.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 10000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'vtk' Type of solution file to write. If you have tecplot file viewer you can user tecplot instead of vtk Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 20 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'ausm' Inviscid flux-reconstruction shceme. You can use: slau , ldfss0 , ausmP , and ausmUP instead of __ausm . Scheme['FaceState'] = 'muscl' Higher-order  face-state reconstruction method. you can use: none , ppm , and weno . Scheme['Limiter'] = '0 0 0  0 0 0' Switch off the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TurbulenceLimiter'] = '1 1 1' Using limiter only for turbulent variables face-state reconstruction improve convergence. Scheme['TurbulenceModel']='sst' using SST turbulence model. Other models kkl , sa , and sst2003 can be user also. Scheme['TransitionModel']='none' none is metioned for no transition model. Scheme['TimeStep']='l' Local time stepping method. You can use global time-stepping method also g . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.17659 Free-stream density. Flow[\"UInf\"] = 69.445 Free-stream x-component of velcotiy vector. (Mach = 0.5 at T_ref=300K) Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 101325.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 1.63416586e-5 Reference viscosity is set such that the Reynolds number (L_ref=1m) is 5 million OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\", \"Mu\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-8, -4, -5, -6, -6, -6] Broad boundary condition.[Riemann inlet, subsonic outlet, no-slip wall and slip wall for rest ]. Since the bottom faces\nof the full domain have two different boundary conditions, as shown in Fig. 1, and the blocking provided here is such that first out the four blocks\nhave inviscid region as a boundary condition at the bottom face and other three have the no-slip adiabatic wall as a boundary condition at\nthe bottom faces. The boundary condition at the bottom face ( Jmin ) will be changed manually in the layout.md file after the automatic \ncase setup. Rest of the variables should be left to their default value. To execute this script, use the following command: $python automaton.py Now you will see a new folder created with RunDir name ( FlatPlate_Turb ). Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -008  0001  -005  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Change the Jmin boundary condition for the first block from no-slip wall (-5) to slip wall (-6). ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -008  0001  -006  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Finally, to run the simulation use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.3 Coefficient of friction along the surface of the plate for SST turbulence model. Fig.4 Coefficient of friction along the surface of the plate for k-kL turbulence model.","tags":"","loc":"page/05_tutorials/05_TurbFp.html","title":"Flat plate (Turbulent) – FEST-3D"},{"text":"Transonic turbulent flow of Mach 0.72, Reynolds number 6.5 million, and angle of attack 2.92 deg over the RAE2822 Fig.1 Contour of pressure for subsonic flow over RAE2822 airfoil. Problem Statement In this test case, a transonic turbulent flow of Mach 0.72 over the RAE2822 will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 2. The case definition and grid used were obtained from NPARC Alliance Validation Archive . Fig.2 Domain and boundary condition for RAE2822 airfoil test case. Mesh A structured C-grid of size 369 × 65 x 2 (with 305 grid points on the airfoil)\n will be used, as shown in Fig. 3. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/RAE2822/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, four blocks will\nbe used. integer, parameter :: xblocks = 6 integer, parameter :: yblocks = 1 To compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate the grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/RAE2822/CreateBlocks/ directory. Fig.3 The Mesh for turbulent flow over flat plate test case. Setup To setup the case directory, a python automation script is provided: automaton.py . First, setup the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'RAE2822' Name of the run directory to create for current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains grid file. NumberOfBlocks = 6 Total number of blocks. It should match with number of gridfiles avaiable in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 100.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 10000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'vtk' Type of solution file to write. If you have tecplot file viewer you can user tecplot instead of vtk Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 20 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'ausm' Inviscid flux-reconstruction shceme. You can use: slau , ldfss0 , ausmP , and ausmUP instead of __ausm . Scheme['FaceState'] = 'muscl' Higher-order  face-state reconstruction method. you can use: none , ppm , and weno . Scheme['Limiter'] = '1 1 1  0 0 0' Switch on the limiter for I,J,and K direction and switch off pressure based switching for all direction. Scheme['TurbulenceLimiter'] = '1 1 1' Using limiter only for turbulent variables face-state reconstruction improve convergence. Scheme['TurbulenceModel']='sst' using SST turbulence model. Other models kkl , sa , and sst2003 can be user also. Scheme['TransitionModel']='none' none is metioned for no transition model. Scheme['TimeStep']='l' Local time stepping method. You can use global time-stepping method also g . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.2 Free-stream density. Flow[\"UInf\"] = 252.9 Free-stream x-component of velcotiy vector. (Mach = 0.5 at T_ref=300K) Flow[\"VInf\"] = 10.2 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 103338.0 Free-stream pressure. Flow[\"TurbulenceIntensity\"] = 1.0 Free-stream turbulence intensity. Flow[\"ViscosityRatio\"] = 10.0 Free-stream viscosity ratio. Flow[\"Intermittency\"] = 1.0 Free-stream intermittency. Flow[\"ReferenceViscosity\"] = 1.4243-5 Reference viscosity is set such that the Reynolds number (L_ref=1m) is 5 million Flow[\"ViscosityLaw\"] = \"sutherland_law\"``` Viscosity variation law. OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\", \"Mu\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-4, -4, -5, -8, -6, -6] Broad boundary condition.[subsonic outlet, no-slip wall, far-field, and slip wall for rest ]. Rest of the variables should be left to their default value. To execute this script, use the following command: $python automaton.py Now, you will see a new folder created with RunDir name ( RAE2822 ). Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n6\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -004  0001  0005  -008  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -008  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -008  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  0004  -005  -008  -006  -006\n## PROCESS 4\n04  grid_04.txt  bc_04.md  0003  0005  -005  -008  -006  -006\n## PROCESS 5\n05  grid_05.txt  bc_05.md  0004  -004  0000  -008  -006  -006 Finally, to run the simulation use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal.","tags":"","loc":"page/05_tutorials/06_rae2822.html","title":"RAE2822 airfoil – FEST-3D"},{"text":"Subsonic transition flow of Mach 0.015, Reynolds number 0.36 million over a flat plate Fig.1 Domain of computation for transition flow over flat plate test case. Problem Statement In this test case, a subsonic transition flow of Mach 0.015 over a flat plate will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 1. The case definition and grid used were obtained from Turbulence Modeling Resource . Mesh A structured grid of size 285 × 161 x 2 will be used as shown in Fig. 2. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/TurbulentFlatPlate/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, four blocks will\nbe used. integer, parameter :: xblocks = 4 integer, parameter :: yblocks = 1 To compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/TurbulentFlatPlate/CreateBlocks/ directory. Fig.2 The Mesh for turbulent flow over flat plate test case. Setup To set up the case directory, a python automation script is provided: automaton.py . First, set up the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'T3A' Name of the run directory to create for the current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains the grid files. NumberOfBlocks = 4 Total number of blocks. It should match with the number of grid files available in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 30.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 400000 Maximum number of iteration to perform. Control['SaveIterations'] = 10000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'tecplot' Type of solution file to write. If you have vtk file viewer you can user vtk instead of tecplot Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 20 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'ausmUP' Inviscid flux-reconstruction shceme. You can use: slau , ldfss0 , ausmP , and ausm instead of ausmUP . Scheme['FaceState'] = 'muscl' Higher-order  face-state reconstruction method. you can use: none , ppm , and weno . Scheme['Limiter'] = '0 0 0  0 0 0' Switch off the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TurbulenceLimiter'] = '1 1 1' Using limiter only for turbulent variables face-state reconstruction improve convergence. Scheme['TurbulenceModel']='sst2003' using SST2003 turbulence model. Other models kkl , sa , and sst can be user also. Scheme['TransitionModel']='lctm2015' $\\gamma$ one-equation transition model is metioned as transition model. Scheme['TimeStep']='g' Global time stepping method. You can use local time-stepping method also l . Scheme['TimeIntegration']='plusgs' Preconditioned LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.2 Free-stream density. Flow[\"UInf\"] = 5.18 Free-stream x-component of velcotiy vector. (Mach = 0.015 at T_ref=300K) Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 103320.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 1.8e-5 Reference viscosity is set such that the Reynolds number (L_ref=1m) is 0.36 million OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\", \"TKE\", \"Omega\", \"Mu\", \"Mu_t\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\", \"TKE_abs\", \"Omega_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-3, -4, -5, -8, -6, -6] Broad boundary condition.[Subsonic inlet, subsonic outlet, no-slip wall, far-field, and slip wall for rest ]. Since the bottom faces\nof the full domain have two different boundary conditions, as shown in Fig. 1, and the blocking provided here is such that first out the four blocks\nhave inviscid region as a boundary condition at the bottom face and other three have the no-slip adiabatic wall as a boundary condition at\nthe bottom faces. The boundary condition at the bottom face ( Jmin ) will be changed manually in the layout.md file after the automatic \ncase setup. Rest of the variables should be left to their default value. To execute this script, use the following command: $python automaton.py Now you will see a new folder created with RunDir name ( FlatPlate_Turb ). Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -003  0001  -005  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Change the Jmin boundary condition for the first block from no-slip wall (-5) to slip wall (-6). ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -003  0001  -006  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Finally, to run the simulation use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.3 Coefficient of friction along the surface of the plate for SST turbulence model. Fig.4 Coefficient of friction along the surface of the plate for k-kL turbulence model.","tags":"","loc":"page/05_tutorials/07_TransFp.html","title":"Flat plate (Transition) – FEST-3D"}]}